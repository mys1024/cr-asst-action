import { Blob as Blob$1, File, __commonJS, __require, __toESM, isFile, isFunction } from "./isFile-Cusceg7q.js";
import { deprecate, inspect } from "util";
import { Duplex, PassThrough, Readable, Transform, Writable, getDefaultHighWaterMark } from "node:stream";
import { aborted, callbackify, debuglog, inspect as inspect$1, promisify, stripVTControlCharacters } from "node:util";
import { EventEmitter, addAbortListener, on, once, setMaxListeners } from "node:events";
import process$1, { execArgv, execPath, hrtime, platform, stdout } from "node:process";
import { appendFile, readFile, writeFile } from "node:fs/promises";
import { ReadStream, appendFileSync, createReadStream, createWriteStream, readFileSync, statSync, writeFileSync } from "node:fs";
import { ReadableStream } from "node:stream/web";
import { fileURLToPath } from "node:url";
import { ChildProcess, spawn, spawnSync } from "node:child_process";
import { StringDecoder } from "node:string_decoder";
import tty from "node:tty";
import path from "node:path";
import { scheduler, setImmediate as setImmediate$1, setTimeout as setTimeout$1 } from "node:timers/promises";
import { constants } from "node:os";
import { serialize } from "node:v8";
import { finished } from "node:stream/promises";
import { Buffer as Buffer$1 } from "node:buffer";

//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js
var require_utils$4 = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toCommandProperties = exports.toCommandValue = void 0;
	/**
	* Sanitizes an input into a string so it can be passed into issueCommand safely
	* @param input input to sanitize into a string
	*/
	function toCommandValue(input) {
		if (input === null || input === void 0) return "";
		else if (typeof input === "string" || input instanceof String) return input;
		return JSON.stringify(input);
	}
	exports.toCommandValue = toCommandValue;
	/**
	*
	* @param annotationProperties
	* @returns The command properties to send with the actual annotation command
	* See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
	*/
	function toCommandProperties(annotationProperties) {
		if (!Object.keys(annotationProperties).length) return {};
		return {
			title: annotationProperties.title,
			file: annotationProperties.file,
			line: annotationProperties.startLine,
			endLine: annotationProperties.endLine,
			col: annotationProperties.startColumn,
			endColumn: annotationProperties.endColumn
		};
	}
	exports.toCommandProperties = toCommandProperties;
} });

//#endregion
//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js
var require_command = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js"(exports) {
	var __createBinding$12 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$12 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$12 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$12(result, mod, k);
		}
		__setModuleDefault$12(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.issue = exports.issueCommand = void 0;
	const os$3 = __importStar$12(__require("os"));
	const utils_1$4 = require_utils$4();
	/**
	* Commands
	*
	* Command Format:
	*   ::name key=value,key=value::message
	*
	* Examples:
	*   ::warning::This is the message
	*   ::set-env name=MY_VAR::some value
	*/
	function issueCommand(command, properties, message) {
		const cmd = new Command(command, properties, message);
		process.stdout.write(cmd.toString() + os$3.EOL);
	}
	exports.issueCommand = issueCommand;
	function issue(name, message = "") {
		issueCommand(name, {}, message);
	}
	exports.issue = issue;
	const CMD_STRING = "::";
	var Command = class {
		constructor(command, properties, message) {
			if (!command) command = "missing.command";
			this.command = command;
			this.properties = properties;
			this.message = message;
		}
		toString() {
			let cmdStr = CMD_STRING + this.command;
			if (this.properties && Object.keys(this.properties).length > 0) {
				cmdStr += " ";
				let first = true;
				for (const key in this.properties) if (this.properties.hasOwnProperty(key)) {
					const val = this.properties[key];
					if (val) {
						if (first) first = false;
						else cmdStr += ",";
						cmdStr += `${key}=${escapeProperty(val)}`;
					}
				}
			}
			cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
			return cmdStr;
		}
	};
	function escapeData(s$1) {
		return (0, utils_1$4.toCommandValue)(s$1).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
	}
	function escapeProperty(s$1) {
		return (0, utils_1$4.toCommandValue)(s$1).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
	}
} });

//#endregion
//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js"(exports) {
	var __createBinding$11 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$11 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$11 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$11(result, mod, k);
		}
		__setModuleDefault$11(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
	const crypto$3 = __importStar$11(__require("crypto"));
	const fs$5 = __importStar$11(__require("fs"));
	const os$2 = __importStar$11(__require("os"));
	const utils_1$3 = require_utils$4();
	function issueFileCommand(command, message) {
		const filePath = process.env[`GITHUB_${command}`];
		if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
		if (!fs$5.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
		fs$5.appendFileSync(filePath, `${(0, utils_1$3.toCommandValue)(message)}${os$2.EOL}`, { encoding: "utf8" });
	}
	exports.issueFileCommand = issueFileCommand;
	function prepareKeyValueMessage(key, value) {
		const delimiter = `ghadelimiter_${crypto$3.randomUUID()}`;
		const convertedValue = (0, utils_1$3.toCommandValue)(value);
		if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
		if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
		return `${key}<<${delimiter}${os$2.EOL}${convertedValue}${os$2.EOL}${delimiter}`;
	}
	exports.prepareKeyValueMessage = prepareKeyValueMessage;
} });

//#endregion
//#region node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({ "node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/proxy.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkBypass = exports.getProxyUrl = void 0;
	function getProxyUrl$1(reqUrl) {
		const usingSsl = reqUrl.protocol === "https:";
		if (checkBypass(reqUrl)) return void 0;
		const proxyVar = (() => {
			if (usingSsl) return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
			else return process.env["http_proxy"] || process.env["HTTP_PROXY"];
		})();
		if (proxyVar) try {
			return new DecodedURL(proxyVar);
		} catch (_a$2) {
			if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://")) return new DecodedURL(`http://${proxyVar}`);
		}
		else return void 0;
	}
	exports.getProxyUrl = getProxyUrl$1;
	function checkBypass(reqUrl) {
		if (!reqUrl.hostname) return false;
		const reqHost = reqUrl.hostname;
		if (isLoopbackAddress(reqHost)) return true;
		const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
		if (!noProxy) return false;
		let reqPort;
		if (reqUrl.port) reqPort = Number(reqUrl.port);
		else if (reqUrl.protocol === "http:") reqPort = 80;
		else if (reqUrl.protocol === "https:") reqPort = 443;
		const upperReqHosts = [reqUrl.hostname.toUpperCase()];
		if (typeof reqPort === "number") upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
		for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) return true;
		return false;
	}
	exports.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
		const hostLower = host.toLowerCase();
		return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
	}
	var DecodedURL = class extends URL {
		constructor(url, base) {
			super(url, base);
			this._decodedUsername = decodeURIComponent(super.username);
			this._decodedPassword = decodeURIComponent(super.password);
		}
		get username() {
			return this._decodedUsername;
		}
		get password() {
			return this._decodedPassword;
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js
var require_tunnel$1 = __commonJS({ "node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js"(exports) {
	var net$3 = __require("net");
	var tls$1 = __require("tls");
	var http$3 = __require("http");
	var https$2 = __require("https");
	var events$1 = __require("events");
	var assert$21 = __require("assert");
	var util$17 = __require("util");
	exports.httpOverHttp = httpOverHttp;
	exports.httpsOverHttp = httpsOverHttp;
	exports.httpOverHttps = httpOverHttps;
	exports.httpsOverHttps = httpsOverHttps;
	function httpOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$3.request;
		return agent;
	}
	function httpsOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$3.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function httpOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$2.request;
		return agent;
	}
	function httpsOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$2.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function TunnelingAgent(options) {
		var self = this;
		self.options = options || {};
		self.proxyOptions = self.options.proxy || {};
		self.maxSockets = self.options.maxSockets || http$3.Agent.defaultMaxSockets;
		self.requests = [];
		self.sockets = [];
		self.on("free", function onFree(socket, host, port, localAddress) {
			var options$1 = toOptions(host, port, localAddress);
			for (var i$1 = 0, len = self.requests.length; i$1 < len; ++i$1) {
				var pending = self.requests[i$1];
				if (pending.host === options$1.host && pending.port === options$1.port) {
					self.requests.splice(i$1, 1);
					pending.request.onSocket(socket);
					return;
				}
			}
			socket.destroy();
			self.removeSocket(socket);
		});
	}
	util$17.inherits(TunnelingAgent, events$1.EventEmitter);
	TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
		var self = this;
		var options = mergeOptions$1({ request: req }, self.options, toOptions(host, port, localAddress));
		if (self.sockets.length >= this.maxSockets) {
			self.requests.push(options);
			return;
		}
		self.createSocket(options, function(socket) {
			socket.on("free", onFree);
			socket.on("close", onCloseOrRemove);
			socket.on("agentRemove", onCloseOrRemove);
			req.onSocket(socket);
			function onFree() {
				self.emit("free", socket, options);
			}
			function onCloseOrRemove(err) {
				self.removeSocket(socket);
				socket.removeListener("free", onFree);
				socket.removeListener("close", onCloseOrRemove);
				socket.removeListener("agentRemove", onCloseOrRemove);
			}
		});
	};
	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
		var self = this;
		var placeholder = {};
		self.sockets.push(placeholder);
		var connectOptions = mergeOptions$1({}, self.proxyOptions, {
			method: "CONNECT",
			path: options.host + ":" + options.port,
			agent: false,
			headers: { host: options.host + ":" + options.port }
		});
		if (options.localAddress) connectOptions.localAddress = options.localAddress;
		if (connectOptions.proxyAuth) {
			connectOptions.headers = connectOptions.headers || {};
			connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
		}
		debug$3("making CONNECT request");
		var connectReq = self.request(connectOptions);
		connectReq.useChunkedEncodingByDefault = false;
		connectReq.once("response", onResponse);
		connectReq.once("upgrade", onUpgrade);
		connectReq.once("connect", onConnect);
		connectReq.once("error", onError$1);
		connectReq.end();
		function onResponse(res) {
			res.upgrade = true;
		}
		function onUpgrade(res, socket, head) {
			process.nextTick(function() {
				onConnect(res, socket, head);
			});
		}
		function onConnect(res, socket, head) {
			connectReq.removeAllListeners();
			socket.removeAllListeners();
			if (res.statusCode !== 200) {
				debug$3("tunneling socket could not be established, statusCode=%d", res.statusCode);
				socket.destroy();
				var error$1 = /* @__PURE__ */ new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
				error$1.code = "ECONNRESET";
				options.request.emit("error", error$1);
				self.removeSocket(placeholder);
				return;
			}
			if (head.length > 0) {
				debug$3("got illegal response body from proxy");
				socket.destroy();
				var error$1 = /* @__PURE__ */ new Error("got illegal response body from proxy");
				error$1.code = "ECONNRESET";
				options.request.emit("error", error$1);
				self.removeSocket(placeholder);
				return;
			}
			debug$3("tunneling connection has established");
			self.sockets[self.sockets.indexOf(placeholder)] = socket;
			return cb(socket);
		}
		function onError$1(cause) {
			connectReq.removeAllListeners();
			debug$3("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
			var error$1 = /* @__PURE__ */ new Error("tunneling socket could not be established, cause=" + cause.message);
			error$1.code = "ECONNRESET";
			options.request.emit("error", error$1);
			self.removeSocket(placeholder);
		}
	};
	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
		var pos = this.sockets.indexOf(socket);
		if (pos === -1) return;
		this.sockets.splice(pos, 1);
		var pending = this.requests.shift();
		if (pending) this.createSocket(pending, function(socket$1) {
			pending.request.onSocket(socket$1);
		});
	};
	function createSecureSocket(options, cb) {
		var self = this;
		TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
			var hostHeader = options.request.getHeader("host");
			var tlsOptions = mergeOptions$1({}, self.options, {
				socket,
				servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
			});
			var secureSocket = tls$1.connect(0, tlsOptions);
			self.sockets[self.sockets.indexOf(socket)] = secureSocket;
			cb(secureSocket);
		});
	}
	function toOptions(host, port, localAddress) {
		if (typeof host === "string") return {
			host,
			port,
			localAddress
		};
		return host;
	}
	function mergeOptions$1(target) {
		for (var i$1 = 1, len = arguments.length; i$1 < len; ++i$1) {
			var overrides = arguments[i$1];
			if (typeof overrides === "object") {
				var keys = Object.keys(overrides);
				for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
					var k = keys[j];
					if (overrides[k] !== void 0) target[k] = overrides[k];
				}
			}
		}
		return target;
	}
	var debug$3;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) debug$3 = function() {
		var args = Array.prototype.slice.call(arguments);
		if (typeof args[0] === "string") args[0] = "TUNNEL: " + args[0];
		else args.unshift("TUNNEL:");
		console.error.apply(console, args);
	};
	else debug$3 = function() {};
	exports.debug = debug$3;
} });

//#endregion
//#region node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js
var require_tunnel = __commonJS({ "node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js"(exports, module) {
	module.exports = require_tunnel$1();
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/symbols.js
var require_symbols$4 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/symbols.js"(exports, module) {
	module.exports = {
		kClose: Symbol("close"),
		kDestroy: Symbol("destroy"),
		kDispatch: Symbol("dispatch"),
		kUrl: Symbol("url"),
		kWriting: Symbol("writing"),
		kResuming: Symbol("resuming"),
		kQueue: Symbol("queue"),
		kConnect: Symbol("connect"),
		kConnecting: Symbol("connecting"),
		kHeadersList: Symbol("headers list"),
		kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
		kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
		kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
		kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
		kKeepAlive: Symbol("keep alive"),
		kHeadersTimeout: Symbol("headers timeout"),
		kBodyTimeout: Symbol("body timeout"),
		kServerName: Symbol("server name"),
		kLocalAddress: Symbol("local address"),
		kHost: Symbol("host"),
		kNoRef: Symbol("no ref"),
		kBodyUsed: Symbol("used"),
		kRunning: Symbol("running"),
		kBlocking: Symbol("blocking"),
		kPending: Symbol("pending"),
		kSize: Symbol("size"),
		kBusy: Symbol("busy"),
		kQueued: Symbol("queued"),
		kFree: Symbol("free"),
		kConnected: Symbol("connected"),
		kClosed: Symbol("closed"),
		kNeedDrain: Symbol("need drain"),
		kReset: Symbol("reset"),
		kDestroyed: Symbol.for("nodejs.stream.destroyed"),
		kMaxHeadersSize: Symbol("max headers size"),
		kRunningIdx: Symbol("running index"),
		kPendingIdx: Symbol("pending index"),
		kError: Symbol("error"),
		kClients: Symbol("clients"),
		kClient: Symbol("client"),
		kParser: Symbol("parser"),
		kOnDestroyed: Symbol("destroy callbacks"),
		kPipelining: Symbol("pipelining"),
		kSocket: Symbol("socket"),
		kHostHeader: Symbol("host header"),
		kConnector: Symbol("connector"),
		kStrictContentLength: Symbol("strict content length"),
		kMaxRedirections: Symbol("maxRedirections"),
		kMaxRequests: Symbol("maxRequestsPerClient"),
		kProxy: Symbol("proxy agent options"),
		kCounter: Symbol("socket request counter"),
		kInterceptors: Symbol("dispatch interceptors"),
		kMaxResponseSize: Symbol("max response size"),
		kHTTP2Session: Symbol("http2Session"),
		kHTTP2SessionState: Symbol("http2Session state"),
		kHTTP2BuildRequest: Symbol("http2 build request"),
		kHTTP1BuildRequest: Symbol("http1 build request"),
		kHTTP2CopyHeaders: Symbol("http2 copy headers"),
		kHTTPConnVersion: Symbol("http connection version"),
		kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
		kConstruct: Symbol("constructable")
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/errors.js"(exports, module) {
	var UndiciError$2 = class extends Error {
		constructor(message) {
			super(message);
			this.name = "UndiciError";
			this.code = "UND_ERR";
		}
	};
	var ConnectTimeoutError$1 = class ConnectTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ConnectTimeoutError$1);
			this.name = "ConnectTimeoutError";
			this.message = message || "Connect Timeout Error";
			this.code = "UND_ERR_CONNECT_TIMEOUT";
		}
	};
	var HeadersTimeoutError$1 = class HeadersTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersTimeoutError$1);
			this.name = "HeadersTimeoutError";
			this.message = message || "Headers Timeout Error";
			this.code = "UND_ERR_HEADERS_TIMEOUT";
		}
	};
	var HeadersOverflowError$1 = class HeadersOverflowError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersOverflowError$1);
			this.name = "HeadersOverflowError";
			this.message = message || "Headers Overflow Error";
			this.code = "UND_ERR_HEADERS_OVERFLOW";
		}
	};
	var BodyTimeoutError$1 = class BodyTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, BodyTimeoutError$1);
			this.name = "BodyTimeoutError";
			this.message = message || "Body Timeout Error";
			this.code = "UND_ERR_BODY_TIMEOUT";
		}
	};
	var ResponseStatusCodeError$1 = class ResponseStatusCodeError$1 extends UndiciError$2 {
		constructor(message, statusCode, headers, body) {
			super(message);
			Error.captureStackTrace(this, ResponseStatusCodeError$1);
			this.name = "ResponseStatusCodeError";
			this.message = message || "Response Status Code Error";
			this.code = "UND_ERR_RESPONSE_STATUS_CODE";
			this.body = body;
			this.status = statusCode;
			this.statusCode = statusCode;
			this.headers = headers;
		}
	};
	var InvalidArgumentError$22 = class InvalidArgumentError$22 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidArgumentError$22);
			this.name = "InvalidArgumentError";
			this.message = message || "Invalid Argument Error";
			this.code = "UND_ERR_INVALID_ARG";
		}
	};
	var InvalidReturnValueError$2 = class InvalidReturnValueError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidReturnValueError$2);
			this.name = "InvalidReturnValueError";
			this.message = message || "Invalid Return Value Error";
			this.code = "UND_ERR_INVALID_RETURN_VALUE";
		}
	};
	var RequestAbortedError$9 = class RequestAbortedError$9 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestAbortedError$9);
			this.name = "AbortError";
			this.message = message || "Request aborted";
			this.code = "UND_ERR_ABORTED";
		}
	};
	var InformationalError$1 = class InformationalError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InformationalError$1);
			this.name = "InformationalError";
			this.message = message || "Request information";
			this.code = "UND_ERR_INFO";
		}
	};
	var RequestContentLengthMismatchError$1 = class RequestContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestContentLengthMismatchError$1);
			this.name = "RequestContentLengthMismatchError";
			this.message = message || "Request body length does not match content-length header";
			this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ResponseContentLengthMismatchError$1 = class ResponseContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseContentLengthMismatchError$1);
			this.name = "ResponseContentLengthMismatchError";
			this.message = message || "Response body length does not match content-length header";
			this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ClientDestroyedError$2 = class ClientDestroyedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientDestroyedError$2);
			this.name = "ClientDestroyedError";
			this.message = message || "The client is destroyed";
			this.code = "UND_ERR_DESTROYED";
		}
	};
	var ClientClosedError$1 = class ClientClosedError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientClosedError$1);
			this.name = "ClientClosedError";
			this.message = message || "The client is closed";
			this.code = "UND_ERR_CLOSED";
		}
	};
	var SocketError$3 = class SocketError$3 extends UndiciError$2 {
		constructor(message, socket) {
			super(message);
			Error.captureStackTrace(this, SocketError$3);
			this.name = "SocketError";
			this.message = message || "Socket error";
			this.code = "UND_ERR_SOCKET";
			this.socket = socket;
		}
	};
	var NotSupportedError$2 = class NotSupportedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "NotSupportedError";
			this.message = message || "Not supported error";
			this.code = "UND_ERR_NOT_SUPPORTED";
		}
	};
	var BalancedPoolMissingUpstreamError$1 = class extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "MissingUpstreamError";
			this.message = message || "No upstream has been added to the BalancedPool";
			this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
		}
	};
	var HTTPParserError$1 = class HTTPParserError$1 extends Error {
		constructor(message, code, data) {
			super(message);
			Error.captureStackTrace(this, HTTPParserError$1);
			this.name = "HTTPParserError";
			this.code = code ? `HPE_${code}` : void 0;
			this.data = data ? data.toString() : void 0;
		}
	};
	var ResponseExceededMaxSizeError$1 = class ResponseExceededMaxSizeError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseExceededMaxSizeError$1);
			this.name = "ResponseExceededMaxSizeError";
			this.message = message || "Response content exceeded max size";
			this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
		}
	};
	var RequestRetryError$1 = class RequestRetryError$1 extends UndiciError$2 {
		constructor(message, code, { headers, data }) {
			super(message);
			Error.captureStackTrace(this, RequestRetryError$1);
			this.name = "RequestRetryError";
			this.message = message || "Request retry error";
			this.code = "UND_ERR_REQ_RETRY";
			this.statusCode = code;
			this.data = data;
			this.headers = headers;
		}
	};
	module.exports = {
		HTTPParserError: HTTPParserError$1,
		UndiciError: UndiciError$2,
		HeadersTimeoutError: HeadersTimeoutError$1,
		HeadersOverflowError: HeadersOverflowError$1,
		BodyTimeoutError: BodyTimeoutError$1,
		RequestContentLengthMismatchError: RequestContentLengthMismatchError$1,
		ConnectTimeoutError: ConnectTimeoutError$1,
		ResponseStatusCodeError: ResponseStatusCodeError$1,
		InvalidArgumentError: InvalidArgumentError$22,
		InvalidReturnValueError: InvalidReturnValueError$2,
		RequestAbortedError: RequestAbortedError$9,
		ClientDestroyedError: ClientDestroyedError$2,
		ClientClosedError: ClientClosedError$1,
		InformationalError: InformationalError$1,
		SocketError: SocketError$3,
		NotSupportedError: NotSupportedError$2,
		ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,
		BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$1,
		ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1,
		RequestRetryError: RequestRetryError$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/constants.js
var require_constants$5 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/constants.js"(exports, module) {
	/** @type {Record<string, string | undefined>} */
	const headerNameLowerCasedRecord$1 = {};
	const wellknownHeaderNames = [
		"Accept",
		"Accept-Encoding",
		"Accept-Language",
		"Accept-Ranges",
		"Access-Control-Allow-Credentials",
		"Access-Control-Allow-Headers",
		"Access-Control-Allow-Methods",
		"Access-Control-Allow-Origin",
		"Access-Control-Expose-Headers",
		"Access-Control-Max-Age",
		"Access-Control-Request-Headers",
		"Access-Control-Request-Method",
		"Age",
		"Allow",
		"Alt-Svc",
		"Alt-Used",
		"Authorization",
		"Cache-Control",
		"Clear-Site-Data",
		"Connection",
		"Content-Disposition",
		"Content-Encoding",
		"Content-Language",
		"Content-Length",
		"Content-Location",
		"Content-Range",
		"Content-Security-Policy",
		"Content-Security-Policy-Report-Only",
		"Content-Type",
		"Cookie",
		"Cross-Origin-Embedder-Policy",
		"Cross-Origin-Opener-Policy",
		"Cross-Origin-Resource-Policy",
		"Date",
		"Device-Memory",
		"Downlink",
		"ECT",
		"ETag",
		"Expect",
		"Expect-CT",
		"Expires",
		"Forwarded",
		"From",
		"Host",
		"If-Match",
		"If-Modified-Since",
		"If-None-Match",
		"If-Range",
		"If-Unmodified-Since",
		"Keep-Alive",
		"Last-Modified",
		"Link",
		"Location",
		"Max-Forwards",
		"Origin",
		"Permissions-Policy",
		"Pragma",
		"Proxy-Authenticate",
		"Proxy-Authorization",
		"RTT",
		"Range",
		"Referer",
		"Referrer-Policy",
		"Refresh",
		"Retry-After",
		"Sec-WebSocket-Accept",
		"Sec-WebSocket-Extensions",
		"Sec-WebSocket-Key",
		"Sec-WebSocket-Protocol",
		"Sec-WebSocket-Version",
		"Server",
		"Server-Timing",
		"Service-Worker-Allowed",
		"Service-Worker-Navigation-Preload",
		"Set-Cookie",
		"SourceMap",
		"Strict-Transport-Security",
		"Supports-Loading-Mode",
		"TE",
		"Timing-Allow-Origin",
		"Trailer",
		"Transfer-Encoding",
		"Upgrade",
		"Upgrade-Insecure-Requests",
		"User-Agent",
		"Vary",
		"Via",
		"WWW-Authenticate",
		"X-Content-Type-Options",
		"X-DNS-Prefetch-Control",
		"X-Frame-Options",
		"X-Permitted-Cross-Domain-Policies",
		"X-Powered-By",
		"X-Requested-With",
		"X-XSS-Protection"
	];
	for (let i$1 = 0; i$1 < wellknownHeaderNames.length; ++i$1) {
		const key = wellknownHeaderNames[i$1];
		const lowerCasedKey = key.toLowerCase();
		headerNameLowerCasedRecord$1[key] = headerNameLowerCasedRecord$1[lowerCasedKey] = lowerCasedKey;
	}
	Object.setPrototypeOf(headerNameLowerCasedRecord$1, null);
	module.exports = {
		wellknownHeaderNames,
		headerNameLowerCasedRecord: headerNameLowerCasedRecord$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/util.js
var require_util$6 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/util.js"(exports, module) {
	const assert$20 = __require("assert");
	const { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$2 } = require_symbols$4();
	const { IncomingMessage } = __require("http");
	const stream$1 = __require("stream");
	const net$2 = __require("net");
	const { InvalidArgumentError: InvalidArgumentError$21 } = require_errors();
	const { Blob: Blob$8 } = __require("buffer");
	const nodeUtil = __require("util");
	const { stringify: stringify$3 } = __require("querystring");
	const { headerNameLowerCasedRecord } = require_constants$5();
	const [nodeMajor$1, nodeMinor$1] = process.versions.node.split(".").map((v) => Number(v));
	function nop$1() {}
	function isStream$1(obj) {
		return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
	}
	function isBlobLike$8(object) {
		return Blob$8 && object instanceof Blob$8 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
	}
	function buildURL$2(url, queryParams) {
		if (url.includes("?") || url.includes("#")) throw new Error("Query params cannot be passed when url already contains \"?\" or \"#\".");
		const stringified = stringify$3(queryParams);
		if (stringified) url += "?" + stringified;
		return url;
	}
	function parseURL$1(url) {
		if (typeof url === "string") {
			url = new URL(url);
			if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
			return url;
		}
		if (!url || typeof url !== "object") throw new InvalidArgumentError$21("Invalid URL: The URL argument must be a non-null object.");
		if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
		if (!(url instanceof URL)) {
			if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) throw new InvalidArgumentError$21("Invalid URL: port must be a valid integer or a string representation of an integer.");
			if (url.path != null && typeof url.path !== "string") throw new InvalidArgumentError$21("Invalid URL path: the path must be a string or null/undefined.");
			if (url.pathname != null && typeof url.pathname !== "string") throw new InvalidArgumentError$21("Invalid URL pathname: the pathname must be a string or null/undefined.");
			if (url.hostname != null && typeof url.hostname !== "string") throw new InvalidArgumentError$21("Invalid URL hostname: the hostname must be a string or null/undefined.");
			if (url.origin != null && typeof url.origin !== "string") throw new InvalidArgumentError$21("Invalid URL origin: the origin must be a string or null/undefined.");
			const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
			let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
			let path$9 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
			if (origin.endsWith("/")) origin = origin.substring(0, origin.length - 1);
			if (path$9 && !path$9.startsWith("/")) path$9 = `/${path$9}`;
			url = new URL(origin + path$9);
		}
		return url;
	}
	function parseOrigin$1(url) {
		url = parseURL$1(url);
		if (url.pathname !== "/" || url.search || url.hash) throw new InvalidArgumentError$21("invalid url");
		return url;
	}
	function getHostname(host) {
		if (host[0] === "[") {
			const idx$1 = host.indexOf("]");
			assert$20(idx$1 !== -1);
			return host.substring(1, idx$1);
		}
		const idx = host.indexOf(":");
		if (idx === -1) return host;
		return host.substring(0, idx);
	}
	function getServerName(host) {
		if (!host) return null;
		assert$20.strictEqual(typeof host, "string");
		const servername = getHostname(host);
		if (net$2.isIP(servername)) return "";
		return servername;
	}
	function deepClone(obj) {
		return JSON.parse(JSON.stringify(obj));
	}
	function isAsyncIterable(obj) {
		return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
	}
	function isIterable(obj) {
		return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
	}
	function bodyLength(body) {
		if (body == null) return 0;
		else if (isStream$1(body)) {
			const state = body._readableState;
			return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
		} else if (isBlobLike$8(body)) return body.size != null ? body.size : null;
		else if (isBuffer(body)) return body.byteLength;
		return null;
	}
	function isDestroyed(stream$2) {
		return !stream$2 || !!(stream$2.destroyed || stream$2[kDestroyed$1]);
	}
	function isReadableAborted(stream$2) {
		const state = stream$2 && stream$2._readableState;
		return isDestroyed(stream$2) && state && !state.endEmitted;
	}
	function destroy(stream$2, err) {
		if (stream$2 == null || !isStream$1(stream$2) || isDestroyed(stream$2)) return;
		if (typeof stream$2.destroy === "function") {
			if (Object.getPrototypeOf(stream$2).constructor === IncomingMessage) stream$2.socket = null;
			stream$2.destroy(err);
		} else if (err) process.nextTick((stream$3, err$1) => {
			stream$3.emit("error", err$1);
		}, stream$2, err);
		if (stream$2.destroyed !== true) stream$2[kDestroyed$1] = true;
	}
	const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout(val) {
		const m$1 = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
		return m$1 ? parseInt(m$1[1], 10) * 1e3 : null;
	}
	/**
	* Retrieves a header name and returns its lowercase value.
	* @param {string | Buffer} value Header name
	* @returns {string}
	*/
	function headerNameToString(value) {
		return headerNameLowerCasedRecord[value] || value.toLowerCase();
	}
	function parseHeaders$1(headers, obj = {}) {
		if (!Array.isArray(headers)) return headers;
		for (let i$1 = 0; i$1 < headers.length; i$1 += 2) {
			const key = headers[i$1].toString().toLowerCase();
			let val = obj[key];
			if (!val) if (Array.isArray(headers[i$1 + 1])) obj[key] = headers[i$1 + 1].map((x) => x.toString("utf8"));
			else obj[key] = headers[i$1 + 1].toString("utf8");
			else {
				if (!Array.isArray(val)) {
					val = [val];
					obj[key] = val;
				}
				val.push(headers[i$1 + 1].toString("utf8"));
			}
		}
		if ("content-length" in obj && "content-disposition" in obj) obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
		return obj;
	}
	function parseRawHeaders(headers) {
		const ret = [];
		let hasContentLength = false;
		let contentDispositionIdx = -1;
		for (let n$1 = 0; n$1 < headers.length; n$1 += 2) {
			const key = headers[n$1 + 0].toString();
			const val = headers[n$1 + 1].toString("utf8");
			if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
				ret.push(key, val);
				hasContentLength = true;
			} else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) contentDispositionIdx = ret.push(key, val) - 1;
			else ret.push(key, val);
		}
		if (hasContentLength && contentDispositionIdx !== -1) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
		return ret;
	}
	function isBuffer(buffer) {
		return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
	}
	function validateHandler(handler$1, method, upgrade$1) {
		if (!handler$1 || typeof handler$1 !== "object") throw new InvalidArgumentError$21("handler must be an object");
		if (typeof handler$1.onConnect !== "function") throw new InvalidArgumentError$21("invalid onConnect method");
		if (typeof handler$1.onError !== "function") throw new InvalidArgumentError$21("invalid onError method");
		if (typeof handler$1.onBodySent !== "function" && handler$1.onBodySent !== void 0) throw new InvalidArgumentError$21("invalid onBodySent method");
		if (upgrade$1 || method === "CONNECT") {
			if (typeof handler$1.onUpgrade !== "function") throw new InvalidArgumentError$21("invalid onUpgrade method");
		} else {
			if (typeof handler$1.onHeaders !== "function") throw new InvalidArgumentError$21("invalid onHeaders method");
			if (typeof handler$1.onData !== "function") throw new InvalidArgumentError$21("invalid onData method");
			if (typeof handler$1.onComplete !== "function") throw new InvalidArgumentError$21("invalid onComplete method");
		}
	}
	function isDisturbed$2(body) {
		return !!(body && (stream$1.isDisturbed ? stream$1.isDisturbed(body) || body[kBodyUsed$2] : body[kBodyUsed$2] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
	}
	function isErrored$2(body) {
		return !!(body && (stream$1.isErrored ? stream$1.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
	}
	function isReadable$1(body) {
		return !!(body && (stream$1.isReadable ? stream$1.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
	}
	function getSocketInfo(socket) {
		return {
			localAddress: socket.localAddress,
			localPort: socket.localPort,
			remoteAddress: socket.remoteAddress,
			remotePort: socket.remotePort,
			remoteFamily: socket.remoteFamily,
			timeout: socket.timeout,
			bytesWritten: socket.bytesWritten,
			bytesRead: socket.bytesRead
		};
	}
	async function* convertIterableToBuffer(iterable) {
		for await (const chunk of iterable) yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
	}
	let ReadableStream$7;
	function ReadableStreamFrom$3(iterable) {
		if (!ReadableStream$7) ReadableStream$7 = __require("stream/web").ReadableStream;
		if (ReadableStream$7.from) return ReadableStream$7.from(convertIterableToBuffer(iterable));
		let iterator$1;
		return new ReadableStream$7({
			async start() {
				iterator$1 = iterable[Symbol.asyncIterator]();
			},
			async pull(controller) {
				const { done, value } = await iterator$1.next();
				if (done) queueMicrotask(() => {
					controller.close();
				});
				else {
					const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
					controller.enqueue(new Uint8Array(buf));
				}
				return controller.desiredSize > 0;
			},
			async cancel(reason) {
				await iterator$1.return();
			}
		}, 0);
	}
	function isFormDataLike(object) {
		return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
	}
	function throwIfAborted$1(signal) {
		if (!signal) return;
		if (typeof signal.throwIfAborted === "function") signal.throwIfAborted();
		else if (signal.aborted) {
			const err = /* @__PURE__ */ new Error("The operation was aborted");
			err.name = "AbortError";
			throw err;
		}
	}
	function addAbortListener$3(signal, listener) {
		if ("addEventListener" in signal) {
			signal.addEventListener("abort", listener, { once: true });
			return () => signal.removeEventListener("abort", listener);
		}
		signal.addListener("abort", listener);
		return () => signal.removeListener("abort", listener);
	}
	const hasToWellFormed = !!String.prototype.toWellFormed;
	/**
	* @param {string} val
	*/
	function toUSVString$5(val) {
		if (hasToWellFormed) return `${val}`.toWellFormed();
		else if (nodeUtil.toUSVString) return nodeUtil.toUSVString(val);
		return `${val}`;
	}
	function parseRangeHeader$1(range) {
		if (range == null || range === "") return {
			start: 0,
			end: null,
			size: null
		};
		const m$1 = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
		return m$1 ? {
			start: parseInt(m$1[1]),
			end: m$1[2] ? parseInt(m$1[2]) : null,
			size: m$1[3] ? parseInt(m$1[3]) : null
		} : null;
	}
	const kEnumerableProperty$9 = Object.create(null);
	kEnumerableProperty$9.enumerable = true;
	module.exports = {
		kEnumerableProperty: kEnumerableProperty$9,
		nop: nop$1,
		isDisturbed: isDisturbed$2,
		isErrored: isErrored$2,
		isReadable: isReadable$1,
		toUSVString: toUSVString$5,
		isReadableAborted,
		isBlobLike: isBlobLike$8,
		parseOrigin: parseOrigin$1,
		parseURL: parseURL$1,
		getServerName,
		isStream: isStream$1,
		isIterable,
		isAsyncIterable,
		isDestroyed,
		headerNameToString,
		parseRawHeaders,
		parseHeaders: parseHeaders$1,
		parseKeepAliveTimeout,
		destroy,
		bodyLength,
		deepClone,
		ReadableStreamFrom: ReadableStreamFrom$3,
		isBuffer,
		validateHandler,
		getSocketInfo,
		isFormDataLike,
		buildURL: buildURL$2,
		throwIfAborted: throwIfAborted$1,
		addAbortListener: addAbortListener$3,
		parseRangeHeader: parseRangeHeader$1,
		nodeMajor: nodeMajor$1,
		nodeMinor: nodeMinor$1,
		nodeHasAutoSelectFamily: nodeMajor$1 > 18 || nodeMajor$1 === 18 && nodeMinor$1 >= 13,
		safeHTTPMethods: [
			"GET",
			"HEAD",
			"OPTIONS",
			"TRACE"
		]
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/timers.js
var require_timers = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/timers.js"(exports, module) {
	let fastNow = Date.now();
	let fastNowTimeout;
	const fastTimers = [];
	function onTimeout() {
		fastNow = Date.now();
		let len = fastTimers.length;
		let idx = 0;
		while (idx < len) {
			const timer = fastTimers[idx];
			if (timer.state === 0) timer.state = fastNow + timer.delay;
			else if (timer.state > 0 && fastNow >= timer.state) {
				timer.state = -1;
				timer.callback(timer.opaque);
			}
			if (timer.state === -1) {
				timer.state = -2;
				if (idx !== len - 1) fastTimers[idx] = fastTimers.pop();
				else fastTimers.pop();
				len -= 1;
			} else idx += 1;
		}
		if (fastTimers.length > 0) refreshTimeout();
	}
	function refreshTimeout() {
		if (fastNowTimeout && fastNowTimeout.refresh) fastNowTimeout.refresh();
		else {
			clearTimeout(fastNowTimeout);
			fastNowTimeout = setTimeout(onTimeout, 1e3);
			if (fastNowTimeout.unref) fastNowTimeout.unref();
		}
	}
	var Timeout = class {
		constructor(callback, delay, opaque) {
			this.callback = callback;
			this.delay = delay;
			this.opaque = opaque;
			this.state = -2;
			this.refresh();
		}
		refresh() {
			if (this.state === -2) {
				fastTimers.push(this);
				if (!fastNowTimeout || fastTimers.length === 1) refreshTimeout();
			}
			this.state = 0;
		}
		clear() {
			this.state = -1;
		}
	};
	module.exports = {
		setTimeout(callback, delay, opaque) {
			return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
		},
		clearTimeout(timeout) {
			if (timeout instanceof Timeout) timeout.clear();
			else clearTimeout(timeout);
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
	/**
	* Copyright Brian White. All rights reserved.
	*
	* @see https://github.com/mscdex/streamsearch
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to
	* deal in the Software without restriction, including without limitation the
	* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	* sell copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	* IN THE SOFTWARE.
	*
	* Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	* by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	*/
	const EventEmitter$3 = __require("node:events").EventEmitter;
	const inherits$5 = __require("node:util").inherits;
	function SBMH(needle) {
		if (typeof needle === "string") needle = Buffer.from(needle);
		if (!Buffer.isBuffer(needle)) throw new TypeError("The needle has to be a String or a Buffer.");
		const needleLength = needle.length;
		if (needleLength === 0) throw new Error("The needle cannot be an empty String/Buffer.");
		if (needleLength > 256) throw new Error("The needle cannot have a length bigger than 256.");
		this.maxMatches = Infinity;
		this.matches = 0;
		this._occ = new Array(256).fill(needleLength);
		this._lookbehind_size = 0;
		this._needle = needle;
		this._bufpos = 0;
		this._lookbehind = Buffer.alloc(needleLength);
		for (var i$1 = 0; i$1 < needleLength - 1; ++i$1) this._occ[needle[i$1]] = needleLength - 1 - i$1;
	}
	inherits$5(SBMH, EventEmitter$3);
	SBMH.prototype.reset = function() {
		this._lookbehind_size = 0;
		this.matches = 0;
		this._bufpos = 0;
	};
	SBMH.prototype.push = function(chunk, pos) {
		if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, "binary");
		const chlen = chunk.length;
		this._bufpos = pos || 0;
		let r;
		while (r !== chlen && this.matches < this.maxMatches) r = this._sbmh_feed(chunk);
		return r;
	};
	SBMH.prototype._sbmh_feed = function(data) {
		const len = data.length;
		const needle = this._needle;
		const needleLength = needle.length;
		const lastNeedleChar = needle[needleLength - 1];
		let pos = -this._lookbehind_size;
		let ch;
		if (pos < 0) {
			while (pos < 0 && pos <= len - needleLength) {
				ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
				if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
					this._lookbehind_size = 0;
					++this.matches;
					this.emit("info", true);
					return this._bufpos = pos + needleLength;
				}
				pos += this._occ[ch];
			}
			if (pos < 0) while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) ++pos;
			if (pos >= 0) {
				this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
				this._lookbehind_size = 0;
			} else {
				const bytesToCutOff = this._lookbehind_size + pos;
				if (bytesToCutOff > 0) this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
				this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
				this._lookbehind_size -= bytesToCutOff;
				data.copy(this._lookbehind, this._lookbehind_size);
				this._lookbehind_size += len;
				this._bufpos = len;
				return len;
			}
		}
		pos += (pos >= 0) * this._bufpos;
		if (data.indexOf(needle, pos) !== -1) {
			pos = data.indexOf(needle, pos);
			++this.matches;
			if (pos > 0) this.emit("info", true, data, this._bufpos, pos);
			else this.emit("info", true);
			return this._bufpos = pos + needleLength;
		} else pos = len - needleLength;
		while (pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)) ++pos;
		if (pos < len) {
			data.copy(this._lookbehind, 0, pos, pos + (len - pos));
			this._lookbehind_size = len - pos;
		}
		if (pos > 0) this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
		this._bufpos = len;
		return len;
	};
	SBMH.prototype._sbmh_lookup_char = function(data, pos) {
		return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
	};
	SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
		for (var i$1 = 0; i$1 < len; ++i$1) if (this._sbmh_lookup_char(data, pos + i$1) !== this._needle[i$1]) return false;
		return true;
	};
	module.exports = SBMH;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
	const inherits$4 = __require("node:util").inherits;
	const ReadableStream$6 = __require("node:stream").Readable;
	function PartStream$1(opts) {
		ReadableStream$6.call(this, opts);
	}
	inherits$4(PartStream$1, ReadableStream$6);
	PartStream$1.prototype._read = function(n$1) {};
	module.exports = PartStream$1;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
	module.exports = function getLimit$3(limits, name, defaultLimit) {
		if (!limits || limits[name] === void 0 || limits[name] === null) return defaultLimit;
		if (typeof limits[name] !== "number" || isNaN(limits[name])) throw new TypeError("Limit " + name + " is not a valid number");
		return limits[name];
	};
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
	const EventEmitter$2 = __require("node:events").EventEmitter;
	const inherits$3 = __require("node:util").inherits;
	const getLimit$2 = require_getLimit();
	const StreamSearch$1 = require_sbmh();
	const B_DCRLF = Buffer.from("\r\n\r\n");
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
	function HeaderParser$1(cfg) {
		EventEmitter$2.call(this);
		cfg = cfg || {};
		const self = this;
		this.nread = 0;
		this.maxed = false;
		this.npairs = 0;
		this.maxHeaderPairs = getLimit$2(cfg, "maxHeaderPairs", 2e3);
		this.maxHeaderSize = getLimit$2(cfg, "maxHeaderSize", 80 * 1024);
		this.buffer = "";
		this.header = {};
		this.finished = false;
		this.ss = new StreamSearch$1(B_DCRLF);
		this.ss.on("info", function(isMatch, data, start, end) {
			if (data && !self.maxed) {
				if (self.nread + end - start >= self.maxHeaderSize) {
					end = self.maxHeaderSize - self.nread + start;
					self.nread = self.maxHeaderSize;
					self.maxed = true;
				} else self.nread += end - start;
				self.buffer += data.toString("binary", start, end);
			}
			if (isMatch) self._finish();
		});
	}
	inherits$3(HeaderParser$1, EventEmitter$2);
	HeaderParser$1.prototype.push = function(data) {
		const r = this.ss.push(data);
		if (this.finished) return r;
	};
	HeaderParser$1.prototype.reset = function() {
		this.finished = false;
		this.buffer = "";
		this.header = {};
		this.ss.reset();
	};
	HeaderParser$1.prototype._finish = function() {
		if (this.buffer) this._parseHeader();
		this.ss.matches = this.ss.maxMatches;
		const header = this.header;
		this.header = {};
		this.buffer = "";
		this.finished = true;
		this.nread = this.npairs = 0;
		this.maxed = false;
		this.emit("header", header);
	};
	HeaderParser$1.prototype._parseHeader = function() {
		if (this.npairs === this.maxHeaderPairs) return;
		const lines = this.buffer.split(RE_CRLF);
		const len = lines.length;
		let m$1, h$2;
		for (var i$1 = 0; i$1 < len; ++i$1) {
			if (lines[i$1].length === 0) continue;
			if (lines[i$1][0] === "	" || lines[i$1][0] === " ") {
				if (h$2) {
					this.header[h$2][this.header[h$2].length - 1] += lines[i$1];
					continue;
				}
			}
			const posColon = lines[i$1].indexOf(":");
			if (posColon === -1 || posColon === 0) return;
			m$1 = RE_HDR.exec(lines[i$1]);
			h$2 = m$1[1].toLowerCase();
			this.header[h$2] = this.header[h$2] || [];
			this.header[h$2].push(m$1[2] || "");
			if (++this.npairs === this.maxHeaderPairs) break;
		}
	};
	module.exports = HeaderParser$1;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
	const WritableStream$1 = __require("node:stream").Writable;
	const inherits$2 = __require("node:util").inherits;
	const StreamSearch = require_sbmh();
	const PartStream = require_PartStream();
	const HeaderParser = require_HeaderParser();
	const DASH = 45;
	const B_ONEDASH = Buffer.from("-");
	const B_CRLF = Buffer.from("\r\n");
	const EMPTY_FN = function() {};
	function Dicer$2(cfg) {
		if (!(this instanceof Dicer$2)) return new Dicer$2(cfg);
		WritableStream$1.call(this, cfg);
		if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") throw new TypeError("Boundary required");
		if (typeof cfg.boundary === "string") this.setBoundary(cfg.boundary);
		else this._bparser = void 0;
		this._headerFirst = cfg.headerFirst;
		this._dashes = 0;
		this._parts = 0;
		this._finished = false;
		this._realFinish = false;
		this._isPreamble = true;
		this._justMatched = false;
		this._firstWrite = true;
		this._inHeader = true;
		this._part = void 0;
		this._cb = void 0;
		this._ignoreData = false;
		this._partOpts = { highWaterMark: cfg.partHwm };
		this._pause = false;
		const self = this;
		this._hparser = new HeaderParser(cfg);
		this._hparser.on("header", function(header) {
			self._inHeader = false;
			self._part.emit("header", header);
		});
	}
	inherits$2(Dicer$2, WritableStream$1);
	Dicer$2.prototype.emit = function(ev) {
		if (ev === "finish" && !this._realFinish) {
			if (!this._finished) {
				const self = this;
				process.nextTick(function() {
					self.emit("error", /* @__PURE__ */ new Error("Unexpected end of multipart data"));
					if (self._part && !self._ignoreData) {
						const type = self._isPreamble ? "Preamble" : "Part";
						self._part.emit("error", /* @__PURE__ */ new Error(type + " terminated early due to unexpected end of multipart data"));
						self._part.push(null);
						process.nextTick(function() {
							self._realFinish = true;
							self.emit("finish");
							self._realFinish = false;
						});
						return;
					}
					self._realFinish = true;
					self.emit("finish");
					self._realFinish = false;
				});
			}
		} else WritableStream$1.prototype.emit.apply(this, arguments);
	};
	Dicer$2.prototype._write = function(data, encoding, cb) {
		if (!this._hparser && !this._bparser) return cb();
		if (this._headerFirst && this._isPreamble) {
			if (!this._part) {
				this._part = new PartStream(this._partOpts);
				if (this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
				else this._ignore();
			}
			const r = this._hparser.push(data);
			if (!this._inHeader && r !== void 0 && r < data.length) data = data.slice(r);
			else return cb();
		}
		if (this._firstWrite) {
			this._bparser.push(B_CRLF);
			this._firstWrite = false;
		}
		this._bparser.push(data);
		if (this._pause) this._cb = cb;
		else cb();
	};
	Dicer$2.prototype.reset = function() {
		this._part = void 0;
		this._bparser = void 0;
		this._hparser = void 0;
	};
	Dicer$2.prototype.setBoundary = function(boundary) {
		const self = this;
		this._bparser = new StreamSearch("\r\n--" + boundary);
		this._bparser.on("info", function(isMatch, data, start, end) {
			self._oninfo(isMatch, data, start, end);
		});
	};
	Dicer$2.prototype._ignore = function() {
		if (this._part && !this._ignoreData) {
			this._ignoreData = true;
			this._part.on("error", EMPTY_FN);
			this._part.resume();
		}
	};
	Dicer$2.prototype._oninfo = function(isMatch, data, start, end) {
		let buf;
		const self = this;
		let i$1 = 0;
		let r;
		let shouldWriteMore = true;
		if (!this._part && this._justMatched && data) {
			while (this._dashes < 2 && start + i$1 < end) if (data[start + i$1] === DASH) {
				++i$1;
				++this._dashes;
			} else {
				if (this._dashes) buf = B_ONEDASH;
				this._dashes = 0;
				break;
			}
			if (this._dashes === 2) {
				if (start + i$1 < end && this.listenerCount("trailer") !== 0) this.emit("trailer", data.slice(start + i$1, end));
				this.reset();
				this._finished = true;
				if (self._parts === 0) {
					self._realFinish = true;
					self.emit("finish");
					self._realFinish = false;
				}
			}
			if (this._dashes) return;
		}
		if (this._justMatched) this._justMatched = false;
		if (!this._part) {
			this._part = new PartStream(this._partOpts);
			this._part._read = function(n$1) {
				self._unpause();
			};
			if (this._isPreamble && this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
			else if (this._isPreamble !== true && this.listenerCount("part") !== 0) this.emit("part", this._part);
			else this._ignore();
			if (!this._isPreamble) this._inHeader = true;
		}
		if (data && start < end && !this._ignoreData) {
			if (this._isPreamble || !this._inHeader) {
				if (buf) shouldWriteMore = this._part.push(buf);
				shouldWriteMore = this._part.push(data.slice(start, end));
				if (!shouldWriteMore) this._pause = true;
			} else if (!this._isPreamble && this._inHeader) {
				if (buf) this._hparser.push(buf);
				r = this._hparser.push(data.slice(start, end));
				if (!this._inHeader && r !== void 0 && r < end) this._oninfo(false, data, start + r, end);
			}
		}
		if (isMatch) {
			this._hparser.reset();
			if (this._isPreamble) this._isPreamble = false;
			else if (start !== end) {
				++this._parts;
				this._part.on("end", function() {
					if (--self._parts === 0) if (self._finished) {
						self._realFinish = true;
						self.emit("finish");
						self._realFinish = false;
					} else self._unpause();
				});
			}
			this._part.push(null);
			this._part = void 0;
			this._ignoreData = false;
			this._justMatched = true;
			this._dashes = 0;
		}
	};
	Dicer$2.prototype._unpause = function() {
		if (!this._pause) return;
		this._pause = false;
		if (this._cb) {
			const cb = this._cb;
			this._cb = void 0;
			cb();
		}
	};
	module.exports = Dicer$2;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
	const utf8Decoder = new TextDecoder("utf-8");
	const textDecoders = new Map([["utf-8", utf8Decoder], ["utf8", utf8Decoder]]);
	function getDecoder(charset) {
		let lc;
		while (true) switch (charset) {
			case "utf-8":
			case "utf8": return decoders.utf8;
			case "latin1":
			case "ascii":
			case "us-ascii":
			case "iso-8859-1":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "windows-1252":
			case "iso_8859-1:1987":
			case "cp1252":
			case "x-cp1252": return decoders.latin1;
			case "utf16le":
			case "utf-16le":
			case "ucs2":
			case "ucs-2": return decoders.utf16le;
			case "base64": return decoders.base64;
			default:
				if (lc === void 0) {
					lc = true;
					charset = charset.toLowerCase();
					continue;
				}
				return decoders.other.bind(charset);
		}
	}
	const decoders = {
		utf8: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.utf8Slice(0, data.length);
		},
		latin1: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") return data;
			return data.latin1Slice(0, data.length);
		},
		utf16le: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.ucs2Slice(0, data.length);
		},
		base64: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.base64Slice(0, data.length);
		},
		other: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			if (textDecoders.has((void 0).toString())) try {
				return textDecoders.get(void 0).decode(data);
			} catch {}
			return typeof data === "string" ? data : data.toString();
		}
	};
	function decodeText$3(text, sourceEncoding, destEncoding) {
		if (text) return getDecoder(destEncoding)(text, sourceEncoding);
		return text;
	}
	module.exports = decodeText$3;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
	const decodeText$2 = require_decodeText();
	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
	const EncodedLookup = {
		"%00": "\0",
		"%01": "",
		"%02": "",
		"%03": "",
		"%04": "",
		"%05": "",
		"%06": "",
		"%07": "\x07",
		"%08": "\b",
		"%09": "	",
		"%0a": "\n",
		"%0A": "\n",
		"%0b": "\v",
		"%0B": "\v",
		"%0c": "\f",
		"%0C": "\f",
		"%0d": "\r",
		"%0D": "\r",
		"%0e": "",
		"%0E": "",
		"%0f": "",
		"%0F": "",
		"%10": "",
		"%11": "",
		"%12": "",
		"%13": "",
		"%14": "",
		"%15": "",
		"%16": "",
		"%17": "",
		"%18": "",
		"%19": "",
		"%1a": "",
		"%1A": "",
		"%1b": "\x1B",
		"%1B": "\x1B",
		"%1c": "",
		"%1C": "",
		"%1d": "",
		"%1D": "",
		"%1e": "",
		"%1E": "",
		"%1f": "",
		"%1F": "",
		"%20": " ",
		"%21": "!",
		"%22": "\"",
		"%23": "#",
		"%24": "$",
		"%25": "%",
		"%26": "&",
		"%27": "'",
		"%28": "(",
		"%29": ")",
		"%2a": "*",
		"%2A": "*",
		"%2b": "+",
		"%2B": "+",
		"%2c": ",",
		"%2C": ",",
		"%2d": "-",
		"%2D": "-",
		"%2e": ".",
		"%2E": ".",
		"%2f": "/",
		"%2F": "/",
		"%30": "0",
		"%31": "1",
		"%32": "2",
		"%33": "3",
		"%34": "4",
		"%35": "5",
		"%36": "6",
		"%37": "7",
		"%38": "8",
		"%39": "9",
		"%3a": ":",
		"%3A": ":",
		"%3b": ";",
		"%3B": ";",
		"%3c": "<",
		"%3C": "<",
		"%3d": "=",
		"%3D": "=",
		"%3e": ">",
		"%3E": ">",
		"%3f": "?",
		"%3F": "?",
		"%40": "@",
		"%41": "A",
		"%42": "B",
		"%43": "C",
		"%44": "D",
		"%45": "E",
		"%46": "F",
		"%47": "G",
		"%48": "H",
		"%49": "I",
		"%4a": "J",
		"%4A": "J",
		"%4b": "K",
		"%4B": "K",
		"%4c": "L",
		"%4C": "L",
		"%4d": "M",
		"%4D": "M",
		"%4e": "N",
		"%4E": "N",
		"%4f": "O",
		"%4F": "O",
		"%50": "P",
		"%51": "Q",
		"%52": "R",
		"%53": "S",
		"%54": "T",
		"%55": "U",
		"%56": "V",
		"%57": "W",
		"%58": "X",
		"%59": "Y",
		"%5a": "Z",
		"%5A": "Z",
		"%5b": "[",
		"%5B": "[",
		"%5c": "\\",
		"%5C": "\\",
		"%5d": "]",
		"%5D": "]",
		"%5e": "^",
		"%5E": "^",
		"%5f": "_",
		"%5F": "_",
		"%60": "`",
		"%61": "a",
		"%62": "b",
		"%63": "c",
		"%64": "d",
		"%65": "e",
		"%66": "f",
		"%67": "g",
		"%68": "h",
		"%69": "i",
		"%6a": "j",
		"%6A": "j",
		"%6b": "k",
		"%6B": "k",
		"%6c": "l",
		"%6C": "l",
		"%6d": "m",
		"%6D": "m",
		"%6e": "n",
		"%6E": "n",
		"%6f": "o",
		"%6F": "o",
		"%70": "p",
		"%71": "q",
		"%72": "r",
		"%73": "s",
		"%74": "t",
		"%75": "u",
		"%76": "v",
		"%77": "w",
		"%78": "x",
		"%79": "y",
		"%7a": "z",
		"%7A": "z",
		"%7b": "{",
		"%7B": "{",
		"%7c": "|",
		"%7C": "|",
		"%7d": "}",
		"%7D": "}",
		"%7e": "~",
		"%7E": "~",
		"%7f": "",
		"%7F": "",
		"%80": "",
		"%81": "",
		"%82": "",
		"%83": "",
		"%84": "",
		"%85": "",
		"%86": "",
		"%87": "",
		"%88": "",
		"%89": "",
		"%8a": "",
		"%8A": "",
		"%8b": "",
		"%8B": "",
		"%8c": "",
		"%8C": "",
		"%8d": "",
		"%8D": "",
		"%8e": "",
		"%8E": "",
		"%8f": "",
		"%8F": "",
		"%90": "",
		"%91": "",
		"%92": "",
		"%93": "",
		"%94": "",
		"%95": "",
		"%96": "",
		"%97": "",
		"%98": "",
		"%99": "",
		"%9a": "",
		"%9A": "",
		"%9b": "",
		"%9B": "",
		"%9c": "",
		"%9C": "",
		"%9d": "",
		"%9D": "",
		"%9e": "",
		"%9E": "",
		"%9f": "",
		"%9F": "",
		"%a0": "\xA0",
		"%A0": "\xA0",
		"%a1": "¡",
		"%A1": "¡",
		"%a2": "¢",
		"%A2": "¢",
		"%a3": "£",
		"%A3": "£",
		"%a4": "¤",
		"%A4": "¤",
		"%a5": "¥",
		"%A5": "¥",
		"%a6": "¦",
		"%A6": "¦",
		"%a7": "§",
		"%A7": "§",
		"%a8": "¨",
		"%A8": "¨",
		"%a9": "©",
		"%A9": "©",
		"%aa": "ª",
		"%Aa": "ª",
		"%aA": "ª",
		"%AA": "ª",
		"%ab": "«",
		"%Ab": "«",
		"%aB": "«",
		"%AB": "«",
		"%ac": "¬",
		"%Ac": "¬",
		"%aC": "¬",
		"%AC": "¬",
		"%ad": "­",
		"%Ad": "­",
		"%aD": "­",
		"%AD": "­",
		"%ae": "®",
		"%Ae": "®",
		"%aE": "®",
		"%AE": "®",
		"%af": "¯",
		"%Af": "¯",
		"%aF": "¯",
		"%AF": "¯",
		"%b0": "°",
		"%B0": "°",
		"%b1": "±",
		"%B1": "±",
		"%b2": "²",
		"%B2": "²",
		"%b3": "³",
		"%B3": "³",
		"%b4": "´",
		"%B4": "´",
		"%b5": "µ",
		"%B5": "µ",
		"%b6": "¶",
		"%B6": "¶",
		"%b7": "·",
		"%B7": "·",
		"%b8": "¸",
		"%B8": "¸",
		"%b9": "¹",
		"%B9": "¹",
		"%ba": "º",
		"%Ba": "º",
		"%bA": "º",
		"%BA": "º",
		"%bb": "»",
		"%Bb": "»",
		"%bB": "»",
		"%BB": "»",
		"%bc": "¼",
		"%Bc": "¼",
		"%bC": "¼",
		"%BC": "¼",
		"%bd": "½",
		"%Bd": "½",
		"%bD": "½",
		"%BD": "½",
		"%be": "¾",
		"%Be": "¾",
		"%bE": "¾",
		"%BE": "¾",
		"%bf": "¿",
		"%Bf": "¿",
		"%bF": "¿",
		"%BF": "¿",
		"%c0": "À",
		"%C0": "À",
		"%c1": "Á",
		"%C1": "Á",
		"%c2": "Â",
		"%C2": "Â",
		"%c3": "Ã",
		"%C3": "Ã",
		"%c4": "Ä",
		"%C4": "Ä",
		"%c5": "Å",
		"%C5": "Å",
		"%c6": "Æ",
		"%C6": "Æ",
		"%c7": "Ç",
		"%C7": "Ç",
		"%c8": "È",
		"%C8": "È",
		"%c9": "É",
		"%C9": "É",
		"%ca": "Ê",
		"%Ca": "Ê",
		"%cA": "Ê",
		"%CA": "Ê",
		"%cb": "Ë",
		"%Cb": "Ë",
		"%cB": "Ë",
		"%CB": "Ë",
		"%cc": "Ì",
		"%Cc": "Ì",
		"%cC": "Ì",
		"%CC": "Ì",
		"%cd": "Í",
		"%Cd": "Í",
		"%cD": "Í",
		"%CD": "Í",
		"%ce": "Î",
		"%Ce": "Î",
		"%cE": "Î",
		"%CE": "Î",
		"%cf": "Ï",
		"%Cf": "Ï",
		"%cF": "Ï",
		"%CF": "Ï",
		"%d0": "Ð",
		"%D0": "Ð",
		"%d1": "Ñ",
		"%D1": "Ñ",
		"%d2": "Ò",
		"%D2": "Ò",
		"%d3": "Ó",
		"%D3": "Ó",
		"%d4": "Ô",
		"%D4": "Ô",
		"%d5": "Õ",
		"%D5": "Õ",
		"%d6": "Ö",
		"%D6": "Ö",
		"%d7": "×",
		"%D7": "×",
		"%d8": "Ø",
		"%D8": "Ø",
		"%d9": "Ù",
		"%D9": "Ù",
		"%da": "Ú",
		"%Da": "Ú",
		"%dA": "Ú",
		"%DA": "Ú",
		"%db": "Û",
		"%Db": "Û",
		"%dB": "Û",
		"%DB": "Û",
		"%dc": "Ü",
		"%Dc": "Ü",
		"%dC": "Ü",
		"%DC": "Ü",
		"%dd": "Ý",
		"%Dd": "Ý",
		"%dD": "Ý",
		"%DD": "Ý",
		"%de": "Þ",
		"%De": "Þ",
		"%dE": "Þ",
		"%DE": "Þ",
		"%df": "ß",
		"%Df": "ß",
		"%dF": "ß",
		"%DF": "ß",
		"%e0": "à",
		"%E0": "à",
		"%e1": "á",
		"%E1": "á",
		"%e2": "â",
		"%E2": "â",
		"%e3": "ã",
		"%E3": "ã",
		"%e4": "ä",
		"%E4": "ä",
		"%e5": "å",
		"%E5": "å",
		"%e6": "æ",
		"%E6": "æ",
		"%e7": "ç",
		"%E7": "ç",
		"%e8": "è",
		"%E8": "è",
		"%e9": "é",
		"%E9": "é",
		"%ea": "ê",
		"%Ea": "ê",
		"%eA": "ê",
		"%EA": "ê",
		"%eb": "ë",
		"%Eb": "ë",
		"%eB": "ë",
		"%EB": "ë",
		"%ec": "ì",
		"%Ec": "ì",
		"%eC": "ì",
		"%EC": "ì",
		"%ed": "í",
		"%Ed": "í",
		"%eD": "í",
		"%ED": "í",
		"%ee": "î",
		"%Ee": "î",
		"%eE": "î",
		"%EE": "î",
		"%ef": "ï",
		"%Ef": "ï",
		"%eF": "ï",
		"%EF": "ï",
		"%f0": "ð",
		"%F0": "ð",
		"%f1": "ñ",
		"%F1": "ñ",
		"%f2": "ò",
		"%F2": "ò",
		"%f3": "ó",
		"%F3": "ó",
		"%f4": "ô",
		"%F4": "ô",
		"%f5": "õ",
		"%F5": "õ",
		"%f6": "ö",
		"%F6": "ö",
		"%f7": "÷",
		"%F7": "÷",
		"%f8": "ø",
		"%F8": "ø",
		"%f9": "ù",
		"%F9": "ù",
		"%fa": "ú",
		"%Fa": "ú",
		"%fA": "ú",
		"%FA": "ú",
		"%fb": "û",
		"%Fb": "û",
		"%fB": "û",
		"%FB": "û",
		"%fc": "ü",
		"%Fc": "ü",
		"%fC": "ü",
		"%FC": "ü",
		"%fd": "ý",
		"%Fd": "ý",
		"%fD": "ý",
		"%FD": "ý",
		"%fe": "þ",
		"%Fe": "þ",
		"%fE": "þ",
		"%FE": "þ",
		"%ff": "ÿ",
		"%Ff": "ÿ",
		"%fF": "ÿ",
		"%FF": "ÿ"
	};
	function encodedReplacer(match) {
		return EncodedLookup[match];
	}
	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;
	function parseParams$2(str$1) {
		const res = [];
		let state = STATE_KEY;
		let charset = "";
		let inquote = false;
		let escaping = false;
		let p = 0;
		let tmp = "";
		const len = str$1.length;
		for (var i$1 = 0; i$1 < len; ++i$1) {
			const char = str$1[i$1];
			if (char === "\\" && inquote) if (escaping) escaping = false;
			else {
				escaping = true;
				continue;
			}
			else if (char === "\"") if (!escaping) {
				if (inquote) {
					inquote = false;
					state = STATE_KEY;
				} else inquote = true;
				continue;
			} else escaping = false;
			else {
				if (escaping && inquote) tmp += "\\";
				escaping = false;
				if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
					if (state === STATE_CHARSET) {
						state = STATE_LANG;
						charset = tmp.substring(1);
					} else state = STATE_VALUE;
					tmp = "";
					continue;
				} else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
					state = char === "*" ? STATE_CHARSET : STATE_VALUE;
					res[p] = [tmp, void 0];
					tmp = "";
					continue;
				} else if (!inquote && char === ";") {
					state = STATE_KEY;
					if (charset) {
						if (tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
						charset = "";
					} else if (tmp.length) tmp = decodeText$2(tmp, "binary", "utf8");
					if (res[p] === void 0) res[p] = tmp;
					else res[p][1] = tmp;
					tmp = "";
					++p;
					continue;
				} else if (!inquote && (char === " " || char === "	")) continue;
			}
			tmp += char;
		}
		if (charset && tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
		else if (tmp) tmp = decodeText$2(tmp, "binary", "utf8");
		if (res[p] === void 0) {
			if (tmp) res[p] = tmp;
		} else res[p][1] = tmp;
		return res;
	}
	module.exports = parseParams$2;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
	module.exports = function basename$1(path$9) {
		if (typeof path$9 !== "string") return "";
		for (var i$1 = path$9.length - 1; i$1 >= 0; --i$1) switch (path$9.charCodeAt(i$1)) {
			case 47:
			case 92:
				path$9 = path$9.slice(i$1 + 1);
				return path$9 === ".." || path$9 === "." ? "" : path$9;
		}
		return path$9 === ".." || path$9 === "." ? "" : path$9;
	};
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
	const { Readable: Readable$6 } = __require("node:stream");
	const { inherits: inherits$1 } = __require("node:util");
	const Dicer$1 = require_Dicer();
	const parseParams$1 = require_parseParams();
	const decodeText$1 = require_decodeText();
	const basename = require_basename();
	const getLimit$1 = require_getLimit();
	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET$1 = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;
	Multipart.detect = /^multipart\/form-data/i;
	function Multipart(boy, cfg) {
		let i$1;
		let len;
		const self = this;
		let boundary;
		const limits = cfg.limits;
		const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
		const parsedConType = cfg.parsedConType || [];
		const defCharset = cfg.defCharset || "utf8";
		const preservePath = cfg.preservePath;
		const fileOpts = { highWaterMark: cfg.fileHwm };
		for (i$1 = 0, len = parsedConType.length; i$1 < len; ++i$1) if (Array.isArray(parsedConType[i$1]) && RE_BOUNDARY.test(parsedConType[i$1][0])) {
			boundary = parsedConType[i$1][1];
			break;
		}
		function checkFinished() {
			if (nends === 0 && finished$2 && !boy._done) {
				finished$2 = false;
				self.end();
			}
		}
		if (typeof boundary !== "string") throw new Error("Multipart: Boundary not found");
		const fieldSizeLimit = getLimit$1(limits, "fieldSize", 1 * 1024 * 1024);
		const fileSizeLimit = getLimit$1(limits, "fileSize", Infinity);
		const filesLimit = getLimit$1(limits, "files", Infinity);
		const fieldsLimit = getLimit$1(limits, "fields", Infinity);
		const partsLimit = getLimit$1(limits, "parts", Infinity);
		const headerPairsLimit = getLimit$1(limits, "headerPairs", 2e3);
		const headerSizeLimit = getLimit$1(limits, "headerSize", 80 * 1024);
		let nfiles = 0;
		let nfields = 0;
		let nends = 0;
		let curFile;
		let curField;
		let finished$2 = false;
		this._needDrain = false;
		this._pause = false;
		this._cb = void 0;
		this._nparts = 0;
		this._boy = boy;
		const parserCfg = {
			boundary,
			maxHeaderPairs: headerPairsLimit,
			maxHeaderSize: headerSizeLimit,
			partHwm: fileOpts.highWaterMark,
			highWaterMark: cfg.highWaterMark
		};
		this.parser = new Dicer$1(parserCfg);
		this.parser.on("drain", function() {
			self._needDrain = false;
			if (self._cb && !self._pause) {
				const cb = self._cb;
				self._cb = void 0;
				cb();
			}
		}).on("part", function onPart(part) {
			if (++self._nparts > partsLimit) {
				self.parser.removeListener("part", onPart);
				self.parser.on("part", skipPart);
				boy.hitPartsLimit = true;
				boy.emit("partsLimit");
				return skipPart(part);
			}
			if (curField) {
				const field = curField;
				field.emit("end");
				field.removeAllListeners("end");
			}
			part.on("header", function(header) {
				let contype;
				let fieldname;
				let parsed;
				let charset;
				let encoding;
				let filename;
				let nsize = 0;
				if (header["content-type"]) {
					parsed = parseParams$1(header["content-type"][0]);
					if (parsed[0]) {
						contype = parsed[0].toLowerCase();
						for (i$1 = 0, len = parsed.length; i$1 < len; ++i$1) if (RE_CHARSET$1.test(parsed[i$1][0])) {
							charset = parsed[i$1][1].toLowerCase();
							break;
						}
					}
				}
				if (contype === void 0) contype = "text/plain";
				if (charset === void 0) charset = defCharset;
				if (header["content-disposition"]) {
					parsed = parseParams$1(header["content-disposition"][0]);
					if (!RE_FIELD.test(parsed[0])) return skipPart(part);
					for (i$1 = 0, len = parsed.length; i$1 < len; ++i$1) if (RE_NAME.test(parsed[i$1][0])) fieldname = parsed[i$1][1];
					else if (RE_FILENAME.test(parsed[i$1][0])) {
						filename = parsed[i$1][1];
						if (!preservePath) filename = basename(filename);
					}
				} else return skipPart(part);
				if (header["content-transfer-encoding"]) encoding = header["content-transfer-encoding"][0].toLowerCase();
				else encoding = "7bit";
				let onData, onEnd;
				if (isPartAFile(fieldname, contype, filename)) {
					if (nfiles === filesLimit) {
						if (!boy.hitFilesLimit) {
							boy.hitFilesLimit = true;
							boy.emit("filesLimit");
						}
						return skipPart(part);
					}
					++nfiles;
					if (boy.listenerCount("file") === 0) {
						self.parser._ignore();
						return;
					}
					++nends;
					const file = new FileStream(fileOpts);
					curFile = file;
					file.on("end", function() {
						--nends;
						self._pause = false;
						checkFinished();
						if (self._cb && !self._needDrain) {
							const cb = self._cb;
							self._cb = void 0;
							cb();
						}
					});
					file._read = function(n$1) {
						if (!self._pause) return;
						self._pause = false;
						if (self._cb && !self._needDrain) {
							const cb = self._cb;
							self._cb = void 0;
							cb();
						}
					};
					boy.emit("file", fieldname, file, filename, encoding, contype);
					onData = function(data) {
						if ((nsize += data.length) > fileSizeLimit) {
							const extralen = fileSizeLimit - nsize + data.length;
							if (extralen > 0) file.push(data.slice(0, extralen));
							file.truncated = true;
							file.bytesRead = fileSizeLimit;
							part.removeAllListeners("data");
							file.emit("limit");
							return;
						} else if (!file.push(data)) self._pause = true;
						file.bytesRead = nsize;
					};
					onEnd = function() {
						curFile = void 0;
						file.push(null);
					};
				} else {
					if (nfields === fieldsLimit) {
						if (!boy.hitFieldsLimit) {
							boy.hitFieldsLimit = true;
							boy.emit("fieldsLimit");
						}
						return skipPart(part);
					}
					++nfields;
					++nends;
					let buffer = "";
					let truncated = false;
					curField = part;
					onData = function(data) {
						if ((nsize += data.length) > fieldSizeLimit) {
							const extralen = fieldSizeLimit - (nsize - data.length);
							buffer += data.toString("binary", 0, extralen);
							truncated = true;
							part.removeAllListeners("data");
						} else buffer += data.toString("binary");
					};
					onEnd = function() {
						curField = void 0;
						if (buffer.length) buffer = decodeText$1(buffer, "binary", charset);
						boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
						--nends;
						checkFinished();
					};
				}
				part._readableState.sync = false;
				part.on("data", onData);
				part.on("end", onEnd);
			}).on("error", function(err) {
				if (curFile) curFile.emit("error", err);
			});
		}).on("error", function(err) {
			boy.emit("error", err);
		}).on("finish", function() {
			finished$2 = true;
			checkFinished();
		});
	}
	Multipart.prototype.write = function(chunk, cb) {
		const r = this.parser.write(chunk);
		if (r && !this._pause) cb();
		else {
			this._needDrain = !r;
			this._cb = cb;
		}
	};
	Multipart.prototype.end = function() {
		const self = this;
		if (self.parser.writable) self.parser.end();
		else if (!self._boy._done) process.nextTick(function() {
			self._boy._done = true;
			self._boy.emit("finish");
		});
	};
	function skipPart(part) {
		part.resume();
	}
	function FileStream(opts) {
		Readable$6.call(this, opts);
		this.bytesRead = 0;
		this.truncated = false;
	}
	inherits$1(FileStream, Readable$6);
	FileStream.prototype._read = function(n$1) {};
	module.exports = Multipart;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
	const RE_PLUS = /\+/g;
	const HEX = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	function Decoder$1() {
		this.buffer = void 0;
	}
	Decoder$1.prototype.write = function(str$1) {
		str$1 = str$1.replace(RE_PLUS, " ");
		let res = "";
		let i$1 = 0;
		let p = 0;
		const len = str$1.length;
		for (; i$1 < len; ++i$1) if (this.buffer !== void 0) if (!HEX[str$1.charCodeAt(i$1)]) {
			res += "%" + this.buffer;
			this.buffer = void 0;
			--i$1;
		} else {
			this.buffer += str$1[i$1];
			++p;
			if (this.buffer.length === 2) {
				res += String.fromCharCode(parseInt(this.buffer, 16));
				this.buffer = void 0;
			}
		}
		else if (str$1[i$1] === "%") {
			if (i$1 > p) {
				res += str$1.substring(p, i$1);
				p = i$1;
			}
			this.buffer = "";
			++p;
		}
		if (p < len && this.buffer === void 0) res += str$1.substring(p);
		return res;
	};
	Decoder$1.prototype.reset = function() {
		this.buffer = void 0;
	};
	module.exports = Decoder$1;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
	const Decoder = require_Decoder();
	const decodeText = require_decodeText();
	const getLimit = require_getLimit();
	const RE_CHARSET = /^charset$/i;
	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded(boy, cfg) {
		const limits = cfg.limits;
		const parsedConType = cfg.parsedConType;
		this.boy = boy;
		this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
		this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
		this.fieldsLimit = getLimit(limits, "fields", Infinity);
		let charset;
		for (var i$1 = 0, len = parsedConType.length; i$1 < len; ++i$1) if (Array.isArray(parsedConType[i$1]) && RE_CHARSET.test(parsedConType[i$1][0])) {
			charset = parsedConType[i$1][1].toLowerCase();
			break;
		}
		if (charset === void 0) charset = cfg.defCharset || "utf8";
		this.decoder = new Decoder();
		this.charset = charset;
		this._fields = 0;
		this._state = "key";
		this._checkingBytes = true;
		this._bytesKey = 0;
		this._bytesVal = 0;
		this._key = "";
		this._val = "";
		this._keyTrunc = false;
		this._valTrunc = false;
		this._hitLimit = false;
	}
	UrlEncoded.prototype.write = function(data, cb) {
		if (this._fields === this.fieldsLimit) {
			if (!this.boy.hitFieldsLimit) {
				this.boy.hitFieldsLimit = true;
				this.boy.emit("fieldsLimit");
			}
			return cb();
		}
		let idxeq;
		let idxamp;
		let i$1;
		let p = 0;
		const len = data.length;
		while (p < len) if (this._state === "key") {
			idxeq = idxamp = void 0;
			for (i$1 = p; i$1 < len; ++i$1) {
				if (!this._checkingBytes) ++p;
				if (data[i$1] === 61) {
					idxeq = i$1;
					break;
				} else if (data[i$1] === 38) {
					idxamp = i$1;
					break;
				}
				if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesKey;
			}
			if (idxeq !== void 0) {
				if (idxeq > p) this._key += this.decoder.write(data.toString("binary", p, idxeq));
				this._state = "val";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._val = "";
				this._bytesVal = 0;
				this._valTrunc = false;
				this.decoder.reset();
				p = idxeq + 1;
			} else if (idxamp !== void 0) {
				++this._fields;
				let key;
				const keyTrunc = this._keyTrunc;
				if (idxamp > p) key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
				else key = this._key;
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				if (key.length) this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$1 > p) this._key += this.decoder.write(data.toString("binary", p, i$1));
				p = i$1;
				if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
					this._checkingBytes = false;
					this._keyTrunc = true;
				}
			} else {
				if (p < len) this._key += this.decoder.write(data.toString("binary", p));
				p = len;
			}
		} else {
			idxamp = void 0;
			for (i$1 = p; i$1 < len; ++i$1) {
				if (!this._checkingBytes) ++p;
				if (data[i$1] === 38) {
					idxamp = i$1;
					break;
				}
				if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesVal;
			}
			if (idxamp !== void 0) {
				++this._fields;
				if (idxamp > p) this._val += this.decoder.write(data.toString("binary", p, idxamp));
				this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
				this._state = "key";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$1 > p) this._val += this.decoder.write(data.toString("binary", p, i$1));
				p = i$1;
				if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
					this._checkingBytes = false;
					this._valTrunc = true;
				}
			} else {
				if (p < len) this._val += this.decoder.write(data.toString("binary", p));
				p = len;
			}
		}
		cb();
	};
	UrlEncoded.prototype.end = function() {
		if (this.boy._done) return;
		if (this._state === "key" && this._key.length > 0) this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
		else if (this._state === "val") this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
		this.boy._done = true;
		this.boy.emit("finish");
	};
	module.exports = UrlEncoded;
} });

//#endregion
//#region node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({ "node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js"(exports, module) {
	const WritableStream = __require("node:stream").Writable;
	const { inherits } = __require("node:util");
	const Dicer = require_Dicer();
	const MultipartParser = require_multipart();
	const UrlencodedParser = require_urlencoded();
	const parseParams = require_parseParams();
	function Busboy$1(opts) {
		if (!(this instanceof Busboy$1)) return new Busboy$1(opts);
		if (typeof opts !== "object") throw new TypeError("Busboy expected an options-Object.");
		if (typeof opts.headers !== "object") throw new TypeError("Busboy expected an options-Object with headers-attribute.");
		if (typeof opts.headers["content-type"] !== "string") throw new TypeError("Missing Content-Type-header.");
		const { headers,...streamOptions } = opts;
		this.opts = {
			autoDestroy: false,
			...streamOptions
		};
		WritableStream.call(this, this.opts);
		this._done = false;
		this._parser = this.getParserByHeaders(headers);
		this._finished = false;
	}
	inherits(Busboy$1, WritableStream);
	Busboy$1.prototype.emit = function(ev) {
		if (ev === "finish") {
			if (!this._done) {
				this._parser?.end();
				return;
			} else if (this._finished) return;
			this._finished = true;
		}
		WritableStream.prototype.emit.apply(this, arguments);
	};
	Busboy$1.prototype.getParserByHeaders = function(headers) {
		const parsed = parseParams(headers["content-type"]);
		const cfg = {
			defCharset: this.opts.defCharset,
			fileHwm: this.opts.fileHwm,
			headers,
			highWaterMark: this.opts.highWaterMark,
			isPartAFile: this.opts.isPartAFile,
			limits: this.opts.limits,
			parsedConType: parsed,
			preservePath: this.opts.preservePath
		};
		if (MultipartParser.detect.test(parsed[0])) return new MultipartParser(this, cfg);
		if (UrlencodedParser.detect.test(parsed[0])) return new UrlencodedParser(this, cfg);
		throw new Error("Unsupported Content-Type.");
	};
	Busboy$1.prototype._write = function(chunk, encoding, cb) {
		this._parser.write(chunk, cb);
	};
	module.exports = Busboy$1;
	module.exports.default = Busboy$1;
	module.exports.Busboy = Busboy$1;
	module.exports.Dicer = Dicer;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/constants.js
var require_constants$4 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/constants.js"(exports, module) {
	const { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
	const corsSafeListedMethods = [
		"GET",
		"HEAD",
		"POST"
	];
	const corsSafeListedMethodsSet$1 = new Set(corsSafeListedMethods);
	const nullBodyStatus$2 = [
		101,
		204,
		205,
		304
	];
	const redirectStatus = [
		301,
		302,
		303,
		307,
		308
	];
	const redirectStatusSet$3 = new Set(redirectStatus);
	const badPorts = [
		"1",
		"7",
		"9",
		"11",
		"13",
		"15",
		"17",
		"19",
		"20",
		"21",
		"22",
		"23",
		"25",
		"37",
		"42",
		"43",
		"53",
		"69",
		"77",
		"79",
		"87",
		"95",
		"101",
		"102",
		"103",
		"104",
		"109",
		"110",
		"111",
		"113",
		"115",
		"117",
		"119",
		"123",
		"135",
		"137",
		"139",
		"143",
		"161",
		"179",
		"389",
		"427",
		"465",
		"512",
		"513",
		"514",
		"515",
		"526",
		"530",
		"531",
		"532",
		"540",
		"548",
		"554",
		"556",
		"563",
		"587",
		"601",
		"636",
		"989",
		"990",
		"993",
		"995",
		"1719",
		"1720",
		"1723",
		"2049",
		"3659",
		"4045",
		"5060",
		"5061",
		"6000",
		"6566",
		"6665",
		"6666",
		"6667",
		"6668",
		"6669",
		"6697",
		"10080"
	];
	const badPortsSet$1 = new Set(badPorts);
	const referrerPolicy$1 = [
		"",
		"no-referrer",
		"no-referrer-when-downgrade",
		"same-origin",
		"origin",
		"strict-origin",
		"origin-when-cross-origin",
		"strict-origin-when-cross-origin",
		"unsafe-url"
	];
	const referrerPolicySet = new Set(referrerPolicy$1);
	const requestRedirect$1 = [
		"follow",
		"manual",
		"error"
	];
	const safeMethods = [
		"GET",
		"HEAD",
		"OPTIONS",
		"TRACE"
	];
	const safeMethodsSet$1 = new Set(safeMethods);
	const requestMode$1 = [
		"navigate",
		"same-origin",
		"no-cors",
		"cors"
	];
	const requestCredentials$1 = [
		"omit",
		"same-origin",
		"include"
	];
	const requestCache$1 = [
		"default",
		"no-store",
		"reload",
		"no-cache",
		"force-cache",
		"only-if-cached"
	];
	const requestBodyHeader$1 = [
		"content-encoding",
		"content-language",
		"content-location",
		"content-type",
		"content-length"
	];
	const requestDuplex$1 = ["half"];
	const forbiddenMethods = [
		"CONNECT",
		"TRACE",
		"TRACK"
	];
	const forbiddenMethodsSet$1 = new Set(forbiddenMethods);
	const subresource = [
		"audio",
		"audioworklet",
		"font",
		"image",
		"manifest",
		"paintworklet",
		"script",
		"style",
		"track",
		"video",
		"xslt",
		""
	];
	const subresourceSet$1 = new Set(subresource);
	/** @type {globalThis['DOMException']} */
	const DOMException$6 = globalThis.DOMException ?? (() => {
		try {
			atob("~");
		} catch (err) {
			return Object.getPrototypeOf(err).constructor;
		}
	})();
	let channel;
	/** @type {globalThis['structuredClone']} */
	const structuredClone$1 = globalThis.structuredClone ?? function structuredClone$2(value, options = void 0) {
		if (arguments.length === 0) throw new TypeError("missing argument");
		if (!channel) channel = new MessageChannel();
		channel.port1.unref();
		channel.port2.unref();
		channel.port1.postMessage(value, options?.transfer);
		return receiveMessageOnPort(channel.port2).message;
	};
	module.exports = {
		DOMException: DOMException$6,
		structuredClone: structuredClone$1,
		subresource,
		forbiddenMethods,
		requestBodyHeader: requestBodyHeader$1,
		referrerPolicy: referrerPolicy$1,
		requestRedirect: requestRedirect$1,
		requestMode: requestMode$1,
		requestCredentials: requestCredentials$1,
		requestCache: requestCache$1,
		redirectStatus,
		corsSafeListedMethods,
		nullBodyStatus: nullBodyStatus$2,
		safeMethods,
		badPorts,
		requestDuplex: requestDuplex$1,
		subresourceSet: subresourceSet$1,
		badPortsSet: badPortsSet$1,
		redirectStatusSet: redirectStatusSet$3,
		corsSafeListedMethodsSet: corsSafeListedMethodsSet$1,
		safeMethodsSet: safeMethodsSet$1,
		forbiddenMethodsSet: forbiddenMethodsSet$1,
		referrerPolicySet
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/global.js
var require_global$1 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/global.js"(exports, module) {
	const globalOrigin = Symbol.for("undici.globalOrigin.1");
	function getGlobalOrigin$4() {
		return globalThis[globalOrigin];
	}
	function setGlobalOrigin(newOrigin) {
		if (newOrigin === void 0) {
			Object.defineProperty(globalThis, globalOrigin, {
				value: void 0,
				writable: true,
				enumerable: false,
				configurable: false
			});
			return;
		}
		const parsedURL = new URL(newOrigin);
		if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
		Object.defineProperty(globalThis, globalOrigin, {
			value: parsedURL,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	module.exports = {
		getGlobalOrigin: getGlobalOrigin$4,
		setGlobalOrigin
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/util.js
var require_util$5 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/util.js"(exports, module) {
	const { redirectStatusSet: redirectStatusSet$2, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants$4();
	const { getGlobalOrigin: getGlobalOrigin$3 } = require_global$1();
	const { performance: performance$1 } = __require("perf_hooks");
	const { isBlobLike: isBlobLike$7, toUSVString: toUSVString$4, ReadableStreamFrom: ReadableStreamFrom$2 } = require_util$6();
	const assert$19 = __require("assert");
	const { isUint8Array: isUint8Array$2 } = __require("util/types");
	let supportedHashes = [];
	/** @type {import('crypto')|undefined} */
	let crypto$2;
	try {
		crypto$2 = __require("crypto");
		const possibleRelevantHashes = [
			"sha256",
			"sha384",
			"sha512"
		];
		supportedHashes = crypto$2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	} catch {}
	function responseURL(response) {
		const urlList = response.urlList;
		const length = urlList.length;
		return length === 0 ? null : urlList[length - 1].toString();
	}
	function responseLocationURL$1(response, requestFragment) {
		if (!redirectStatusSet$2.has(response.status)) return null;
		let location = response.headersList.get("location");
		if (location !== null && isValidHeaderValue$1(location)) location = new URL(location, responseURL(response));
		if (location && !location.hash) location.hash = requestFragment;
		return location;
	}
	/** @returns {URL} */
	function requestCurrentURL$1(request$2) {
		return request$2.urlList[request$2.urlList.length - 1];
	}
	function requestBadPort$1(request$2) {
		const url = requestCurrentURL$1(request$2);
		if (urlIsHttpHttpsScheme$2(url) && badPortsSet.has(url.port)) return "blocked";
		return "allowed";
	}
	function isErrorLike$2(object) {
		return object instanceof Error || object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException";
	}
	function isValidReasonPhrase$1(statusText) {
		for (let i$1 = 0; i$1 < statusText.length; ++i$1) {
			const c$1 = statusText.charCodeAt(i$1);
			if (!(c$1 === 9 || c$1 >= 32 && c$1 <= 126 || c$1 >= 128 && c$1 <= 255)) return false;
		}
		return true;
	}
	/**
	* @see https://tools.ietf.org/html/rfc7230#section-3.2.6
	* @param {number} c
	*/
	function isTokenCharCode(c$1) {
		switch (c$1) {
			case 34:
			case 40:
			case 41:
			case 44:
			case 47:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 91:
			case 92:
			case 93:
			case 123:
			case 125: return false;
			default: return c$1 >= 33 && c$1 <= 126;
		}
	}
	/**
	* @param {string} characters
	*/
	function isValidHTTPToken$1(characters) {
		if (characters.length === 0) return false;
		for (let i$1 = 0; i$1 < characters.length; ++i$1) if (!isTokenCharCode(characters.charCodeAt(i$1))) return false;
		return true;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-name
	* @param {string} potentialValue
	*/
	function isValidHeaderName$2(potentialValue) {
		return isValidHTTPToken$1(potentialValue);
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-value
	* @param {string} potentialValue
	*/
	function isValidHeaderValue$1(potentialValue) {
		if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) return false;
		if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) return false;
		return true;
	}
	function setRequestReferrerPolicyOnRedirect$1(request$2, actualResponse) {
		const { headersList } = actualResponse;
		const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
		let policy = "";
		if (policyHeader.length > 0) for (let i$1 = policyHeader.length; i$1 !== 0; i$1--) {
			const token = policyHeader[i$1 - 1].trim();
			if (referrerPolicyTokens.has(token)) {
				policy = token;
				break;
			}
		}
		if (policy !== "") request$2.referrerPolicy = policy;
	}
	function crossOriginResourcePolicyCheck$1() {
		return "allowed";
	}
	function corsCheck$1() {
		return "success";
	}
	function TAOCheck$1() {
		return "success";
	}
	function appendFetchMetadata$1(httpRequest) {
		let header = null;
		header = httpRequest.mode;
		httpRequest.headersList.set("sec-fetch-mode", header);
	}
	function appendRequestOriginHeader$1(request$2) {
		let serializedOrigin = request$2.origin;
		if (request$2.responseTainting === "cors" || request$2.mode === "websocket") {
			if (serializedOrigin) request$2.headersList.append("origin", serializedOrigin);
		} else if (request$2.method !== "GET" && request$2.method !== "HEAD") {
			switch (request$2.referrerPolicy) {
				case "no-referrer":
					serializedOrigin = null;
					break;
				case "no-referrer-when-downgrade":
				case "strict-origin":
				case "strict-origin-when-cross-origin":
					if (request$2.origin && urlHasHttpsScheme$1(request$2.origin) && !urlHasHttpsScheme$1(requestCurrentURL$1(request$2))) serializedOrigin = null;
					break;
				case "same-origin":
					if (!sameOrigin$2(request$2, requestCurrentURL$1(request$2))) serializedOrigin = null;
					break;
				default:
			}
			if (serializedOrigin) request$2.headersList.append("origin", serializedOrigin);
		}
	}
	function coarsenedSharedCurrentTime$1(crossOriginIsolatedCapability) {
		return performance$1.now();
	}
	function createOpaqueTimingInfo$1(timingInfo) {
		return {
			startTime: timingInfo.startTime ?? 0,
			redirectStartTime: 0,
			redirectEndTime: 0,
			postRedirectStartTime: timingInfo.startTime ?? 0,
			finalServiceWorkerStartTime: 0,
			finalNetworkResponseStartTime: 0,
			finalNetworkRequestStartTime: 0,
			endTime: 0,
			encodedBodySize: 0,
			decodedBodySize: 0,
			finalConnectionTimingInfo: null
		};
	}
	function makePolicyContainer$2() {
		return { referrerPolicy: "strict-origin-when-cross-origin" };
	}
	function clonePolicyContainer$1(policyContainer) {
		return { referrerPolicy: policyContainer.referrerPolicy };
	}
	function determineRequestsReferrer$1(request$2) {
		const policy = request$2.referrerPolicy;
		assert$19(policy);
		let referrerSource = null;
		if (request$2.referrer === "client") {
			const globalOrigin$1 = getGlobalOrigin$3();
			if (!globalOrigin$1 || globalOrigin$1.origin === "null") return "no-referrer";
			referrerSource = new URL(globalOrigin$1);
		} else if (request$2.referrer instanceof URL) referrerSource = request$2.referrer;
		let referrerURL = stripURLForReferrer(referrerSource);
		const referrerOrigin = stripURLForReferrer(referrerSource, true);
		if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
		const areSameOrigin = sameOrigin$2(request$2, referrerURL);
		const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request$2.url);
		switch (policy) {
			case "origin": return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
			case "unsafe-url": return referrerURL;
			case "same-origin": return areSameOrigin ? referrerOrigin : "no-referrer";
			case "origin-when-cross-origin": return areSameOrigin ? referrerURL : referrerOrigin;
			case "strict-origin-when-cross-origin": {
				const currentURL = requestCurrentURL$1(request$2);
				if (sameOrigin$2(referrerURL, currentURL)) return referrerURL;
				if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return "no-referrer";
				return referrerOrigin;
			}
			case "strict-origin":
			case "no-referrer-when-downgrade":
			default: return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	* @param {URL} url
	* @param {boolean|undefined} originOnly
	*/
	function stripURLForReferrer(url, originOnly) {
		assert$19(url instanceof URL);
		if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") return "no-referrer";
		url.username = "";
		url.password = "";
		url.hash = "";
		if (originOnly) {
			url.pathname = "";
			url.search = "";
		}
		return url;
	}
	function isURLPotentiallyTrustworthy(url) {
		if (!(url instanceof URL)) return false;
		if (url.href === "about:blank" || url.href === "about:srcdoc") return true;
		if (url.protocol === "data:") return true;
		if (url.protocol === "file:") return true;
		return isOriginPotentiallyTrustworthy(url.origin);
		function isOriginPotentiallyTrustworthy(origin) {
			if (origin == null || origin === "null") return false;
			const originAsURL = new URL(origin);
			if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") return true;
			if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost")) return true;
			return false;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	* @param {Uint8Array} bytes
	* @param {string} metadataList
	*/
	function bytesMatch$1(bytes, metadataList) {
		/* istanbul ignore if: only if node is built with --without-ssl */
		if (crypto$2 === void 0) return true;
		const parsedMetadata = parseMetadata(metadataList);
		if (parsedMetadata === "no metadata") return true;
		if (parsedMetadata.length === 0) return true;
		const strongest = getStrongestMetadata(parsedMetadata);
		const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
		for (const item of metadata) {
			const algorithm = item.algo;
			const expectedValue = item.hash;
			let actualValue = crypto$2.createHash(algorithm).update(bytes).digest("base64");
			if (actualValue[actualValue.length - 1] === "=") if (actualValue[actualValue.length - 2] === "=") actualValue = actualValue.slice(0, -2);
			else actualValue = actualValue.slice(0, -1);
			if (compareBase64Mixed(actualValue, expectedValue)) return true;
		}
		return false;
	}
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	* @param {string} metadata
	*/
	function parseMetadata(metadata) {
		/** @type {{ algo: string, hash: string }[]} */
		const result = [];
		let empty = true;
		for (const token of metadata.split(" ")) {
			empty = false;
			const parsedToken = parseHashWithOptions.exec(token);
			if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) continue;
			const algorithm = parsedToken.groups.algo.toLowerCase();
			if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
		}
		if (empty === true) return "no metadata";
		return result;
	}
	/**
	* @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	*/
	function getStrongestMetadata(metadataList) {
		let algorithm = metadataList[0].algo;
		if (algorithm[3] === "5") return algorithm;
		for (let i$1 = 1; i$1 < metadataList.length; ++i$1) {
			const metadata = metadataList[i$1];
			if (metadata.algo[3] === "5") {
				algorithm = "sha512";
				break;
			} else if (algorithm[3] === "3") continue;
			else if (metadata.algo[3] === "3") algorithm = "sha384";
		}
		return algorithm;
	}
	function filterMetadataListByAlgorithm(metadataList, algorithm) {
		if (metadataList.length === 1) return metadataList;
		let pos = 0;
		for (let i$1 = 0; i$1 < metadataList.length; ++i$1) if (metadataList[i$1].algo === algorithm) metadataList[pos++] = metadataList[i$1];
		metadataList.length = pos;
		return metadataList;
	}
	/**
	* Compares two base64 strings, allowing for base64url
	* in the second string.
	*
	* @param {string} actualValue always base64
	* @param {string} expectedValue base64 or base64url
	* @returns {boolean}
	*/
	function compareBase64Mixed(actualValue, expectedValue) {
		if (actualValue.length !== expectedValue.length) return false;
		for (let i$1 = 0; i$1 < actualValue.length; ++i$1) if (actualValue[i$1] !== expectedValue[i$1]) {
			if (actualValue[i$1] === "+" && expectedValue[i$1] === "-" || actualValue[i$1] === "/" && expectedValue[i$1] === "_") continue;
			return false;
		}
		return true;
	}
	function tryUpgradeRequestToAPotentiallyTrustworthyURL$1(request$2) {}
	/**
	* @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	* @param {URL} A
	* @param {URL} B
	*/
	function sameOrigin$2(A, B) {
		if (A.origin === B.origin && A.origin === "null") return true;
		if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) return true;
		return false;
	}
	function createDeferredPromise$3() {
		let res;
		let rej;
		const promise = new Promise((resolve, reject) => {
			res = resolve;
			rej = reject;
		});
		return {
			promise,
			resolve: res,
			reject: rej
		};
	}
	function isAborted$2(fetchParams) {
		return fetchParams.controller.state === "aborted";
	}
	function isCancelled$2(fetchParams) {
		return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
	}
	const normalizeMethodRecord$1 = {
		delete: "DELETE",
		DELETE: "DELETE",
		get: "GET",
		GET: "GET",
		head: "HEAD",
		HEAD: "HEAD",
		options: "OPTIONS",
		OPTIONS: "OPTIONS",
		post: "POST",
		POST: "POST",
		put: "PUT",
		PUT: "PUT"
	};
	Object.setPrototypeOf(normalizeMethodRecord$1, null);
	/**
	* @see https://fetch.spec.whatwg.org/#concept-method-normalize
	* @param {string} method
	*/
	function normalizeMethod$1(method) {
		return normalizeMethodRecord$1[method.toLowerCase()] ?? method;
	}
	function serializeJavascriptValueToJSONString$1(value) {
		const result = JSON.stringify(value);
		if (result === void 0) throw new TypeError("Value is not JSON serializable");
		assert$19(typeof result === "string");
		return result;
	}
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
	/**
	* @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	* @param {() => unknown[]} iterator
	* @param {string} name name of the instance
	* @param {'key'|'value'|'key+value'} kind
	*/
	function makeIterator$2(iterator$1, name, kind$1) {
		const object = {
			index: 0,
			kind: kind$1,
			target: iterator$1
		};
		const i$1 = {
			next() {
				if (Object.getPrototypeOf(this) !== i$1) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
				const { index, kind: kind$2, target } = object;
				const values = target();
				const len = values.length;
				if (index >= len) return {
					value: void 0,
					done: true
				};
				const pair = values[index];
				object.index = index + 1;
				return iteratorResult(pair, kind$2);
			},
			[Symbol.toStringTag]: `${name} Iterator`
		};
		Object.setPrototypeOf(i$1, esIteratorPrototype);
		return Object.setPrototypeOf({}, i$1);
	}
	function iteratorResult(pair, kind$1) {
		let result;
		switch (kind$1) {
			case "key": {
				result = pair[0];
				break;
			}
			case "value": {
				result = pair[1];
				break;
			}
			case "key+value": {
				result = pair;
				break;
			}
		}
		return {
			value: result,
			done: false
		};
	}
	/**
	* @see https://fetch.spec.whatwg.org/#body-fully-read
	*/
	async function fullyReadBody$2(body, processBody, processBodyError) {
		const successSteps = processBody;
		const errorSteps = processBodyError;
		let reader;
		try {
			reader = body.stream.getReader();
		} catch (e) {
			errorSteps(e);
			return;
		}
		try {
			const result = await readAllBytes$1(reader);
			successSteps(result);
		} catch (e) {
			errorSteps(e);
		}
	}
	/** @type {ReadableStream} */
	let ReadableStream$5 = globalThis.ReadableStream;
	function isReadableStreamLike$1(stream$2) {
		if (!ReadableStream$5) ReadableStream$5 = __require("stream/web").ReadableStream;
		return stream$2 instanceof ReadableStream$5 || stream$2[Symbol.toStringTag] === "ReadableStream" && typeof stream$2.tee === "function";
	}
	const MAXIMUM_ARGUMENT_LENGTH = 65535;
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-decode
	* @param {number[]|Uint8Array} input
	*/
	function isomorphicDecode$1(input) {
		if (input.length < MAXIMUM_ARGUMENT_LENGTH) return String.fromCharCode(...input);
		return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
	}
	/**
	* @param {ReadableStreamController<Uint8Array>} controller
	*/
	function readableStreamClose$2(controller) {
		try {
			controller.close();
		} catch (err) {
			if (!err.message.includes("Controller is already closed")) throw err;
		}
	}
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-encode
	* @param {string} input
	*/
	function isomorphicEncode$2(input) {
		for (let i$1 = 0; i$1 < input.length; i$1++) assert$19(input.charCodeAt(i$1) <= 255);
		return input;
	}
	/**
	* @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	* @see https://streams.spec.whatwg.org/#read-loop
	* @param {ReadableStreamDefaultReader} reader
	*/
	async function readAllBytes$1(reader) {
		const bytes = [];
		let byteLength = 0;
		while (true) {
			const { done, value: chunk } = await reader.read();
			if (done) return Buffer.concat(bytes, byteLength);
			if (!isUint8Array$2(chunk)) throw new TypeError("Received non-Uint8Array chunk");
			bytes.push(chunk);
			byteLength += chunk.length;
		}
	}
	/**
	* @see https://fetch.spec.whatwg.org/#is-local
	* @param {URL} url
	*/
	function urlIsLocal$1(url) {
		assert$19("protocol" in url);
		const protocol = url.protocol;
		return protocol === "about:" || protocol === "blob:" || protocol === "data:";
	}
	/**
	* @param {string|URL} url
	*/
	function urlHasHttpsScheme$1(url) {
		if (typeof url === "string") return url.startsWith("https:");
		return url.protocol === "https:";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-scheme
	* @param {URL} url
	*/
	function urlIsHttpHttpsScheme$2(url) {
		assert$19("protocol" in url);
		const protocol = url.protocol;
		return protocol === "http:" || protocol === "https:";
	}
	/**
	* Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
	*/
	const hasOwn$2 = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
	module.exports = {
		isAborted: isAborted$2,
		isCancelled: isCancelled$2,
		createDeferredPromise: createDeferredPromise$3,
		ReadableStreamFrom: ReadableStreamFrom$2,
		toUSVString: toUSVString$4,
		tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL$1,
		coarsenedSharedCurrentTime: coarsenedSharedCurrentTime$1,
		determineRequestsReferrer: determineRequestsReferrer$1,
		makePolicyContainer: makePolicyContainer$2,
		clonePolicyContainer: clonePolicyContainer$1,
		appendFetchMetadata: appendFetchMetadata$1,
		appendRequestOriginHeader: appendRequestOriginHeader$1,
		TAOCheck: TAOCheck$1,
		corsCheck: corsCheck$1,
		crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck$1,
		createOpaqueTimingInfo: createOpaqueTimingInfo$1,
		setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect$1,
		isValidHTTPToken: isValidHTTPToken$1,
		requestBadPort: requestBadPort$1,
		requestCurrentURL: requestCurrentURL$1,
		responseURL,
		responseLocationURL: responseLocationURL$1,
		isBlobLike: isBlobLike$7,
		isURLPotentiallyTrustworthy,
		isValidReasonPhrase: isValidReasonPhrase$1,
		sameOrigin: sameOrigin$2,
		normalizeMethod: normalizeMethod$1,
		serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString$1,
		makeIterator: makeIterator$2,
		isValidHeaderName: isValidHeaderName$2,
		isValidHeaderValue: isValidHeaderValue$1,
		hasOwn: hasOwn$2,
		isErrorLike: isErrorLike$2,
		fullyReadBody: fullyReadBody$2,
		bytesMatch: bytesMatch$1,
		isReadableStreamLike: isReadableStreamLike$1,
		readableStreamClose: readableStreamClose$2,
		isomorphicEncode: isomorphicEncode$2,
		isomorphicDecode: isomorphicDecode$1,
		urlIsLocal: urlIsLocal$1,
		urlHasHttpsScheme: urlHasHttpsScheme$1,
		urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$2,
		readAllBytes: readAllBytes$1,
		normalizeMethodRecord: normalizeMethodRecord$1,
		parseMetadata
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/symbols.js
var require_symbols$3 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/symbols.js"(exports, module) {
	module.exports = {
		kUrl: Symbol("url"),
		kHeaders: Symbol("headers"),
		kSignal: Symbol("signal"),
		kState: Symbol("state"),
		kGuard: Symbol("guard"),
		kRealm: Symbol("realm")
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/webidl.js"(exports, module) {
	const { types: types$4 } = __require("util");
	const { hasOwn: hasOwn$1, toUSVString: toUSVString$3 } = require_util$5();
	/** @type {import('../../types/webidl').Webidl} */
	const webidl$14 = {};
	webidl$14.converters = {};
	webidl$14.util = {};
	webidl$14.errors = {};
	webidl$14.errors.exception = function(message) {
		return /* @__PURE__ */ new TypeError(`${message.header}: ${message.message}`);
	};
	webidl$14.errors.conversionFailed = function(context$1) {
		const plural$1 = context$1.types.length === 1 ? "" : " one of";
		const message = `${context$1.argument} could not be converted to${plural$1}: ${context$1.types.join(", ")}.`;
		return webidl$14.errors.exception({
			header: context$1.prefix,
			message
		});
	};
	webidl$14.errors.invalidArgument = function(context$1) {
		return webidl$14.errors.exception({
			header: context$1.prefix,
			message: `"${context$1.value}" is an invalid ${context$1.type}.`
		});
	};
	webidl$14.brandCheck = function(V, I, opts = void 0) {
		if (opts?.strict !== false && !(V instanceof I)) throw new TypeError("Illegal invocation");
		else return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
	};
	webidl$14.argumentLengthCheck = function({ length }, min, ctx) {
		if (length < min) throw webidl$14.errors.exception({
			message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
			...ctx
		});
	};
	webidl$14.illegalConstructor = function() {
		throw webidl$14.errors.exception({
			header: "TypeError",
			message: "Illegal constructor"
		});
	};
	webidl$14.util.Type = function(V) {
		switch (typeof V) {
			case "undefined": return "Undefined";
			case "boolean": return "Boolean";
			case "string": return "String";
			case "symbol": return "Symbol";
			case "number": return "Number";
			case "bigint": return "BigInt";
			case "function":
			case "object": {
				if (V === null) return "Null";
				return "Object";
			}
		}
	};
	webidl$14.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
		let upperBound;
		let lowerBound;
		if (bitLength === 64) {
			upperBound = Math.pow(2, 53) - 1;
			if (signedness === "unsigned") lowerBound = 0;
			else lowerBound = Math.pow(-2, 53) + 1;
		} else if (signedness === "unsigned") {
			lowerBound = 0;
			upperBound = Math.pow(2, bitLength) - 1;
		} else {
			lowerBound = Math.pow(-2, bitLength) - 1;
			upperBound = Math.pow(2, bitLength - 1) - 1;
		}
		let x = Number(V);
		if (x === 0) x = 0;
		if (opts.enforceRange === true) {
			if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Could not convert ${V} to an integer.`
			});
			x = webidl$14.util.IntegerPart(x);
			if (x < lowerBound || x > upperBound) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
			});
			return x;
		}
		if (!Number.isNaN(x) && opts.clamp === true) {
			x = Math.min(Math.max(x, lowerBound), upperBound);
			if (Math.floor(x) % 2 === 0) x = Math.floor(x);
			else x = Math.ceil(x);
			return x;
		}
		if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) return 0;
		x = webidl$14.util.IntegerPart(x);
		x = x % Math.pow(2, bitLength);
		if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) return x - Math.pow(2, bitLength);
		return x;
	};
	webidl$14.util.IntegerPart = function(n$1) {
		const r = Math.floor(Math.abs(n$1));
		if (n$1 < 0) return -1 * r;
		return r;
	};
	webidl$14.sequenceConverter = function(converter) {
		return (V) => {
			if (webidl$14.util.Type(V) !== "Object") throw webidl$14.errors.exception({
				header: "Sequence",
				message: `Value of type ${webidl$14.util.Type(V)} is not an Object.`
			});
			/** @type {Generator} */
			const method = V?.[Symbol.iterator]?.();
			const seq = [];
			if (method === void 0 || typeof method.next !== "function") throw webidl$14.errors.exception({
				header: "Sequence",
				message: "Object is not an iterator."
			});
			while (true) {
				const { done, value } = method.next();
				if (done) break;
				seq.push(converter(value));
			}
			return seq;
		};
	};
	webidl$14.recordConverter = function(keyConverter, valueConverter) {
		return (O) => {
			if (webidl$14.util.Type(O) !== "Object") throw webidl$14.errors.exception({
				header: "Record",
				message: `Value of type ${webidl$14.util.Type(O)} is not an Object.`
			});
			const result = {};
			if (!types$4.isProxy(O)) {
				const keys$1 = Object.keys(O);
				for (const key of keys$1) {
					const typedKey = keyConverter(key);
					const typedValue = valueConverter(O[key]);
					result[typedKey] = typedValue;
				}
				return result;
			}
			const keys = Reflect.ownKeys(O);
			for (const key of keys) {
				const desc = Reflect.getOwnPropertyDescriptor(O, key);
				if (desc?.enumerable) {
					const typedKey = keyConverter(key);
					const typedValue = valueConverter(O[key]);
					result[typedKey] = typedValue;
				}
			}
			return result;
		};
	};
	webidl$14.interfaceConverter = function(i$1) {
		return (V, opts = {}) => {
			if (opts.strict !== false && !(V instanceof i$1)) throw webidl$14.errors.exception({
				header: i$1.name,
				message: `Expected ${V} to be an instance of ${i$1.name}.`
			});
			return V;
		};
	};
	webidl$14.dictionaryConverter = function(converters) {
		return (dictionary) => {
			const type = webidl$14.util.Type(dictionary);
			const dict = {};
			if (type === "Null" || type === "Undefined") return dict;
			else if (type !== "Object") throw webidl$14.errors.exception({
				header: "Dictionary",
				message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
			});
			for (const options of converters) {
				const { key, defaultValue, required, converter } = options;
				if (required === true) {
					if (!hasOwn$1(dictionary, key)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `Missing required key "${key}".`
					});
				}
				let value = dictionary[key];
				const hasDefault = hasOwn$1(options, "defaultValue");
				if (hasDefault && value !== null) value = value ?? defaultValue;
				if (required || hasDefault || value !== void 0) {
					value = converter(value);
					if (options.allowedValues && !options.allowedValues.includes(value)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
					});
					dict[key] = value;
				}
			}
			return dict;
		};
	};
	webidl$14.nullableConverter = function(converter) {
		return (V) => {
			if (V === null) return V;
			return converter(V);
		};
	};
	webidl$14.converters.DOMString = function(V, opts = {}) {
		if (V === null && opts.legacyNullToEmptyString) return "";
		if (typeof V === "symbol") throw new TypeError("Could not convert argument of type symbol to string.");
		return String(V);
	};
	webidl$14.converters.ByteString = function(V) {
		const x = webidl$14.converters.DOMString(V);
		for (let index = 0; index < x.length; index++) if (x.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
		return x;
	};
	webidl$14.converters.USVString = toUSVString$3;
	webidl$14.converters.boolean = function(V) {
		const x = Boolean(V);
		return x;
	};
	webidl$14.converters.any = function(V) {
		return V;
	};
	webidl$14.converters["long long"] = function(V) {
		const x = webidl$14.util.ConvertToInt(V, 64, "signed");
		return x;
	};
	webidl$14.converters["unsigned long long"] = function(V) {
		const x = webidl$14.util.ConvertToInt(V, 64, "unsigned");
		return x;
	};
	webidl$14.converters["unsigned long"] = function(V) {
		const x = webidl$14.util.ConvertToInt(V, 32, "unsigned");
		return x;
	};
	webidl$14.converters["unsigned short"] = function(V, opts) {
		const x = webidl$14.util.ConvertToInt(V, 16, "unsigned", opts);
		return x;
	};
	webidl$14.converters.ArrayBuffer = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$4.isAnyArrayBuffer(V)) throw webidl$14.errors.conversionFailed({
			prefix: `${V}`,
			argument: `${V}`,
			types: ["ArrayBuffer"]
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.TypedArray = function(V, T, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$4.isTypedArray(V) || V.constructor.name !== T.name) throw webidl$14.errors.conversionFailed({
			prefix: `${T.name}`,
			argument: `${V}`,
			types: [T.name]
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.DataView = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$4.isDataView(V)) throw webidl$14.errors.exception({
			header: "DataView",
			message: "Object is not a DataView."
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.BufferSource = function(V, opts = {}) {
		if (types$4.isAnyArrayBuffer(V)) return webidl$14.converters.ArrayBuffer(V, opts);
		if (types$4.isTypedArray(V)) return webidl$14.converters.TypedArray(V, V.constructor);
		if (types$4.isDataView(V)) return webidl$14.converters.DataView(V, opts);
		throw new TypeError(`Could not convert ${V} to a BufferSource.`);
	};
	webidl$14.converters["sequence<ByteString>"] = webidl$14.sequenceConverter(webidl$14.converters.ByteString);
	webidl$14.converters["sequence<sequence<ByteString>>"] = webidl$14.sequenceConverter(webidl$14.converters["sequence<ByteString>"]);
	webidl$14.converters["record<ByteString, ByteString>"] = webidl$14.recordConverter(webidl$14.converters.ByteString, webidl$14.converters.ByteString);
	module.exports = { webidl: webidl$14 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/dataURL.js"(exports, module) {
	const assert$18 = __require("assert");
	const { atob: atob$1 } = __require("buffer");
	const { isomorphicDecode } = require_util$5();
	const encoder$1 = new TextEncoder();
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	*/
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	*/
	const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
	/** @param {URL} dataURL */
	function dataURLProcessor$1(dataURL) {
		assert$18(dataURL.protocol === "data:");
		let input = URLSerializer$4(dataURL, true);
		input = input.slice(5);
		const position = { position: 0 };
		let mimeType = collectASequenceOfCodePointsFast$1(",", input, position);
		const mimeTypeLength = mimeType.length;
		mimeType = removeASCIIWhitespace(mimeType, true, true);
		if (position.position >= input.length) return "failure";
		position.position++;
		const encodedBody = input.slice(mimeTypeLength + 1);
		let body = stringPercentDecode(encodedBody);
		if (/;(\u0020){0,}base64$/i.test(mimeType)) {
			const stringBody = isomorphicDecode(body);
			body = forgivingBase64(stringBody);
			if (body === "failure") return "failure";
			mimeType = mimeType.slice(0, -6);
			mimeType = mimeType.replace(/(\u0020)+$/, "");
			mimeType = mimeType.slice(0, -1);
		}
		if (mimeType.startsWith(";")) mimeType = "text/plain" + mimeType;
		let mimeTypeRecord = parseMIMEType$3(mimeType);
		if (mimeTypeRecord === "failure") mimeTypeRecord = parseMIMEType$3("text/plain;charset=US-ASCII");
		return {
			mimeType: mimeTypeRecord,
			body
		};
	}
	/**
	* @param {URL} url
	* @param {boolean} excludeFragment
	*/
	function URLSerializer$4(url, excludeFragment = false) {
		if (!excludeFragment) return url.href;
		const href = url.href;
		const hashLength = url.hash.length;
		return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
	}
	/**
	* @param {(char: string) => boolean} condition
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePoints(condition, input, position) {
		let result = "";
		while (position.position < input.length && condition(input[position.position])) {
			result += input[position.position];
			position.position++;
		}
		return result;
	}
	/**
	* A faster collectASequenceOfCodePoints that only works when comparing a single character.
	* @param {string} char
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePointsFast$1(char, input, position) {
		const idx = input.indexOf(char, position.position);
		const start = position.position;
		if (idx === -1) {
			position.position = input.length;
			return input.slice(start);
		}
		position.position = idx;
		return input.slice(start, position.position);
	}
	/** @param {string} input */
	function stringPercentDecode(input) {
		const bytes = encoder$1.encode(input);
		return percentDecode(bytes);
	}
	/** @param {Uint8Array} input */
	function percentDecode(input) {
		/** @type {number[]} */
		const output = [];
		for (let i$1 = 0; i$1 < input.length; i$1++) {
			const byte = input[i$1];
			if (byte !== 37) output.push(byte);
			else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i$1 + 1], input[i$1 + 2]))) output.push(37);
			else {
				const nextTwoBytes = String.fromCharCode(input[i$1 + 1], input[i$1 + 2]);
				const bytePoint = Number.parseInt(nextTwoBytes, 16);
				output.push(bytePoint);
				i$1 += 2;
			}
		}
		return Uint8Array.from(output);
	}
	/** @param {string} input */
	function parseMIMEType$3(input) {
		input = removeHTTPWhitespace(input, true, true);
		const position = { position: 0 };
		const type = collectASequenceOfCodePointsFast$1("/", input, position);
		if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) return "failure";
		if (position.position > input.length) return "failure";
		position.position++;
		let subtype = collectASequenceOfCodePointsFast$1(";", input, position);
		subtype = removeHTTPWhitespace(subtype, false, true);
		if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return "failure";
		const typeLowercase = type.toLowerCase();
		const subtypeLowercase = subtype.toLowerCase();
		const mimeType = {
			type: typeLowercase,
			subtype: subtypeLowercase,
			parameters: /* @__PURE__ */ new Map(),
			essence: `${typeLowercase}/${subtypeLowercase}`
		};
		while (position.position < input.length) {
			position.position++;
			collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
			let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
			parameterName = parameterName.toLowerCase();
			if (position.position < input.length) {
				if (input[position.position] === ";") continue;
				position.position++;
			}
			if (position.position > input.length) break;
			let parameterValue = null;
			if (input[position.position] === "\"") {
				parameterValue = collectAnHTTPQuotedString(input, position, true);
				collectASequenceOfCodePointsFast$1(";", input, position);
			} else {
				parameterValue = collectASequenceOfCodePointsFast$1(";", input, position);
				parameterValue = removeHTTPWhitespace(parameterValue, false, true);
				if (parameterValue.length === 0) continue;
			}
			if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
		}
		return mimeType;
	}
	/** @param {string} data */
	function forgivingBase64(data) {
		data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
		if (data.length % 4 === 0) data = data.replace(/=?=$/, "");
		if (data.length % 4 === 1) return "failure";
		if (/[^+/0-9A-Za-z]/.test(data)) return "failure";
		const binary = atob$1(data);
		const bytes = new Uint8Array(binary.length);
		for (let byte = 0; byte < binary.length; byte++) bytes[byte] = binary.charCodeAt(byte);
		return bytes;
	}
	/**
	* @param {string} input
	* @param {{ position: number }} position
	* @param {boolean?} extractValue
	*/
	function collectAnHTTPQuotedString(input, position, extractValue) {
		const positionStart = position.position;
		let value = "";
		assert$18(input[position.position] === "\"");
		position.position++;
		while (true) {
			value += collectASequenceOfCodePoints((char) => char !== "\"" && char !== "\\", input, position);
			if (position.position >= input.length) break;
			const quoteOrBackslash = input[position.position];
			position.position++;
			if (quoteOrBackslash === "\\") {
				if (position.position >= input.length) {
					value += "\\";
					break;
				}
				value += input[position.position];
				position.position++;
			} else {
				assert$18(quoteOrBackslash === "\"");
				break;
			}
		}
		if (extractValue) return value;
		return input.slice(positionStart, position.position);
	}
	/**
	* @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	*/
	function serializeAMimeType$4(mimeType) {
		assert$18(mimeType !== "failure");
		const { parameters, essence } = mimeType;
		let serialization = essence;
		for (let [name, value] of parameters.entries()) {
			serialization += ";";
			serialization += name;
			serialization += "=";
			if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
				value = value.replace(/(\\|")/g, "\\$1");
				value = "\"" + value;
				value += "\"";
			}
			serialization += value;
		}
		return serialization;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} char
	*/
	function isHTTPWhiteSpace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === " ";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} str
	*/
	function removeHTTPWhitespace(str$1, leading = true, trailing = true) {
		let lead = 0;
		let trail = str$1.length - 1;
		if (leading) for (; lead < str$1.length && isHTTPWhiteSpace(str$1[lead]); lead++);
		if (trailing) for (; trail > 0 && isHTTPWhiteSpace(str$1[trail]); trail--);
		return str$1.slice(lead, trail + 1);
	}
	/**
	* @see https://infra.spec.whatwg.org/#ascii-whitespace
	* @param {string} char
	*/
	function isASCIIWhitespace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
	}
	/**
	* @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	*/
	function removeASCIIWhitespace(str$1, leading = true, trailing = true) {
		let lead = 0;
		let trail = str$1.length - 1;
		if (leading) for (; lead < str$1.length && isASCIIWhitespace(str$1[lead]); lead++);
		if (trailing) for (; trail > 0 && isASCIIWhitespace(str$1[trail]); trail--);
		return str$1.slice(lead, trail + 1);
	}
	module.exports = {
		dataURLProcessor: dataURLProcessor$1,
		URLSerializer: URLSerializer$4,
		collectASequenceOfCodePoints,
		collectASequenceOfCodePointsFast: collectASequenceOfCodePointsFast$1,
		stringPercentDecode,
		parseMIMEType: parseMIMEType$3,
		collectAnHTTPQuotedString,
		serializeAMimeType: serializeAMimeType$4
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/file.js"(exports, module) {
	const { Blob: Blob$7, File: NativeFile$2 } = __require("buffer");
	const { types: types$3 } = __require("util");
	const { kState: kState$9 } = require_symbols$3();
	const { isBlobLike: isBlobLike$6 } = require_util$5();
	const { webidl: webidl$13 } = require_webidl();
	const { parseMIMEType: parseMIMEType$2, serializeAMimeType: serializeAMimeType$3 } = require_dataURL();
	const { kEnumerableProperty: kEnumerableProperty$8 } = require_util$6();
	const encoder = new TextEncoder();
	var File$4 = class File$4 extends Blob$7 {
		constructor(fileBits, fileName, options = {}) {
			webidl$13.argumentLengthCheck(arguments, 2, { header: "File constructor" });
			fileBits = webidl$13.converters["sequence<BlobPart>"](fileBits);
			fileName = webidl$13.converters.USVString(fileName);
			options = webidl$13.converters.FilePropertyBag(options);
			const n$1 = fileName;
			let t = options.type;
			let d$1;
			substep: {
				if (t) {
					t = parseMIMEType$2(t);
					if (t === "failure") {
						t = "";
						break substep;
					}
					t = serializeAMimeType$3(t).toLowerCase();
				}
				d$1 = options.lastModified;
			}
			super(processBlobParts(fileBits, options), { type: t });
			this[kState$9] = {
				name: n$1,
				lastModified: d$1,
				type: t
			};
		}
		get name() {
			webidl$13.brandCheck(this, File$4);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, File$4);
			return this[kState$9].lastModified;
		}
		get type() {
			webidl$13.brandCheck(this, File$4);
			return this[kState$9].type;
		}
	};
	var FileLike$1 = class FileLike$1 {
		constructor(blobLike, fileName, options = {}) {
			const n$1 = fileName;
			const t = options.type;
			const d$1 = options.lastModified ?? Date.now();
			this[kState$9] = {
				blobLike,
				name: n$1,
				type: t,
				lastModified: d$1
			};
		}
		stream(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.stream(...args);
		}
		arrayBuffer(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.arrayBuffer(...args);
		}
		slice(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.slice(...args);
		}
		text(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.text(...args);
		}
		get size() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.size;
		}
		get type() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.type;
		}
		get name() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].lastModified;
		}
		get [Symbol.toStringTag]() {
			return "File";
		}
	};
	Object.defineProperties(File$4.prototype, {
		[Symbol.toStringTag]: {
			value: "File",
			configurable: true
		},
		name: kEnumerableProperty$8,
		lastModified: kEnumerableProperty$8
	});
	webidl$13.converters.Blob = webidl$13.interfaceConverter(Blob$7);
	webidl$13.converters.BlobPart = function(V, opts) {
		if (webidl$13.util.Type(V) === "Object") {
			if (isBlobLike$6(V)) return webidl$13.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types$3.isAnyArrayBuffer(V)) return webidl$13.converters.BufferSource(V, opts);
		}
		return webidl$13.converters.USVString(V, opts);
	};
	webidl$13.converters["sequence<BlobPart>"] = webidl$13.sequenceConverter(webidl$13.converters.BlobPart);
	webidl$13.converters.FilePropertyBag = webidl$13.dictionaryConverter([
		{
			key: "lastModified",
			converter: webidl$13.converters["long long"],
			get defaultValue() {
				return Date.now();
			}
		},
		{
			key: "type",
			converter: webidl$13.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "endings",
			converter: (value) => {
				value = webidl$13.converters.DOMString(value);
				value = value.toLowerCase();
				if (value !== "native") value = "transparent";
				return value;
			},
			defaultValue: "transparent"
		}
	]);
	/**
	* @see https://www.w3.org/TR/FileAPI/#process-blob-parts
	* @param {(NodeJS.TypedArray|Blob|string)[]} parts
	* @param {{ type: string, endings: string }} options
	*/
	function processBlobParts(parts, options) {
		/** @type {NodeJS.TypedArray[]} */
		const bytes = [];
		for (const element of parts) if (typeof element === "string") {
			let s$1 = element;
			if (options.endings === "native") s$1 = convertLineEndingsNative(s$1);
			bytes.push(encoder.encode(s$1));
		} else if (types$3.isAnyArrayBuffer(element) || types$3.isTypedArray(element)) if (!element.buffer) bytes.push(new Uint8Array(element));
		else bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
		else if (isBlobLike$6(element)) bytes.push(element);
		return bytes;
	}
	/**
	* @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
	* @param {string} s
	*/
	function convertLineEndingsNative(s$1) {
		let nativeLineEnding = "\n";
		if (process.platform === "win32") nativeLineEnding = "\r\n";
		return s$1.replace(/\r?\n/g, nativeLineEnding);
	}
	function isFileLike$3(object) {
		return NativeFile$2 && object instanceof NativeFile$2 || object instanceof File$4 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
	}
	module.exports = {
		File: File$4,
		FileLike: FileLike$1,
		isFileLike: isFileLike$3
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/formdata.js"(exports, module) {
	const { isBlobLike: isBlobLike$5, toUSVString: toUSVString$2, makeIterator: makeIterator$1 } = require_util$5();
	const { kState: kState$8 } = require_symbols$3();
	const { File: UndiciFile$1, FileLike, isFileLike: isFileLike$2 } = require_file();
	const { webidl: webidl$12 } = require_webidl();
	const { Blob: Blob$6, File: NativeFile$1 } = __require("buffer");
	/** @type {globalThis['File']} */
	const File$3 = NativeFile$1 ?? UndiciFile$1;
	var FormData$4 = class FormData$4 {
		constructor(form) {
			if (form !== void 0) throw webidl$12.errors.conversionFailed({
				prefix: "FormData constructor",
				argument: "Argument 1",
				types: ["undefined"]
			});
			this[kState$8] = [];
		}
		append(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
			if (arguments.length === 3 && !isBlobLike$5(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$5(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? webidl$12.converters.USVString(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			this[kState$8].push(entry);
		}
		delete(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
			name = webidl$12.converters.USVString(name);
			this[kState$8] = this[kState$8].filter((entry) => entry.name !== name);
		}
		get(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
			name = webidl$12.converters.USVString(name);
			const idx = this[kState$8].findIndex((entry) => entry.name === name);
			if (idx === -1) return null;
			return this[kState$8][idx].value;
		}
		getAll(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].filter((entry) => entry.name === name).map((entry) => entry.value);
		}
		has(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].findIndex((entry) => entry.name === name) !== -1;
		}
		set(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
			if (arguments.length === 3 && !isBlobLike$5(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$5(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? toUSVString$2(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			const idx = this[kState$8].findIndex((entry$1) => entry$1.name === name);
			if (idx !== -1) this[kState$8] = [
				...this[kState$8].slice(0, idx),
				entry,
				...this[kState$8].slice(idx + 1).filter((entry$1) => entry$1.name !== name)
			];
			else this[kState$8].push(entry);
		}
		entries() {
			webidl$12.brandCheck(this, FormData$4);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
		}
		keys() {
			webidl$12.brandCheck(this, FormData$4);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key");
		}
		values() {
			webidl$12.brandCheck(this, FormData$4);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "value");
		}
		/**
		* @param {(value: string, key: string, self: FormData) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
	};
	FormData$4.prototype[Symbol.iterator] = FormData$4.prototype.entries;
	Object.defineProperties(FormData$4.prototype, { [Symbol.toStringTag]: {
		value: "FormData",
		configurable: true
	} });
	/**
	* @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	* @param {string} name
	* @param {string|Blob} value
	* @param {?string} filename
	* @returns
	*/
	function makeEntry(name, value, filename) {
		name = Buffer.from(name).toString("utf8");
		if (typeof value === "string") value = Buffer.from(value).toString("utf8");
		else {
			if (!isFileLike$2(value)) value = value instanceof Blob$6 ? new File$3([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
			if (filename !== void 0) {
				/** @type {FilePropertyBag} */
				const options = {
					type: value.type,
					lastModified: value.lastModified
				};
				value = NativeFile$1 && value instanceof NativeFile$1 || value instanceof UndiciFile$1 ? new File$3([value], filename, options) : new FileLike(value, filename, options);
			}
		}
		return {
			name,
			value
		};
	}
	module.exports = { FormData: FormData$4 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/body.js"(exports, module) {
	const Busboy = require_main();
	const util$16 = require_util$6();
	const { ReadableStreamFrom: ReadableStreamFrom$1, isBlobLike: isBlobLike$4, isReadableStreamLike, readableStreamClose: readableStreamClose$1, createDeferredPromise: createDeferredPromise$2, fullyReadBody: fullyReadBody$1 } = require_util$5();
	const { FormData: FormData$3 } = require_formdata();
	const { kState: kState$7 } = require_symbols$3();
	const { webidl: webidl$11 } = require_webidl();
	const { DOMException: DOMException$5, structuredClone } = require_constants$4();
	const { Blob: Blob$5, File: NativeFile } = __require("buffer");
	const { kBodyUsed: kBodyUsed$1 } = require_symbols$4();
	const assert$17 = __require("assert");
	const { isErrored: isErrored$1 } = require_util$6();
	const { isUint8Array: isUint8Array$1, isArrayBuffer: isArrayBuffer$1 } = __require("util/types");
	const { File: UndiciFile } = require_file();
	const { parseMIMEType: parseMIMEType$1, serializeAMimeType: serializeAMimeType$2 } = require_dataURL();
	let random;
	try {
		const crypto$4 = __require("node:crypto");
		random = (max) => crypto$4.randomInt(0, max);
	} catch {
		random = (max) => Math.floor(Math.random(max));
	}
	let ReadableStream$4 = globalThis.ReadableStream;
	/** @type {globalThis['File']} */
	const File$2 = NativeFile ?? UndiciFile;
	const textEncoder$3 = new TextEncoder();
	const textDecoder$1 = new TextDecoder();
	function extractBody$3(object, keepalive = false) {
		if (!ReadableStream$4) ReadableStream$4 = __require("stream/web").ReadableStream;
		let stream$2 = null;
		if (object instanceof ReadableStream$4) stream$2 = object;
		else if (isBlobLike$4(object)) stream$2 = object.stream();
		else stream$2 = new ReadableStream$4({
			async pull(controller) {
				controller.enqueue(typeof source === "string" ? textEncoder$3.encode(source) : source);
				queueMicrotask(() => readableStreamClose$1(controller));
			},
			start() {},
			type: void 0
		});
		assert$17(isReadableStreamLike(stream$2));
		let action = null;
		let source = null;
		let length = null;
		let type = null;
		if (typeof object === "string") {
			source = object;
			type = "text/plain;charset=UTF-8";
		} else if (object instanceof URLSearchParams) {
			source = object.toString();
			type = "application/x-www-form-urlencoded;charset=UTF-8";
		} else if (isArrayBuffer$1(object)) source = new Uint8Array(object.slice());
		else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
		else if (util$16.isFormDataLike(object)) {
			const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
			const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
			/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
			const escape$2 = (str$1) => str$1.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
			const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
			const blobParts = [];
			const rn = new Uint8Array([13, 10]);
			length = 0;
			let hasUnknownSizeValue = false;
			for (const [name, value] of object) if (typeof value === "string") {
				const chunk$1 = textEncoder$3.encode(prefix + `; name="${escape$2(normalizeLinefeeds(name))}"\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
				blobParts.push(chunk$1);
				length += chunk$1.byteLength;
			} else {
				const chunk$1 = textEncoder$3.encode(`${prefix}; name="${escape$2(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape$2(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
				blobParts.push(chunk$1, value, rn);
				if (typeof value.size === "number") length += chunk$1.byteLength + value.size + rn.byteLength;
				else hasUnknownSizeValue = true;
			}
			const chunk = textEncoder$3.encode(`--${boundary}--`);
			blobParts.push(chunk);
			length += chunk.byteLength;
			if (hasUnknownSizeValue) length = null;
			source = object;
			action = async function* () {
				for (const part of blobParts) if (part.stream) yield* part.stream();
				else yield part;
			};
			type = "multipart/form-data; boundary=" + boundary;
		} else if (isBlobLike$4(object)) {
			source = object;
			length = object.size;
			if (object.type) type = object.type;
		} else if (typeof object[Symbol.asyncIterator] === "function") {
			if (keepalive) throw new TypeError("keepalive");
			if (util$16.isDisturbed(object) || object.locked) throw new TypeError("Response body object should not be disturbed or locked");
			stream$2 = object instanceof ReadableStream$4 ? object : ReadableStreamFrom$1(object);
		}
		if (typeof source === "string" || util$16.isBuffer(source)) length = Buffer.byteLength(source);
		if (action != null) {
			let iterator$1;
			stream$2 = new ReadableStream$4({
				async start() {
					iterator$1 = action(object)[Symbol.asyncIterator]();
				},
				async pull(controller) {
					const { value, done } = await iterator$1.next();
					if (done) queueMicrotask(() => {
						controller.close();
					});
					else if (!isErrored$1(stream$2)) controller.enqueue(new Uint8Array(value));
					return controller.desiredSize > 0;
				},
				async cancel(reason) {
					await iterator$1.return();
				},
				type: void 0
			});
		}
		const body = {
			stream: stream$2,
			source,
			length
		};
		return [body, type];
	}
	function safelyExtractBody$1(object, keepalive = false) {
		if (!ReadableStream$4)
 // istanbul ignore next
		ReadableStream$4 = __require("stream/web").ReadableStream;
		if (object instanceof ReadableStream$4) {
			// istanbul ignore next
			assert$17(!util$16.isDisturbed(object), "The body has already been consumed.");
			// istanbul ignore next
			assert$17(!object.locked, "The stream is locked.");
		}
		return extractBody$3(object, keepalive);
	}
	function cloneBody$2(body) {
		const [out1, out2] = body.stream.tee();
		const out2Clone = structuredClone(out2, { transfer: [out2] });
		const [, finalClone] = out2Clone.tee();
		body.stream = out1;
		return {
			stream: finalClone,
			length: body.length,
			source: body.source
		};
	}
	async function* consumeBody$1(body) {
		if (body) if (isUint8Array$1(body)) yield body;
		else {
			const stream$2 = body.stream;
			if (util$16.isDisturbed(stream$2)) throw new TypeError("The body has already been consumed.");
			if (stream$2.locked) throw new TypeError("The stream is locked.");
			stream$2[kBodyUsed$1] = true;
			yield* stream$2;
		}
	}
	function throwIfAborted(state) {
		if (state.aborted) throw new DOMException$5("The operation was aborted.", "AbortError");
	}
	function bodyMixinMethods(instance) {
		const methods = {
			blob() {
				return specConsumeBody(this, (bytes) => {
					let mimeType = bodyMimeType(this);
					if (mimeType === "failure") mimeType = "";
					else if (mimeType) mimeType = serializeAMimeType$2(mimeType);
					return new Blob$5([bytes], { type: mimeType });
				}, instance);
			},
			arrayBuffer() {
				return specConsumeBody(this, (bytes) => {
					return new Uint8Array(bytes).buffer;
				}, instance);
			},
			text() {
				return specConsumeBody(this, utf8DecodeBytes, instance);
			},
			json() {
				return specConsumeBody(this, parseJSONFromBytes, instance);
			},
			async formData() {
				webidl$11.brandCheck(this, instance);
				throwIfAborted(this[kState$7]);
				const contentType = this.headers.get("Content-Type");
				if (/multipart\/form-data/.test(contentType)) {
					const headers = {};
					for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
					const responseFormData = new FormData$3();
					let busboy;
					try {
						busboy = new Busboy({
							headers,
							preservePath: true
						});
					} catch (err) {
						throw new DOMException$5(`${err}`, "AbortError");
					}
					busboy.on("field", (name, value) => {
						responseFormData.append(name, value);
					});
					busboy.on("file", (name, value, filename, encoding, mimeType) => {
						const chunks = [];
						if (encoding === "base64" || encoding.toLowerCase() === "base64") {
							let base64chunk = "";
							value.on("data", (chunk) => {
								base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
								const end = base64chunk.length - base64chunk.length % 4;
								chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
								base64chunk = base64chunk.slice(end);
							});
							value.on("end", () => {
								chunks.push(Buffer.from(base64chunk, "base64"));
								responseFormData.append(name, new File$2(chunks, filename, { type: mimeType }));
							});
						} else {
							value.on("data", (chunk) => {
								chunks.push(chunk);
							});
							value.on("end", () => {
								responseFormData.append(name, new File$2(chunks, filename, { type: mimeType }));
							});
						}
					});
					const busboyResolve = new Promise((resolve, reject) => {
						busboy.on("finish", resolve);
						busboy.on("error", (err) => reject(new TypeError(err)));
					});
					if (this.body !== null) for await (const chunk of consumeBody$1(this[kState$7].body)) busboy.write(chunk);
					busboy.end();
					await busboyResolve;
					return responseFormData;
				} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
					let entries;
					try {
						let text = "";
						const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
						for await (const chunk of consumeBody$1(this[kState$7].body)) {
							if (!isUint8Array$1(chunk)) throw new TypeError("Expected Uint8Array chunk");
							text += streamingDecoder.decode(chunk, { stream: true });
						}
						text += streamingDecoder.decode();
						entries = new URLSearchParams(text);
					} catch (err) {
						// istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
						throw Object.assign(/* @__PURE__ */ new TypeError(), { cause: err });
					}
					const formData = new FormData$3();
					for (const [name, value] of entries) formData.append(name, value);
					return formData;
				} else {
					await Promise.resolve();
					throwIfAborted(this[kState$7]);
					throw webidl$11.errors.exception({
						header: `${instance.name}.formData`,
						message: "Could not parse content as FormData."
					});
				}
			}
		};
		return methods;
	}
	function mixinBody$2(prototype) {
		Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	* @param {Response|Request} object
	* @param {(value: unknown) => unknown} convertBytesToJSValue
	* @param {Response|Request} instance
	*/
	async function specConsumeBody(object, convertBytesToJSValue, instance) {
		webidl$11.brandCheck(object, instance);
		throwIfAborted(object[kState$7]);
		if (bodyUnusable(object[kState$7].body)) throw new TypeError("Body is unusable");
		const promise = createDeferredPromise$2();
		const errorSteps = (error$1) => promise.reject(error$1);
		const successSteps = (data) => {
			try {
				promise.resolve(convertBytesToJSValue(data));
			} catch (e) {
				errorSteps(e);
			}
		};
		if (object[kState$7].body == null) {
			successSteps(new Uint8Array());
			return promise.promise;
		}
		await fullyReadBody$1(object[kState$7].body, successSteps, errorSteps);
		return promise.promise;
	}
	function bodyUnusable(body) {
		return body != null && (body.stream.locked || util$16.isDisturbed(body.stream));
	}
	/**
	* @see https://encoding.spec.whatwg.org/#utf-8-decode
	* @param {Buffer} buffer
	*/
	function utf8DecodeBytes(buffer) {
		if (buffer.length === 0) return "";
		if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) buffer = buffer.subarray(3);
		const output = textDecoder$1.decode(buffer);
		return output;
	}
	/**
	* @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	* @param {Uint8Array} bytes
	*/
	function parseJSONFromBytes(bytes) {
		return JSON.parse(utf8DecodeBytes(bytes));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	* @param {import('./response').Response|import('./request').Request} object
	*/
	function bodyMimeType(object) {
		const { headersList } = object[kState$7];
		const contentType = headersList.get("content-type");
		if (contentType === null) return "failure";
		return parseMIMEType$1(contentType);
	}
	module.exports = {
		extractBody: extractBody$3,
		safelyExtractBody: safelyExtractBody$1,
		cloneBody: cloneBody$2,
		mixinBody: mixinBody$2
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/request.js
var require_request$1 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/request.js"(exports, module) {
	const { InvalidArgumentError: InvalidArgumentError$20, NotSupportedError: NotSupportedError$1 } = require_errors();
	const assert$16 = __require("assert");
	const { kHTTP2BuildRequest: kHTTP2BuildRequest$1, kHTTP2CopyHeaders: kHTTP2CopyHeaders$1, kHTTP1BuildRequest: kHTTP1BuildRequest$1 } = require_symbols$4();
	const util$15 = require_util$6();
	/**
	* Verifies that the given val is a valid HTTP token
	* per the rules defined in RFC 7230
	* See https://tools.ietf.org/html/rfc7230#section-3.2.6
	*/
	const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
	/**
	* Matches if val contains an invalid field-vchar
	*  field-value    = *( field-content / obs-fold )
	*  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	*  field-vchar    = VCHAR / obs-text
	*/
	const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
	const invalidPathRegex = /[^\u0021-\u00ff]/;
	const kHandler = Symbol("handler");
	const channels$3 = {};
	let extractBody$2;
	try {
		const diagnosticsChannel$2 = __require("diagnostics_channel");
		channels$3.create = diagnosticsChannel$2.channel("undici:request:create");
		channels$3.bodySent = diagnosticsChannel$2.channel("undici:request:bodySent");
		channels$3.headers = diagnosticsChannel$2.channel("undici:request:headers");
		channels$3.trailers = diagnosticsChannel$2.channel("undici:request:trailers");
		channels$3.error = diagnosticsChannel$2.channel("undici:request:error");
	} catch {
		channels$3.create = { hasSubscribers: false };
		channels$3.bodySent = { hasSubscribers: false };
		channels$3.headers = { hasSubscribers: false };
		channels$3.trailers = { hasSubscribers: false };
		channels$3.error = { hasSubscribers: false };
	}
	var Request$6 = class Request$6 {
		constructor(origin, { path: path$9, method, body, headers, query, idempotent, blocking, upgrade: upgrade$1, headersTimeout, bodyTimeout, reset: reset$1, throwOnError, expectContinue }, handler$1) {
			if (typeof path$9 !== "string") throw new InvalidArgumentError$20("path must be a string");
			else if (path$9[0] !== "/" && !(path$9.startsWith("http://") || path$9.startsWith("https://")) && method !== "CONNECT") throw new InvalidArgumentError$20("path must be an absolute URL or start with a slash");
			else if (invalidPathRegex.exec(path$9) !== null) throw new InvalidArgumentError$20("invalid request path");
			if (typeof method !== "string") throw new InvalidArgumentError$20("method must be a string");
			else if (tokenRegExp.exec(method) === null) throw new InvalidArgumentError$20("invalid request method");
			if (upgrade$1 && typeof upgrade$1 !== "string") throw new InvalidArgumentError$20("upgrade must be a string");
			if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$20("invalid headersTimeout");
			if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$20("invalid bodyTimeout");
			if (reset$1 != null && typeof reset$1 !== "boolean") throw new InvalidArgumentError$20("invalid reset");
			if (expectContinue != null && typeof expectContinue !== "boolean") throw new InvalidArgumentError$20("invalid expectContinue");
			this.headersTimeout = headersTimeout;
			this.bodyTimeout = bodyTimeout;
			this.throwOnError = throwOnError === true;
			this.method = method;
			this.abort = null;
			if (body == null) this.body = null;
			else if (util$15.isStream(body)) {
				this.body = body;
				const rState = this.body._readableState;
				if (!rState || !rState.autoDestroy) {
					this.endHandler = function autoDestroy() {
						util$15.destroy(this);
					};
					this.body.on("end", this.endHandler);
				}
				this.errorHandler = (err) => {
					if (this.abort) this.abort(err);
					else this.error = err;
				};
				this.body.on("error", this.errorHandler);
			} else if (util$15.isBuffer(body)) this.body = body.byteLength ? body : null;
			else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
			else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;
			else if (typeof body === "string") this.body = body.length ? Buffer.from(body) : null;
			else if (util$15.isFormDataLike(body) || util$15.isIterable(body) || util$15.isBlobLike(body)) this.body = body;
			else throw new InvalidArgumentError$20("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
			this.completed = false;
			this.aborted = false;
			this.upgrade = upgrade$1 || null;
			this.path = query ? util$15.buildURL(path$9, query) : path$9;
			this.origin = origin;
			this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
			this.blocking = blocking == null ? false : blocking;
			this.reset = reset$1 == null ? null : reset$1;
			this.host = null;
			this.contentLength = null;
			this.contentType = null;
			this.headers = "";
			this.expectContinue = expectContinue != null ? expectContinue : false;
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$1 = 0; i$1 < headers.length; i$1 += 2) processHeader(this, headers[i$1], headers[i$1 + 1]);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$1 = 0; i$1 < keys.length; i$1++) {
					const key = keys[i$1];
					processHeader(this, key, headers[key]);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			if (util$15.isFormDataLike(this.body)) {
				if (util$15.nodeMajor < 16 || util$15.nodeMajor === 16 && util$15.nodeMinor < 8) throw new InvalidArgumentError$20("Form-Data bodies are only supported in node v16.8 and newer.");
				if (!extractBody$2) extractBody$2 = require_body().extractBody;
				const [bodyStream, contentType] = extractBody$2(body);
				if (this.contentType == null) {
					this.contentType = contentType;
					this.headers += `content-type: ${contentType}\r\n`;
				}
				this.body = bodyStream.stream;
				this.contentLength = bodyStream.length;
			} else if (util$15.isBlobLike(body) && this.contentType == null && body.type) {
				this.contentType = body.type;
				this.headers += `content-type: ${body.type}\r\n`;
			}
			util$15.validateHandler(handler$1, method, upgrade$1);
			this.servername = util$15.getServerName(this.host);
			this[kHandler] = handler$1;
			if (channels$3.create.hasSubscribers) channels$3.create.publish({ request: this });
		}
		onBodySent(chunk) {
			if (this[kHandler].onBodySent) try {
				return this[kHandler].onBodySent(chunk);
			} catch (err) {
				this.abort(err);
			}
		}
		onRequestSent() {
			if (channels$3.bodySent.hasSubscribers) channels$3.bodySent.publish({ request: this });
			if (this[kHandler].onRequestSent) try {
				return this[kHandler].onRequestSent();
			} catch (err) {
				this.abort(err);
			}
		}
		onConnect(abort$1) {
			assert$16(!this.aborted);
			assert$16(!this.completed);
			if (this.error) abort$1(this.error);
			else {
				this.abort = abort$1;
				return this[kHandler].onConnect(abort$1);
			}
		}
		onHeaders(statusCode, headers, resume$1, statusText) {
			assert$16(!this.aborted);
			assert$16(!this.completed);
			if (channels$3.headers.hasSubscribers) channels$3.headers.publish({
				request: this,
				response: {
					statusCode,
					headers,
					statusText
				}
			});
			try {
				return this[kHandler].onHeaders(statusCode, headers, resume$1, statusText);
			} catch (err) {
				this.abort(err);
			}
		}
		onData(chunk) {
			assert$16(!this.aborted);
			assert$16(!this.completed);
			try {
				return this[kHandler].onData(chunk);
			} catch (err) {
				this.abort(err);
				return false;
			}
		}
		onUpgrade(statusCode, headers, socket) {
			assert$16(!this.aborted);
			assert$16(!this.completed);
			return this[kHandler].onUpgrade(statusCode, headers, socket);
		}
		onComplete(trailers) {
			this.onFinally();
			assert$16(!this.aborted);
			this.completed = true;
			if (channels$3.trailers.hasSubscribers) channels$3.trailers.publish({
				request: this,
				trailers
			});
			try {
				return this[kHandler].onComplete(trailers);
			} catch (err) {
				this.onError(err);
			}
		}
		onError(error$1) {
			this.onFinally();
			if (channels$3.error.hasSubscribers) channels$3.error.publish({
				request: this,
				error: error$1
			});
			if (this.aborted) return;
			this.aborted = true;
			return this[kHandler].onError(error$1);
		}
		onFinally() {
			if (this.errorHandler) {
				this.body.off("error", this.errorHandler);
				this.errorHandler = null;
			}
			if (this.endHandler) {
				this.body.off("end", this.endHandler);
				this.endHandler = null;
			}
		}
		addHeader(key, value) {
			processHeader(this, key, value);
			return this;
		}
		static [kHTTP1BuildRequest$1](origin, opts, handler$1) {
			return new Request$6(origin, opts, handler$1);
		}
		static [kHTTP2BuildRequest$1](origin, opts, handler$1) {
			const headers = opts.headers;
			opts = {
				...opts,
				headers: null
			};
			const request$2 = new Request$6(origin, opts, handler$1);
			request$2.headers = {};
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$1 = 0; i$1 < headers.length; i$1 += 2) processHeader(request$2, headers[i$1], headers[i$1 + 1], true);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$1 = 0; i$1 < keys.length; i$1++) {
					const key = keys[i$1];
					processHeader(request$2, key, headers[key], true);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			return request$2;
		}
		static [kHTTP2CopyHeaders$1](raw) {
			const rawHeaders = raw.split("\r\n");
			const headers = {};
			for (const header of rawHeaders) {
				const [key, value] = header.split(": ");
				if (value == null || value.length === 0) continue;
				if (headers[key]) headers[key] += `,${value}`;
				else headers[key] = value;
			}
			return headers;
		}
	};
	function processHeaderValue(key, val, skipAppend) {
		if (val && typeof val === "object") throw new InvalidArgumentError$20(`invalid ${key} header`);
		val = val != null ? `${val}` : "";
		if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
		return skipAppend ? val : `${key}: ${val}\r\n`;
	}
	function processHeader(request$2, key, val, skipAppend = false) {
		if (val && typeof val === "object" && !Array.isArray(val)) throw new InvalidArgumentError$20(`invalid ${key} header`);
		else if (val === void 0) return;
		if (request$2.host === null && key.length === 4 && key.toLowerCase() === "host") {
			if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
			request$2.host = val;
		} else if (request$2.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
			request$2.contentLength = parseInt(val, 10);
			if (!Number.isFinite(request$2.contentLength)) throw new InvalidArgumentError$20("invalid content-length header");
		} else if (request$2.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
			request$2.contentType = val;
			if (skipAppend) request$2.headers[key] = processHeaderValue(key, val, skipAppend);
			else request$2.headers += processHeaderValue(key, val);
		} else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") throw new InvalidArgumentError$20("invalid transfer-encoding header");
		else if (key.length === 10 && key.toLowerCase() === "connection") {
			const value = typeof val === "string" ? val.toLowerCase() : null;
			if (value !== "close" && value !== "keep-alive") throw new InvalidArgumentError$20("invalid connection header");
			else if (value === "close") request$2.reset = true;
		} else if (key.length === 10 && key.toLowerCase() === "keep-alive") throw new InvalidArgumentError$20("invalid keep-alive header");
		else if (key.length === 7 && key.toLowerCase() === "upgrade") throw new InvalidArgumentError$20("invalid upgrade header");
		else if (key.length === 6 && key.toLowerCase() === "expect") throw new NotSupportedError$1("expect header not supported");
		else if (tokenRegExp.exec(key) === null) throw new InvalidArgumentError$20("invalid header key");
		else if (Array.isArray(val)) for (let i$1 = 0; i$1 < val.length; i$1++) if (skipAppend) if (request$2.headers[key]) request$2.headers[key] += `,${processHeaderValue(key, val[i$1], skipAppend)}`;
		else request$2.headers[key] = processHeaderValue(key, val[i$1], skipAppend);
		else request$2.headers += processHeaderValue(key, val[i$1]);
		else if (skipAppend) request$2.headers[key] = processHeaderValue(key, val, skipAppend);
		else request$2.headers += processHeaderValue(key, val);
	}
	module.exports = Request$6;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/dispatcher.js"(exports, module) {
	const EventEmitter$1 = __require("events");
	var Dispatcher$3 = class extends EventEmitter$1 {
		dispatch() {
			throw new Error("not implemented");
		}
		close() {
			throw new Error("not implemented");
		}
		destroy() {
			throw new Error("not implemented");
		}
	};
	module.exports = Dispatcher$3;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/dispatcher-base.js"(exports, module) {
	const Dispatcher$2 = require_dispatcher();
	const { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$19 } = require_errors();
	const { kDestroy: kDestroy$4, kClose: kClose$6, kDispatch: kDispatch$3, kInterceptors: kInterceptors$5 } = require_symbols$4();
	const kDestroyed = Symbol("destroyed");
	const kClosed = Symbol("closed");
	const kOnDestroyed = Symbol("onDestroyed");
	const kOnClosed = Symbol("onClosed");
	const kInterceptedDispatch = Symbol("Intercepted Dispatch");
	var DispatcherBase$4 = class extends Dispatcher$2 {
		constructor() {
			super();
			this[kDestroyed] = false;
			this[kOnDestroyed] = null;
			this[kClosed] = false;
			this[kOnClosed] = [];
		}
		get destroyed() {
			return this[kDestroyed];
		}
		get closed() {
			return this[kClosed];
		}
		get interceptors() {
			return this[kInterceptors$5];
		}
		set interceptors(newInterceptors) {
			if (newInterceptors) for (let i$1 = newInterceptors.length - 1; i$1 >= 0; i$1--) {
				const interceptor = this[kInterceptors$5][i$1];
				if (typeof interceptor !== "function") throw new InvalidArgumentError$19("interceptor must be an function");
			}
			this[kInterceptors$5] = newInterceptors;
		}
		close(callback) {
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.close((err, data) => {
					return err ? reject(err) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				queueMicrotask(() => callback(new ClientDestroyedError$1(), null));
				return;
			}
			if (this[kClosed]) {
				if (this[kOnClosed]) this[kOnClosed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			this[kClosed] = true;
			this[kOnClosed].push(callback);
			const onClosed = () => {
				const callbacks = this[kOnClosed];
				this[kOnClosed] = null;
				for (let i$1 = 0; i$1 < callbacks.length; i$1++) callbacks[i$1](null, null);
			};
			this[kClose$6]().then(() => this.destroy()).then(() => {
				queueMicrotask(onClosed);
			});
		}
		destroy(err, callback) {
			if (typeof err === "function") {
				callback = err;
				err = null;
			}
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.destroy(err, (err$1, data) => {
					return err$1 ? reject(err$1) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			if (!err) err = new ClientDestroyedError$1();
			this[kDestroyed] = true;
			this[kOnDestroyed] = this[kOnDestroyed] || [];
			this[kOnDestroyed].push(callback);
			const onDestroyed = () => {
				const callbacks = this[kOnDestroyed];
				this[kOnDestroyed] = null;
				for (let i$1 = 0; i$1 < callbacks.length; i$1++) callbacks[i$1](null, null);
			};
			this[kDestroy$4](err).then(() => {
				queueMicrotask(onDestroyed);
			});
		}
		[kInterceptedDispatch](opts, handler$1) {
			if (!this[kInterceptors$5] || this[kInterceptors$5].length === 0) {
				this[kInterceptedDispatch] = this[kDispatch$3];
				return this[kDispatch$3](opts, handler$1);
			}
			let dispatch = this[kDispatch$3].bind(this);
			for (let i$1 = this[kInterceptors$5].length - 1; i$1 >= 0; i$1--) dispatch = this[kInterceptors$5][i$1](dispatch);
			this[kInterceptedDispatch] = dispatch;
			return dispatch(opts, handler$1);
		}
		dispatch(opts, handler$1) {
			if (!handler$1 || typeof handler$1 !== "object") throw new InvalidArgumentError$19("handler must be an object");
			try {
				if (!opts || typeof opts !== "object") throw new InvalidArgumentError$19("opts must be an object.");
				if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError$1();
				if (this[kClosed]) throw new ClientClosedError();
				return this[kInterceptedDispatch](opts, handler$1);
			} catch (err) {
				if (typeof handler$1.onError !== "function") throw new InvalidArgumentError$19("invalid onError method");
				handler$1.onError(err);
				return false;
			}
		}
	};
	module.exports = DispatcherBase$4;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/core/connect.js"(exports, module) {
	const net$1 = __require("net");
	const assert$15 = __require("assert");
	const util$14 = require_util$6();
	const { InvalidArgumentError: InvalidArgumentError$18, ConnectTimeoutError } = require_errors();
	let tls;
	let SessionCache;
	if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) SessionCache = class WeakSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
			this._sessionRegistry = new global.FinalizationRegistry((key) => {
				if (this._sessionCache.size < this._maxCachedSessions) return;
				const ref = this._sessionCache.get(key);
				if (ref !== void 0 && ref.deref() === void 0) this._sessionCache.delete(key);
			});
		}
		get(sessionKey) {
			const ref = this._sessionCache.get(sessionKey);
			return ref ? ref.deref() : null;
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			this._sessionCache.set(sessionKey, new WeakRef(session));
			this._sessionRegistry.register(session, sessionKey);
		}
	};
	else SessionCache = class SimpleSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
		}
		get(sessionKey) {
			return this._sessionCache.get(sessionKey);
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			if (this._sessionCache.size >= this._maxCachedSessions) {
				const { value: oldestKey } = this._sessionCache.keys().next();
				this._sessionCache.delete(oldestKey);
			}
			this._sessionCache.set(sessionKey, session);
		}
	};
	function buildConnector$4({ allowH2, maxCachedSessions, socketPath, timeout,...opts }) {
		if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError$18("maxCachedSessions must be a positive integer or zero");
		const options = {
			path: socketPath,
			...opts
		};
		const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
		timeout = timeout == null ? 1e4 : timeout;
		allowH2 = allowH2 != null ? allowH2 : false;
		return function connect$2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
			let socket;
			if (protocol === "https:") {
				if (!tls) tls = __require("tls");
				servername = servername || options.servername || util$14.getServerName(host) || null;
				const sessionKey = servername || hostname;
				const session = sessionCache.get(sessionKey) || null;
				assert$15(sessionKey);
				socket = tls.connect({
					highWaterMark: 16384,
					...options,
					servername,
					session,
					localAddress,
					ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
					socket: httpSocket,
					port: port || 443,
					host: hostname
				});
				socket.on("session", function(session$1) {
					sessionCache.set(sessionKey, session$1);
				});
			} else {
				assert$15(!httpSocket, "httpSocket can only be sent on TLS update");
				socket = net$1.connect({
					highWaterMark: 64 * 1024,
					...options,
					localAddress,
					port: port || 80,
					host: hostname
				});
			}
			if (options.keepAlive == null || options.keepAlive) {
				const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
				socket.setKeepAlive(true, keepAliveInitialDelay);
			}
			const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
			socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(null, this);
				}
			}).on("error", function(err) {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(err);
				}
			});
			return socket;
		};
	}
	function setupTimeout(onConnectTimeout$1, timeout) {
		if (!timeout) return () => {};
		let s1 = null;
		let s2 = null;
		const timeoutId = setTimeout(() => {
			s1 = setImmediate(() => {
				if (process.platform === "win32") s2 = setImmediate(() => onConnectTimeout$1());
				else onConnectTimeout$1();
			});
		}, timeout);
		return () => {
			clearTimeout(timeoutId);
			clearImmediate(s1);
			clearImmediate(s2);
		};
	}
	function onConnectTimeout(socket) {
		util$14.destroy(socket, new ConnectTimeoutError());
	}
	module.exports = buildConnector$4;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/utils.js
var require_utils$3 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.enumToMap = void 0;
	function enumToMap(obj) {
		const res = {};
		Object.keys(obj).forEach((key) => {
			const value = obj[key];
			if (typeof value === "number") res[key] = value;
		});
		return res;
	}
	exports.enumToMap = enumToMap;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/constants.js
var require_constants$3 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/constants.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
	const utils_1$2 = require_utils$3();
	var ERROR;
	(function(ERROR$1) {
		ERROR$1[ERROR$1["OK"] = 0] = "OK";
		ERROR$1[ERROR$1["INTERNAL"] = 1] = "INTERNAL";
		ERROR$1[ERROR$1["STRICT"] = 2] = "STRICT";
		ERROR$1[ERROR$1["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		ERROR$1[ERROR$1["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		ERROR$1[ERROR$1["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		ERROR$1[ERROR$1["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		ERROR$1[ERROR$1["INVALID_URL"] = 7] = "INVALID_URL";
		ERROR$1[ERROR$1["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		ERROR$1[ERROR$1["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		ERROR$1[ERROR$1["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		ERROR$1[ERROR$1["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		ERROR$1[ERROR$1["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		ERROR$1[ERROR$1["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		ERROR$1[ERROR$1["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		ERROR$1[ERROR$1["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		ERROR$1[ERROR$1["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		ERROR$1[ERROR$1["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		ERROR$1[ERROR$1["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		ERROR$1[ERROR$1["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		ERROR$1[ERROR$1["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		ERROR$1[ERROR$1["PAUSED"] = 21] = "PAUSED";
		ERROR$1[ERROR$1["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		ERROR$1[ERROR$1["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		ERROR$1[ERROR$1["USER"] = 24] = "USER";
	})(ERROR = exports.ERROR || (exports.ERROR = {}));
	var TYPE$1;
	(function(TYPE$2) {
		TYPE$2[TYPE$2["BOTH"] = 0] = "BOTH";
		TYPE$2[TYPE$2["REQUEST"] = 1] = "REQUEST";
		TYPE$2[TYPE$2["RESPONSE"] = 2] = "RESPONSE";
	})(TYPE$1 = exports.TYPE || (exports.TYPE = {}));
	var FLAGS;
	(function(FLAGS$1) {
		FLAGS$1[FLAGS$1["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		FLAGS$1[FLAGS$1["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		FLAGS$1[FLAGS$1["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		FLAGS$1[FLAGS$1["CHUNKED"] = 8] = "CHUNKED";
		FLAGS$1[FLAGS$1["UPGRADE"] = 16] = "UPGRADE";
		FLAGS$1[FLAGS$1["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		FLAGS$1[FLAGS$1["SKIPBODY"] = 64] = "SKIPBODY";
		FLAGS$1[FLAGS$1["TRAILING"] = 128] = "TRAILING";
		FLAGS$1[FLAGS$1["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
	})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
	var LENIENT_FLAGS;
	(function(LENIENT_FLAGS$1) {
		LENIENT_FLAGS$1[LENIENT_FLAGS$1["HEADERS"] = 1] = "HEADERS";
		LENIENT_FLAGS$1[LENIENT_FLAGS$1["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		LENIENT_FLAGS$1[LENIENT_FLAGS$1["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
	})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
	var METHODS;
	(function(METHODS$1) {
		METHODS$1[METHODS$1["DELETE"] = 0] = "DELETE";
		METHODS$1[METHODS$1["GET"] = 1] = "GET";
		METHODS$1[METHODS$1["HEAD"] = 2] = "HEAD";
		METHODS$1[METHODS$1["POST"] = 3] = "POST";
		METHODS$1[METHODS$1["PUT"] = 4] = "PUT";
		METHODS$1[METHODS$1["CONNECT"] = 5] = "CONNECT";
		METHODS$1[METHODS$1["OPTIONS"] = 6] = "OPTIONS";
		METHODS$1[METHODS$1["TRACE"] = 7] = "TRACE";
		METHODS$1[METHODS$1["COPY"] = 8] = "COPY";
		METHODS$1[METHODS$1["LOCK"] = 9] = "LOCK";
		METHODS$1[METHODS$1["MKCOL"] = 10] = "MKCOL";
		METHODS$1[METHODS$1["MOVE"] = 11] = "MOVE";
		METHODS$1[METHODS$1["PROPFIND"] = 12] = "PROPFIND";
		METHODS$1[METHODS$1["PROPPATCH"] = 13] = "PROPPATCH";
		METHODS$1[METHODS$1["SEARCH"] = 14] = "SEARCH";
		METHODS$1[METHODS$1["UNLOCK"] = 15] = "UNLOCK";
		METHODS$1[METHODS$1["BIND"] = 16] = "BIND";
		METHODS$1[METHODS$1["REBIND"] = 17] = "REBIND";
		METHODS$1[METHODS$1["UNBIND"] = 18] = "UNBIND";
		METHODS$1[METHODS$1["ACL"] = 19] = "ACL";
		METHODS$1[METHODS$1["REPORT"] = 20] = "REPORT";
		METHODS$1[METHODS$1["MKACTIVITY"] = 21] = "MKACTIVITY";
		METHODS$1[METHODS$1["CHECKOUT"] = 22] = "CHECKOUT";
		METHODS$1[METHODS$1["MERGE"] = 23] = "MERGE";
		METHODS$1[METHODS$1["M-SEARCH"] = 24] = "M-SEARCH";
		METHODS$1[METHODS$1["NOTIFY"] = 25] = "NOTIFY";
		METHODS$1[METHODS$1["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		METHODS$1[METHODS$1["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		METHODS$1[METHODS$1["PATCH"] = 28] = "PATCH";
		METHODS$1[METHODS$1["PURGE"] = 29] = "PURGE";
		METHODS$1[METHODS$1["MKCALENDAR"] = 30] = "MKCALENDAR";
		METHODS$1[METHODS$1["LINK"] = 31] = "LINK";
		METHODS$1[METHODS$1["UNLINK"] = 32] = "UNLINK";
		METHODS$1[METHODS$1["SOURCE"] = 33] = "SOURCE";
		METHODS$1[METHODS$1["PRI"] = 34] = "PRI";
		METHODS$1[METHODS$1["DESCRIBE"] = 35] = "DESCRIBE";
		METHODS$1[METHODS$1["ANNOUNCE"] = 36] = "ANNOUNCE";
		METHODS$1[METHODS$1["SETUP"] = 37] = "SETUP";
		METHODS$1[METHODS$1["PLAY"] = 38] = "PLAY";
		METHODS$1[METHODS$1["PAUSE"] = 39] = "PAUSE";
		METHODS$1[METHODS$1["TEARDOWN"] = 40] = "TEARDOWN";
		METHODS$1[METHODS$1["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		METHODS$1[METHODS$1["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		METHODS$1[METHODS$1["REDIRECT"] = 43] = "REDIRECT";
		METHODS$1[METHODS$1["RECORD"] = 44] = "RECORD";
		METHODS$1[METHODS$1["FLUSH"] = 45] = "FLUSH";
	})(METHODS = exports.METHODS || (exports.METHODS = {}));
	exports.METHODS_HTTP = [
		METHODS.DELETE,
		METHODS.GET,
		METHODS.HEAD,
		METHODS.POST,
		METHODS.PUT,
		METHODS.CONNECT,
		METHODS.OPTIONS,
		METHODS.TRACE,
		METHODS.COPY,
		METHODS.LOCK,
		METHODS.MKCOL,
		METHODS.MOVE,
		METHODS.PROPFIND,
		METHODS.PROPPATCH,
		METHODS.SEARCH,
		METHODS.UNLOCK,
		METHODS.BIND,
		METHODS.REBIND,
		METHODS.UNBIND,
		METHODS.ACL,
		METHODS.REPORT,
		METHODS.MKACTIVITY,
		METHODS.CHECKOUT,
		METHODS.MERGE,
		METHODS["M-SEARCH"],
		METHODS.NOTIFY,
		METHODS.SUBSCRIBE,
		METHODS.UNSUBSCRIBE,
		METHODS.PATCH,
		METHODS.PURGE,
		METHODS.MKCALENDAR,
		METHODS.LINK,
		METHODS.UNLINK,
		METHODS.PRI,
		METHODS.SOURCE
	];
	exports.METHODS_ICE = [METHODS.SOURCE];
	exports.METHODS_RTSP = [
		METHODS.OPTIONS,
		METHODS.DESCRIBE,
		METHODS.ANNOUNCE,
		METHODS.SETUP,
		METHODS.PLAY,
		METHODS.PAUSE,
		METHODS.TEARDOWN,
		METHODS.GET_PARAMETER,
		METHODS.SET_PARAMETER,
		METHODS.REDIRECT,
		METHODS.RECORD,
		METHODS.FLUSH,
		METHODS.GET,
		METHODS.POST
	];
	exports.METHOD_MAP = utils_1$2.enumToMap(METHODS);
	exports.H_METHOD_MAP = {};
	Object.keys(exports.METHOD_MAP).forEach((key) => {
		if (/^H/.test(key)) exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
	});
	var FINISH;
	(function(FINISH$1) {
		FINISH$1[FINISH$1["SAFE"] = 0] = "SAFE";
		FINISH$1[FINISH$1["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		FINISH$1[FINISH$1["UNSAFE"] = 2] = "UNSAFE";
	})(FINISH = exports.FINISH || (exports.FINISH = {}));
	exports.ALPHA = [];
	for (let i$1 = "A".charCodeAt(0); i$1 <= "Z".charCodeAt(0); i$1++) {
		exports.ALPHA.push(String.fromCharCode(i$1));
		exports.ALPHA.push(String.fromCharCode(i$1 + 32));
	}
	exports.NUM_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9
	};
	exports.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	};
	exports.NUM = [
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9"
	];
	exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
	exports.MARK = [
		"-",
		"_",
		".",
		"!",
		"~",
		"*",
		"'",
		"(",
		")"
	];
	exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
		"%",
		";",
		":",
		"&",
		"=",
		"+",
		"$",
		","
	]);
	exports.STRICT_URL_CHAR = [
		"!",
		"\"",
		"$",
		"%",
		"&",
		"'",
		"(",
		")",
		"*",
		"+",
		",",
		"-",
		".",
		"/",
		":",
		";",
		"<",
		"=",
		">",
		"@",
		"[",
		"\\",
		"]",
		"^",
		"_",
		"`",
		"{",
		"|",
		"}",
		"~"
	].concat(exports.ALPHANUM);
	exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
	for (let i$1 = 128; i$1 <= 255; i$1++) exports.URL_CHAR.push(i$1);
	exports.HEX = exports.NUM.concat([
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F"
	]);
	exports.STRICT_TOKEN = [
		"!",
		"#",
		"$",
		"%",
		"&",
		"'",
		"*",
		"+",
		"-",
		".",
		"^",
		"_",
		"`",
		"|",
		"~"
	].concat(exports.ALPHANUM);
	exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
	exports.HEADER_CHARS = ["	"];
	for (let i$1 = 32; i$1 <= 255; i$1++) if (i$1 !== 127) exports.HEADER_CHARS.push(i$1);
	exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c$1) => c$1 !== 44);
	exports.MAJOR = exports.NUM_MAP;
	exports.MINOR = exports.MAJOR;
	var HEADER_STATE;
	(function(HEADER_STATE$1) {
		HEADER_STATE$1[HEADER_STATE$1["GENERAL"] = 0] = "GENERAL";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION"] = 1] = "CONNECTION";
		HEADER_STATE$1[HEADER_STATE$1["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		HEADER_STATE$1[HEADER_STATE$1["UPGRADE"] = 4] = "UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
	})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
	exports.SPECIAL_HEADERS = {
		"connection": HEADER_STATE.CONNECTION,
		"content-length": HEADER_STATE.CONTENT_LENGTH,
		"proxy-connection": HEADER_STATE.CONNECTION,
		"transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
		"upgrade": HEADER_STATE.UPGRADE
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/handler/RedirectHandler.js"(exports, module) {
	const util$13 = require_util$6();
	const { kBodyUsed } = require_symbols$4();
	const assert$14 = __require("assert");
	const { InvalidArgumentError: InvalidArgumentError$17 } = require_errors();
	const EE$1 = __require("events");
	const redirectableStatusCodes = [
		300,
		301,
		302,
		303,
		307,
		308
	];
	const kBody$1 = Symbol("body");
	var BodyAsyncIterable = class {
		constructor(body) {
			this[kBody$1] = body;
			this[kBodyUsed] = false;
		}
		async *[Symbol.asyncIterator]() {
			assert$14(!this[kBodyUsed], "disturbed");
			this[kBodyUsed] = true;
			yield* this[kBody$1];
		}
	};
	var RedirectHandler$2 = class {
		constructor(dispatch, maxRedirections, opts, handler$1) {
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$17("maxRedirections must be a positive number");
			util$13.validateHandler(handler$1, opts.method, opts.upgrade);
			this.dispatch = dispatch;
			this.location = null;
			this.abort = null;
			this.opts = {
				...opts,
				maxRedirections: 0
			};
			this.maxRedirections = maxRedirections;
			this.handler = handler$1;
			this.history = [];
			if (util$13.isStream(this.opts.body)) {
				if (util$13.bodyLength(this.opts.body) === 0) this.opts.body.on("data", function() {
					assert$14(false);
				});
				if (typeof this.opts.body.readableDidRead !== "boolean") {
					this.opts.body[kBodyUsed] = false;
					EE$1.prototype.on.call(this.opts.body, "data", function() {
						this[kBodyUsed] = true;
					});
				}
			} else if (this.opts.body && typeof this.opts.body.pipeTo === "function") this.opts.body = new BodyAsyncIterable(this.opts.body);
			else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util$13.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
		}
		onConnect(abort$1) {
			this.abort = abort$1;
			this.handler.onConnect(abort$1, { history: this.history });
		}
		onUpgrade(statusCode, headers, socket) {
			this.handler.onUpgrade(statusCode, headers, socket);
		}
		onError(error$1) {
			this.handler.onError(error$1);
		}
		onHeaders(statusCode, headers, resume$1, statusText) {
			this.location = this.history.length >= this.maxRedirections || util$13.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
			if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
			if (!this.location) return this.handler.onHeaders(statusCode, headers, resume$1, statusText);
			const { origin, pathname, search } = util$13.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
			const path$9 = search ? `${pathname}${search}` : pathname;
			this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
			this.opts.path = path$9;
			this.opts.origin = origin;
			this.opts.maxRedirections = 0;
			this.opts.query = null;
			if (statusCode === 303 && this.opts.method !== "HEAD") {
				this.opts.method = "GET";
				this.opts.body = null;
			}
		}
		onData(chunk) {
			if (this.location) {} else return this.handler.onData(chunk);
		}
		onComplete(trailers) {
			if (this.location) {
				this.location = null;
				this.abort = null;
				this.dispatch(this.opts, this);
			} else this.handler.onComplete(trailers);
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) this.handler.onBodySent(chunk);
		}
	};
	function parseLocation(statusCode, headers) {
		if (redirectableStatusCodes.indexOf(statusCode) === -1) return null;
		for (let i$1 = 0; i$1 < headers.length; i$1 += 2) if (headers[i$1].toString().toLowerCase() === "location") return headers[i$1 + 1];
	}
	function shouldRemoveHeader(header, removeContent, unknownOrigin) {
		if (header.length === 4) return util$13.headerNameToString(header) === "host";
		if (removeContent && util$13.headerNameToString(header).startsWith("content-")) return true;
		if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
			const name = util$13.headerNameToString(header);
			return name === "authorization" || name === "cookie" || name === "proxy-authorization";
		}
		return false;
	}
	function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
		const ret = [];
		if (Array.isArray(headers)) {
			for (let i$1 = 0; i$1 < headers.length; i$1 += 2) if (!shouldRemoveHeader(headers[i$1], removeContent, unknownOrigin)) ret.push(headers[i$1], headers[i$1 + 1]);
		} else if (headers && typeof headers === "object") {
			for (const key of Object.keys(headers)) if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers[key]);
		} else assert$14(headers == null, "headers must be an object or an array");
		return ret;
	}
	module.exports = RedirectHandler$2;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports, module) {
	const RedirectHandler$1 = require_RedirectHandler();
	function createRedirectInterceptor$3({ maxRedirections: defaultMaxRedirections }) {
		return (dispatch) => {
			return function Intercept(opts, handler$1) {
				const { maxRedirections = defaultMaxRedirections } = opts;
				if (!maxRedirections) return dispatch(opts, handler$1);
				const redirectHandler = new RedirectHandler$1(dispatch, maxRedirections, opts, handler$1);
				opts = {
					...opts,
					maxRedirections: 0
				};
				return dispatch(opts, redirectHandler);
			};
		};
	}
	module.exports = createRedirectInterceptor$3;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports, module) {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports, module) {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/client.js
var require_client = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/client.js"(exports, module) {
	const assert$13 = __require("assert");
	const net = __require("net");
	const http$2 = __require("http");
	const { pipeline: pipeline$2 } = __require("stream");
	const util$12 = require_util$6();
	const timers = require_timers();
	const Request$5 = require_request$1();
	const DispatcherBase$3 = require_dispatcher_base();
	const { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError: InvalidArgumentError$16, RequestAbortedError: RequestAbortedError$8, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$2, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = require_errors();
	const buildConnector$3 = require_connect();
	const { kUrl: kUrl$3, kReset, kServerName, kClient: kClient$1, kBusy: kBusy$1, kParser, kConnect, kBlocking, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$4, kWriting, kQueue: kQueue$1, kConnected: kConnected$5, kConnecting, kNeedDrain: kNeedDrain$3, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError: kError$2, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2, kInterceptors: kInterceptors$4, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, kHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols$4();
	/** @type {import('http2')} */
	let http2;
	try {
		http2 = __require("http2");
	} catch {
		http2 = { constants: {} };
	}
	const { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
	let h2ExperimentalWarned = false;
	const FastBuffer = Buffer[Symbol.species];
	const kClosedResolve$1 = Symbol("kClosedResolve");
	const channels$2 = {};
	try {
		const diagnosticsChannel$2 = __require("diagnostics_channel");
		channels$2.sendHeaders = diagnosticsChannel$2.channel("undici:client:sendHeaders");
		channels$2.beforeConnect = diagnosticsChannel$2.channel("undici:client:beforeConnect");
		channels$2.connectError = diagnosticsChannel$2.channel("undici:client:connectError");
		channels$2.connected = diagnosticsChannel$2.channel("undici:client:connected");
	} catch {
		channels$2.sendHeaders = { hasSubscribers: false };
		channels$2.beforeConnect = { hasSubscribers: false };
		channels$2.connectError = { hasSubscribers: false };
		channels$2.connected = { hasSubscribers: false };
	}
	/**
	* @type {import('../types/client').default}
	*/
	var Client$4 = class extends DispatcherBase$3 {
		/**
		*
		* @param {string|URL} url
		* @param {import('../types/client').Client.Options} options
		*/
		constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls: tls$2, strictContentLength, maxCachedSessions, maxRedirections, connect: connect$2, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, maxConcurrentStreams } = {}) {
			super();
			if (keepAlive !== void 0) throw new InvalidArgumentError$16("unsupported keepAlive, use pipelining=0 instead");
			if (socketTimeout !== void 0) throw new InvalidArgumentError$16("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
			if (requestTimeout !== void 0) throw new InvalidArgumentError$16("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
			if (idleTimeout !== void 0) throw new InvalidArgumentError$16("unsupported idleTimeout, use keepAliveTimeout instead");
			if (maxKeepAliveTimeout !== void 0) throw new InvalidArgumentError$16("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
			if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError$16("invalid maxHeaderSize");
			if (socketPath != null && typeof socketPath !== "string") throw new InvalidArgumentError$16("invalid socketPath");
			if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError$16("invalid connectTimeout");
			if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveTimeout");
			if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveMaxTimeout");
			if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError$16("invalid keepAliveTimeoutThreshold");
			if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$16("headersTimeout must be a positive integer or zero");
			if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$16("bodyTimeout must be a positive integer or zero");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$16("connect must be a function or an object");
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$16("maxRedirections must be a positive number");
			if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError$16("maxRequestsPerClient must be a positive number");
			if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) throw new InvalidArgumentError$16("localAddress must be valid string IP address");
			if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError$16("maxResponseSize must be a positive number");
			if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError$16("autoSelectFamilyAttemptTimeout must be a positive number");
			if (allowH2 != null && typeof allowH2 !== "boolean") throw new InvalidArgumentError$16("allowH2 must be a valid boolean value");
			if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) throw new InvalidArgumentError$16("maxConcurrentStreams must be a possitive integer, greater than 0");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$3({
				...tls$2,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$12.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$4] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor$2({ maxRedirections })];
			this[kUrl$3] = util$12.parseOrigin(url);
			this[kConnector] = connect$2;
			this[kSocket] = null;
			this[kPipelining] = pipelining != null ? pipelining : 1;
			this[kMaxHeadersSize] = maxHeaderSize || http$2.maxHeaderSize;
			this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
			this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
			this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
			this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
			this[kServerName] = null;
			this[kLocalAddress] = localAddress != null ? localAddress : null;
			this[kResuming] = 0;
			this[kNeedDrain$3] = 0;
			this[kHostHeader] = `host: ${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}\r\n`;
			this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
			this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
			this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
			this[kMaxRedirections$1] = maxRedirections;
			this[kMaxRequests] = maxRequestsPerClient;
			this[kClosedResolve$1] = null;
			this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
			this[kHTTPConnVersion] = "h1";
			this[kHTTP2Session] = null;
			this[kHTTP2SessionState] = !allowH2 ? null : {
				openStreams: 0,
				maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
			};
			this[kHost] = `${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}`;
			this[kQueue$1] = [];
			this[kRunningIdx] = 0;
			this[kPendingIdx] = 0;
		}
		get pipelining() {
			return this[kPipelining];
		}
		set pipelining(value) {
			this[kPipelining] = value;
			resume(this, true);
		}
		get [kPending$2]() {
			return this[kQueue$1].length - this[kPendingIdx];
		}
		get [kRunning$3]() {
			return this[kPendingIdx] - this[kRunningIdx];
		}
		get [kSize$4]() {
			return this[kQueue$1].length - this[kRunningIdx];
		}
		get [kConnected$5]() {
			return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
		}
		get [kBusy$1]() {
			const socket = this[kSocket];
			return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize$4] >= (this[kPipelining] || 1) || this[kPending$2] > 0;
		}
		/* istanbul ignore: only used for test */
		[kConnect](cb) {
			connect$1(this);
			this.once("connect", cb);
		}
		[kDispatch$2](opts, handler$1) {
			const origin = opts.origin || this[kUrl$3].origin;
			const request$2 = this[kHTTPConnVersion] === "h2" ? Request$5[kHTTP2BuildRequest](origin, opts, handler$1) : Request$5[kHTTP1BuildRequest](origin, opts, handler$1);
			this[kQueue$1].push(request$2);
			if (this[kResuming]) {} else if (util$12.bodyLength(request$2.body) == null && util$12.isIterable(request$2.body)) {
				this[kResuming] = 1;
				process.nextTick(resume, this);
			} else resume(this, true);
			if (this[kResuming] && this[kNeedDrain$3] !== 2 && this[kBusy$1]) this[kNeedDrain$3] = 2;
			return this[kNeedDrain$3] < 2;
		}
		async [kClose$5]() {
			return new Promise((resolve) => {
				if (!this[kSize$4]) resolve(null);
				else this[kClosedResolve$1] = resolve;
			});
		}
		async [kDestroy$3](err) {
			return new Promise((resolve) => {
				const requests = this[kQueue$1].splice(this[kPendingIdx]);
				for (let i$1 = 0; i$1 < requests.length; i$1++) {
					const request$2 = requests[i$1];
					errorRequest(this, request$2, err);
				}
				const callback = () => {
					if (this[kClosedResolve$1]) {
						this[kClosedResolve$1]();
						this[kClosedResolve$1] = null;
					}
					resolve();
				};
				if (this[kHTTP2Session] != null) {
					util$12.destroy(this[kHTTP2Session], err);
					this[kHTTP2Session] = null;
					this[kHTTP2SessionState] = null;
				}
				if (!this[kSocket]) queueMicrotask(callback);
				else util$12.destroy(this[kSocket].on("close", callback), err);
				resume(this);
			});
		}
	};
	function onHttp2SessionError(err) {
		assert$13(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		this[kSocket][kError$2] = err;
		onError(this[kClient$1], err);
	}
	function onHttp2FrameError(type, code, id) {
		const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
		if (id === 0) {
			this[kSocket][kError$2] = err;
			onError(this[kClient$1], err);
		}
	}
	function onHttp2SessionEnd() {
		util$12.destroy(this, new SocketError$2("other side closed"));
		util$12.destroy(this[kSocket], new SocketError$2("other side closed"));
	}
	function onHTTP2GoAway(code) {
		const client = this[kClient$1];
		const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
		client[kSocket] = null;
		client[kHTTP2Session] = null;
		if (client.destroyed) {
			assert$13(this[kPending$2] === 0);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$1 = 0; i$1 < requests.length; i$1++) {
				const request$2 = requests[i$1];
				errorRequest(this, request$2, err);
			}
		} else if (client[kRunning$3] > 0) {
			const request$2 = client[kQueue$1][client[kRunningIdx]];
			client[kQueue$1][client[kRunningIdx]++] = null;
			errorRequest(client, request$2, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$13(client[kRunning$3] === 0);
		client.emit("disconnect", client[kUrl$3], [client], err);
		resume(client);
	}
	const constants$1 = require_constants$3();
	const createRedirectInterceptor$2 = require_redirectInterceptor();
	const EMPTY_BUF = Buffer.alloc(0);
	async function lazyllhttp() {
		const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
		let mod;
		try {
			mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
		} catch (e) {
			/* istanbul ignore next */
			mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
		}
		return await WebAssembly.instantiate(mod, { env: {
			wasm_on_url: (p, at$1, len) => {
				/* istanbul ignore next */
				return 0;
			},
			wasm_on_status: (p, at$1, len) => {
				assert$13.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_message_begin: (p) => {
				assert$13.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageBegin() || 0;
			},
			wasm_on_header_field: (p, at$1, len) => {
				assert$13.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_header_value: (p, at$1, len) => {
				assert$13.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_headers_complete: (p, statusCode, upgrade$1, shouldKeepAlive) => {
				assert$13.strictEqual(currentParser.ptr, p);
				return currentParser.onHeadersComplete(statusCode, Boolean(upgrade$1), Boolean(shouldKeepAlive)) || 0;
			},
			wasm_on_body: (p, at$1, len) => {
				assert$13.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_message_complete: (p) => {
				assert$13.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageComplete() || 0;
			}
		} });
	}
	let llhttpInstance = null;
	let llhttpPromise = lazyllhttp();
	llhttpPromise.catch();
	let currentParser = null;
	let currentBufferRef = null;
	let currentBufferSize = 0;
	let currentBufferPtr = null;
	const TIMEOUT_HEADERS = 1;
	const TIMEOUT_BODY = 2;
	const TIMEOUT_IDLE = 3;
	var Parser = class {
		constructor(client, socket, { exports: exports$1 }) {
			assert$13(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
			this.llhttp = exports$1;
			this.ptr = this.llhttp.llhttp_alloc(constants$1.TYPE.RESPONSE);
			this.client = client;
			this.socket = socket;
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.statusCode = null;
			this.statusText = "";
			this.upgrade = false;
			this.headers = [];
			this.headersSize = 0;
			this.headersMaxSize = client[kMaxHeadersSize];
			this.shouldKeepAlive = false;
			this.paused = false;
			this.resume = this.resume.bind(this);
			this.bytesRead = 0;
			this.keepAlive = "";
			this.contentLength = "";
			this.connection = "";
			this.maxResponseSize = client[kMaxResponseSize];
		}
		setTimeout(value, type) {
			this.timeoutType = type;
			if (value !== this.timeoutValue) {
				timers.clearTimeout(this.timeout);
				if (value) {
					this.timeout = timers.setTimeout(onParserTimeout, value, this);
					// istanbul ignore else: only for jest
					if (this.timeout.unref) this.timeout.unref();
				} else this.timeout = null;
				this.timeoutValue = value;
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
		}
		resume() {
			if (this.socket.destroyed || !this.paused) return;
			assert$13(this.ptr != null);
			assert$13(currentParser == null);
			this.llhttp.llhttp_resume(this.ptr);
			assert$13(this.timeoutType === TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			this.paused = false;
			this.execute(this.socket.read() || EMPTY_BUF);
			this.readMore();
		}
		readMore() {
			while (!this.paused && this.ptr) {
				const chunk = this.socket.read();
				if (chunk === null) break;
				this.execute(chunk);
			}
		}
		execute(data) {
			assert$13(this.ptr != null);
			assert$13(currentParser == null);
			assert$13(!this.paused);
			const { socket, llhttp } = this;
			if (data.length > currentBufferSize) {
				if (currentBufferPtr) llhttp.free(currentBufferPtr);
				currentBufferSize = Math.ceil(data.length / 4096) * 4096;
				currentBufferPtr = llhttp.malloc(currentBufferSize);
			}
			new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
			try {
				let ret;
				try {
					currentBufferRef = data;
					currentParser = this;
					ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
				} catch (err) {
					/* istanbul ignore next: difficult to make a test case for */
					throw err;
				} finally {
					currentParser = null;
					currentBufferRef = null;
				}
				const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
				if (ret === constants$1.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));
				else if (ret === constants$1.ERROR.PAUSED) {
					this.paused = true;
					socket.unshift(data.slice(offset));
				} else if (ret !== constants$1.ERROR.OK) {
					const ptr = llhttp.llhttp_get_error_reason(this.ptr);
					let message = "";
					/* istanbul ignore else: difficult to make a test case for */
					if (ptr) {
						const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
						message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
					}
					throw new HTTPParserError(message, constants$1.ERROR[ret], data.slice(offset));
				}
			} catch (err) {
				util$12.destroy(socket, err);
			}
		}
		destroy() {
			assert$13(this.ptr != null);
			assert$13(currentParser == null);
			this.llhttp.llhttp_free(this.ptr);
			this.ptr = null;
			timers.clearTimeout(this.timeout);
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.paused = false;
		}
		onStatus(buf) {
			this.statusText = buf.toString();
		}
		onMessageBegin() {
			const { socket, client } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			const request$2 = client[kQueue$1][client[kRunningIdx]];
			if (!request$2) return -1;
		}
		onHeaderField(buf) {
			const len = this.headers.length;
			if ((len & 1) === 0) this.headers.push(buf);
			else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
			this.trackHeader(buf.length);
		}
		onHeaderValue(buf) {
			let len = this.headers.length;
			if ((len & 1) === 1) {
				this.headers.push(buf);
				len += 1;
			} else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
			const key = this.headers[len - 2];
			if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") this.keepAlive += buf.toString();
			else if (key.length === 10 && key.toString().toLowerCase() === "connection") this.connection += buf.toString();
			else if (key.length === 14 && key.toString().toLowerCase() === "content-length") this.contentLength += buf.toString();
			this.trackHeader(buf.length);
		}
		trackHeader(len) {
			this.headersSize += len;
			if (this.headersSize >= this.headersMaxSize) util$12.destroy(this.socket, new HeadersOverflowError());
		}
		onUpgrade(head) {
			const { upgrade: upgrade$1, client, socket, headers, statusCode } = this;
			assert$13(upgrade$1);
			const request$2 = client[kQueue$1][client[kRunningIdx]];
			assert$13(request$2);
			assert$13(!socket.destroyed);
			assert$13(socket === client[kSocket]);
			assert$13(!this.paused);
			assert$13(request$2.upgrade || request$2.method === "CONNECT");
			this.statusCode = null;
			this.statusText = "";
			this.shouldKeepAlive = null;
			assert$13(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			socket.unshift(head);
			socket[kParser].destroy();
			socket[kParser] = null;
			socket[kClient$1] = null;
			socket[kError$2] = null;
			socket.removeListener("error", onSocketError$1).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose$1);
			client[kSocket] = null;
			client[kQueue$1][client[kRunningIdx]++] = null;
			client.emit("disconnect", client[kUrl$3], [client], new InformationalError("upgrade"));
			try {
				request$2.onUpgrade(statusCode, headers, socket);
			} catch (err) {
				util$12.destroy(socket, err);
			}
			resume(client);
		}
		onHeadersComplete(statusCode, upgrade$1, shouldKeepAlive) {
			const { client, socket, headers, statusText } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			const request$2 = client[kQueue$1][client[kRunningIdx]];
			/* istanbul ignore next: difficult to make a test case for */
			if (!request$2) return -1;
			assert$13(!this.upgrade);
			assert$13(this.statusCode < 200);
			if (statusCode === 100) {
				util$12.destroy(socket, new SocketError$2("bad response", util$12.getSocketInfo(socket)));
				return -1;
			}
			if (upgrade$1 && !request$2.upgrade) {
				util$12.destroy(socket, new SocketError$2("bad upgrade", util$12.getSocketInfo(socket)));
				return -1;
			}
			assert$13.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
			this.statusCode = statusCode;
			this.shouldKeepAlive = shouldKeepAlive || request$2.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
			if (this.statusCode >= 200) {
				const bodyTimeout = request$2.bodyTimeout != null ? request$2.bodyTimeout : client[kBodyTimeout];
				this.setTimeout(bodyTimeout, TIMEOUT_BODY);
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			if (request$2.method === "CONNECT") {
				assert$13(client[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			if (upgrade$1) {
				assert$13(client[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			assert$13(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (this.shouldKeepAlive && client[kPipelining]) {
				const keepAliveTimeout = this.keepAlive ? util$12.parseKeepAliveTimeout(this.keepAlive) : null;
				if (keepAliveTimeout != null) {
					const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
					if (timeout <= 0) socket[kReset] = true;
					else client[kKeepAliveTimeoutValue] = timeout;
				} else client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
			} else socket[kReset] = true;
			const pause = request$2.onHeaders(statusCode, headers, this.resume, statusText) === false;
			if (request$2.aborted) return -1;
			if (request$2.method === "HEAD") return 1;
			if (statusCode < 200) return 1;
			if (socket[kBlocking]) {
				socket[kBlocking] = false;
				resume(client);
			}
			return pause ? constants$1.ERROR.PAUSED : 0;
		}
		onBody(buf) {
			const { client, socket, statusCode, maxResponseSize } = this;
			if (socket.destroyed) return -1;
			const request$2 = client[kQueue$1][client[kRunningIdx]];
			assert$13(request$2);
			assert$13.strictEqual(this.timeoutType, TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			assert$13(statusCode >= 200);
			if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
				util$12.destroy(socket, new ResponseExceededMaxSizeError());
				return -1;
			}
			this.bytesRead += buf.length;
			if (request$2.onData(buf) === false) return constants$1.ERROR.PAUSED;
		}
		onMessageComplete() {
			const { client, socket, statusCode, upgrade: upgrade$1, headers, contentLength, bytesRead, shouldKeepAlive } = this;
			if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
			if (upgrade$1) return;
			const request$2 = client[kQueue$1][client[kRunningIdx]];
			assert$13(request$2);
			assert$13(statusCode >= 100);
			this.statusCode = null;
			this.statusText = "";
			this.bytesRead = 0;
			this.contentLength = "";
			this.keepAlive = "";
			this.connection = "";
			assert$13(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (statusCode < 200) return;
			/* istanbul ignore next: should be handled by llhttp? */
			if (request$2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
				util$12.destroy(socket, new ResponseContentLengthMismatchError());
				return -1;
			}
			request$2.onComplete(headers);
			client[kQueue$1][client[kRunningIdx]++] = null;
			if (socket[kWriting]) {
				assert$13.strictEqual(client[kRunning$3], 0);
				util$12.destroy(socket, new InformationalError("reset"));
				return constants$1.ERROR.PAUSED;
			} else if (!shouldKeepAlive) {
				util$12.destroy(socket, new InformationalError("reset"));
				return constants$1.ERROR.PAUSED;
			} else if (socket[kReset] && client[kRunning$3] === 0) {
				util$12.destroy(socket, new InformationalError("reset"));
				return constants$1.ERROR.PAUSED;
			} else if (client[kPipelining] === 1) setImmediate(resume, client);
			else resume(client);
		}
	};
	function onParserTimeout(parser) {
		const { socket, timeoutType, client } = parser;
		/* istanbul ignore else */
		if (timeoutType === TIMEOUT_HEADERS) {
			if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning$3] > 1) {
				assert$13(!parser.paused, "cannot be paused while waiting for headers");
				util$12.destroy(socket, new HeadersTimeoutError());
			}
		} else if (timeoutType === TIMEOUT_BODY) {
			if (!parser.paused) util$12.destroy(socket, new BodyTimeoutError());
		} else if (timeoutType === TIMEOUT_IDLE) {
			assert$13(client[kRunning$3] === 0 && client[kKeepAliveTimeoutValue]);
			util$12.destroy(socket, new InformationalError("socket idle timeout"));
		}
	}
	function onSocketReadable() {
		const { [kParser]: parser } = this;
		if (parser) parser.readMore();
	}
	function onSocketError$1(err) {
		const { [kClient$1]: client, [kParser]: parser } = this;
		assert$13(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		if (client[kHTTPConnVersion] !== "h2") {
			if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		this[kError$2] = err;
		onError(this[kClient$1], err);
	}
	function onError(client, err) {
		if (client[kRunning$3] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
			assert$13(client[kPendingIdx] === client[kRunningIdx]);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$1 = 0; i$1 < requests.length; i$1++) {
				const request$2 = requests[i$1];
				errorRequest(client, request$2, err);
			}
			assert$13(client[kSize$4] === 0);
		}
	}
	function onSocketEnd() {
		const { [kParser]: parser, [kClient$1]: client } = this;
		if (client[kHTTPConnVersion] !== "h2") {
			if (parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		util$12.destroy(this, new SocketError$2("other side closed", util$12.getSocketInfo(this)));
	}
	function onSocketClose$1() {
		const { [kClient$1]: client, [kParser]: parser } = this;
		if (client[kHTTPConnVersion] === "h1" && parser) {
			if (!this[kError$2] && parser.statusCode && !parser.shouldKeepAlive) parser.onMessageComplete();
			this[kParser].destroy();
			this[kParser] = null;
		}
		const err = this[kError$2] || new SocketError$2("closed", util$12.getSocketInfo(this));
		client[kSocket] = null;
		if (client.destroyed) {
			assert$13(client[kPending$2] === 0);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$1 = 0; i$1 < requests.length; i$1++) {
				const request$2 = requests[i$1];
				errorRequest(client, request$2, err);
			}
		} else if (client[kRunning$3] > 0 && err.code !== "UND_ERR_INFO") {
			const request$2 = client[kQueue$1][client[kRunningIdx]];
			client[kQueue$1][client[kRunningIdx]++] = null;
			errorRequest(client, request$2, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$13(client[kRunning$3] === 0);
		client.emit("disconnect", client[kUrl$3], [client], err);
		resume(client);
	}
	async function connect$1(client) {
		assert$13(!client[kConnecting]);
		assert$13(!client[kSocket]);
		let { host, hostname, protocol, port } = client[kUrl$3];
		if (hostname[0] === "[") {
			const idx = hostname.indexOf("]");
			assert$13(idx !== -1);
			const ip = hostname.substring(1, idx);
			assert$13(net.isIP(ip));
			hostname = ip;
		}
		client[kConnecting] = true;
		if (channels$2.beforeConnect.hasSubscribers) channels$2.beforeConnect.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port,
				servername: client[kServerName],
				localAddress: client[kLocalAddress]
			},
			connector: client[kConnector]
		});
		try {
			const socket = await new Promise((resolve, reject) => {
				client[kConnector]({
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				}, (err, socket$1) => {
					if (err) reject(err);
					else resolve(socket$1);
				});
			});
			if (client.destroyed) {
				util$12.destroy(socket.on("error", () => {}), new ClientDestroyedError());
				return;
			}
			client[kConnecting] = false;
			assert$13(socket);
			const isH2 = socket.alpnProtocol === "h2";
			if (isH2) {
				if (!h2ExperimentalWarned) {
					h2ExperimentalWarned = true;
					process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" });
				}
				const session = http2.connect(client[kUrl$3], {
					createConnection: () => socket,
					peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
				});
				client[kHTTPConnVersion] = "h2";
				session[kClient$1] = client;
				session[kSocket] = socket;
				session.on("error", onHttp2SessionError);
				session.on("frameError", onHttp2FrameError);
				session.on("end", onHttp2SessionEnd);
				session.on("goaway", onHTTP2GoAway);
				session.on("close", onSocketClose$1);
				session.unref();
				client[kHTTP2Session] = session;
				socket[kHTTP2Session] = session;
			} else {
				if (!llhttpInstance) {
					llhttpInstance = await llhttpPromise;
					llhttpPromise = null;
				}
				socket[kNoRef] = false;
				socket[kWriting] = false;
				socket[kReset] = false;
				socket[kBlocking] = false;
				socket[kParser] = new Parser(client, socket, llhttpInstance);
			}
			socket[kCounter] = 0;
			socket[kMaxRequests] = client[kMaxRequests];
			socket[kClient$1] = client;
			socket[kError$2] = null;
			socket.on("error", onSocketError$1).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose$1);
			client[kSocket] = socket;
			if (channels$2.connected.hasSubscribers) channels$2.connected.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				socket
			});
			client.emit("connect", client[kUrl$3], [client]);
		} catch (err) {
			if (client.destroyed) return;
			client[kConnecting] = false;
			if (channels$2.connectError.hasSubscribers) channels$2.connectError.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				error: err
			});
			if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
				assert$13(client[kRunning$3] === 0);
				while (client[kPending$2] > 0 && client[kQueue$1][client[kPendingIdx]].servername === client[kServerName]) {
					const request$2 = client[kQueue$1][client[kPendingIdx]++];
					errorRequest(client, request$2, err);
				}
			} else onError(client, err);
			client.emit("connectionError", client[kUrl$3], [client], err);
		}
		resume(client);
	}
	function emitDrain(client) {
		client[kNeedDrain$3] = 0;
		client.emit("drain", client[kUrl$3], [client]);
	}
	function resume(client, sync$3) {
		if (client[kResuming] === 2) return;
		client[kResuming] = 2;
		_resume(client, sync$3);
		client[kResuming] = 0;
		if (client[kRunningIdx] > 256) {
			client[kQueue$1].splice(0, client[kRunningIdx]);
			client[kPendingIdx] -= client[kRunningIdx];
			client[kRunningIdx] = 0;
		}
	}
	function _resume(client, sync$3) {
		while (true) {
			if (client.destroyed) {
				assert$13(client[kPending$2] === 0);
				return;
			}
			if (client[kClosedResolve$1] && !client[kSize$4]) {
				client[kClosedResolve$1]();
				client[kClosedResolve$1] = null;
				return;
			}
			const socket = client[kSocket];
			if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
				if (client[kSize$4] === 0) {
					if (!socket[kNoRef] && socket.unref) {
						socket.unref();
						socket[kNoRef] = true;
					}
				} else if (socket[kNoRef] && socket.ref) {
					socket.ref();
					socket[kNoRef] = false;
				}
				if (client[kSize$4] === 0) {
					if (socket[kParser].timeoutType !== TIMEOUT_IDLE) socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
				} else if (client[kRunning$3] > 0 && socket[kParser].statusCode < 200) {
					if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
						const request$3 = client[kQueue$1][client[kRunningIdx]];
						const headersTimeout = request$3.headersTimeout != null ? request$3.headersTimeout : client[kHeadersTimeout];
						socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
					}
				}
			}
			if (client[kBusy$1]) client[kNeedDrain$3] = 2;
			else if (client[kNeedDrain$3] === 2) {
				if (sync$3) {
					client[kNeedDrain$3] = 1;
					process.nextTick(emitDrain, client);
				} else emitDrain(client);
				continue;
			}
			if (client[kPending$2] === 0) return;
			if (client[kRunning$3] >= (client[kPipelining] || 1)) return;
			const request$2 = client[kQueue$1][client[kPendingIdx]];
			if (client[kUrl$3].protocol === "https:" && client[kServerName] !== request$2.servername) {
				if (client[kRunning$3] > 0) return;
				client[kServerName] = request$2.servername;
				if (socket && socket.servername !== request$2.servername) {
					util$12.destroy(socket, new InformationalError("servername changed"));
					return;
				}
			}
			if (client[kConnecting]) return;
			if (!socket && !client[kHTTP2Session]) {
				connect$1(client);
				return;
			}
			if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) return;
			if (client[kRunning$3] > 0 && !request$2.idempotent) return;
			if (client[kRunning$3] > 0 && (request$2.upgrade || request$2.method === "CONNECT")) return;
			if (client[kRunning$3] > 0 && util$12.bodyLength(request$2.body) !== 0 && (util$12.isStream(request$2.body) || util$12.isAsyncIterable(request$2.body))) return;
			if (!request$2.aborted && write(client, request$2)) client[kPendingIdx]++;
			else client[kQueue$1].splice(client[kPendingIdx], 1);
		}
	}
	function shouldSendContentLength(method) {
		return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
	}
	function write(client, request$2) {
		if (client[kHTTPConnVersion] === "h2") {
			writeH2(client, client[kHTTP2Session], request$2);
			return;
		}
		const { body, method, path: path$9, host, upgrade: upgrade$1, headers, blocking, reset: reset$1 } = request$2;
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		const bodyLength$1 = util$12.bodyLength(body);
		let contentLength = bodyLength$1;
		if (contentLength === null) contentLength = request$2.contentLength;
		if (contentLength === 0 && !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$2.contentLength !== null && request$2.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$2, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		const socket = client[kSocket];
		try {
			request$2.onConnect((err) => {
				if (request$2.aborted || request$2.completed) return;
				errorRequest(client, request$2, err || new RequestAbortedError$8());
				util$12.destroy(socket, new InformationalError("aborted"));
			});
		} catch (err) {
			errorRequest(client, request$2, err);
		}
		if (request$2.aborted) return false;
		if (method === "HEAD") socket[kReset] = true;
		if (upgrade$1 || method === "CONNECT") socket[kReset] = true;
		if (reset$1 != null) socket[kReset] = reset$1;
		if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) socket[kReset] = true;
		if (blocking) socket[kBlocking] = true;
		let header = `${method} ${path$9} HTTP/1.1\r\n`;
		if (typeof host === "string") header += `host: ${host}\r\n`;
		else header += client[kHostHeader];
		if (upgrade$1) header += `connection: upgrade\r\nupgrade: ${upgrade$1}\r\n`;
		else if (client[kPipelining] && !socket[kReset]) header += "connection: keep-alive\r\n";
		else header += "connection: close\r\n";
		if (headers) header += headers;
		if (channels$2.sendHeaders.hasSubscribers) channels$2.sendHeaders.publish({
			request: request$2,
			headers: header,
			socket
		});
		/* istanbul ignore else: assertion */
		if (!body || bodyLength$1 === 0) {
			if (contentLength === 0) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else {
				assert$13(contentLength === null, "no body must not have content length");
				socket.write(`${header}\r\n`, "latin1");
			}
			request$2.onRequestSent();
		} else if (util$12.isBuffer(body)) {
			assert$13(contentLength === body.byteLength, "buffer body must have content length");
			socket.cork();
			socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			socket.write(body);
			socket.uncork();
			request$2.onBodySent(body);
			request$2.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
		} else if (util$12.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
			body: body.stream(),
			client,
			request: request$2,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else writeBlob({
			body,
			client,
			request: request$2,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$12.isStream(body)) writeStream({
			body,
			client,
			request: request$2,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$12.isIterable(body)) writeIterable({
			body,
			client,
			request: request$2,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else assert$13(false);
		return true;
	}
	function writeH2(client, session, request$2) {
		const { body, method, path: path$9, host, upgrade: upgrade$1, expectContinue, signal, headers: reqHeaders } = request$2;
		let headers;
		if (typeof reqHeaders === "string") headers = Request$5[kHTTP2CopyHeaders](reqHeaders.trim());
		else headers = reqHeaders;
		if (upgrade$1) {
			errorRequest(client, request$2, /* @__PURE__ */ new Error("Upgrade not supported for H2"));
			return false;
		}
		try {
			request$2.onConnect((err) => {
				if (request$2.aborted || request$2.completed) return;
				errorRequest(client, request$2, err || new RequestAbortedError$8());
			});
		} catch (err) {
			errorRequest(client, request$2, err);
		}
		if (request$2.aborted) return false;
		/** @type {import('node:http2').ClientHttp2Stream} */
		let stream$2;
		const h2State = client[kHTTP2SessionState];
		headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
		headers[HTTP2_HEADER_METHOD] = method;
		if (method === "CONNECT") {
			session.ref();
			stream$2 = session.request(headers, {
				endStream: false,
				signal
			});
			if (stream$2.id && !stream$2.pending) {
				request$2.onUpgrade(null, null, stream$2);
				++h2State.openStreams;
			} else stream$2.once("ready", () => {
				request$2.onUpgrade(null, null, stream$2);
				++h2State.openStreams;
			});
			stream$2.once("close", () => {
				h2State.openStreams -= 1;
				if (h2State.openStreams === 0) session.unref();
			});
			return true;
		}
		headers[HTTP2_HEADER_PATH] = path$9;
		headers[HTTP2_HEADER_SCHEME] = "https";
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		let contentLength = util$12.bodyLength(body);
		if (contentLength == null) contentLength = request$2.contentLength;
		if (contentLength === 0 || !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$2.contentLength != null && request$2.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$2, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		if (contentLength != null) {
			assert$13(body, "no body must not have content length");
			headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
		}
		session.ref();
		const shouldEndStream = method === "GET" || method === "HEAD";
		if (expectContinue) {
			headers[HTTP2_HEADER_EXPECT] = "100-continue";
			stream$2 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			stream$2.once("continue", writeBodyH2);
		} else {
			stream$2 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			writeBodyH2();
		}
		++h2State.openStreams;
		stream$2.once("response", (headers$1) => {
			const { [HTTP2_HEADER_STATUS]: statusCode,...realHeaders } = headers$1;
			if (request$2.onHeaders(Number(statusCode), realHeaders, stream$2.resume.bind(stream$2), "") === false) stream$2.pause();
		});
		stream$2.once("end", () => {
			request$2.onComplete([]);
		});
		stream$2.on("data", (chunk) => {
			if (request$2.onData(chunk) === false) stream$2.pause();
		});
		stream$2.once("close", () => {
			h2State.openStreams -= 1;
			if (h2State.openStreams === 0) session.unref();
		});
		stream$2.once("error", function(err) {
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$12.destroy(stream$2, err);
			}
		});
		stream$2.once("frameError", (type, code) => {
			const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
			errorRequest(client, request$2, err);
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$12.destroy(stream$2, err);
			}
		});
		return true;
		function writeBodyH2() {
			/* istanbul ignore else: assertion */
			if (!body) request$2.onRequestSent();
			else if (util$12.isBuffer(body)) {
				assert$13(contentLength === body.byteLength, "buffer body must have content length");
				stream$2.cork();
				stream$2.write(body);
				stream$2.uncork();
				stream$2.end();
				request$2.onBodySent(body);
				request$2.onRequestSent();
			} else if (util$12.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
				client,
				request: request$2,
				contentLength,
				h2stream: stream$2,
				expectsPayload,
				body: body.stream(),
				socket: client[kSocket],
				header: ""
			});
			else writeBlob({
				body,
				client,
				request: request$2,
				contentLength,
				expectsPayload,
				h2stream: stream$2,
				header: "",
				socket: client[kSocket]
			});
			else if (util$12.isStream(body)) writeStream({
				body,
				client,
				request: request$2,
				contentLength,
				expectsPayload,
				socket: client[kSocket],
				h2stream: stream$2,
				header: ""
			});
			else if (util$12.isIterable(body)) writeIterable({
				body,
				client,
				request: request$2,
				contentLength,
				expectsPayload,
				header: "",
				h2stream: stream$2,
				socket: client[kSocket]
			});
			else assert$13(false);
		}
	}
	function writeStream({ h2stream, body, client, request: request$2, socket, contentLength, header, expectsPayload }) {
		assert$13(contentLength !== 0 || client[kRunning$3] === 0, "stream body cannot be pipelined");
		if (client[kHTTPConnVersion] === "h2") {
			const pipe = pipeline$2(body, h2stream, (err) => {
				if (err) {
					util$12.destroy(body, err);
					util$12.destroy(h2stream, err);
				} else request$2.onRequestSent();
			});
			pipe.on("data", onPipeData);
			pipe.once("end", () => {
				pipe.removeListener("data", onPipeData);
				util$12.destroy(pipe);
			});
			function onPipeData(chunk) {
				request$2.onBodySent(chunk);
			}
			return;
		}
		let finished$2 = false;
		const writer = new AsyncWriter({
			socket,
			request: request$2,
			contentLength,
			client,
			expectsPayload,
			header
		});
		const onData = function(chunk) {
			if (finished$2) return;
			try {
				if (!writer.write(chunk) && this.pause) this.pause();
			} catch (err) {
				util$12.destroy(this, err);
			}
		};
		const onDrain = function() {
			if (finished$2) return;
			if (body.resume) body.resume();
		};
		const onAbort = function() {
			if (finished$2) return;
			const err = new RequestAbortedError$8();
			queueMicrotask(() => onFinished(err));
		};
		const onFinished = function(err) {
			if (finished$2) return;
			finished$2 = true;
			assert$13(socket.destroyed || socket[kWriting] && client[kRunning$3] <= 1);
			socket.off("drain", onDrain).off("error", onFinished);
			body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
			if (!err) try {
				writer.end();
			} catch (er) {
				err = er;
			}
			writer.destroy(err);
			if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) util$12.destroy(body, err);
			else util$12.destroy(body);
		};
		body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
		if (body.resume) body.resume();
		socket.on("drain", onDrain).on("error", onFinished);
	}
	async function writeBlob({ h2stream, body, client, request: request$2, socket, contentLength, header, expectsPayload }) {
		assert$13(contentLength === body.size, "blob body must have content length");
		const isH2 = client[kHTTPConnVersion] === "h2";
		try {
			if (contentLength != null && contentLength !== body.size) throw new RequestContentLengthMismatchError();
			const buffer = Buffer.from(await body.arrayBuffer());
			if (isH2) {
				h2stream.cork();
				h2stream.write(buffer);
				h2stream.uncork();
			} else {
				socket.cork();
				socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
				socket.write(buffer);
				socket.uncork();
			}
			request$2.onBodySent(buffer);
			request$2.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
			resume(client);
		} catch (err) {
			util$12.destroy(isH2 ? h2stream : socket, err);
		}
	}
	async function writeIterable({ h2stream, body, client, request: request$2, socket, contentLength, header, expectsPayload }) {
		assert$13(contentLength !== 0 || client[kRunning$3] === 0, "iterator body cannot be pipelined");
		let callback = null;
		function onDrain() {
			if (callback) {
				const cb = callback;
				callback = null;
				cb();
			}
		}
		const waitForDrain = () => new Promise((resolve, reject) => {
			assert$13(callback === null);
			if (socket[kError$2]) reject(socket[kError$2]);
			else callback = resolve;
		});
		if (client[kHTTPConnVersion] === "h2") {
			h2stream.on("close", onDrain).on("drain", onDrain);
			try {
				for await (const chunk of body) {
					if (socket[kError$2]) throw socket[kError$2];
					const res = h2stream.write(chunk);
					request$2.onBodySent(chunk);
					if (!res) await waitForDrain();
				}
			} catch (err) {
				h2stream.destroy(err);
			} finally {
				request$2.onRequestSent();
				h2stream.end();
				h2stream.off("close", onDrain).off("drain", onDrain);
			}
			return;
		}
		socket.on("close", onDrain).on("drain", onDrain);
		const writer = new AsyncWriter({
			socket,
			request: request$2,
			contentLength,
			client,
			expectsPayload,
			header
		});
		try {
			for await (const chunk of body) {
				if (socket[kError$2]) throw socket[kError$2];
				if (!writer.write(chunk)) await waitForDrain();
			}
			writer.end();
		} catch (err) {
			writer.destroy(err);
		} finally {
			socket.off("close", onDrain).off("drain", onDrain);
		}
	}
	var AsyncWriter = class {
		constructor({ socket, request: request$2, contentLength, client, expectsPayload, header }) {
			this.socket = socket;
			this.request = request$2;
			this.contentLength = contentLength;
			this.client = client;
			this.bytesWritten = 0;
			this.expectsPayload = expectsPayload;
			this.header = header;
			socket[kWriting] = true;
		}
		write(chunk) {
			const { socket, request: request$2, contentLength, client, bytesWritten, expectsPayload, header } = this;
			if (socket[kError$2]) throw socket[kError$2];
			if (socket.destroyed) return false;
			const len = Buffer.byteLength(chunk);
			if (!len) return true;
			if (contentLength !== null && bytesWritten + len > contentLength) {
				if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
				process.emitWarning(new RequestContentLengthMismatchError());
			}
			socket.cork();
			if (bytesWritten === 0) {
				if (!expectsPayload) socket[kReset] = true;
				if (contentLength === null) socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
				else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			}
			if (contentLength === null) socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
			this.bytesWritten += len;
			const ret = socket.write(chunk);
			socket.uncork();
			request$2.onBodySent(chunk);
			if (!ret) {
				if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
					// istanbul ignore else: only for jest
					if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
				}
			}
			return ret;
		}
		end() {
			const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request$2 } = this;
			request$2.onRequestSent();
			socket[kWriting] = false;
			if (socket[kError$2]) throw socket[kError$2];
			if (socket.destroyed) return;
			if (bytesWritten === 0) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else socket.write(`${header}\r\n`, "latin1");
			else if (contentLength === null) socket.write("\r\n0\r\n\r\n", "latin1");
			if (contentLength !== null && bytesWritten !== contentLength) if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
			else process.emitWarning(new RequestContentLengthMismatchError());
			if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
				// istanbul ignore else: only for jest
				if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
			}
			resume(client);
		}
		destroy(err) {
			const { socket, client } = this;
			socket[kWriting] = false;
			if (err) {
				assert$13(client[kRunning$3] <= 1, "pipeline should only contain this request");
				util$12.destroy(socket, err);
			}
		}
	};
	function errorRequest(client, request$2, err) {
		try {
			request$2.onError(err);
			assert$13(request$2.aborted);
		} catch (err$1) {
			client.emit("error", err$1);
		}
	}
	module.exports = Client$4;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/node/fixed-queue.js"(exports, module) {
	const kSize$3 = 2048;
	const kMask = kSize$3 - 1;
	var FixedCircularBuffer = class {
		constructor() {
			this.bottom = 0;
			this.top = 0;
			this.list = new Array(kSize$3);
			this.next = null;
		}
		isEmpty() {
			return this.top === this.bottom;
		}
		isFull() {
			return (this.top + 1 & kMask) === this.bottom;
		}
		push(data) {
			this.list[this.top] = data;
			this.top = this.top + 1 & kMask;
		}
		shift() {
			const nextItem = this.list[this.bottom];
			if (nextItem === void 0) return null;
			this.list[this.bottom] = void 0;
			this.bottom = this.bottom + 1 & kMask;
			return nextItem;
		}
	};
	module.exports = class FixedQueue$1 {
		constructor() {
			this.head = this.tail = new FixedCircularBuffer();
		}
		isEmpty() {
			return this.head.isEmpty();
		}
		push(data) {
			if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
			this.head.push(data);
		}
		shift() {
			const tail = this.tail;
			const next = tail.shift();
			if (tail.isEmpty() && tail.next !== null) this.tail = tail.next;
			return next;
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/pool-stats.js"(exports, module) {
	const { kFree: kFree$1, kConnected: kConnected$4, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$2 } = require_symbols$4();
	const kPool = Symbol("pool");
	var PoolStats$1 = class {
		constructor(pool) {
			this[kPool] = pool;
		}
		get connected() {
			return this[kPool][kConnected$4];
		}
		get free() {
			return this[kPool][kFree$1];
		}
		get pending() {
			return this[kPool][kPending$1];
		}
		get queued() {
			return this[kPool][kQueued$1];
		}
		get running() {
			return this[kPool][kRunning$2];
		}
		get size() {
			return this[kPool][kSize$2];
		}
	};
	module.exports = PoolStats$1;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/pool-base.js"(exports, module) {
	const DispatcherBase$2 = require_dispatcher_base();
	const FixedQueue = require_fixed_queue();
	const { kConnected: kConnected$3, kSize: kSize$1, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$2, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1 } = require_symbols$4();
	const PoolStats = require_pool_stats();
	const kClients$4 = Symbol("clients");
	const kNeedDrain$2 = Symbol("needDrain");
	const kQueue = Symbol("queue");
	const kClosedResolve = Symbol("closed resolve");
	const kOnDrain$1 = Symbol("onDrain");
	const kOnConnect$1 = Symbol("onConnect");
	const kOnDisconnect$1 = Symbol("onDisconnect");
	const kOnConnectionError$1 = Symbol("onConnectionError");
	const kGetDispatcher$2 = Symbol("get dispatcher");
	const kAddClient$2 = Symbol("add client");
	const kRemoveClient$1 = Symbol("remove client");
	const kStats = Symbol("stats");
	var PoolBase$2 = class extends DispatcherBase$2 {
		constructor() {
			super();
			this[kQueue] = new FixedQueue();
			this[kClients$4] = [];
			this[kQueued] = 0;
			const pool = this;
			this[kOnDrain$1] = function onDrain(origin, targets) {
				const queue = pool[kQueue];
				let needDrain = false;
				while (!needDrain) {
					const item = queue.shift();
					if (!item) break;
					pool[kQueued]--;
					needDrain = !this.dispatch(item.opts, item.handler);
				}
				this[kNeedDrain$2] = needDrain;
				if (!this[kNeedDrain$2] && pool[kNeedDrain$2]) {
					pool[kNeedDrain$2] = false;
					pool.emit("drain", origin, [pool, ...targets]);
				}
				if (pool[kClosedResolve] && queue.isEmpty()) Promise.all(pool[kClients$4].map((c$1) => c$1.close())).then(pool[kClosedResolve]);
			};
			this[kOnConnect$1] = (origin, targets) => {
				pool.emit("connect", origin, [pool, ...targets]);
			};
			this[kOnDisconnect$1] = (origin, targets, err) => {
				pool.emit("disconnect", origin, [pool, ...targets], err);
			};
			this[kOnConnectionError$1] = (origin, targets, err) => {
				pool.emit("connectionError", origin, [pool, ...targets], err);
			};
			this[kStats] = new PoolStats(this);
		}
		get [kBusy]() {
			return this[kNeedDrain$2];
		}
		get [kConnected$3]() {
			return this[kClients$4].filter((client) => client[kConnected$3]).length;
		}
		get [kFree]() {
			return this[kClients$4].filter((client) => client[kConnected$3] && !client[kNeedDrain$2]).length;
		}
		get [kPending]() {
			let ret = this[kQueued];
			for (const { [kPending]: pending } of this[kClients$4]) ret += pending;
			return ret;
		}
		get [kRunning$1]() {
			let ret = 0;
			for (const { [kRunning$1]: running } of this[kClients$4]) ret += running;
			return ret;
		}
		get [kSize$1]() {
			let ret = this[kQueued];
			for (const { [kSize$1]: size } of this[kClients$4]) ret += size;
			return ret;
		}
		get stats() {
			return this[kStats];
		}
		async [kClose$4]() {
			if (this[kQueue].isEmpty()) return Promise.all(this[kClients$4].map((c$1) => c$1.close()));
			else return new Promise((resolve) => {
				this[kClosedResolve] = resolve;
			});
		}
		async [kDestroy$2](err) {
			while (true) {
				const item = this[kQueue].shift();
				if (!item) break;
				item.handler.onError(err);
			}
			return Promise.all(this[kClients$4].map((c$1) => c$1.destroy(err)));
		}
		[kDispatch$1](opts, handler$1) {
			const dispatcher = this[kGetDispatcher$2]();
			if (!dispatcher) {
				this[kNeedDrain$2] = true;
				this[kQueue].push({
					opts,
					handler: handler$1
				});
				this[kQueued]++;
			} else if (!dispatcher.dispatch(opts, handler$1)) {
				dispatcher[kNeedDrain$2] = true;
				this[kNeedDrain$2] = !this[kGetDispatcher$2]();
			}
			return !this[kNeedDrain$2];
		}
		[kAddClient$2](client) {
			client.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]);
			this[kClients$4].push(client);
			if (this[kNeedDrain$2]) process.nextTick(() => {
				if (this[kNeedDrain$2]) this[kOnDrain$1](client[kUrl$2], [this, client]);
			});
			return this;
		}
		[kRemoveClient$1](client) {
			client.close(() => {
				const idx = this[kClients$4].indexOf(client);
				if (idx !== -1) this[kClients$4].splice(idx, 1);
			});
			this[kNeedDrain$2] = this[kClients$4].some((dispatcher) => !dispatcher[kNeedDrain$2] && dispatcher.closed !== true && dispatcher.destroyed !== true);
		}
	};
	module.exports = {
		PoolBase: PoolBase$2,
		kClients: kClients$4,
		kNeedDrain: kNeedDrain$2,
		kAddClient: kAddClient$2,
		kRemoveClient: kRemoveClient$1,
		kGetDispatcher: kGetDispatcher$2
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/pool.js
var require_pool = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/pool.js"(exports, module) {
	const { PoolBase: PoolBase$1, kClients: kClients$3, kNeedDrain: kNeedDrain$1, kAddClient: kAddClient$1, kGetDispatcher: kGetDispatcher$1 } = require_pool_base();
	const Client$3 = require_client();
	const { InvalidArgumentError: InvalidArgumentError$15 } = require_errors();
	const util$11 = require_util$6();
	const { kUrl: kUrl$1, kInterceptors: kInterceptors$3 } = require_symbols$4();
	const buildConnector$2 = require_connect();
	const kOptions$3 = Symbol("options");
	const kConnections = Symbol("connections");
	const kFactory$3 = Symbol("factory");
	function defaultFactory$3(origin, opts) {
		return new Client$3(origin, opts);
	}
	var Pool$5 = class extends PoolBase$1 {
		constructor(origin, { connections, factory = defaultFactory$3, connect: connect$2, connectTimeout, tls: tls$2, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2,...options } = {}) {
			super();
			if (connections != null && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError$15("invalid connections");
			if (typeof factory !== "function") throw new InvalidArgumentError$15("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$15("connect must be a function or an object");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$2({
				...tls$2,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$11.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$3] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
			this[kConnections] = connections || null;
			this[kUrl$1] = util$11.parseOrigin(origin);
			this[kOptions$3] = {
				...util$11.deepClone(options),
				connect: connect$2,
				allowH2
			};
			this[kOptions$3].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kFactory$3] = factory;
		}
		[kGetDispatcher$1]() {
			let dispatcher = this[kClients$3].find((dispatcher$1) => !dispatcher$1[kNeedDrain$1]);
			if (dispatcher) return dispatcher;
			if (!this[kConnections] || this[kClients$3].length < this[kConnections]) {
				dispatcher = this[kFactory$3](this[kUrl$1], this[kOptions$3]);
				this[kAddClient$1](dispatcher);
			}
			return dispatcher;
		}
	};
	module.exports = Pool$5;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/balanced-pool.js"(exports, module) {
	const { BalancedPoolMissingUpstreamError, InvalidArgumentError: InvalidArgumentError$14 } = require_errors();
	const { PoolBase, kClients: kClients$2, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = require_pool_base();
	const Pool$4 = require_pool();
	const { kUrl, kInterceptors: kInterceptors$2 } = require_symbols$4();
	const { parseOrigin } = require_util$6();
	const kFactory$2 = Symbol("factory");
	const kOptions$2 = Symbol("options");
	const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
	const kCurrentWeight = Symbol("kCurrentWeight");
	const kIndex = Symbol("kIndex");
	const kWeight = Symbol("kWeight");
	const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
	const kErrorPenalty = Symbol("kErrorPenalty");
	function getGreatestCommonDivisor(a$1, b) {
		if (b === 0) return a$1;
		return getGreatestCommonDivisor(b, a$1 % b);
	}
	function defaultFactory$2(origin, opts) {
		return new Pool$4(origin, opts);
	}
	var BalancedPool$1 = class extends PoolBase {
		constructor(upstreams = [], { factory = defaultFactory$2,...opts } = {}) {
			super();
			this[kOptions$2] = opts;
			this[kIndex] = -1;
			this[kCurrentWeight] = 0;
			this[kMaxWeightPerServer] = this[kOptions$2].maxWeightPerServer || 100;
			this[kErrorPenalty] = this[kOptions$2].errorPenalty || 15;
			if (!Array.isArray(upstreams)) upstreams = [upstreams];
			if (typeof factory !== "function") throw new InvalidArgumentError$14("factory must be a function.");
			this[kInterceptors$2] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
			this[kFactory$2] = factory;
			for (const upstream of upstreams) this.addUpstream(upstream);
			this._updateBalancedPoolStats();
		}
		addUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			if (this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true)) return this;
			const pool = this[kFactory$2](upstreamOrigin, Object.assign({}, this[kOptions$2]));
			this[kAddClient](pool);
			pool.on("connect", () => {
				pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
			});
			pool.on("connectionError", () => {
				pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
				this._updateBalancedPoolStats();
			});
			pool.on("disconnect", (...args) => {
				const err = args[2];
				if (err && err.code === "UND_ERR_SOCKET") {
					pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
					this._updateBalancedPoolStats();
				}
			});
			for (const client of this[kClients$2]) client[kWeight] = this[kMaxWeightPerServer];
			this._updateBalancedPoolStats();
			return this;
		}
		_updateBalancedPoolStats() {
			this[kGreatestCommonDivisor] = this[kClients$2].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
		}
		removeUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			const pool = this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true);
			if (pool) this[kRemoveClient](pool);
			return this;
		}
		get upstreams() {
			return this[kClients$2].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
		}
		[kGetDispatcher]() {
			if (this[kClients$2].length === 0) throw new BalancedPoolMissingUpstreamError();
			const dispatcher = this[kClients$2].find((dispatcher$1) => !dispatcher$1[kNeedDrain] && dispatcher$1.closed !== true && dispatcher$1.destroyed !== true);
			if (!dispatcher) return;
			const allClientsBusy = this[kClients$2].map((pool) => pool[kNeedDrain]).reduce((a$1, b) => a$1 && b, true);
			if (allClientsBusy) return;
			let counter = 0;
			let maxWeightIndex = this[kClients$2].findIndex((pool) => !pool[kNeedDrain]);
			while (counter++ < this[kClients$2].length) {
				this[kIndex] = (this[kIndex] + 1) % this[kClients$2].length;
				const pool = this[kClients$2][this[kIndex]];
				if (pool[kWeight] > this[kClients$2][maxWeightIndex][kWeight] && !pool[kNeedDrain]) maxWeightIndex = this[kIndex];
				if (this[kIndex] === 0) {
					this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
					if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
				}
				if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
			}
			this[kCurrentWeight] = this[kClients$2][maxWeightIndex][kWeight];
			this[kIndex] = maxWeightIndex;
			return this[kClients$2][maxWeightIndex];
		}
	};
	module.exports = BalancedPool$1;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/compat/dispatcher-weakref.js"(exports, module) {
	/* istanbul ignore file: only for Node 12 */
	const { kConnected: kConnected$2, kSize } = require_symbols$4();
	var CompatWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value[kConnected$2] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
		}
	};
	var CompatFinalizer = class {
		constructor(finalizer) {
			this.finalizer = finalizer;
		}
		register(dispatcher, key) {
			if (dispatcher.on) dispatcher.on("disconnect", () => {
				if (dispatcher[kConnected$2] === 0 && dispatcher[kSize] === 0) this.finalizer(key);
			});
		}
	};
	module.exports = function() {
		if (process.env.NODE_V8_COVERAGE) return {
			WeakRef: CompatWeakRef,
			FinalizationRegistry: CompatFinalizer
		};
		return {
			WeakRef: global.WeakRef || CompatWeakRef,
			FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
		};
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/agent.js
var require_agent$1 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/agent.js"(exports, module) {
	const { InvalidArgumentError: InvalidArgumentError$13 } = require_errors();
	const { kClients: kClients$1, kRunning, kClose: kClose$3, kDestroy: kDestroy$1, kDispatch, kInterceptors: kInterceptors$1 } = require_symbols$4();
	const DispatcherBase$1 = require_dispatcher_base();
	const Pool$3 = require_pool();
	const Client$2 = require_client();
	const util$10 = require_util$6();
	const createRedirectInterceptor$1 = require_redirectInterceptor();
	const { WeakRef: WeakRef$1, FinalizationRegistry: FinalizationRegistry$1 } = require_dispatcher_weakref()();
	const kOnConnect = Symbol("onConnect");
	const kOnDisconnect = Symbol("onDisconnect");
	const kOnConnectionError = Symbol("onConnectionError");
	const kMaxRedirections = Symbol("maxRedirections");
	const kOnDrain = Symbol("onDrain");
	const kFactory$1 = Symbol("factory");
	const kFinalizer = Symbol("finalizer");
	const kOptions$1 = Symbol("options");
	function defaultFactory$1(origin, opts) {
		return opts && opts.connections === 1 ? new Client$2(origin, opts) : new Pool$3(origin, opts);
	}
	var Agent$5 = class extends DispatcherBase$1 {
		constructor({ factory = defaultFactory$1, maxRedirections = 0, connect: connect$2,...options } = {}) {
			super();
			if (typeof factory !== "function") throw new InvalidArgumentError$13("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$13("connect must be a function or an object");
			if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError$13("maxRedirections must be a positive number");
			if (connect$2 && typeof connect$2 !== "function") connect$2 = { ...connect$2 };
			this[kInterceptors$1] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor$1({ maxRedirections })];
			this[kOptions$1] = {
				...util$10.deepClone(options),
				connect: connect$2
			};
			this[kOptions$1].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kMaxRedirections] = maxRedirections;
			this[kFactory$1] = factory;
			this[kClients$1] = /* @__PURE__ */ new Map();
			this[kFinalizer] = new FinalizationRegistry$1(
				/* istanbul ignore next: gc is undeterministic */
				(key) => {
					const ref = this[kClients$1].get(key);
					if (ref !== void 0 && ref.deref() === void 0) this[kClients$1].delete(key);
				}
			);
			const agent = this;
			this[kOnDrain] = (origin, targets) => {
				agent.emit("drain", origin, [agent, ...targets]);
			};
			this[kOnConnect] = (origin, targets) => {
				agent.emit("connect", origin, [agent, ...targets]);
			};
			this[kOnDisconnect] = (origin, targets, err) => {
				agent.emit("disconnect", origin, [agent, ...targets], err);
			};
			this[kOnConnectionError] = (origin, targets, err) => {
				agent.emit("connectionError", origin, [agent, ...targets], err);
			};
		}
		get [kRunning]() {
			let ret = 0;
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore next: gc is undeterministic */
				if (client) ret += client[kRunning];
			}
			return ret;
		}
		[kDispatch](opts, handler$1) {
			let key;
			if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) key = String(opts.origin);
			else throw new InvalidArgumentError$13("opts.origin must be a non-empty string or URL.");
			const ref = this[kClients$1].get(key);
			let dispatcher = ref ? ref.deref() : null;
			if (!dispatcher) {
				dispatcher = this[kFactory$1](opts.origin, this[kOptions$1]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
				this[kClients$1].set(key, new WeakRef$1(dispatcher));
				this[kFinalizer].register(dispatcher, key);
			}
			return dispatcher.dispatch(opts, handler$1);
		}
		async [kClose$3]() {
			const closePromises = [];
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) closePromises.push(client.close());
			}
			await Promise.all(closePromises);
		}
		async [kDestroy$1](err) {
			const destroyPromises = [];
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) destroyPromises.push(client.destroy(err));
			}
			await Promise.all(destroyPromises);
		}
	};
	module.exports = Agent$5;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/readable.js"(exports, module) {
	const assert$12 = __require("assert");
	const { Readable: Readable$5 } = __require("stream");
	const { RequestAbortedError: RequestAbortedError$7, NotSupportedError, InvalidArgumentError: InvalidArgumentError$12 } = require_errors();
	const util$9 = require_util$6();
	const { ReadableStreamFrom, toUSVString: toUSVString$1 } = require_util$6();
	let Blob$4;
	const kConsume = Symbol("kConsume");
	const kReading = Symbol("kReading");
	const kBody = Symbol("kBody");
	const kAbort = Symbol("abort");
	const kContentType = Symbol("kContentType");
	const noop$3 = () => {};
	module.exports = class BodyReadable extends Readable$5 {
		constructor({ resume: resume$1, abort: abort$1, contentType = "", highWaterMark = 64 * 1024 }) {
			super({
				autoDestroy: true,
				read: resume$1,
				highWaterMark
			});
			this._readableState.dataEmitted = false;
			this[kAbort] = abort$1;
			this[kConsume] = null;
			this[kBody] = null;
			this[kContentType] = contentType;
			this[kReading] = false;
		}
		destroy(err) {
			if (this.destroyed) return this;
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$7();
			if (err) this[kAbort]();
			return super.destroy(err);
		}
		emit(ev, ...args) {
			if (ev === "data") this._readableState.dataEmitted = true;
			else if (ev === "error") this._readableState.errorEmitted = true;
			return super.emit(ev, ...args);
		}
		on(ev, ...args) {
			if (ev === "data" || ev === "readable") this[kReading] = true;
			return super.on(ev, ...args);
		}
		addListener(ev, ...args) {
			return this.on(ev, ...args);
		}
		off(ev, ...args) {
			const ret = super.off(ev, ...args);
			if (ev === "data" || ev === "readable") this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
			return ret;
		}
		removeListener(ev, ...args) {
			return this.off(ev, ...args);
		}
		push(chunk) {
			if (this[kConsume] && chunk !== null && this.readableLength === 0) {
				consumePush(this[kConsume], chunk);
				return this[kReading] ? super.push(chunk) : true;
			}
			return super.push(chunk);
		}
		async text() {
			return consume(this, "text");
		}
		async json() {
			return consume(this, "json");
		}
		async blob() {
			return consume(this, "blob");
		}
		async arrayBuffer() {
			return consume(this, "arrayBuffer");
		}
		async formData() {
			throw new NotSupportedError();
		}
		get bodyUsed() {
			return util$9.isDisturbed(this);
		}
		get body() {
			if (!this[kBody]) {
				this[kBody] = ReadableStreamFrom(this);
				if (this[kConsume]) {
					this[kBody].getReader();
					assert$12(this[kBody].locked);
				}
			}
			return this[kBody];
		}
		dump(opts) {
			let limit$1 = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
			const signal = opts && opts.signal;
			if (signal) try {
				if (typeof signal !== "object" || !("aborted" in signal)) throw new InvalidArgumentError$12("signal must be an AbortSignal");
				util$9.throwIfAborted(signal);
			} catch (err) {
				return Promise.reject(err);
			}
			if (this.closed) return Promise.resolve(null);
			return new Promise((resolve, reject) => {
				const signalListenerCleanup = signal ? util$9.addAbortListener(signal, () => {
					this.destroy();
				}) : noop$3;
				this.on("close", function() {
					signalListenerCleanup();
					if (signal && signal.aborted) reject(signal.reason || Object.assign(/* @__PURE__ */ new Error("The operation was aborted"), { name: "AbortError" }));
					else resolve(null);
				}).on("error", noop$3).on("data", function(chunk) {
					limit$1 -= chunk.length;
					if (limit$1 <= 0) this.destroy();
				}).resume();
			});
		}
	};
	function isLocked(self) {
		return self[kBody] && self[kBody].locked === true || self[kConsume];
	}
	function isUnusable(self) {
		return util$9.isDisturbed(self) || isLocked(self);
	}
	async function consume(stream$2, type) {
		if (isUnusable(stream$2)) throw new TypeError("unusable");
		assert$12(!stream$2[kConsume]);
		return new Promise((resolve, reject) => {
			stream$2[kConsume] = {
				type,
				stream: stream$2,
				resolve,
				reject,
				length: 0,
				body: []
			};
			stream$2.on("error", function(err) {
				consumeFinish(this[kConsume], err);
			}).on("close", function() {
				if (this[kConsume].body !== null) consumeFinish(this[kConsume], new RequestAbortedError$7());
			});
			process.nextTick(consumeStart, stream$2[kConsume]);
		});
	}
	function consumeStart(consume$1) {
		if (consume$1.body === null) return;
		const { _readableState: state } = consume$1.stream;
		for (const chunk of state.buffer) consumePush(consume$1, chunk);
		if (state.endEmitted) consumeEnd(this[kConsume]);
		else consume$1.stream.on("end", function() {
			consumeEnd(this[kConsume]);
		});
		consume$1.stream.resume();
		while (consume$1.stream.read() != null);
	}
	function consumeEnd(consume$1) {
		const { type, body, resolve, stream: stream$2, length } = consume$1;
		try {
			if (type === "text") resolve(toUSVString$1(Buffer.concat(body)));
			else if (type === "json") resolve(JSON.parse(Buffer.concat(body)));
			else if (type === "arrayBuffer") {
				const dst = new Uint8Array(length);
				let pos = 0;
				for (const buf of body) {
					dst.set(buf, pos);
					pos += buf.byteLength;
				}
				resolve(dst.buffer);
			} else if (type === "blob") {
				if (!Blob$4) Blob$4 = __require("buffer").Blob;
				resolve(new Blob$4(body, { type: stream$2[kContentType] }));
			}
			consumeFinish(consume$1);
		} catch (err) {
			stream$2.destroy(err);
		}
	}
	function consumePush(consume$1, chunk) {
		consume$1.length += chunk.length;
		consume$1.body.push(chunk);
	}
	function consumeFinish(consume$1, err) {
		if (consume$1.body === null) return;
		if (err) consume$1.reject(err);
		else consume$1.resolve();
		consume$1.type = null;
		consume$1.stream = null;
		consume$1.resolve = null;
		consume$1.reject = null;
		consume$1.length = 0;
		consume$1.body = null;
	}
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/util.js
var require_util$4 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/util.js"(exports, module) {
	const assert$11 = __require("assert");
	const { ResponseStatusCodeError } = require_errors();
	const { toUSVString } = require_util$6();
	async function getResolveErrorBodyCallback$2({ callback, body, contentType, statusCode, statusMessage, headers }) {
		assert$11(body);
		let chunks = [];
		let limit$1 = 0;
		for await (const chunk of body) {
			chunks.push(chunk);
			limit$1 += chunk.length;
			if (limit$1 > 128 * 1024) {
				chunks = null;
				break;
			}
		}
		if (statusCode === 204 || !contentType || !chunks) {
			process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
			return;
		}
		try {
			if (contentType.startsWith("application/json")) {
				const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
			if (contentType.startsWith("text/")) {
				const payload = toUSVString(Buffer.concat(chunks));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
		} catch (err) {}
		process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
	}
	module.exports = { getResolveErrorBodyCallback: getResolveErrorBodyCallback$2 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/abort-signal.js"(exports, module) {
	const { addAbortListener: addAbortListener$2 } = require_util$6();
	const { RequestAbortedError: RequestAbortedError$6 } = require_errors();
	const kListener = Symbol("kListener");
	const kSignal$1 = Symbol("kSignal");
	function abort(self) {
		if (self.abort) self.abort();
		else self.onError(new RequestAbortedError$6());
	}
	function addSignal$5(self, signal) {
		self[kSignal$1] = null;
		self[kListener] = null;
		if (!signal) return;
		if (signal.aborted) {
			abort(self);
			return;
		}
		self[kSignal$1] = signal;
		self[kListener] = () => {
			abort(self);
		};
		addAbortListener$2(self[kSignal$1], self[kListener]);
	}
	function removeSignal$5(self) {
		if (!self[kSignal$1]) return;
		if ("removeEventListener" in self[kSignal$1]) self[kSignal$1].removeEventListener("abort", self[kListener]);
		else self[kSignal$1].removeListener("abort", self[kListener]);
		self[kSignal$1] = null;
		self[kListener] = null;
	}
	module.exports = {
		addSignal: addSignal$5,
		removeSignal: removeSignal$5
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-request.js"(exports, module) {
	const Readable$4 = require_readable();
	const { InvalidArgumentError: InvalidArgumentError$11, RequestAbortedError: RequestAbortedError$5 } = require_errors();
	const util$8 = require_util$6();
	const { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = require_util$4();
	const { AsyncResource: AsyncResource$4 } = __require("async_hooks");
	const { addSignal: addSignal$4, removeSignal: removeSignal$4 } = require_abort_signal();
	var RequestHandler = class extends AsyncResource$4 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$11("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$11("invalid callback");
				if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) throw new InvalidArgumentError$11("invalid highWaterMark");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$11("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$11("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$11("invalid onInfo callback");
				super("UNDICI_REQUEST");
			} catch (err) {
				if (util$8.isStream(body)) util$8.destroy(body.on("error", util$8.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.body = body;
			this.trailers = {};
			this.context = null;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError;
			this.highWaterMark = highWaterMark;
			if (util$8.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$4(this, signal);
		}
		onConnect(abort$1, context$1) {
			if (!this.callback) throw new RequestAbortedError$5();
			this.abort = abort$1;
			this.context = context$1;
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const { callback, opaque, abort: abort$1, context: context$1, responseHeaders, highWaterMark } = this;
			const headers = responseHeaders === "raw" ? util$8.parseRawHeaders(rawHeaders) : util$8.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			const parsedHeaders = responseHeaders === "raw" ? util$8.parseHeaders(rawHeaders) : headers;
			const contentType = parsedHeaders["content-type"];
			const body = new Readable$4({
				resume: resume$1,
				abort: abort$1,
				contentType,
				highWaterMark
			});
			this.callback = null;
			this.res = body;
			if (callback !== null) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback$1, null, {
				callback,
				body,
				contentType,
				statusCode,
				statusMessage,
				headers
			});
			else this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				trailers: this.trailers,
				opaque,
				body,
				context: context$1
			});
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$4(this);
			util$8.parseHeaders(trailers, this.trailers);
			res.push(null);
		}
		onError(err) {
			const { res, callback, body, opaque } = this;
			removeSignal$4(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (res) {
				this.res = null;
				queueMicrotask(() => {
					util$8.destroy(res, err);
				});
			}
			if (body) {
				this.body = null;
				util$8.destroy(body, err);
			}
		}
	};
	function request$1(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			request$1.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new RequestHandler(opts, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = request$1;
	module.exports.RequestHandler = RequestHandler;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-stream.js"(exports, module) {
	const { finished: finished$1, PassThrough: PassThrough$3 } = __require("stream");
	const { InvalidArgumentError: InvalidArgumentError$10, InvalidReturnValueError: InvalidReturnValueError$1, RequestAbortedError: RequestAbortedError$4 } = require_errors();
	const util$7 = require_util$6();
	const { getResolveErrorBodyCallback } = require_util$4();
	const { AsyncResource: AsyncResource$3 } = __require("async_hooks");
	const { addSignal: addSignal$3, removeSignal: removeSignal$3 } = require_abort_signal();
	var StreamHandler = class extends AsyncResource$3 {
		constructor(opts, factory, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$10("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$10("invalid callback");
				if (typeof factory !== "function") throw new InvalidArgumentError$10("invalid factory");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$10("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$10("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$10("invalid onInfo callback");
				super("UNDICI_STREAM");
			} catch (err) {
				if (util$7.isStream(body)) util$7.destroy(body.on("error", util$7.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.factory = factory;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.context = null;
			this.trailers = null;
			this.body = body;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError || false;
			if (util$7.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$3(this, signal);
		}
		onConnect(abort$1, context$1) {
			if (!this.callback) throw new RequestAbortedError$4();
			this.abort = abort$1;
			this.context = context$1;
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const { factory, opaque, context: context$1, callback, responseHeaders } = this;
			const headers = responseHeaders === "raw" ? util$7.parseRawHeaders(rawHeaders) : util$7.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			this.factory = null;
			let res;
			if (this.throwOnError && statusCode >= 400) {
				const parsedHeaders = responseHeaders === "raw" ? util$7.parseHeaders(rawHeaders) : headers;
				const contentType = parsedHeaders["content-type"];
				res = new PassThrough$3();
				this.callback = null;
				this.runInAsyncScope(getResolveErrorBodyCallback, null, {
					callback,
					body: res,
					contentType,
					statusCode,
					statusMessage,
					headers
				});
			} else {
				if (factory === null) return;
				res = this.runInAsyncScope(factory, null, {
					statusCode,
					headers,
					opaque,
					context: context$1
				});
				if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") throw new InvalidReturnValueError$1("expected Writable");
				finished$1(res, { readable: false }, (err) => {
					const { callback: callback$1, res: res$1, opaque: opaque$1, trailers, abort: abort$1 } = this;
					this.res = null;
					if (err || !res$1.readable) util$7.destroy(res$1, err);
					this.callback = null;
					this.runInAsyncScope(callback$1, null, err || null, {
						opaque: opaque$1,
						trailers
					});
					if (err) abort$1();
				});
			}
			res.on("drain", resume$1);
			this.res = res;
			const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
			return needDrain !== true;
		}
		onData(chunk) {
			const { res } = this;
			return res ? res.write(chunk) : true;
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$3(this);
			if (!res) return;
			this.trailers = util$7.parseHeaders(trailers);
			res.end();
		}
		onError(err) {
			const { res, callback, opaque, body } = this;
			removeSignal$3(this);
			this.factory = null;
			if (res) {
				this.res = null;
				util$7.destroy(res, err);
			} else if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (body) {
				this.body = null;
				util$7.destroy(body, err);
			}
		}
	};
	function stream(opts, factory, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			stream.call(this, opts, factory, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new StreamHandler(opts, factory, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = stream;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-pipeline.js"(exports, module) {
	const { Readable: Readable$3, Duplex: Duplex$1, PassThrough: PassThrough$2 } = __require("stream");
	const { InvalidArgumentError: InvalidArgumentError$9, InvalidReturnValueError, RequestAbortedError: RequestAbortedError$3 } = require_errors();
	const util$6 = require_util$6();
	const { AsyncResource: AsyncResource$2 } = __require("async_hooks");
	const { addSignal: addSignal$2, removeSignal: removeSignal$2 } = require_abort_signal();
	const assert$10 = __require("assert");
	const kResume = Symbol("resume");
	var PipelineRequest = class extends Readable$3 {
		constructor() {
			super({ autoDestroy: true });
			this[kResume] = null;
		}
		_read() {
			const { [kResume]: resume$1 } = this;
			if (resume$1) {
				this[kResume] = null;
				resume$1();
			}
		}
		_destroy(err, callback) {
			this._read();
			callback(err);
		}
	};
	var PipelineResponse = class extends Readable$3 {
		constructor(resume$1) {
			super({ autoDestroy: true });
			this[kResume] = resume$1;
		}
		_read() {
			this[kResume]();
		}
		_destroy(err, callback) {
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$3();
			callback(err);
		}
	};
	var PipelineHandler = class extends AsyncResource$2 {
		constructor(opts, handler$1) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$9("invalid opts");
			if (typeof handler$1 !== "function") throw new InvalidArgumentError$9("invalid handler");
			const { signal, method, opaque, onInfo, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
			if (method === "CONNECT") throw new InvalidArgumentError$9("invalid method");
			if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$9("invalid onInfo callback");
			super("UNDICI_PIPELINE");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.handler = handler$1;
			this.abort = null;
			this.context = null;
			this.onInfo = onInfo || null;
			this.req = new PipelineRequest().on("error", util$6.nop);
			this.ret = new Duplex$1({
				readableObjectMode: opts.objectMode,
				autoDestroy: true,
				read: () => {
					const { body } = this;
					if (body && body.resume) body.resume();
				},
				write: (chunk, encoding, callback) => {
					const { req } = this;
					if (req.push(chunk, encoding) || req._readableState.destroyed) callback();
					else req[kResume] = callback;
				},
				destroy: (err, callback) => {
					const { body, req, res, ret, abort: abort$1 } = this;
					if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError$3();
					if (abort$1 && err) abort$1();
					util$6.destroy(body, err);
					util$6.destroy(req, err);
					util$6.destroy(res, err);
					removeSignal$2(this);
					callback(err);
				}
			}).on("prefinish", () => {
				const { req } = this;
				req.push(null);
			});
			this.res = null;
			addSignal$2(this, signal);
		}
		onConnect(abort$1, context$1) {
			const { ret, res } = this;
			assert$10(!res, "pipeline cannot be retried");
			if (ret.destroyed) throw new RequestAbortedError$3();
			this.abort = abort$1;
			this.context = context$1;
		}
		onHeaders(statusCode, rawHeaders, resume$1) {
			const { opaque, handler: handler$1, context: context$1 } = this;
			if (statusCode < 200) {
				if (this.onInfo) {
					const headers = this.responseHeaders === "raw" ? util$6.parseRawHeaders(rawHeaders) : util$6.parseHeaders(rawHeaders);
					this.onInfo({
						statusCode,
						headers
					});
				}
				return;
			}
			this.res = new PipelineResponse(resume$1);
			let body;
			try {
				this.handler = null;
				const headers = this.responseHeaders === "raw" ? util$6.parseRawHeaders(rawHeaders) : util$6.parseHeaders(rawHeaders);
				body = this.runInAsyncScope(handler$1, null, {
					statusCode,
					headers,
					opaque,
					body: this.res,
					context: context$1
				});
			} catch (err) {
				this.res.on("error", util$6.nop);
				throw err;
			}
			if (!body || typeof body.on !== "function") throw new InvalidReturnValueError("expected Readable");
			body.on("data", (chunk) => {
				const { ret, body: body$1 } = this;
				if (!ret.push(chunk) && body$1.pause) body$1.pause();
			}).on("error", (err) => {
				const { ret } = this;
				util$6.destroy(ret, err);
			}).on("end", () => {
				const { ret } = this;
				ret.push(null);
			}).on("close", () => {
				const { ret } = this;
				if (!ret._readableState.ended) util$6.destroy(ret, new RequestAbortedError$3());
			});
			this.body = body;
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			res.push(null);
		}
		onError(err) {
			const { ret } = this;
			this.handler = null;
			util$6.destroy(ret, err);
		}
	};
	function pipeline$1(opts, handler$1) {
		try {
			const pipelineHandler = new PipelineHandler(opts, handler$1);
			this.dispatch({
				...opts,
				body: pipelineHandler.req
			}, pipelineHandler);
			return pipelineHandler.ret;
		} catch (err) {
			return new PassThrough$2().destroy(err);
		}
	}
	module.exports = pipeline$1;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-upgrade.js"(exports, module) {
	const { InvalidArgumentError: InvalidArgumentError$8, RequestAbortedError: RequestAbortedError$2, SocketError: SocketError$1 } = require_errors();
	const { AsyncResource: AsyncResource$1 } = __require("async_hooks");
	const util$5 = require_util$6();
	const { addSignal: addSignal$1, removeSignal: removeSignal$1 } = require_abort_signal();
	const assert$9 = __require("assert");
	var UpgradeHandler = class extends AsyncResource$1 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$8("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$8("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
			super("UNDICI_UPGRADE");
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.abort = null;
			this.context = null;
			addSignal$1(this, signal);
		}
		onConnect(abort$1, context$1) {
			if (!this.callback) throw new RequestAbortedError$2();
			this.abort = abort$1;
			this.context = null;
		}
		onHeaders() {
			throw new SocketError$1("bad upgrade", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context: context$1 } = this;
			assert$9.strictEqual(statusCode, 101);
			removeSignal$1(this);
			this.callback = null;
			const headers = this.responseHeaders === "raw" ? util$5.parseRawHeaders(rawHeaders) : util$5.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				headers,
				socket,
				opaque,
				context: context$1
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal$1(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function upgrade(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			upgrade.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const upgradeHandler = new UpgradeHandler(opts, callback);
			this.dispatch({
				...opts,
				method: opts.method || "GET",
				upgrade: opts.protocol || "Websocket"
			}, upgradeHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = upgrade;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/api-connect.js"(exports, module) {
	const { AsyncResource } = __require("async_hooks");
	const { InvalidArgumentError: InvalidArgumentError$7, RequestAbortedError: RequestAbortedError$1, SocketError } = require_errors();
	const util$4 = require_util$6();
	const { addSignal, removeSignal } = require_abort_signal();
	var ConnectHandler = class extends AsyncResource {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$7("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$7("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$7("signal must be an EventEmitter or EventTarget");
			super("UNDICI_CONNECT");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.callback = callback;
			this.abort = null;
			addSignal(this, signal);
		}
		onConnect(abort$1, context$1) {
			if (!this.callback) throw new RequestAbortedError$1();
			this.abort = abort$1;
			this.context = context$1;
		}
		onHeaders() {
			throw new SocketError("bad connect", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context: context$1 } = this;
			removeSignal(this);
			this.callback = null;
			let headers = rawHeaders;
			if (headers != null) headers = this.responseHeaders === "raw" ? util$4.parseRawHeaders(rawHeaders) : util$4.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				socket,
				opaque,
				context: context$1
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function connect(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			connect.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const connectHandler = new ConnectHandler(opts, callback);
			this.dispatch({
				...opts,
				method: "CONNECT"
			}, connectHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = connect;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/index.js
var require_api = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/api/index.js"(exports, module) {
	module.exports.request = require_api_request();
	module.exports.stream = require_api_stream();
	module.exports.pipeline = require_api_pipeline();
	module.exports.upgrade = require_api_upgrade();
	module.exports.connect = require_api_connect();
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-errors.js"(exports, module) {
	const { UndiciError: UndiciError$1 } = require_errors();
	var MockNotMatchedError$1 = class MockNotMatchedError$1 extends UndiciError$1 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, MockNotMatchedError$1);
			this.name = "MockNotMatchedError";
			this.message = message || "The request does not match any registered mock dispatches";
			this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
		}
	};
	module.exports = { MockNotMatchedError: MockNotMatchedError$1 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-symbols.js"(exports, module) {
	module.exports = {
		kAgent: Symbol("agent"),
		kOptions: Symbol("options"),
		kFactory: Symbol("factory"),
		kDispatches: Symbol("dispatches"),
		kDispatchKey: Symbol("dispatch key"),
		kDefaultHeaders: Symbol("default headers"),
		kDefaultTrailers: Symbol("default trailers"),
		kContentLength: Symbol("content length"),
		kMockAgent: Symbol("mock agent"),
		kMockAgentSet: Symbol("mock agent set"),
		kMockAgentGet: Symbol("mock agent get"),
		kMockDispatch: Symbol("mock dispatch"),
		kClose: Symbol("close"),
		kOriginalClose: Symbol("original agent close"),
		kOrigin: Symbol("origin"),
		kIsMockActive: Symbol("is mock active"),
		kNetConnect: Symbol("net connect"),
		kGetNetConnect: Symbol("get net connect"),
		kConnected: Symbol("connected")
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-utils.js"(exports, module) {
	const { MockNotMatchedError } = require_mock_errors();
	const { kDispatches: kDispatches$4, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect: kGetNetConnect$1 } = require_mock_symbols();
	const { buildURL: buildURL$1, nop } = require_util$6();
	const { STATUS_CODES: STATUS_CODES$2 } = __require("http");
	const { types: { isPromise } } = __require("util");
	function matchValue$1(match, value) {
		if (typeof match === "string") return match === value;
		if (match instanceof RegExp) return match.test(value);
		if (typeof match === "function") return match(value) === true;
		return false;
	}
	function lowerCaseEntries(headers) {
		return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
			return [headerName.toLocaleLowerCase(), headerValue];
		}));
	}
	/**
	* @param {import('../../index').Headers|string[]|Record<string, string>} headers
	* @param {string} key
	*/
	function getHeaderByName(headers, key) {
		if (Array.isArray(headers)) {
			for (let i$1 = 0; i$1 < headers.length; i$1 += 2) if (headers[i$1].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i$1 + 1];
			return void 0;
		} else if (typeof headers.get === "function") return headers.get(key);
		else return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
	}
	/** @param {string[]} headers */
	function buildHeadersFromArray(headers) {
		const clone$1 = headers.slice();
		const entries = [];
		for (let index = 0; index < clone$1.length; index += 2) entries.push([clone$1[index], clone$1[index + 1]]);
		return Object.fromEntries(entries);
	}
	function matchHeaders(mockDispatch$1, headers) {
		if (typeof mockDispatch$1.headers === "function") {
			if (Array.isArray(headers)) headers = buildHeadersFromArray(headers);
			return mockDispatch$1.headers(headers ? lowerCaseEntries(headers) : {});
		}
		if (typeof mockDispatch$1.headers === "undefined") return true;
		if (typeof headers !== "object" || typeof mockDispatch$1.headers !== "object") return false;
		for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch$1.headers)) {
			const headerValue = getHeaderByName(headers, matchHeaderName);
			if (!matchValue$1(matchHeaderValue, headerValue)) return false;
		}
		return true;
	}
	function safeUrl(path$9) {
		if (typeof path$9 !== "string") return path$9;
		const pathSegments = path$9.split("?");
		if (pathSegments.length !== 2) return path$9;
		const qp = new URLSearchParams(pathSegments.pop());
		qp.sort();
		return [...pathSegments, qp.toString()].join("?");
	}
	function matchKey(mockDispatch$1, { path: path$9, method, body, headers }) {
		const pathMatch = matchValue$1(mockDispatch$1.path, path$9);
		const methodMatch = matchValue$1(mockDispatch$1.method, method);
		const bodyMatch = typeof mockDispatch$1.body !== "undefined" ? matchValue$1(mockDispatch$1.body, body) : true;
		const headersMatch = matchHeaders(mockDispatch$1, headers);
		return pathMatch && methodMatch && bodyMatch && headersMatch;
	}
	function getResponseData$2(data) {
		if (Buffer.isBuffer(data)) return data;
		else if (typeof data === "object") return JSON.stringify(data);
		else return data.toString();
	}
	function getMockDispatch(mockDispatches, key) {
		const basePath = key.query ? buildURL$1(key.path, key.query) : key.path;
		const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
		let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path$9 }) => matchValue$1(safeUrl(path$9), resolvedPath));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue$1(method, key.method));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue$1(body, key.body) : true);
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
		matchedMockDispatches = matchedMockDispatches.filter((mockDispatch$1) => matchHeaders(mockDispatch$1, key.headers));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
		return matchedMockDispatches[0];
	}
	function addMockDispatch$1(mockDispatches, key, data) {
		const baseData = {
			timesInvoked: 0,
			times: 1,
			persist: false,
			consumed: false
		};
		const replyData = typeof data === "function" ? { callback: data } : { ...data };
		const newMockDispatch = {
			...baseData,
			...key,
			pending: true,
			data: {
				error: null,
				...replyData
			}
		};
		mockDispatches.push(newMockDispatch);
		return newMockDispatch;
	}
	function deleteMockDispatch(mockDispatches, key) {
		const index = mockDispatches.findIndex((dispatch) => {
			if (!dispatch.consumed) return false;
			return matchKey(dispatch, key);
		});
		if (index !== -1) mockDispatches.splice(index, 1);
	}
	function buildKey$1(opts) {
		const { path: path$9, method, body, headers, query } = opts;
		return {
			path: path$9,
			method,
			body,
			headers,
			query
		};
	}
	function generateKeyValues(data) {
		return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
			...keyValuePairs,
			Buffer.from(`${key}`),
			Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
		], []);
	}
	/**
	* @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
	* @param {number} statusCode
	*/
	function getStatusText(statusCode) {
		return STATUS_CODES$2[statusCode] || "unknown";
	}
	async function getResponse(body) {
		const buffers = [];
		for await (const data of body) buffers.push(data);
		return Buffer.concat(buffers).toString("utf8");
	}
	/**
	* Mock dispatch function used to simulate undici dispatches
	*/
	function mockDispatch(opts, handler$1) {
		const key = buildKey$1(opts);
		const mockDispatch$1 = getMockDispatch(this[kDispatches$4], key);
		mockDispatch$1.timesInvoked++;
		if (mockDispatch$1.data.callback) mockDispatch$1.data = {
			...mockDispatch$1.data,
			...mockDispatch$1.data.callback(opts)
		};
		const { data: { statusCode, data, headers, trailers, error: error$1 }, delay, persist } = mockDispatch$1;
		const { timesInvoked, times } = mockDispatch$1;
		mockDispatch$1.consumed = !persist && timesInvoked >= times;
		mockDispatch$1.pending = timesInvoked < times;
		if (error$1 !== null) {
			deleteMockDispatch(this[kDispatches$4], key);
			handler$1.onError(error$1);
			return true;
		}
		if (typeof delay === "number" && delay > 0) setTimeout(() => {
			handleReply(this[kDispatches$4]);
		}, delay);
		else handleReply(this[kDispatches$4]);
		function handleReply(mockDispatches, _data = data) {
			const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
			const body = typeof _data === "function" ? _data({
				...opts,
				headers: optsHeaders
			}) : _data;
			if (isPromise(body)) {
				body.then((newData) => handleReply(mockDispatches, newData));
				return;
			}
			const responseData = getResponseData$2(body);
			const responseHeaders = generateKeyValues(headers);
			const responseTrailers = generateKeyValues(trailers);
			handler$1.abort = nop;
			handler$1.onHeaders(statusCode, responseHeaders, resume$1, getStatusText(statusCode));
			handler$1.onData(Buffer.from(responseData));
			handler$1.onComplete(responseTrailers);
			deleteMockDispatch(mockDispatches, key);
		}
		function resume$1() {}
		return true;
	}
	function buildMockDispatch$2() {
		const agent = this[kMockAgent$2];
		const origin = this[kOrigin$2];
		const originalDispatch = this[kOriginalDispatch$2];
		return function dispatch(opts, handler$1) {
			if (agent.isMockActive) try {
				mockDispatch.call(this, opts, handler$1);
			} catch (error$1) {
				if (error$1 instanceof MockNotMatchedError) {
					const netConnect = agent[kGetNetConnect$1]();
					if (netConnect === false) throw new MockNotMatchedError(`${error$1.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
					if (checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler$1);
					else throw new MockNotMatchedError(`${error$1.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
				} else throw error$1;
			}
			else originalDispatch.call(this, opts, handler$1);
		};
	}
	function checkNetConnect(netConnect, origin) {
		const url = new URL(origin);
		if (netConnect === true) return true;
		else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue$1(matcher, url.host))) return true;
		return false;
	}
	function buildMockOptions$1(opts) {
		if (opts) {
			const { agent,...mockOptions } = opts;
			return mockOptions;
		}
	}
	module.exports = {
		getResponseData: getResponseData$2,
		getMockDispatch,
		addMockDispatch: addMockDispatch$1,
		deleteMockDispatch,
		buildKey: buildKey$1,
		generateKeyValues,
		matchValue: matchValue$1,
		getResponse,
		getStatusText,
		mockDispatch,
		buildMockDispatch: buildMockDispatch$2,
		checkNetConnect,
		buildMockOptions: buildMockOptions$1,
		getHeaderByName
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-interceptor.js"(exports, module) {
	const { getResponseData: getResponseData$1, buildKey, addMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$3, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = require_mock_symbols();
	const { InvalidArgumentError: InvalidArgumentError$6 } = require_errors();
	const { buildURL } = require_util$6();
	/**
	* Defines the scope API for an interceptor reply
	*/
	var MockScope = class {
		constructor(mockDispatch$1) {
			this[kMockDispatch] = mockDispatch$1;
		}
		/**
		* Delay a reply by a set amount in ms.
		*/
		delay(waitInMs) {
			if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError$6("waitInMs must be a valid integer > 0");
			this[kMockDispatch].delay = waitInMs;
			return this;
		}
		/**
		* For a defined reply, never mark as consumed.
		*/
		persist() {
			this[kMockDispatch].persist = true;
			return this;
		}
		/**
		* Allow one to define a reply for a set amount of matching requests.
		*/
		times(repeatTimes) {
			if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError$6("repeatTimes must be a valid integer > 0");
			this[kMockDispatch].times = repeatTimes;
			return this;
		}
	};
	/**
	* Defines an interceptor for a Mock
	*/
	var MockInterceptor$2 = class {
		constructor(opts, mockDispatches) {
			if (typeof opts !== "object") throw new InvalidArgumentError$6("opts must be an object");
			if (typeof opts.path === "undefined") throw new InvalidArgumentError$6("opts.path must be defined");
			if (typeof opts.method === "undefined") opts.method = "GET";
			if (typeof opts.path === "string") if (opts.query) opts.path = buildURL(opts.path, opts.query);
			else {
				const parsedURL = new URL(opts.path, "data://");
				opts.path = parsedURL.pathname + parsedURL.search;
			}
			if (typeof opts.method === "string") opts.method = opts.method.toUpperCase();
			this[kDispatchKey] = buildKey(opts);
			this[kDispatches$3] = mockDispatches;
			this[kDefaultHeaders] = {};
			this[kDefaultTrailers] = {};
			this[kContentLength] = false;
		}
		createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
			const responseData = getResponseData$1(data);
			const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
			const headers = {
				...this[kDefaultHeaders],
				...contentLength,
				...responseOptions.headers
			};
			const trailers = {
				...this[kDefaultTrailers],
				...responseOptions.trailers
			};
			return {
				statusCode,
				data,
				headers,
				trailers
			};
		}
		validateReplyParameters(statusCode, data, responseOptions) {
			if (typeof statusCode === "undefined") throw new InvalidArgumentError$6("statusCode must be defined");
			if (typeof data === "undefined") throw new InvalidArgumentError$6("data must be defined");
			if (typeof responseOptions !== "object") throw new InvalidArgumentError$6("responseOptions must be an object");
		}
		/**
		* Mock an undici request with a defined reply.
		*/
		reply(replyData) {
			if (typeof replyData === "function") {
				const wrappedDefaultsCallback = (opts) => {
					const resolvedData = replyData(opts);
					if (typeof resolvedData !== "object") throw new InvalidArgumentError$6("reply options callback must return an object");
					const { statusCode: statusCode$1, data: data$1 = "", responseOptions: responseOptions$1 = {} } = resolvedData;
					this.validateReplyParameters(statusCode$1, data$1, responseOptions$1);
					return { ...this.createMockScopeDispatchData(statusCode$1, data$1, responseOptions$1) };
				};
				const newMockDispatch$1 = addMockDispatch(this[kDispatches$3], this[kDispatchKey], wrappedDefaultsCallback);
				return new MockScope(newMockDispatch$1);
			}
			const [statusCode, data = "", responseOptions = {}] = [...arguments];
			this.validateReplyParameters(statusCode, data, responseOptions);
			const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
			const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], dispatchData);
			return new MockScope(newMockDispatch);
		}
		/**
		* Mock an undici request with a defined error.
		*/
		replyWithError(error$1) {
			if (typeof error$1 === "undefined") throw new InvalidArgumentError$6("error must be defined");
			const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], { error: error$1 });
			return new MockScope(newMockDispatch);
		}
		/**
		* Set default reply headers on the interceptor for subsequent replies
		*/
		defaultReplyHeaders(headers) {
			if (typeof headers === "undefined") throw new InvalidArgumentError$6("headers must be defined");
			this[kDefaultHeaders] = headers;
			return this;
		}
		/**
		* Set default reply trailers on the interceptor for subsequent replies
		*/
		defaultReplyTrailers(trailers) {
			if (typeof trailers === "undefined") throw new InvalidArgumentError$6("trailers must be defined");
			this[kDefaultTrailers] = trailers;
			return this;
		}
		/**
		* Set reply content length header for replies on the interceptor
		*/
		replyContentLength() {
			this[kContentLength] = true;
			return this;
		}
	};
	module.exports.MockInterceptor = MockInterceptor$2;
	module.exports.MockScope = MockScope;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-client.js"(exports, module) {
	const { promisify: promisify$2 } = __require("util");
	const Client$1 = require_client();
	const { buildMockDispatch: buildMockDispatch$1 } = require_mock_utils();
	const { kDispatches: kDispatches$2, kMockAgent: kMockAgent$1, kClose: kClose$2, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = require_mock_symbols();
	const { MockInterceptor: MockInterceptor$1 } = require_mock_interceptor();
	const Symbols$1 = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$5 } = require_errors();
	/**
	* MockClient provides an API that extends the Client to influence the mockDispatches.
	*/
	var MockClient$2 = class extends Client$1 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$5("Argument opts.agent must implement Agent");
			this[kMockAgent$1] = opts.agent;
			this[kOrigin$1] = origin;
			this[kDispatches$2] = [];
			this[kConnected$1] = 1;
			this[kOriginalDispatch$1] = this.dispatch;
			this[kOriginalClose$1] = this.close.bind(this);
			this.dispatch = buildMockDispatch$1.call(this);
			this.close = this[kClose$2];
		}
		get [Symbols$1.kConnected]() {
			return this[kConnected$1];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor$1(opts, this[kDispatches$2]);
		}
		async [kClose$2]() {
			await promisify$2(this[kOriginalClose$1])();
			this[kConnected$1] = 0;
			this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
		}
	};
	module.exports = MockClient$2;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-pool.js"(exports, module) {
	const { promisify: promisify$1 } = __require("util");
	const Pool$2 = require_pool();
	const { buildMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$1, kMockAgent, kClose: kClose$1, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = require_mock_symbols();
	const { MockInterceptor } = require_mock_interceptor();
	const Symbols = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$4 } = require_errors();
	/**
	* MockPool provides an API that extends the Pool to influence the mockDispatches.
	*/
	var MockPool$2 = class extends Pool$2 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$4("Argument opts.agent must implement Agent");
			this[kMockAgent] = opts.agent;
			this[kOrigin] = origin;
			this[kDispatches$1] = [];
			this[kConnected] = 1;
			this[kOriginalDispatch] = this.dispatch;
			this[kOriginalClose] = this.close.bind(this);
			this.dispatch = buildMockDispatch.call(this);
			this.close = this[kClose$1];
		}
		get [Symbols.kConnected]() {
			return this[kConnected];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor(opts, this[kDispatches$1]);
		}
		async [kClose$1]() {
			await promisify$1(this[kOriginalClose])();
			this[kConnected] = 0;
			this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
		}
	};
	module.exports = MockPool$2;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/pluralizer.js"(exports, module) {
	const singulars = {
		pronoun: "it",
		is: "is",
		was: "was",
		this: "this"
	};
	const plurals = {
		pronoun: "they",
		is: "are",
		was: "were",
		this: "these"
	};
	module.exports = class Pluralizer$1 {
		constructor(singular, plural$1) {
			this.singular = singular;
			this.plural = plural$1;
		}
		pluralize(count$1) {
			const one = count$1 === 1;
			const keys = one ? singulars : plurals;
			const noun = one ? this.singular : this.plural;
			return {
				...keys,
				count: count$1,
				noun
			};
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports, module) {
	const { Transform: Transform$1 } = __require("stream");
	const { Console } = __require("console");
	/**
	* Gets the output of `console.table(…)` as a string.
	*/
	module.exports = class PendingInterceptorsFormatter$1 {
		constructor({ disableColors } = {}) {
			this.transform = new Transform$1({ transform(chunk, _enc, cb) {
				cb(null, chunk);
			} });
			this.logger = new Console({
				stdout: this.transform,
				inspectOptions: { colors: !disableColors && !process.env.CI }
			});
		}
		format(pendingInterceptors) {
			const withPrettyHeaders = pendingInterceptors.map(({ method, path: path$9, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
				Method: method,
				Origin: origin,
				Path: path$9,
				"Status code": statusCode,
				Persistent: persist ? "✅" : "❌",
				Invocations: timesInvoked,
				Remaining: persist ? Infinity : times - timesInvoked
			}));
			this.logger.table(withPrettyHeaders);
			return this.transform.read().toString();
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/mock/mock-agent.js"(exports, module) {
	const { kClients } = require_symbols$4();
	const Agent$4 = require_agent$1();
	const { kAgent: kAgent$1, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = require_mock_symbols();
	const MockClient$1 = require_mock_client();
	const MockPool$1 = require_mock_pool();
	const { matchValue, buildMockOptions } = require_mock_utils();
	const { InvalidArgumentError: InvalidArgumentError$3, UndiciError } = require_errors();
	const Dispatcher$1 = require_dispatcher();
	const Pluralizer = require_pluralizer();
	const PendingInterceptorsFormatter = require_pending_interceptors_formatter();
	var FakeWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value;
		}
	};
	var MockAgent$1 = class extends Dispatcher$1 {
		constructor(opts) {
			super(opts);
			this[kNetConnect] = true;
			this[kIsMockActive] = true;
			if (opts && opts.agent && typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$3("Argument opts.agent must implement Agent");
			const agent = opts && opts.agent ? opts.agent : new Agent$4(opts);
			this[kAgent$1] = agent;
			this[kClients] = agent[kClients];
			this[kOptions] = buildMockOptions(opts);
		}
		get(origin) {
			let dispatcher = this[kMockAgentGet](origin);
			if (!dispatcher) {
				dispatcher = this[kFactory](origin);
				this[kMockAgentSet](origin, dispatcher);
			}
			return dispatcher;
		}
		dispatch(opts, handler$1) {
			this.get(opts.origin);
			return this[kAgent$1].dispatch(opts, handler$1);
		}
		async close() {
			await this[kAgent$1].close();
			this[kClients].clear();
		}
		deactivate() {
			this[kIsMockActive] = false;
		}
		activate() {
			this[kIsMockActive] = true;
		}
		enableNetConnect(matcher) {
			if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
			else this[kNetConnect] = [matcher];
			else if (typeof matcher === "undefined") this[kNetConnect] = true;
			else throw new InvalidArgumentError$3("Unsupported matcher. Must be one of String|Function|RegExp.");
		}
		disableNetConnect() {
			this[kNetConnect] = false;
		}
		get isMockActive() {
			return this[kIsMockActive];
		}
		[kMockAgentSet](origin, dispatcher) {
			this[kClients].set(origin, new FakeWeakRef(dispatcher));
		}
		[kFactory](origin) {
			const mockOptions = Object.assign({ agent: this }, this[kOptions]);
			return this[kOptions] && this[kOptions].connections === 1 ? new MockClient$1(origin, mockOptions) : new MockPool$1(origin, mockOptions);
		}
		[kMockAgentGet](origin) {
			const ref = this[kClients].get(origin);
			if (ref) return ref.deref();
			if (typeof origin !== "string") {
				const dispatcher = this[kFactory]("http://localhost:9999");
				this[kMockAgentSet](origin, dispatcher);
				return dispatcher;
			}
			for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
				const nonExplicitDispatcher = nonExplicitRef.deref();
				if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
					const dispatcher = this[kFactory](origin);
					this[kMockAgentSet](origin, dispatcher);
					dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
					return dispatcher;
				}
			}
		}
		[kGetNetConnect]() {
			return this[kNetConnect];
		}
		pendingInterceptors() {
			const mockAgentClients = this[kClients];
			return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({
				...dispatch,
				origin
			}))).filter(({ pending }) => pending);
		}
		assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
			const pending = this.pendingInterceptors();
			if (pending.length === 0) return;
			const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
			throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
		}
	};
	module.exports = MockAgent$1;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/proxy-agent.js"(exports, module) {
	const { kProxy, kClose, kDestroy, kInterceptors } = require_symbols$4();
	const { URL: URL$3 } = __require("url");
	const Agent$3 = require_agent$1();
	const Pool$1 = require_pool();
	const DispatcherBase = require_dispatcher_base();
	const { InvalidArgumentError: InvalidArgumentError$2, RequestAbortedError } = require_errors();
	const buildConnector$1 = require_connect();
	const kAgent = Symbol("proxy agent");
	const kClient = Symbol("proxy client");
	const kProxyHeaders = Symbol("proxy headers");
	const kRequestTls = Symbol("request tls settings");
	const kProxyTls = Symbol("proxy tls settings");
	const kConnectEndpoint = Symbol("connect endpoint function");
	function defaultProtocolPort(protocol) {
		return protocol === "https:" ? 443 : 80;
	}
	function buildProxyOptions(opts) {
		if (typeof opts === "string") opts = { uri: opts };
		if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
		return {
			uri: opts.uri,
			protocol: opts.protocol || "https"
		};
	}
	function defaultFactory(origin, opts) {
		return new Pool$1(origin, opts);
	}
	var ProxyAgent$1 = class extends DispatcherBase {
		constructor(opts) {
			super(opts);
			this[kProxy] = buildProxyOptions(opts);
			this[kAgent] = new Agent$3(opts);
			this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
			if (typeof opts === "string") opts = { uri: opts };
			if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
			const { clientFactory = defaultFactory } = opts;
			if (typeof clientFactory !== "function") throw new InvalidArgumentError$2("Proxy opts.clientFactory must be a function.");
			this[kRequestTls] = opts.requestTls;
			this[kProxyTls] = opts.proxyTls;
			this[kProxyHeaders] = opts.headers || {};
			const resolvedUrl = new URL$3(opts.uri);
			const { origin, port, host, username, password } = resolvedUrl;
			if (opts.auth && opts.token) throw new InvalidArgumentError$2("opts.auth cannot be used in combination with opts.token");
			else if (opts.auth) this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
			else if (opts.token) this[kProxyHeaders]["proxy-authorization"] = opts.token;
			else if (username && password) this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
			const connect$2 = buildConnector$1({ ...opts.proxyTls });
			this[kConnectEndpoint] = buildConnector$1({ ...opts.requestTls });
			this[kClient] = clientFactory(resolvedUrl, { connect: connect$2 });
			this[kAgent] = new Agent$3({
				...opts,
				connect: async (opts$1, callback) => {
					let requestedHost = opts$1.host;
					if (!opts$1.port) requestedHost += `:${defaultProtocolPort(opts$1.protocol)}`;
					try {
						const { socket, statusCode } = await this[kClient].connect({
							origin,
							port,
							path: requestedHost,
							signal: opts$1.signal,
							headers: {
								...this[kProxyHeaders],
								host
							}
						});
						if (statusCode !== 200) {
							socket.on("error", () => {}).destroy();
							callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
						}
						if (opts$1.protocol !== "https:") {
							callback(null, socket);
							return;
						}
						let servername;
						if (this[kRequestTls]) servername = this[kRequestTls].servername;
						else servername = opts$1.servername;
						this[kConnectEndpoint]({
							...opts$1,
							servername,
							httpSocket: socket
						}, callback);
					} catch (err) {
						callback(err);
					}
				}
			});
		}
		dispatch(opts, handler$1) {
			const { host } = new URL$3(opts.origin);
			const headers = buildHeaders(opts.headers);
			throwIfProxyAuthIsSent(headers);
			return this[kAgent].dispatch({
				...opts,
				headers: {
					...headers,
					host
				}
			}, handler$1);
		}
		async [kClose]() {
			await this[kAgent].close();
			await this[kClient].close();
		}
		async [kDestroy]() {
			await this[kAgent].destroy();
			await this[kClient].destroy();
		}
	};
	/**
	* @param {string[] | Record<string, string>} headers
	* @returns {Record<string, string>}
	*/
	function buildHeaders(headers) {
		if (Array.isArray(headers)) {
			/** @type {Record<string, string>} */
			const headersPair = {};
			for (let i$1 = 0; i$1 < headers.length; i$1 += 2) headersPair[headers[i$1]] = headers[i$1 + 1];
			return headersPair;
		}
		return headers;
	}
	/**
	* @param {Record<string, string>} headers
	*
	* Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
	* Nevertheless, it was changed and to avoid a security vulnerability by end users
	* this check was created.
	* It should be removed in the next major version for performance reasons
	*/
	function throwIfProxyAuthIsSent(headers) {
		const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
		if (existProxyAuth) throw new InvalidArgumentError$2("Proxy-Authorization should be sent in ProxyAgent constructor");
	}
	module.exports = ProxyAgent$1;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/handler/RetryHandler.js"(exports, module) {
	const assert$8 = __require("assert");
	const { kRetryHandlerDefaultRetry } = require_symbols$4();
	const { RequestRetryError } = require_errors();
	const { isDisturbed: isDisturbed$1, parseHeaders, parseRangeHeader } = require_util$6();
	function calculateRetryAfterHeader(retryAfter) {
		const current = Date.now();
		const diff = new Date(retryAfter).getTime() - current;
		return diff;
	}
	var RetryHandler$1 = class RetryHandler$1 {
		constructor(opts, handlers) {
			const { retryOptions,...dispatchOpts } = opts;
			const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
			this.dispatch = handlers.dispatch;
			this.handler = handlers.handler;
			this.opts = dispatchOpts;
			this.abort = null;
			this.aborted = false;
			this.retryOpts = {
				retry: retryFn ?? RetryHandler$1[kRetryHandlerDefaultRetry],
				retryAfter: retryAfter ?? true,
				maxTimeout: maxTimeout ?? 30 * 1e3,
				timeout: minTimeout ?? 500,
				timeoutFactor: timeoutFactor ?? 2,
				maxRetries: maxRetries ?? 5,
				methods: methods ?? [
					"GET",
					"HEAD",
					"OPTIONS",
					"PUT",
					"DELETE",
					"TRACE"
				],
				statusCodes: statusCodes ?? [
					500,
					502,
					503,
					504,
					429
				],
				errorCodes: errorCodes ?? [
					"ECONNRESET",
					"ECONNREFUSED",
					"ENOTFOUND",
					"ENETDOWN",
					"ENETUNREACH",
					"EHOSTDOWN",
					"EHOSTUNREACH",
					"EPIPE"
				]
			};
			this.retryCount = 0;
			this.start = 0;
			this.end = null;
			this.etag = null;
			this.resume = null;
			this.handler.onConnect((reason) => {
				this.aborted = true;
				if (this.abort) this.abort(reason);
				else this.reason = reason;
			});
		}
		onRequestSent() {
			if (this.handler.onRequestSent) this.handler.onRequestSent();
		}
		onUpgrade(statusCode, headers, socket) {
			if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);
		}
		onConnect(abort$1) {
			if (this.aborted) abort$1(this.reason);
			else this.abort = abort$1;
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
		}
		static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
			const { statusCode, code, headers } = err;
			const { method, retryOptions } = opts;
			const { maxRetries, timeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
			let { counter, currentTimeout } = state;
			currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
			if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
				cb(err);
				return;
			}
			if (Array.isArray(methods) && !methods.includes(method)) {
				cb(err);
				return;
			}
			if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
				cb(err);
				return;
			}
			if (counter > maxRetries) {
				cb(err);
				return;
			}
			let retryAfterHeader = headers != null && headers["retry-after"];
			if (retryAfterHeader) {
				retryAfterHeader = Number(retryAfterHeader);
				retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
			}
			const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
			state.currentTimeout = retryTimeout;
			setTimeout(() => cb(null), retryTimeout);
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const headers = parseHeaders(rawHeaders);
			this.retryCount += 1;
			if (statusCode >= 300) {
				this.abort(new RequestRetryError("Request failed", statusCode, {
					headers,
					count: this.retryCount
				}));
				return false;
			}
			if (this.resume != null) {
				this.resume = null;
				if (statusCode !== 206) return true;
				const contentRange = parseRangeHeader(headers["content-range"]);
				if (!contentRange) {
					this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				if (this.etag != null && this.etag !== headers.etag) {
					this.abort(new RequestRetryError("ETag mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				const { start, size, end = size } = contentRange;
				assert$8(this.start === start, "content-range mismatch");
				assert$8(this.end == null || this.end === end, "content-range mismatch");
				this.resume = resume$1;
				return true;
			}
			if (this.end == null) {
				if (statusCode === 206) {
					const range = parseRangeHeader(headers["content-range"]);
					if (range == null) return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
					const { start, size, end = size } = range;
					assert$8(start != null && Number.isFinite(start) && this.start !== start, "content-range mismatch");
					assert$8(Number.isFinite(start));
					assert$8(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length");
					this.start = start;
					this.end = end;
				}
				if (this.end == null) {
					const contentLength = headers["content-length"];
					this.end = contentLength != null ? Number(contentLength) : null;
				}
				assert$8(Number.isFinite(this.start));
				assert$8(this.end == null || Number.isFinite(this.end), "invalid content-length");
				this.resume = resume$1;
				this.etag = headers.etag != null ? headers.etag : null;
				return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
			}
			const err = new RequestRetryError("Request failed", statusCode, {
				headers,
				count: this.retryCount
			});
			this.abort(err);
			return false;
		}
		onData(chunk) {
			this.start += chunk.length;
			return this.handler.onData(chunk);
		}
		onComplete(rawTrailers) {
			this.retryCount = 0;
			return this.handler.onComplete(rawTrailers);
		}
		onError(err) {
			if (this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err);
			this.retryOpts.retry(err, {
				state: {
					counter: this.retryCount++,
					currentTimeout: this.retryAfter
				},
				opts: {
					retryOptions: this.retryOpts,
					...this.opts
				}
			}, onRetry.bind(this));
			function onRetry(err$1) {
				if (err$1 != null || this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err$1);
				if (this.start !== 0) this.opts = {
					...this.opts,
					headers: {
						...this.opts.headers,
						range: `bytes=${this.start}-${this.end ?? ""}`
					}
				};
				try {
					this.dispatch(this.opts, this);
				} catch (err$2) {
					this.handler.onError(err$2);
				}
			}
		}
	};
	module.exports = RetryHandler$1;
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/global.js
var require_global = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/global.js"(exports, module) {
	const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
	const { InvalidArgumentError: InvalidArgumentError$1 } = require_errors();
	const Agent$2 = require_agent$1();
	if (getGlobalDispatcher$5() === void 0) setGlobalDispatcher$1(new Agent$2());
	function setGlobalDispatcher$1(agent) {
		if (!agent || typeof agent.dispatch !== "function") throw new InvalidArgumentError$1("Argument agent must implement Agent");
		Object.defineProperty(globalThis, globalDispatcher, {
			value: agent,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	function getGlobalDispatcher$5() {
		return globalThis[globalDispatcher];
	}
	module.exports = {
		setGlobalDispatcher: setGlobalDispatcher$1,
		getGlobalDispatcher: getGlobalDispatcher$5
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/handler/DecoratorHandler.js"(exports, module) {
	module.exports = class DecoratorHandler$1 {
		constructor(handler$1) {
			this.handler = handler$1;
		}
		onConnect(...args) {
			return this.handler.onConnect(...args);
		}
		onError(...args) {
			return this.handler.onError(...args);
		}
		onUpgrade(...args) {
			return this.handler.onUpgrade(...args);
		}
		onHeaders(...args) {
			return this.handler.onHeaders(...args);
		}
		onData(...args) {
			return this.handler.onData(...args);
		}
		onComplete(...args) {
			return this.handler.onComplete(...args);
		}
		onBodySent(...args) {
			return this.handler.onBodySent(...args);
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/headers.js"(exports, module) {
	const { kHeadersList: kHeadersList$6, kConstruct: kConstruct$4 } = require_symbols$4();
	const { kGuard: kGuard$4 } = require_symbols$3();
	const { kEnumerableProperty: kEnumerableProperty$7 } = require_util$6();
	const { makeIterator, isValidHeaderName: isValidHeaderName$1, isValidHeaderValue } = require_util$5();
	const { webidl: webidl$10 } = require_webidl();
	const assert$7 = __require("assert");
	const kHeadersMap = Symbol("headers map");
	const kHeadersSortedMap = Symbol("headers map sorted");
	/**
	* @param {number} code
	*/
	function isHTTPWhiteSpaceCharCode(code) {
		return code === 10 || code === 13 || code === 9 || code === 32;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	* @param {string} potentialValue
	*/
	function headerValueNormalize(potentialValue) {
		let i$1 = 0;
		let j = potentialValue.length;
		while (j > i$1 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
		while (j > i$1 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i$1))) ++i$1;
		return i$1 === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i$1, j);
	}
	function fill$1(headers, object) {
		if (Array.isArray(object)) for (let i$1 = 0; i$1 < object.length; ++i$1) {
			const header = object[i$1];
			if (header.length !== 2) throw webidl$10.errors.exception({
				header: "Headers constructor",
				message: `expected name/value pair to be length 2, found ${header.length}.`
			});
			appendHeader(headers, header[0], header[1]);
		}
		else if (typeof object === "object" && object !== null) {
			const keys = Object.keys(object);
			for (let i$1 = 0; i$1 < keys.length; ++i$1) appendHeader(headers, keys[i$1], object[keys[i$1]]);
		} else throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-headers-append
	*/
	function appendHeader(headers, name, value) {
		value = headerValueNormalize(value);
		if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value: name,
			type: "header name"
		});
		else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value,
			type: "header value"
		});
		if (headers[kGuard$4] === "immutable") throw new TypeError("immutable");
		else if (headers[kGuard$4] === "request-no-cors") {}
		return headers[kHeadersList$6].append(name, value);
	}
	var HeadersList$2 = class HeadersList$2 {
		/** @type {[string, string][]|null} */
		cookies = null;
		constructor(init$1) {
			if (init$1 instanceof HeadersList$2) {
				this[kHeadersMap] = new Map(init$1[kHeadersMap]);
				this[kHeadersSortedMap] = init$1[kHeadersSortedMap];
				this.cookies = init$1.cookies === null ? null : [...init$1.cookies];
			} else {
				this[kHeadersMap] = new Map(init$1);
				this[kHeadersSortedMap] = null;
			}
		}
		contains(name) {
			name = name.toLowerCase();
			return this[kHeadersMap].has(name);
		}
		clear() {
			this[kHeadersMap].clear();
			this[kHeadersSortedMap] = null;
			this.cookies = null;
		}
		append(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			const exists$1 = this[kHeadersMap].get(lowercaseName);
			if (exists$1) {
				const delimiter = lowercaseName === "cookie" ? "; " : ", ";
				this[kHeadersMap].set(lowercaseName, {
					name: exists$1.name,
					value: `${exists$1.value}${delimiter}${value}`
				});
			} else this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
			if (lowercaseName === "set-cookie") {
				this.cookies ??= [];
				this.cookies.push(value);
			}
		}
		set(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			if (lowercaseName === "set-cookie") this.cookies = [value];
			this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
		}
		delete(name) {
			this[kHeadersSortedMap] = null;
			name = name.toLowerCase();
			if (name === "set-cookie") this.cookies = null;
			this[kHeadersMap].delete(name);
		}
		get(name) {
			const value = this[kHeadersMap].get(name.toLowerCase());
			return value === void 0 ? null : value.value;
		}
		*[Symbol.iterator]() {
			for (const [name, { value }] of this[kHeadersMap]) yield [name, value];
		}
		get entries() {
			const headers = {};
			if (this[kHeadersMap].size) for (const { name, value } of this[kHeadersMap].values()) headers[name] = value;
			return headers;
		}
	};
	var Headers$8 = class Headers$8 {
		constructor(init$1 = void 0) {
			if (init$1 === kConstruct$4) return;
			this[kHeadersList$6] = new HeadersList$2();
			this[kGuard$4] = "none";
			if (init$1 !== void 0) {
				init$1 = webidl$10.converters.HeadersInit(init$1);
				fill$1(this, init$1);
			}
		}
		append(name, value) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			return appendHeader(this, name, value);
		}
		delete(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.delete",
				value: name,
				type: "header name"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			if (!this[kHeadersList$6].contains(name)) return;
			this[kHeadersList$6].delete(name);
		}
		get(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.get",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$6].get(name);
		}
		has(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.has",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$6].contains(name);
		}
		set(name, value) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			value = headerValueNormalize(value);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value: name,
				type: "header name"
			});
			else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value,
				type: "header value"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			this[kHeadersList$6].set(name, value);
		}
		getSetCookie() {
			webidl$10.brandCheck(this, Headers$8);
			const list = this[kHeadersList$6].cookies;
			if (list) return [...list];
			return [];
		}
		get [kHeadersSortedMap]() {
			if (this[kHeadersList$6][kHeadersSortedMap]) return this[kHeadersList$6][kHeadersSortedMap];
			const headers = [];
			const names = [...this[kHeadersList$6]].sort((a$1, b) => a$1[0] < b[0] ? -1 : 1);
			const cookies = this[kHeadersList$6].cookies;
			for (let i$1 = 0; i$1 < names.length; ++i$1) {
				const [name, value] = names[i$1];
				if (name === "set-cookie") for (let j = 0; j < cookies.length; ++j) headers.push([name, cookies[j]]);
				else {
					assert$7(value !== null);
					headers.push([name, value]);
				}
			}
			this[kHeadersList$6][kHeadersSortedMap] = headers;
			return headers;
		}
		keys() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
		}
		values() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
		}
		entries() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key+value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
		}
		/**
		* @param {(value: string, key: string, self: Headers) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
		[Symbol.for("nodejs.util.inspect.custom")]() {
			webidl$10.brandCheck(this, Headers$8);
			return this[kHeadersList$6];
		}
	};
	Headers$8.prototype[Symbol.iterator] = Headers$8.prototype.entries;
	Object.defineProperties(Headers$8.prototype, {
		append: kEnumerableProperty$7,
		delete: kEnumerableProperty$7,
		get: kEnumerableProperty$7,
		has: kEnumerableProperty$7,
		set: kEnumerableProperty$7,
		getSetCookie: kEnumerableProperty$7,
		keys: kEnumerableProperty$7,
		values: kEnumerableProperty$7,
		entries: kEnumerableProperty$7,
		forEach: kEnumerableProperty$7,
		[Symbol.iterator]: { enumerable: false },
		[Symbol.toStringTag]: {
			value: "Headers",
			configurable: true
		}
	});
	webidl$10.converters.HeadersInit = function(V) {
		if (webidl$10.util.Type(V) === "Object") {
			if (V[Symbol.iterator]) return webidl$10.converters["sequence<sequence<ByteString>>"](V);
			return webidl$10.converters["record<ByteString, ByteString>"](V);
		}
		throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	};
	module.exports = {
		fill: fill$1,
		Headers: Headers$8,
		HeadersList: HeadersList$2
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/response.js"(exports, module) {
	const { Headers: Headers$7, HeadersList: HeadersList$1, fill } = require_headers();
	const { extractBody: extractBody$1, cloneBody: cloneBody$1, mixinBody: mixinBody$1 } = require_body();
	const util$3 = require_util$6();
	const { kEnumerableProperty: kEnumerableProperty$6 } = util$3;
	const { isValidReasonPhrase, isCancelled: isCancelled$1, isAborted: isAborted$1, isBlobLike: isBlobLike$3, serializeJavascriptValueToJSONString, isErrorLike: isErrorLike$1, isomorphicEncode: isomorphicEncode$1 } = require_util$5();
	const { redirectStatusSet: redirectStatusSet$1, nullBodyStatus: nullBodyStatus$1, DOMException: DOMException$4 } = require_constants$4();
	const { kState: kState$6, kHeaders: kHeaders$3, kGuard: kGuard$3, kRealm: kRealm$3 } = require_symbols$3();
	const { webidl: webidl$9 } = require_webidl();
	const { FormData: FormData$2 } = require_formdata();
	const { getGlobalOrigin: getGlobalOrigin$2 } = require_global$1();
	const { URLSerializer: URLSerializer$3 } = require_dataURL();
	const { kHeadersList: kHeadersList$5, kConstruct: kConstruct$3 } = require_symbols$4();
	const assert$6 = __require("assert");
	const { types: types$2 } = __require("util");
	const ReadableStream$3 = globalThis.ReadableStream || __require("stream/web").ReadableStream;
	const textEncoder$2 = new TextEncoder("utf-8");
	var Response$4 = class Response$4 {
		static error() {
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$4();
			responseObject[kState$6] = makeNetworkError$1();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kHeadersList$5] = responseObject[kState$6].headersList;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			return responseObject;
		}
		static json(data, init$1 = {}) {
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.json" });
			if (init$1 !== null) init$1 = webidl$9.converters.ResponseInit(init$1);
			const bytes = textEncoder$2.encode(serializeJavascriptValueToJSONString(data));
			const body = extractBody$1(bytes);
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$4();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "response";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			initializeResponse(responseObject, init$1, {
				body: body[0],
				type: "application/json"
			});
			return responseObject;
		}
		static redirect(url, status = 302) {
			const relevantRealm = { settingsObject: {} };
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
			url = webidl$9.converters.USVString(url);
			status = webidl$9.converters["unsigned short"](status);
			let parsedURL;
			try {
				parsedURL = new URL(url, getGlobalOrigin$2());
			} catch (err) {
				throw Object.assign(/* @__PURE__ */ new TypeError("Failed to parse URL from " + url), { cause: err });
			}
			if (!redirectStatusSet$1.has(status)) throw new RangeError("Invalid status code " + status);
			const responseObject = new Response$4();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			responseObject[kState$6].status = status;
			const value = isomorphicEncode$1(URLSerializer$3(parsedURL));
			responseObject[kState$6].headersList.append("location", value);
			return responseObject;
		}
		constructor(body = null, init$1 = {}) {
			if (body !== null) body = webidl$9.converters.BodyInit(body);
			init$1 = webidl$9.converters.ResponseInit(init$1);
			this[kRealm$3] = { settingsObject: {} };
			this[kState$6] = makeResponse$1({});
			this[kHeaders$3] = new Headers$7(kConstruct$3);
			this[kHeaders$3][kGuard$3] = "response";
			this[kHeaders$3][kHeadersList$5] = this[kState$6].headersList;
			this[kHeaders$3][kRealm$3] = this[kRealm$3];
			let bodyWithType = null;
			if (body != null) {
				const [extractedBody, type] = extractBody$1(body);
				bodyWithType = {
					body: extractedBody,
					type
				};
			}
			initializeResponse(this, init$1, bodyWithType);
		}
		get type() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].type;
		}
		get url() {
			webidl$9.brandCheck(this, Response$4);
			const urlList = this[kState$6].urlList;
			const url = urlList[urlList.length - 1] ?? null;
			if (url === null) return "";
			return URLSerializer$3(url, true);
		}
		get redirected() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].urlList.length > 1;
		}
		get status() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].status;
		}
		get ok() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].status >= 200 && this[kState$6].status <= 299;
		}
		get statusText() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].statusText;
		}
		get headers() {
			webidl$9.brandCheck(this, Response$4);
			return this[kHeaders$3];
		}
		get body() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].body ? this[kState$6].body.stream : null;
		}
		get bodyUsed() {
			webidl$9.brandCheck(this, Response$4);
			return !!this[kState$6].body && util$3.isDisturbed(this[kState$6].body.stream);
		}
		clone() {
			webidl$9.brandCheck(this, Response$4);
			if (this.bodyUsed || this.body && this.body.locked) throw webidl$9.errors.exception({
				header: "Response.clone",
				message: "Body has already been consumed."
			});
			const clonedResponse = cloneResponse$1(this[kState$6]);
			const clonedResponseObject = new Response$4();
			clonedResponseObject[kState$6] = clonedResponse;
			clonedResponseObject[kRealm$3] = this[kRealm$3];
			clonedResponseObject[kHeaders$3][kHeadersList$5] = clonedResponse.headersList;
			clonedResponseObject[kHeaders$3][kGuard$3] = this[kHeaders$3][kGuard$3];
			clonedResponseObject[kHeaders$3][kRealm$3] = this[kHeaders$3][kRealm$3];
			return clonedResponseObject;
		}
	};
	mixinBody$1(Response$4);
	Object.defineProperties(Response$4.prototype, {
		type: kEnumerableProperty$6,
		url: kEnumerableProperty$6,
		status: kEnumerableProperty$6,
		ok: kEnumerableProperty$6,
		redirected: kEnumerableProperty$6,
		statusText: kEnumerableProperty$6,
		headers: kEnumerableProperty$6,
		clone: kEnumerableProperty$6,
		body: kEnumerableProperty$6,
		bodyUsed: kEnumerableProperty$6,
		[Symbol.toStringTag]: {
			value: "Response",
			configurable: true
		}
	});
	Object.defineProperties(Response$4, {
		json: kEnumerableProperty$6,
		redirect: kEnumerableProperty$6,
		error: kEnumerableProperty$6
	});
	function cloneResponse$1(response) {
		if (response.internalResponse) return filterResponse$1(cloneResponse$1(response.internalResponse), response.type);
		const newResponse = makeResponse$1({
			...response,
			body: null
		});
		if (response.body != null) newResponse.body = cloneBody$1(response.body);
		return newResponse;
	}
	function makeResponse$1(init$1) {
		return {
			aborted: false,
			rangeRequested: false,
			timingAllowPassed: false,
			requestIncludesCredentials: false,
			type: "default",
			status: 200,
			timingInfo: null,
			cacheState: "",
			statusText: "",
			...init$1,
			headersList: init$1.headersList ? new HeadersList$1(init$1.headersList) : new HeadersList$1(),
			urlList: init$1.urlList ? [...init$1.urlList] : []
		};
	}
	function makeNetworkError$1(reason) {
		const isError = isErrorLike$1(reason);
		return makeResponse$1({
			type: "error",
			status: 0,
			error: isError ? reason : new Error(reason ? String(reason) : reason),
			aborted: reason && reason.name === "AbortError"
		});
	}
	function makeFilteredResponse(response, state) {
		state = {
			internalResponse: response,
			...state
		};
		return new Proxy(response, {
			get(target, p) {
				return p in state ? state[p] : target[p];
			},
			set(target, p, value) {
				assert$6(!(p in state));
				target[p] = value;
				return true;
			}
		});
	}
	function filterResponse$1(response, type) {
		if (type === "basic") return makeFilteredResponse(response, {
			type: "basic",
			headersList: response.headersList
		});
		else if (type === "cors") return makeFilteredResponse(response, {
			type: "cors",
			headersList: response.headersList
		});
		else if (type === "opaque") return makeFilteredResponse(response, {
			type: "opaque",
			urlList: Object.freeze([]),
			status: 0,
			statusText: "",
			body: null
		});
		else if (type === "opaqueredirect") return makeFilteredResponse(response, {
			type: "opaqueredirect",
			status: 0,
			statusText: "",
			headersList: [],
			body: null
		});
		else assert$6(false);
	}
	function makeAppropriateNetworkError$1(fetchParams, err = null) {
		assert$6(isCancelled$1(fetchParams));
		return isAborted$1(fetchParams) ? makeNetworkError$1(Object.assign(new DOMException$4("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError$1(Object.assign(new DOMException$4("Request was cancelled."), { cause: err }));
	}
	function initializeResponse(response, init$1, body) {
		if (init$1.status !== null && (init$1.status < 200 || init$1.status > 599)) throw new RangeError("init[\"status\"] must be in the range of 200 to 599, inclusive.");
		if ("statusText" in init$1 && init$1.statusText != null) {
			if (!isValidReasonPhrase(String(init$1.statusText))) throw new TypeError("Invalid statusText");
		}
		if ("status" in init$1 && init$1.status != null) response[kState$6].status = init$1.status;
		if ("statusText" in init$1 && init$1.statusText != null) response[kState$6].statusText = init$1.statusText;
		if ("headers" in init$1 && init$1.headers != null) fill(response[kHeaders$3], init$1.headers);
		if (body) {
			if (nullBodyStatus$1.includes(response.status)) throw webidl$9.errors.exception({
				header: "Response constructor",
				message: "Invalid response status code " + response.status
			});
			response[kState$6].body = body.body;
			if (body.type != null && !response[kState$6].headersList.contains("Content-Type")) response[kState$6].headersList.append("content-type", body.type);
		}
	}
	webidl$9.converters.ReadableStream = webidl$9.interfaceConverter(ReadableStream$3);
	webidl$9.converters.FormData = webidl$9.interfaceConverter(FormData$2);
	webidl$9.converters.URLSearchParams = webidl$9.interfaceConverter(URLSearchParams);
	webidl$9.converters.XMLHttpRequestBodyInit = function(V) {
		if (typeof V === "string") return webidl$9.converters.USVString(V);
		if (isBlobLike$3(V)) return webidl$9.converters.Blob(V, { strict: false });
		if (types$2.isArrayBuffer(V) || types$2.isTypedArray(V) || types$2.isDataView(V)) return webidl$9.converters.BufferSource(V);
		if (util$3.isFormDataLike(V)) return webidl$9.converters.FormData(V, { strict: false });
		if (V instanceof URLSearchParams) return webidl$9.converters.URLSearchParams(V);
		return webidl$9.converters.DOMString(V);
	};
	webidl$9.converters.BodyInit = function(V) {
		if (V instanceof ReadableStream$3) return webidl$9.converters.ReadableStream(V);
		if (V?.[Symbol.asyncIterator]) return V;
		return webidl$9.converters.XMLHttpRequestBodyInit(V);
	};
	webidl$9.converters.ResponseInit = webidl$9.dictionaryConverter([
		{
			key: "status",
			converter: webidl$9.converters["unsigned short"],
			defaultValue: 200
		},
		{
			key: "statusText",
			converter: webidl$9.converters.ByteString,
			defaultValue: ""
		},
		{
			key: "headers",
			converter: webidl$9.converters.HeadersInit
		}
	]);
	module.exports = {
		makeNetworkError: makeNetworkError$1,
		makeResponse: makeResponse$1,
		makeAppropriateNetworkError: makeAppropriateNetworkError$1,
		filterResponse: filterResponse$1,
		Response: Response$4,
		cloneResponse: cloneResponse$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/request.js
var require_request = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/request.js"(exports, module) {
	const { extractBody, mixinBody, cloneBody } = require_body();
	const { Headers: Headers$6, fill: fillHeaders, HeadersList } = require_headers();
	const { FinalizationRegistry } = require_dispatcher_weakref()();
	const util$2 = require_util$6();
	const { isValidHTTPToken, sameOrigin: sameOrigin$1, normalizeMethod, makePolicyContainer: makePolicyContainer$1, normalizeMethodRecord } = require_util$5();
	const { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = require_constants$4();
	const { kEnumerableProperty: kEnumerableProperty$5 } = util$2;
	const { kHeaders: kHeaders$2, kSignal, kState: kState$5, kGuard: kGuard$2, kRealm: kRealm$2 } = require_symbols$3();
	const { webidl: webidl$8 } = require_webidl();
	const { getGlobalOrigin: getGlobalOrigin$1 } = require_global$1();
	const { URLSerializer: URLSerializer$2 } = require_dataURL();
	const { kHeadersList: kHeadersList$4, kConstruct: kConstruct$2 } = require_symbols$4();
	const assert$5 = __require("assert");
	const { getMaxListeners, setMaxListeners: setMaxListeners$1, getEventListeners, defaultMaxListeners } = __require("events");
	let TransformStream$1 = globalThis.TransformStream;
	const kAbortController = Symbol("abortController");
	const requestFinalizer = new FinalizationRegistry(({ signal, abort: abort$1 }) => {
		signal.removeEventListener("abort", abort$1);
	});
	var Request$4 = class Request$4 {
		constructor(input, init$1 = {}) {
			if (input === kConstruct$2) return;
			webidl$8.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
			input = webidl$8.converters.RequestInfo(input);
			init$1 = webidl$8.converters.RequestInit(init$1);
			this[kRealm$2] = { settingsObject: {
				baseUrl: getGlobalOrigin$1(),
				get origin() {
					return this.baseUrl?.origin;
				},
				policyContainer: makePolicyContainer$1()
			} };
			let request$2 = null;
			let fallbackMode = null;
			const baseUrl$1 = this[kRealm$2].settingsObject.baseUrl;
			let signal = null;
			if (typeof input === "string") {
				let parsedURL;
				try {
					parsedURL = new URL(input, baseUrl$1);
				} catch (err) {
					throw new TypeError("Failed to parse URL from " + input, { cause: err });
				}
				if (parsedURL.username || parsedURL.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
				request$2 = makeRequest$2({ urlList: [parsedURL] });
				fallbackMode = "cors";
			} else {
				assert$5(input instanceof Request$4);
				request$2 = input[kState$5];
				signal = input[kSignal];
			}
			const origin = this[kRealm$2].settingsObject.origin;
			let window$1 = "client";
			if (request$2.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin$1(request$2.window, origin)) window$1 = request$2.window;
			if (init$1.window != null) throw new TypeError(`'window' option '${window$1}' must be null`);
			if ("window" in init$1) window$1 = "no-window";
			request$2 = makeRequest$2({
				method: request$2.method,
				headersList: request$2.headersList,
				unsafeRequest: request$2.unsafeRequest,
				client: this[kRealm$2].settingsObject,
				window: window$1,
				priority: request$2.priority,
				origin: request$2.origin,
				referrer: request$2.referrer,
				referrerPolicy: request$2.referrerPolicy,
				mode: request$2.mode,
				credentials: request$2.credentials,
				cache: request$2.cache,
				redirect: request$2.redirect,
				integrity: request$2.integrity,
				keepalive: request$2.keepalive,
				reloadNavigation: request$2.reloadNavigation,
				historyNavigation: request$2.historyNavigation,
				urlList: [...request$2.urlList]
			});
			const initHasKey = Object.keys(init$1).length !== 0;
			if (initHasKey) {
				if (request$2.mode === "navigate") request$2.mode = "same-origin";
				request$2.reloadNavigation = false;
				request$2.historyNavigation = false;
				request$2.origin = "client";
				request$2.referrer = "client";
				request$2.referrerPolicy = "";
				request$2.url = request$2.urlList[request$2.urlList.length - 1];
				request$2.urlList = [request$2.url];
			}
			if (init$1.referrer !== void 0) {
				const referrer = init$1.referrer;
				if (referrer === "") request$2.referrer = "no-referrer";
				else {
					let parsedReferrer;
					try {
						parsedReferrer = new URL(referrer, baseUrl$1);
					} catch (err) {
						throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
					}
					if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin$1(parsedReferrer, this[kRealm$2].settingsObject.baseUrl)) request$2.referrer = "client";
					else request$2.referrer = parsedReferrer;
				}
			}
			if (init$1.referrerPolicy !== void 0) request$2.referrerPolicy = init$1.referrerPolicy;
			let mode;
			if (init$1.mode !== void 0) mode = init$1.mode;
			else mode = fallbackMode;
			if (mode === "navigate") throw webidl$8.errors.exception({
				header: "Request constructor",
				message: "invalid request mode navigate."
			});
			if (mode != null) request$2.mode = mode;
			if (init$1.credentials !== void 0) request$2.credentials = init$1.credentials;
			if (init$1.cache !== void 0) request$2.cache = init$1.cache;
			if (request$2.cache === "only-if-cached" && request$2.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
			if (init$1.redirect !== void 0) request$2.redirect = init$1.redirect;
			if (init$1.integrity != null) request$2.integrity = String(init$1.integrity);
			if (init$1.keepalive !== void 0) request$2.keepalive = Boolean(init$1.keepalive);
			if (init$1.method !== void 0) {
				let method = init$1.method;
				if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
				if (forbiddenMethodsSet.has(method.toUpperCase())) throw new TypeError(`'${method}' HTTP method is unsupported.`);
				method = normalizeMethodRecord[method] ?? normalizeMethod(method);
				request$2.method = method;
			}
			if (init$1.signal !== void 0) signal = init$1.signal;
			this[kState$5] = request$2;
			const ac = new AbortController();
			this[kSignal] = ac.signal;
			this[kSignal][kRealm$2] = this[kRealm$2];
			if (signal != null) {
				if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
				if (signal.aborted) ac.abort(signal.reason);
				else {
					this[kAbortController] = ac;
					const acRef = new WeakRef(ac);
					const abort$1 = function() {
						const ac$1 = acRef.deref();
						if (ac$1 !== void 0) ac$1.abort(this.reason);
					};
					try {
						if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners$1(100, signal);
						else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) setMaxListeners$1(100, signal);
					} catch {}
					util$2.addAbortListener(signal, abort$1);
					requestFinalizer.register(ac, {
						signal,
						abort: abort$1
					});
				}
			}
			this[kHeaders$2] = new Headers$6(kConstruct$2);
			this[kHeaders$2][kHeadersList$4] = request$2.headersList;
			this[kHeaders$2][kGuard$2] = "request";
			this[kHeaders$2][kRealm$2] = this[kRealm$2];
			if (mode === "no-cors") {
				if (!corsSafeListedMethodsSet.has(request$2.method)) throw new TypeError(`'${request$2.method} is unsupported in no-cors mode.`);
				this[kHeaders$2][kGuard$2] = "request-no-cors";
			}
			if (initHasKey) {
				/** @type {HeadersList} */
				const headersList = this[kHeaders$2][kHeadersList$4];
				const headers = init$1.headers !== void 0 ? init$1.headers : new HeadersList(headersList);
				headersList.clear();
				if (headers instanceof HeadersList) {
					for (const [key, val] of headers) headersList.append(key, val);
					headersList.cookies = headers.cookies;
				} else fillHeaders(this[kHeaders$2], headers);
			}
			const inputBody = input instanceof Request$4 ? input[kState$5].body : null;
			if ((init$1.body != null || inputBody != null) && (request$2.method === "GET" || request$2.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
			let initBody = null;
			if (init$1.body != null) {
				const [extractedBody, contentType] = extractBody(init$1.body, request$2.keepalive);
				initBody = extractedBody;
				if (contentType && !this[kHeaders$2][kHeadersList$4].contains("content-type")) this[kHeaders$2].append("content-type", contentType);
			}
			const inputOrInitBody = initBody ?? inputBody;
			if (inputOrInitBody != null && inputOrInitBody.source == null) {
				if (initBody != null && init$1.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
				if (request$2.mode !== "same-origin" && request$2.mode !== "cors") throw new TypeError("If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"");
				request$2.useCORSPreflightFlag = true;
			}
			let finalBody = inputOrInitBody;
			if (initBody == null && inputBody != null) {
				if (util$2.isDisturbed(inputBody.stream) || inputBody.stream.locked) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
				if (!TransformStream$1) TransformStream$1 = __require("stream/web").TransformStream;
				const identityTransform = new TransformStream$1();
				inputBody.stream.pipeThrough(identityTransform);
				finalBody = {
					source: inputBody.source,
					length: inputBody.length,
					stream: identityTransform.readable
				};
			}
			this[kState$5].body = finalBody;
		}
		get method() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].method;
		}
		get url() {
			webidl$8.brandCheck(this, Request$4);
			return URLSerializer$2(this[kState$5].url);
		}
		get headers() {
			webidl$8.brandCheck(this, Request$4);
			return this[kHeaders$2];
		}
		get destination() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].destination;
		}
		get referrer() {
			webidl$8.brandCheck(this, Request$4);
			if (this[kState$5].referrer === "no-referrer") return "";
			if (this[kState$5].referrer === "client") return "about:client";
			return this[kState$5].referrer.toString();
		}
		get referrerPolicy() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].referrerPolicy;
		}
		get mode() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].mode;
		}
		get credentials() {
			return this[kState$5].credentials;
		}
		get cache() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].cache;
		}
		get redirect() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].redirect;
		}
		get integrity() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].integrity;
		}
		get keepalive() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].keepalive;
		}
		get isReloadNavigation() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].reloadNavigation;
		}
		get isHistoryNavigation() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].historyNavigation;
		}
		get signal() {
			webidl$8.brandCheck(this, Request$4);
			return this[kSignal];
		}
		get body() {
			webidl$8.brandCheck(this, Request$4);
			return this[kState$5].body ? this[kState$5].body.stream : null;
		}
		get bodyUsed() {
			webidl$8.brandCheck(this, Request$4);
			return !!this[kState$5].body && util$2.isDisturbed(this[kState$5].body.stream);
		}
		get duplex() {
			webidl$8.brandCheck(this, Request$4);
			return "half";
		}
		clone() {
			webidl$8.brandCheck(this, Request$4);
			if (this.bodyUsed || this.body?.locked) throw new TypeError("unusable");
			const clonedRequest = cloneRequest(this[kState$5]);
			const clonedRequestObject = new Request$4(kConstruct$2);
			clonedRequestObject[kState$5] = clonedRequest;
			clonedRequestObject[kRealm$2] = this[kRealm$2];
			clonedRequestObject[kHeaders$2] = new Headers$6(kConstruct$2);
			clonedRequestObject[kHeaders$2][kHeadersList$4] = clonedRequest.headersList;
			clonedRequestObject[kHeaders$2][kGuard$2] = this[kHeaders$2][kGuard$2];
			clonedRequestObject[kHeaders$2][kRealm$2] = this[kHeaders$2][kRealm$2];
			const ac = new AbortController();
			if (this.signal.aborted) ac.abort(this.signal.reason);
			else util$2.addAbortListener(this.signal, () => {
				ac.abort(this.signal.reason);
			});
			clonedRequestObject[kSignal] = ac.signal;
			return clonedRequestObject;
		}
	};
	mixinBody(Request$4);
	function makeRequest$2(init$1) {
		const request$2 = {
			method: "GET",
			localURLsOnly: false,
			unsafeRequest: false,
			body: null,
			client: null,
			reservedClient: null,
			replacesClientId: "",
			window: "client",
			keepalive: false,
			serviceWorkers: "all",
			initiator: "",
			destination: "",
			priority: null,
			origin: "client",
			policyContainer: "client",
			referrer: "client",
			referrerPolicy: "",
			mode: "no-cors",
			useCORSPreflightFlag: false,
			credentials: "same-origin",
			useCredentials: false,
			cache: "default",
			redirect: "follow",
			integrity: "",
			cryptoGraphicsNonceMetadata: "",
			parserMetadata: "",
			reloadNavigation: false,
			historyNavigation: false,
			userActivation: false,
			taintedOrigin: false,
			redirectCount: 0,
			responseTainting: "basic",
			preventNoCacheCacheControlHeaderModification: false,
			done: false,
			timingAllowFailed: false,
			...init$1,
			headersList: init$1.headersList ? new HeadersList(init$1.headersList) : new HeadersList()
		};
		request$2.url = request$2.urlList[0];
		return request$2;
	}
	function cloneRequest(request$2) {
		const newRequest = makeRequest$2({
			...request$2,
			body: null
		});
		if (request$2.body != null) newRequest.body = cloneBody(request$2.body);
		return newRequest;
	}
	Object.defineProperties(Request$4.prototype, {
		method: kEnumerableProperty$5,
		url: kEnumerableProperty$5,
		headers: kEnumerableProperty$5,
		redirect: kEnumerableProperty$5,
		clone: kEnumerableProperty$5,
		signal: kEnumerableProperty$5,
		duplex: kEnumerableProperty$5,
		destination: kEnumerableProperty$5,
		body: kEnumerableProperty$5,
		bodyUsed: kEnumerableProperty$5,
		isHistoryNavigation: kEnumerableProperty$5,
		isReloadNavigation: kEnumerableProperty$5,
		keepalive: kEnumerableProperty$5,
		integrity: kEnumerableProperty$5,
		cache: kEnumerableProperty$5,
		credentials: kEnumerableProperty$5,
		attribute: kEnumerableProperty$5,
		referrerPolicy: kEnumerableProperty$5,
		referrer: kEnumerableProperty$5,
		mode: kEnumerableProperty$5,
		[Symbol.toStringTag]: {
			value: "Request",
			configurable: true
		}
	});
	webidl$8.converters.Request = webidl$8.interfaceConverter(Request$4);
	webidl$8.converters.RequestInfo = function(V) {
		if (typeof V === "string") return webidl$8.converters.USVString(V);
		if (V instanceof Request$4) return webidl$8.converters.Request(V);
		return webidl$8.converters.USVString(V);
	};
	webidl$8.converters.AbortSignal = webidl$8.interfaceConverter(AbortSignal);
	webidl$8.converters.RequestInit = webidl$8.dictionaryConverter([
		{
			key: "method",
			converter: webidl$8.converters.ByteString
		},
		{
			key: "headers",
			converter: webidl$8.converters.HeadersInit
		},
		{
			key: "body",
			converter: webidl$8.nullableConverter(webidl$8.converters.BodyInit)
		},
		{
			key: "referrer",
			converter: webidl$8.converters.USVString
		},
		{
			key: "referrerPolicy",
			converter: webidl$8.converters.DOMString,
			allowedValues: referrerPolicy
		},
		{
			key: "mode",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestMode
		},
		{
			key: "credentials",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCredentials
		},
		{
			key: "cache",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCache
		},
		{
			key: "redirect",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestRedirect
		},
		{
			key: "integrity",
			converter: webidl$8.converters.DOMString
		},
		{
			key: "keepalive",
			converter: webidl$8.converters.boolean
		},
		{
			key: "signal",
			converter: webidl$8.nullableConverter((signal) => webidl$8.converters.AbortSignal(signal, { strict: false }))
		},
		{
			key: "window",
			converter: webidl$8.converters.any
		},
		{
			key: "duplex",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestDuplex
		}
	]);
	module.exports = {
		Request: Request$4,
		makeRequest: makeRequest$2
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fetch/index.js"(exports, module) {
	const { Response: Response$3, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = require_response();
	const { Headers: Headers$5 } = require_headers();
	const { Request: Request$3, makeRequest: makeRequest$1 } = require_request();
	const zlib$1 = __require("zlib");
	const { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise: createDeferredPromise$1, isBlobLike: isBlobLike$2, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$1, urlHasHttpsScheme } = require_util$5();
	const { kState: kState$4, kHeaders: kHeaders$1, kGuard: kGuard$1, kRealm: kRealm$1 } = require_symbols$3();
	const assert$4 = __require("assert");
	const { safelyExtractBody } = require_body();
	const { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException: DOMException$3 } = require_constants$4();
	const { kHeadersList: kHeadersList$3 } = require_symbols$4();
	const EE = __require("events");
	const { Readable: Readable$2, pipeline } = __require("stream");
	const { addAbortListener: addAbortListener$1, isErrored, isReadable, nodeMajor, nodeMinor } = require_util$6();
	const { dataURLProcessor, serializeAMimeType: serializeAMimeType$1 } = require_dataURL();
	const { TransformStream } = __require("stream/web");
	const { getGlobalDispatcher: getGlobalDispatcher$4 } = require_global();
	const { webidl: webidl$7 } = require_webidl();
	const { STATUS_CODES: STATUS_CODES$1 } = __require("http");
	const GET_OR_HEAD = ["GET", "HEAD"];
	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	let ReadableStream$2 = globalThis.ReadableStream;
	var Fetch = class extends EE {
		constructor(dispatcher) {
			super();
			this.dispatcher = dispatcher;
			this.connection = null;
			this.dump = false;
			this.state = "ongoing";
			this.setMaxListeners(21);
		}
		terminate(reason) {
			if (this.state !== "ongoing") return;
			this.state = "terminated";
			this.connection?.destroy(reason);
			this.emit("terminated", reason);
		}
		abort(error$1) {
			if (this.state !== "ongoing") return;
			this.state = "aborted";
			if (!error$1) error$1 = new DOMException$3("The operation was aborted.", "AbortError");
			this.serializedAbortReason = error$1;
			this.connection?.destroy(error$1);
			this.emit("terminated", error$1);
		}
	};
	function fetch$2(input, init$1 = {}) {
		webidl$7.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
		const p = createDeferredPromise$1();
		let requestObject;
		try {
			requestObject = new Request$3(input, init$1);
		} catch (e) {
			p.reject(e);
			return p.promise;
		}
		const request$2 = requestObject[kState$4];
		if (requestObject.signal.aborted) {
			abortFetch(p, request$2, null, requestObject.signal.reason);
			return p.promise;
		}
		const globalObject = request$2.client.globalObject;
		if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") request$2.serviceWorkers = "none";
		let responseObject = null;
		const relevantRealm = null;
		let locallyAborted = false;
		let controller = null;
		addAbortListener$1(requestObject.signal, () => {
			locallyAborted = true;
			assert$4(controller != null);
			controller.abort(requestObject.signal.reason);
			abortFetch(p, request$2, responseObject, requestObject.signal.reason);
		});
		const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
		const processResponse = (response) => {
			if (locallyAborted) return Promise.resolve();
			if (response.aborted) {
				abortFetch(p, request$2, responseObject, controller.serializedAbortReason);
				return Promise.resolve();
			}
			if (response.type === "error") {
				p.reject(Object.assign(/* @__PURE__ */ new TypeError("fetch failed"), { cause: response.error }));
				return Promise.resolve();
			}
			responseObject = new Response$3();
			responseObject[kState$4] = response;
			responseObject[kRealm$1] = relevantRealm;
			responseObject[kHeaders$1][kHeadersList$3] = response.headersList;
			responseObject[kHeaders$1][kGuard$1] = "immutable";
			responseObject[kHeaders$1][kRealm$1] = relevantRealm;
			p.resolve(responseObject);
		};
		controller = fetching$2({
			request: request$2,
			processResponseEndOfBody: handleFetchDone,
			processResponse,
			dispatcher: init$1.dispatcher ?? getGlobalDispatcher$4()
		});
		return p.promise;
	}
	function finalizeAndReportTiming(response, initiatorType = "other") {
		if (response.type === "error" && response.aborted) return;
		if (!response.urlList?.length) return;
		const originalURL = response.urlList[0];
		let timingInfo = response.timingInfo;
		let cacheState = response.cacheState;
		if (!urlIsHttpHttpsScheme$1(originalURL)) return;
		if (timingInfo === null) return;
		if (!response.timingAllowPassed) {
			timingInfo = createOpaqueTimingInfo({ startTime: timingInfo.startTime });
			cacheState = "";
		}
		timingInfo.endTime = coarsenedSharedCurrentTime();
		response.timingInfo = timingInfo;
		markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
	}
	function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis$1, cacheState) {
		if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis$1, cacheState);
	}
	function abortFetch(p, request$2, responseObject, error$1) {
		if (!error$1) error$1 = new DOMException$3("The operation was aborted.", "AbortError");
		p.reject(error$1);
		if (request$2.body != null && isReadable(request$2.body?.stream)) request$2.body.stream.cancel(error$1).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
		if (responseObject == null) return;
		const response = responseObject[kState$4];
		if (response.body != null && isReadable(response.body?.stream)) response.body.stream.cancel(error$1).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
	}
	function fetching$2({ request: request$2, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher }) {
		let taskDestination = null;
		let crossOriginIsolatedCapability = false;
		if (request$2.client != null) {
			taskDestination = request$2.client.globalObject;
			crossOriginIsolatedCapability = request$2.client.crossOriginIsolatedCapability;
		}
		const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
		const timingInfo = createOpaqueTimingInfo({ startTime: currenTime });
		const fetchParams = {
			controller: new Fetch(dispatcher),
			request: request$2,
			timingInfo,
			processRequestBodyChunkLength,
			processRequestEndOfBody,
			processResponse,
			processResponseConsumeBody,
			processResponseEndOfBody,
			taskDestination,
			crossOriginIsolatedCapability
		};
		assert$4(!request$2.body || request$2.body.stream);
		if (request$2.window === "client") request$2.window = request$2.client?.globalObject?.constructor?.name === "Window" ? request$2.client : "no-window";
		if (request$2.origin === "client") request$2.origin = request$2.client?.origin;
		if (request$2.policyContainer === "client") if (request$2.client != null) request$2.policyContainer = clonePolicyContainer(request$2.client.policyContainer);
		else request$2.policyContainer = makePolicyContainer();
		if (!request$2.headersList.contains("accept")) {
			const value = "*/*";
			request$2.headersList.append("accept", value);
		}
		if (!request$2.headersList.contains("accept-language")) request$2.headersList.append("accept-language", "*");
		if (request$2.priority === null) {}
		if (subresourceSet.has(request$2.destination)) {}
		mainFetch(fetchParams).catch((err) => {
			fetchParams.controller.terminate(err);
		});
		return fetchParams.controller;
	}
	async function mainFetch(fetchParams, recursive = false) {
		const request$2 = fetchParams.request;
		let response = null;
		if (request$2.localURLsOnly && !urlIsLocal(requestCurrentURL(request$2))) response = makeNetworkError("local URLs only");
		tryUpgradeRequestToAPotentiallyTrustworthyURL(request$2);
		if (requestBadPort(request$2) === "blocked") response = makeNetworkError("bad port");
		if (request$2.referrerPolicy === "") request$2.referrerPolicy = request$2.policyContainer.referrerPolicy;
		if (request$2.referrer !== "no-referrer") request$2.referrer = determineRequestsReferrer(request$2);
		if (response === null) response = await (async () => {
			const currentURL = requestCurrentURL(request$2);
			if (sameOrigin(currentURL, request$2.url) && request$2.responseTainting === "basic" || currentURL.protocol === "data:" || request$2.mode === "navigate" || request$2.mode === "websocket") {
				request$2.responseTainting = "basic";
				return await schemeFetch(fetchParams);
			}
			if (request$2.mode === "same-origin") return makeNetworkError("request mode cannot be \"same-origin\"");
			if (request$2.mode === "no-cors") {
				if (request$2.redirect !== "follow") return makeNetworkError("redirect mode cannot be \"follow\" for \"no-cors\" request");
				request$2.responseTainting = "opaque";
				return await schemeFetch(fetchParams);
			}
			if (!urlIsHttpHttpsScheme$1(requestCurrentURL(request$2))) return makeNetworkError("URL scheme must be a HTTP(S) scheme");
			request$2.responseTainting = "cors";
			return await httpFetch(fetchParams);
		})();
		if (recursive) return response;
		if (response.status !== 0 && !response.internalResponse) {
			if (request$2.responseTainting === "cors") {}
			if (request$2.responseTainting === "basic") response = filterResponse(response, "basic");
			else if (request$2.responseTainting === "cors") response = filterResponse(response, "cors");
			else if (request$2.responseTainting === "opaque") response = filterResponse(response, "opaque");
			else assert$4(false);
		}
		let internalResponse = response.status === 0 ? response : response.internalResponse;
		if (internalResponse.urlList.length === 0) internalResponse.urlList.push(...request$2.urlList);
		if (!request$2.timingAllowFailed) response.timingAllowPassed = true;
		if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request$2.headers.contains("range")) response = internalResponse = makeNetworkError();
		if (response.status !== 0 && (request$2.method === "HEAD" || request$2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
			internalResponse.body = null;
			fetchParams.controller.dump = true;
		}
		if (request$2.integrity) {
			const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
			if (request$2.responseTainting === "opaque" || response.body == null) {
				processBodyError(response.error);
				return;
			}
			const processBody = (bytes) => {
				if (!bytesMatch(bytes, request$2.integrity)) {
					processBodyError("integrity mismatch");
					return;
				}
				response.body = safelyExtractBody(bytes)[0];
				fetchFinale(fetchParams, response);
			};
			await fullyReadBody(response.body, processBody, processBodyError);
		} else fetchFinale(fetchParams, response);
	}
	function schemeFetch(fetchParams) {
		if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
		const { request: request$2 } = fetchParams;
		const { protocol: scheme } = requestCurrentURL(request$2);
		switch (scheme) {
			case "about:": return Promise.resolve(makeNetworkError("about scheme is not supported"));
			case "blob:": {
				if (!resolveObjectURL) resolveObjectURL = __require("buffer").resolveObjectURL;
				const blobURLEntry = requestCurrentURL(request$2);
				if (blobURLEntry.search.length !== 0) return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
				const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
				if (request$2.method !== "GET" || !isBlobLike$2(blobURLEntryObject)) return Promise.resolve(makeNetworkError("invalid method"));
				const bodyWithType = safelyExtractBody(blobURLEntryObject);
				const body = bodyWithType[0];
				const length = isomorphicEncode(`${body.length}`);
				const type = bodyWithType[1] ?? "";
				const response = makeResponse({
					statusText: "OK",
					headersList: [["content-length", {
						name: "Content-Length",
						value: length
					}], ["content-type", {
						name: "Content-Type",
						value: type
					}]]
				});
				response.body = body;
				return Promise.resolve(response);
			}
			case "data:": {
				const currentURL = requestCurrentURL(request$2);
				const dataURLStruct = dataURLProcessor(currentURL);
				if (dataURLStruct === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
				const mimeType = serializeAMimeType$1(dataURLStruct.mimeType);
				return Promise.resolve(makeResponse({
					statusText: "OK",
					headersList: [["content-type", {
						name: "Content-Type",
						value: mimeType
					}]],
					body: safelyExtractBody(dataURLStruct.body)[0]
				}));
			}
			case "file:": return Promise.resolve(makeNetworkError("not implemented... yet..."));
			case "http:":
			case "https:": return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
			default: return Promise.resolve(makeNetworkError("unknown scheme"));
		}
	}
	function finalizeResponse$1(fetchParams, response) {
		fetchParams.request.done = true;
		if (fetchParams.processResponseDone != null) queueMicrotask(() => fetchParams.processResponseDone(response));
	}
	function fetchFinale(fetchParams, response) {
		if (response.type === "error") {
			response.urlList = [fetchParams.request.urlList[0]];
			response.timingInfo = createOpaqueTimingInfo({ startTime: fetchParams.timingInfo.startTime });
		}
		const processResponseEndOfBody = () => {
			fetchParams.request.done = true;
			if (fetchParams.processResponseEndOfBody != null) queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
		};
		if (fetchParams.processResponse != null) queueMicrotask(() => fetchParams.processResponse(response));
		if (response.body == null) processResponseEndOfBody();
		else {
			const identityTransformAlgorithm = (chunk, controller) => {
				controller.enqueue(chunk);
			};
			const transformStream = new TransformStream({
				start() {},
				transform: identityTransformAlgorithm,
				flush: processResponseEndOfBody
			}, { size() {
				return 1;
			} }, { size() {
				return 1;
			} });
			response.body = { stream: response.body.stream.pipeThrough(transformStream) };
		}
		if (fetchParams.processResponseConsumeBody != null) {
			const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
			const processBodyError = (failure$1) => fetchParams.processResponseConsumeBody(response, failure$1);
			if (response.body == null) queueMicrotask(() => processBody(null));
			else return fullyReadBody(response.body, processBody, processBodyError);
			return Promise.resolve();
		}
	}
	async function httpFetch(fetchParams) {
		const request$2 = fetchParams.request;
		let response = null;
		let actualResponse = null;
		const timingInfo = fetchParams.timingInfo;
		if (request$2.serviceWorkers === "all") {}
		if (response === null) {
			if (request$2.redirect === "follow") request$2.serviceWorkers = "none";
			actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
			if (request$2.responseTainting === "cors" && corsCheck(request$2, response) === "failure") return makeNetworkError("cors failure");
			if (TAOCheck(request$2, response) === "failure") request$2.timingAllowFailed = true;
		}
		if ((request$2.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request$2.origin, request$2.client, request$2.destination, actualResponse) === "blocked") return makeNetworkError("blocked");
		if (redirectStatusSet.has(actualResponse.status)) {
			if (request$2.redirect !== "manual") fetchParams.controller.connection.destroy();
			if (request$2.redirect === "error") response = makeNetworkError("unexpected redirect");
			else if (request$2.redirect === "manual") response = actualResponse;
			else if (request$2.redirect === "follow") response = await httpRedirectFetch(fetchParams, response);
			else assert$4(false);
		}
		response.timingInfo = timingInfo;
		return response;
	}
	function httpRedirectFetch(fetchParams, response) {
		const request$2 = fetchParams.request;
		const actualResponse = response.internalResponse ? response.internalResponse : response;
		let locationURL;
		try {
			locationURL = responseLocationURL(actualResponse, requestCurrentURL(request$2).hash);
			if (locationURL == null) return response;
		} catch (err) {
			return Promise.resolve(makeNetworkError(err));
		}
		if (!urlIsHttpHttpsScheme$1(locationURL)) return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
		if (request$2.redirectCount === 20) return Promise.resolve(makeNetworkError("redirect count exceeded"));
		request$2.redirectCount += 1;
		if (request$2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request$2, locationURL)) return Promise.resolve(makeNetworkError("cross origin not allowed for request mode \"cors\""));
		if (request$2.responseTainting === "cors" && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError("URL cannot contain credentials for request mode \"cors\""));
		if (actualResponse.status !== 303 && request$2.body != null && request$2.body.source == null) return Promise.resolve(makeNetworkError());
		if ([301, 302].includes(actualResponse.status) && request$2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request$2.method)) {
			request$2.method = "GET";
			request$2.body = null;
			for (const headerName of requestBodyHeader) request$2.headersList.delete(headerName);
		}
		if (!sameOrigin(requestCurrentURL(request$2), locationURL)) {
			request$2.headersList.delete("authorization");
			request$2.headersList.delete("proxy-authorization", true);
			request$2.headersList.delete("cookie");
			request$2.headersList.delete("host");
		}
		if (request$2.body != null) {
			assert$4(request$2.body.source != null);
			request$2.body = safelyExtractBody(request$2.body.source)[0];
		}
		const timingInfo = fetchParams.timingInfo;
		timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
		if (timingInfo.redirectStartTime === 0) timingInfo.redirectStartTime = timingInfo.startTime;
		request$2.urlList.push(locationURL);
		setRequestReferrerPolicyOnRedirect(request$2, actualResponse);
		return mainFetch(fetchParams, true);
	}
	async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
		const request$2 = fetchParams.request;
		let httpFetchParams = null;
		let httpRequest = null;
		let response = null;
		const httpCache = null;
		const revalidatingFlag = false;
		if (request$2.window === "no-window" && request$2.redirect === "error") {
			httpFetchParams = fetchParams;
			httpRequest = request$2;
		} else {
			httpRequest = makeRequest$1(request$2);
			httpFetchParams = { ...fetchParams };
			httpFetchParams.request = httpRequest;
		}
		const includeCredentials = request$2.credentials === "include" || request$2.credentials === "same-origin" && request$2.responseTainting === "basic";
		const contentLength = httpRequest.body ? httpRequest.body.length : null;
		let contentLengthHeaderValue = null;
		if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) contentLengthHeaderValue = "0";
		if (contentLength != null) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
		if (contentLengthHeaderValue != null) httpRequest.headersList.append("content-length", contentLengthHeaderValue);
		if (contentLength != null && httpRequest.keepalive) {}
		if (httpRequest.referrer instanceof URL) httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
		appendRequestOriginHeader(httpRequest);
		appendFetchMetadata(httpRequest);
		if (!httpRequest.headersList.contains("user-agent")) httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
		if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) httpRequest.cache = "no-store";
		if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "max-age=0");
		if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
			if (!httpRequest.headersList.contains("pragma")) httpRequest.headersList.append("pragma", "no-cache");
			if (!httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "no-cache");
		}
		if (httpRequest.headersList.contains("range")) httpRequest.headersList.append("accept-encoding", "identity");
		if (!httpRequest.headersList.contains("accept-encoding")) if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
		else httpRequest.headersList.append("accept-encoding", "gzip, deflate");
		httpRequest.headersList.delete("host");
		if (includeCredentials) {}
		if (httpCache == null) httpRequest.cache = "no-store";
		if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {}
		if (response == null) {
			if (httpRequest.mode === "only-if-cached") return makeNetworkError("only if cached");
			const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
			if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
			if (response == null) response = forwardResponse;
		}
		response.urlList = [...httpRequest.urlList];
		if (httpRequest.headersList.contains("range")) response.rangeRequested = true;
		response.requestIncludesCredentials = includeCredentials;
		if (response.status === 407) {
			if (request$2.window === "no-window") return makeNetworkError();
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			return makeNetworkError("proxy authentication required");
		}
		if (response.status === 421 && !isNewConnectionFetch && (request$2.body == null || request$2.body.source != null)) {
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			fetchParams.controller.connection.destroy();
			response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
		}
		if (isAuthenticationFetch) {}
		return response;
	}
	async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
		assert$4(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
		fetchParams.controller.connection = {
			abort: null,
			destroyed: false,
			destroy(err) {
				if (!this.destroyed) {
					this.destroyed = true;
					this.abort?.(err ?? new DOMException$3("The operation was aborted.", "AbortError"));
				}
			}
		};
		const request$2 = fetchParams.request;
		let response = null;
		const timingInfo = fetchParams.timingInfo;
		const httpCache = null;
		if (httpCache == null) request$2.cache = "no-store";
		const newConnection = forceNewConnection ? "yes" : "no";
		if (request$2.mode === "websocket") {}
		let requestBody = null;
		if (request$2.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(() => fetchParams.processRequestEndOfBody());
		else if (request$2.body != null) {
			const processBodyChunk = async function* (bytes) {
				if (isCancelled(fetchParams)) return;
				yield bytes;
				fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
			};
			const processEndOfBody = () => {
				if (isCancelled(fetchParams)) return;
				if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
			};
			const processBodyError = (e) => {
				if (isCancelled(fetchParams)) return;
				if (e.name === "AbortError") fetchParams.controller.abort();
				else fetchParams.controller.terminate(e);
			};
			requestBody = async function* () {
				try {
					for await (const bytes of request$2.body.stream) yield* processBodyChunk(bytes);
					processEndOfBody();
				} catch (err) {
					processBodyError(err);
				}
			}();
		}
		try {
			const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
			if (socket) response = makeResponse({
				status,
				statusText,
				headersList,
				socket
			});
			else {
				const iterator$1 = body[Symbol.asyncIterator]();
				fetchParams.controller.next = () => iterator$1.next();
				response = makeResponse({
					status,
					statusText,
					headersList
				});
			}
		} catch (err) {
			if (err.name === "AbortError") {
				fetchParams.controller.connection.destroy();
				return makeAppropriateNetworkError(fetchParams, err);
			}
			return makeNetworkError(err);
		}
		const pullAlgorithm = () => {
			fetchParams.controller.resume();
		};
		const cancelAlgorithm = (reason) => {
			fetchParams.controller.abort(reason);
		};
		if (!ReadableStream$2) ReadableStream$2 = __require("stream/web").ReadableStream;
		const stream$2 = new ReadableStream$2({
			async start(controller) {
				fetchParams.controller.controller = controller;
			},
			async pull(controller) {
				await pullAlgorithm(controller);
			},
			async cancel(reason) {
				await cancelAlgorithm(reason);
			}
		}, {
			highWaterMark: 0,
			size() {
				return 1;
			}
		});
		response.body = { stream: stream$2 };
		fetchParams.controller.on("terminated", onAborted);
		fetchParams.controller.resume = async () => {
			while (true) {
				let bytes;
				let isFailure;
				try {
					const { done, value } = await fetchParams.controller.next();
					if (isAborted(fetchParams)) break;
					bytes = done ? void 0 : value;
				} catch (err) {
					if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = void 0;
					else {
						bytes = err;
						isFailure = true;
					}
				}
				if (bytes === void 0) {
					readableStreamClose(fetchParams.controller.controller);
					finalizeResponse$1(fetchParams, response);
					return;
				}
				timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
				if (isFailure) {
					fetchParams.controller.terminate(bytes);
					return;
				}
				fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
				if (isErrored(stream$2)) {
					fetchParams.controller.terminate();
					return;
				}
				if (!fetchParams.controller.controller.desiredSize) return;
			}
		};
		function onAborted(reason) {
			if (isAborted(fetchParams)) {
				response.aborted = true;
				if (isReadable(stream$2)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
			} else if (isReadable(stream$2)) fetchParams.controller.controller.error(new TypeError("terminated", { cause: isErrorLike(reason) ? reason : void 0 }));
			fetchParams.controller.connection.destroy();
		}
		return response;
		async function dispatch({ body }) {
			const url = requestCurrentURL(request$2);
			/** @type {import('../..').Agent} */
			const agent = fetchParams.controller.dispatcher;
			return new Promise((resolve, reject) => agent.dispatch({
				path: url.pathname + url.search,
				origin: url.origin,
				method: request$2.method,
				body: fetchParams.controller.dispatcher.isMockActive ? request$2.body && (request$2.body.source || request$2.body.stream) : body,
				headers: request$2.headersList.entries,
				maxRedirections: 0,
				upgrade: request$2.mode === "websocket" ? "websocket" : void 0
			}, {
				body: null,
				abort: null,
				onConnect(abort$1) {
					const { connection } = fetchParams.controller;
					if (connection.destroyed) abort$1(new DOMException$3("The operation was aborted.", "AbortError"));
					else {
						fetchParams.controller.on("terminated", abort$1);
						this.abort = connection.abort = abort$1;
					}
				},
				onHeaders(status, headersList, resume$1, statusText) {
					if (status < 200) return;
					let codings = [];
					let location = "";
					const headers = new Headers$5();
					if (Array.isArray(headersList)) for (let n$1 = 0; n$1 < headersList.length; n$1 += 2) {
						const key = headersList[n$1 + 0].toString("latin1");
						const val = headersList[n$1 + 1].toString("latin1");
						if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x) => x.trim());
						else if (key.toLowerCase() === "location") location = val;
						headers[kHeadersList$3].append(key, val);
					}
					else {
						const keys = Object.keys(headersList);
						for (const key of keys) {
							const val = headersList[key];
							if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
							else if (key.toLowerCase() === "location") location = val;
							headers[kHeadersList$3].append(key, val);
						}
					}
					this.body = new Readable$2({ read: resume$1 });
					const decoders$1 = [];
					const willFollow = request$2.redirect === "follow" && location && redirectStatusSet.has(status);
					if (request$2.method !== "HEAD" && request$2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) for (const coding of codings) if (coding === "x-gzip" || coding === "gzip") decoders$1.push(zlib$1.createGunzip({
						flush: zlib$1.constants.Z_SYNC_FLUSH,
						finishFlush: zlib$1.constants.Z_SYNC_FLUSH
					}));
					else if (coding === "deflate") decoders$1.push(zlib$1.createInflate());
					else if (coding === "br") decoders$1.push(zlib$1.createBrotliDecompress());
					else {
						decoders$1.length = 0;
						break;
					}
					resolve({
						status,
						statusText,
						headersList: headers[kHeadersList$3],
						body: decoders$1.length ? pipeline(this.body, ...decoders$1, () => {}) : this.body.on("error", () => {})
					});
					return true;
				},
				onData(chunk) {
					if (fetchParams.controller.dump) return;
					const bytes = chunk;
					timingInfo.encodedBodySize += bytes.byteLength;
					return this.body.push(bytes);
				},
				onComplete() {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					fetchParams.controller.ended = true;
					this.body.push(null);
				},
				onError(error$1) {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					this.body?.destroy(error$1);
					fetchParams.controller.terminate(error$1);
					reject(error$1);
				},
				onUpgrade(status, headersList, socket) {
					if (status !== 101) return;
					const headers = new Headers$5();
					for (let n$1 = 0; n$1 < headersList.length; n$1 += 2) {
						const key = headersList[n$1 + 0].toString("latin1");
						const val = headersList[n$1 + 1].toString("latin1");
						headers[kHeadersList$3].append(key, val);
					}
					resolve({
						status,
						statusText: STATUS_CODES$1[status],
						headersList: headers[kHeadersList$3],
						socket
					});
					return true;
				}
			}));
		}
	}
	module.exports = {
		fetch: fetch$2,
		Fetch,
		fetching: fetching$2,
		finalizeAndReportTiming
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/symbols.js
var require_symbols$2 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/symbols.js"(exports, module) {
	module.exports = {
		kState: Symbol("FileReader state"),
		kResult: Symbol("FileReader result"),
		kError: Symbol("FileReader error"),
		kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
		kEvents: Symbol("FileReader events"),
		kAborted: Symbol("FileReader aborted")
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/progressevent.js"(exports, module) {
	const { webidl: webidl$6 } = require_webidl();
	const kState$3 = Symbol("ProgressEvent state");
	/**
	* @see https://xhr.spec.whatwg.org/#progressevent
	*/
	var ProgressEvent$1 = class ProgressEvent$1 extends Event {
		constructor(type, eventInitDict = {}) {
			type = webidl$6.converters.DOMString(type);
			eventInitDict = webidl$6.converters.ProgressEventInit(eventInitDict ?? {});
			super(type, eventInitDict);
			this[kState$3] = {
				lengthComputable: eventInitDict.lengthComputable,
				loaded: eventInitDict.loaded,
				total: eventInitDict.total
			};
		}
		get lengthComputable() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].lengthComputable;
		}
		get loaded() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].loaded;
		}
		get total() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].total;
		}
	};
	webidl$6.converters.ProgressEventInit = webidl$6.dictionaryConverter([
		{
			key: "lengthComputable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "loaded",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "total",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "bubbles",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		}
	]);
	module.exports = { ProgressEvent: ProgressEvent$1 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/encoding.js"(exports, module) {
	/**
	* @see https://encoding.spec.whatwg.org/#concept-encoding-get
	* @param {string|undefined} label
	*/
	function getEncoding$1(label) {
		if (!label) return "failure";
		switch (label.trim().toLowerCase()) {
			case "unicode-1-1-utf-8":
			case "unicode11utf8":
			case "unicode20utf8":
			case "utf-8":
			case "utf8":
			case "x-unicode20utf8": return "UTF-8";
			case "866":
			case "cp866":
			case "csibm866":
			case "ibm866": return "IBM866";
			case "csisolatin2":
			case "iso-8859-2":
			case "iso-ir-101":
			case "iso8859-2":
			case "iso88592":
			case "iso_8859-2":
			case "iso_8859-2:1987":
			case "l2":
			case "latin2": return "ISO-8859-2";
			case "csisolatin3":
			case "iso-8859-3":
			case "iso-ir-109":
			case "iso8859-3":
			case "iso88593":
			case "iso_8859-3":
			case "iso_8859-3:1988":
			case "l3":
			case "latin3": return "ISO-8859-3";
			case "csisolatin4":
			case "iso-8859-4":
			case "iso-ir-110":
			case "iso8859-4":
			case "iso88594":
			case "iso_8859-4":
			case "iso_8859-4:1988":
			case "l4":
			case "latin4": return "ISO-8859-4";
			case "csisolatincyrillic":
			case "cyrillic":
			case "iso-8859-5":
			case "iso-ir-144":
			case "iso8859-5":
			case "iso88595":
			case "iso_8859-5":
			case "iso_8859-5:1988": return "ISO-8859-5";
			case "arabic":
			case "asmo-708":
			case "csiso88596e":
			case "csiso88596i":
			case "csisolatinarabic":
			case "ecma-114":
			case "iso-8859-6":
			case "iso-8859-6-e":
			case "iso-8859-6-i":
			case "iso-ir-127":
			case "iso8859-6":
			case "iso88596":
			case "iso_8859-6":
			case "iso_8859-6:1987": return "ISO-8859-6";
			case "csisolatingreek":
			case "ecma-118":
			case "elot_928":
			case "greek":
			case "greek8":
			case "iso-8859-7":
			case "iso-ir-126":
			case "iso8859-7":
			case "iso88597":
			case "iso_8859-7":
			case "iso_8859-7:1987":
			case "sun_eu_greek": return "ISO-8859-7";
			case "csiso88598e":
			case "csisolatinhebrew":
			case "hebrew":
			case "iso-8859-8":
			case "iso-8859-8-e":
			case "iso-ir-138":
			case "iso8859-8":
			case "iso88598":
			case "iso_8859-8":
			case "iso_8859-8:1988":
			case "visual": return "ISO-8859-8";
			case "csiso88598i":
			case "iso-8859-8-i":
			case "logical": return "ISO-8859-8-I";
			case "csisolatin6":
			case "iso-8859-10":
			case "iso-ir-157":
			case "iso8859-10":
			case "iso885910":
			case "l6":
			case "latin6": return "ISO-8859-10";
			case "iso-8859-13":
			case "iso8859-13":
			case "iso885913": return "ISO-8859-13";
			case "iso-8859-14":
			case "iso8859-14":
			case "iso885914": return "ISO-8859-14";
			case "csisolatin9":
			case "iso-8859-15":
			case "iso8859-15":
			case "iso885915":
			case "iso_8859-15":
			case "l9": return "ISO-8859-15";
			case "iso-8859-16": return "ISO-8859-16";
			case "cskoi8r":
			case "koi":
			case "koi8":
			case "koi8-r":
			case "koi8_r": return "KOI8-R";
			case "koi8-ru":
			case "koi8-u": return "KOI8-U";
			case "csmacintosh":
			case "mac":
			case "macintosh":
			case "x-mac-roman": return "macintosh";
			case "iso-8859-11":
			case "iso8859-11":
			case "iso885911":
			case "tis-620":
			case "windows-874": return "windows-874";
			case "cp1250":
			case "windows-1250":
			case "x-cp1250": return "windows-1250";
			case "cp1251":
			case "windows-1251":
			case "x-cp1251": return "windows-1251";
			case "ansi_x3.4-1968":
			case "ascii":
			case "cp1252":
			case "cp819":
			case "csisolatin1":
			case "ibm819":
			case "iso-8859-1":
			case "iso-ir-100":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "iso_8859-1:1987":
			case "l1":
			case "latin1":
			case "us-ascii":
			case "windows-1252":
			case "x-cp1252": return "windows-1252";
			case "cp1253":
			case "windows-1253":
			case "x-cp1253": return "windows-1253";
			case "cp1254":
			case "csisolatin5":
			case "iso-8859-9":
			case "iso-ir-148":
			case "iso8859-9":
			case "iso88599":
			case "iso_8859-9":
			case "iso_8859-9:1989":
			case "l5":
			case "latin5":
			case "windows-1254":
			case "x-cp1254": return "windows-1254";
			case "cp1255":
			case "windows-1255":
			case "x-cp1255": return "windows-1255";
			case "cp1256":
			case "windows-1256":
			case "x-cp1256": return "windows-1256";
			case "cp1257":
			case "windows-1257":
			case "x-cp1257": return "windows-1257";
			case "cp1258":
			case "windows-1258":
			case "x-cp1258": return "windows-1258";
			case "x-mac-cyrillic":
			case "x-mac-ukrainian": return "x-mac-cyrillic";
			case "chinese":
			case "csgb2312":
			case "csiso58gb231280":
			case "gb2312":
			case "gb_2312":
			case "gb_2312-80":
			case "gbk":
			case "iso-ir-58":
			case "x-gbk": return "GBK";
			case "gb18030": return "gb18030";
			case "big5":
			case "big5-hkscs":
			case "cn-big5":
			case "csbig5":
			case "x-x-big5": return "Big5";
			case "cseucpkdfmtjapanese":
			case "euc-jp":
			case "x-euc-jp": return "EUC-JP";
			case "csiso2022jp":
			case "iso-2022-jp": return "ISO-2022-JP";
			case "csshiftjis":
			case "ms932":
			case "ms_kanji":
			case "shift-jis":
			case "shift_jis":
			case "sjis":
			case "windows-31j":
			case "x-sjis": return "Shift_JIS";
			case "cseuckr":
			case "csksc56011987":
			case "euc-kr":
			case "iso-ir-149":
			case "korean":
			case "ks_c_5601-1987":
			case "ks_c_5601-1989":
			case "ksc5601":
			case "ksc_5601":
			case "windows-949": return "EUC-KR";
			case "csiso2022kr":
			case "hz-gb-2312":
			case "iso-2022-cn":
			case "iso-2022-cn-ext":
			case "iso-2022-kr":
			case "replacement": return "replacement";
			case "unicodefffe":
			case "utf-16be": return "UTF-16BE";
			case "csunicode":
			case "iso-10646-ucs-2":
			case "ucs-2":
			case "unicode":
			case "unicodefeff":
			case "utf-16":
			case "utf-16le": return "UTF-16LE";
			case "x-user-defined": return "x-user-defined";
			default: return "failure";
		}
	}
	module.exports = { getEncoding: getEncoding$1 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/util.js
var require_util$3 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/util.js"(exports, module) {
	const { kState: kState$2, kError: kError$1, kResult: kResult$1, kAborted: kAborted$1, kLastProgressEventFired } = require_symbols$2();
	const { ProgressEvent } = require_progressevent();
	const { getEncoding } = require_encoding();
	const { DOMException: DOMException$2 } = require_constants$4();
	const { serializeAMimeType, parseMIMEType } = require_dataURL();
	const { types: types$1 } = __require("util");
	const { StringDecoder: StringDecoder$1 } = __require("string_decoder");
	const { btoa: btoa$1 } = __require("buffer");
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$3 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	/**
	* @see https://w3c.github.io/FileAPI/#readOperation
	* @param {import('./filereader').FileReader} fr
	* @param {import('buffer').Blob} blob
	* @param {string} type
	* @param {string?} encodingName
	*/
	function readOperation$1(fr, blob, type, encodingName) {
		if (fr[kState$2] === "loading") throw new DOMException$2("Invalid state", "InvalidStateError");
		fr[kState$2] = "loading";
		fr[kResult$1] = null;
		fr[kError$1] = null;
		/** @type {import('stream/web').ReadableStream} */
		const stream$2 = blob.stream();
		const reader = stream$2.getReader();
		/** @type {Uint8Array[]} */
		const bytes = [];
		let chunkPromise = reader.read();
		let isFirstChunk = true;
		(async () => {
			while (!fr[kAborted$1]) try {
				const { done, value } = await chunkPromise;
				if (isFirstChunk && !fr[kAborted$1]) queueMicrotask(() => {
					fireAProgressEvent$1("loadstart", fr);
				});
				isFirstChunk = false;
				if (!done && types$1.isUint8Array(value)) {
					bytes.push(value);
					if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted$1]) {
						fr[kLastProgressEventFired] = Date.now();
						queueMicrotask(() => {
							fireAProgressEvent$1("progress", fr);
						});
					}
					chunkPromise = reader.read();
				} else if (done) {
					queueMicrotask(() => {
						fr[kState$2] = "done";
						try {
							const result = packageData(bytes, type, blob.type, encodingName);
							if (fr[kAborted$1]) return;
							fr[kResult$1] = result;
							fireAProgressEvent$1("load", fr);
						} catch (error$1) {
							fr[kError$1] = error$1;
							fireAProgressEvent$1("error", fr);
						}
						if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
					});
					break;
				}
			} catch (error$1) {
				if (fr[kAborted$1]) return;
				queueMicrotask(() => {
					fr[kState$2] = "done";
					fr[kError$1] = error$1;
					fireAProgressEvent$1("error", fr);
					if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
				});
				break;
			}
		})();
	}
	/**
	* @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e The name of the event
	* @param {import('./filereader').FileReader} reader
	*/
	function fireAProgressEvent$1(e, reader) {
		const event = new ProgressEvent(e, {
			bubbles: false,
			cancelable: false
		});
		reader.dispatchEvent(event);
	}
	/**
	* @see https://w3c.github.io/FileAPI/#blob-package-data
	* @param {Uint8Array[]} bytes
	* @param {string} type
	* @param {string?} mimeType
	* @param {string?} encodingName
	*/
	function packageData(bytes, type, mimeType, encodingName) {
		switch (type) {
			case "DataURL": {
				let dataURL = "data:";
				const parsed = parseMIMEType(mimeType || "application/octet-stream");
				if (parsed !== "failure") dataURL += serializeAMimeType(parsed);
				dataURL += ";base64,";
				const decoder = new StringDecoder$1("latin1");
				for (const chunk of bytes) dataURL += btoa$1(decoder.write(chunk));
				dataURL += btoa$1(decoder.end());
				return dataURL;
			}
			case "Text": {
				let encoding = "failure";
				if (encodingName) encoding = getEncoding(encodingName);
				if (encoding === "failure" && mimeType) {
					const type$1 = parseMIMEType(mimeType);
					if (type$1 !== "failure") encoding = getEncoding(type$1.parameters.get("charset"));
				}
				if (encoding === "failure") encoding = "UTF-8";
				return decode(bytes, encoding);
			}
			case "ArrayBuffer": {
				const sequence = combineByteSequences(bytes);
				return sequence.buffer;
			}
			case "BinaryString": {
				let binaryString = "";
				const decoder = new StringDecoder$1("latin1");
				for (const chunk of bytes) binaryString += decoder.write(chunk);
				binaryString += decoder.end();
				return binaryString;
			}
		}
	}
	/**
	* @see https://encoding.spec.whatwg.org/#decode
	* @param {Uint8Array[]} ioQueue
	* @param {string} encoding
	*/
	function decode(ioQueue, encoding) {
		const bytes = combineByteSequences(ioQueue);
		const BOMEncoding = BOMSniffing(bytes);
		let slice = 0;
		if (BOMEncoding !== null) {
			encoding = BOMEncoding;
			slice = BOMEncoding === "UTF-8" ? 3 : 2;
		}
		const sliced = bytes.slice(slice);
		return new TextDecoder(encoding).decode(sliced);
	}
	/**
	* @see https://encoding.spec.whatwg.org/#bom-sniff
	* @param {Uint8Array} ioQueue
	*/
	function BOMSniffing(ioQueue) {
		const [a$1, b, c$1] = ioQueue;
		if (a$1 === 239 && b === 187 && c$1 === 191) return "UTF-8";
		else if (a$1 === 254 && b === 255) return "UTF-16BE";
		else if (a$1 === 255 && b === 254) return "UTF-16LE";
		return null;
	}
	/**
	* @param {Uint8Array[]} sequences
	*/
	function combineByteSequences(sequences) {
		const size = sequences.reduce((a$1, b) => {
			return a$1 + b.byteLength;
		}, 0);
		let offset = 0;
		return sequences.reduce((a$1, b) => {
			a$1.set(b, offset);
			offset += b.byteLength;
			return a$1;
		}, new Uint8Array(size));
	}
	module.exports = {
		staticPropertyDescriptors: staticPropertyDescriptors$3,
		readOperation: readOperation$1,
		fireAProgressEvent: fireAProgressEvent$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/fileapi/filereader.js"(exports, module) {
	const { staticPropertyDescriptors: staticPropertyDescriptors$2, readOperation, fireAProgressEvent } = require_util$3();
	const { kState: kState$1, kError, kResult, kEvents, kAborted } = require_symbols$2();
	const { webidl: webidl$5 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$4 } = require_util$6();
	var FileReader = class FileReader extends EventTarget {
		constructor() {
			super();
			this[kState$1] = "empty";
			this[kResult] = null;
			this[kError] = null;
			this[kEvents] = {
				loadend: null,
				error: null,
				abort: null,
				load: null,
				progress: null,
				loadstart: null
			};
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
		* @param {import('buffer').Blob} blob
		*/
		readAsArrayBuffer(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "ArrayBuffer");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsBinaryString
		* @param {import('buffer').Blob} blob
		*/
		readAsBinaryString(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "BinaryString");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsDataText
		* @param {import('buffer').Blob} blob
		* @param {string?} encoding
		*/
		readAsText(blob, encoding = void 0) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			if (encoding !== void 0) encoding = webidl$5.converters.DOMString(encoding);
			readOperation(this, blob, "Text", encoding);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
		* @param {import('buffer').Blob} blob
		*/
		readAsDataURL(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "DataURL");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-abort
		*/
		abort() {
			if (this[kState$1] === "empty" || this[kState$1] === "done") {
				this[kResult] = null;
				return;
			}
			if (this[kState$1] === "loading") {
				this[kState$1] = "done";
				this[kResult] = null;
			}
			this[kAborted] = true;
			fireAProgressEvent("abort", this);
			if (this[kState$1] !== "loading") fireAProgressEvent("loadend", this);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
		*/
		get readyState() {
			webidl$5.brandCheck(this, FileReader);
			switch (this[kState$1]) {
				case "empty": return this.EMPTY;
				case "loading": return this.LOADING;
				case "done": return this.DONE;
			}
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-result
		*/
		get result() {
			webidl$5.brandCheck(this, FileReader);
			return this[kResult];
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-error
		*/
		get error() {
			webidl$5.brandCheck(this, FileReader);
			return this[kError];
		}
		get onloadend() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].loadend;
		}
		set onloadend(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].loadend) this.removeEventListener("loadend", this[kEvents].loadend);
			if (typeof fn === "function") {
				this[kEvents].loadend = fn;
				this.addEventListener("loadend", fn);
			} else this[kEvents].loadend = null;
		}
		get onerror() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].error;
		}
		set onerror(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].error) this.removeEventListener("error", this[kEvents].error);
			if (typeof fn === "function") {
				this[kEvents].error = fn;
				this.addEventListener("error", fn);
			} else this[kEvents].error = null;
		}
		get onloadstart() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].loadstart;
		}
		set onloadstart(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].loadstart) this.removeEventListener("loadstart", this[kEvents].loadstart);
			if (typeof fn === "function") {
				this[kEvents].loadstart = fn;
				this.addEventListener("loadstart", fn);
			} else this[kEvents].loadstart = null;
		}
		get onprogress() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].progress;
		}
		set onprogress(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].progress) this.removeEventListener("progress", this[kEvents].progress);
			if (typeof fn === "function") {
				this[kEvents].progress = fn;
				this.addEventListener("progress", fn);
			} else this[kEvents].progress = null;
		}
		get onload() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].load;
		}
		set onload(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].load) this.removeEventListener("load", this[kEvents].load);
			if (typeof fn === "function") {
				this[kEvents].load = fn;
				this.addEventListener("load", fn);
			} else this[kEvents].load = null;
		}
		get onabort() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].abort;
		}
		set onabort(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].abort) this.removeEventListener("abort", this[kEvents].abort);
			if (typeof fn === "function") {
				this[kEvents].abort = fn;
				this.addEventListener("abort", fn);
			} else this[kEvents].abort = null;
		}
	};
	FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
	FileReader.LOADING = FileReader.prototype.LOADING = 1;
	FileReader.DONE = FileReader.prototype.DONE = 2;
	Object.defineProperties(FileReader.prototype, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2,
		readAsArrayBuffer: kEnumerableProperty$4,
		readAsBinaryString: kEnumerableProperty$4,
		readAsText: kEnumerableProperty$4,
		readAsDataURL: kEnumerableProperty$4,
		abort: kEnumerableProperty$4,
		readyState: kEnumerableProperty$4,
		result: kEnumerableProperty$4,
		error: kEnumerableProperty$4,
		onloadstart: kEnumerableProperty$4,
		onprogress: kEnumerableProperty$4,
		onload: kEnumerableProperty$4,
		onabort: kEnumerableProperty$4,
		onerror: kEnumerableProperty$4,
		onloadend: kEnumerableProperty$4,
		[Symbol.toStringTag]: {
			value: "FileReader",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(FileReader, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2
	});
	module.exports = { FileReader };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/symbols.js
var require_symbols$1 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/symbols.js"(exports, module) {
	module.exports = { kConstruct: require_symbols$4().kConstruct };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/util.js
var require_util$2 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/util.js"(exports, module) {
	const assert$3 = __require("assert");
	const { URLSerializer: URLSerializer$1 } = require_dataURL();
	const { isValidHeaderName } = require_util$5();
	/**
	* @see https://url.spec.whatwg.org/#concept-url-equals
	* @param {URL} A
	* @param {URL} B
	* @param {boolean | undefined} excludeFragment
	* @returns {boolean}
	*/
	function urlEquals$1(A, B, excludeFragment = false) {
		const serializedA = URLSerializer$1(A, excludeFragment);
		const serializedB = URLSerializer$1(B, excludeFragment);
		return serializedA === serializedB;
	}
	/**
	* @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	* @param {string} header
	*/
	function fieldValues(header) {
		assert$3(header !== null);
		const values = [];
		for (let value of header.split(",")) {
			value = value.trim();
			if (!value.length) continue;
			else if (!isValidHeaderName(value)) continue;
			values.push(value);
		}
		return values;
	}
	module.exports = {
		urlEquals: urlEquals$1,
		fieldValues
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/cache.js"(exports, module) {
	const { kConstruct: kConstruct$1 } = require_symbols$1();
	const { urlEquals, fieldValues: getFieldValues } = require_util$2();
	const { kEnumerableProperty: kEnumerableProperty$3, isDisturbed } = require_util$6();
	const { kHeadersList: kHeadersList$2 } = require_symbols$4();
	const { webidl: webidl$4 } = require_webidl();
	const { Response: Response$2, cloneResponse } = require_response();
	const { Request: Request$2 } = require_request();
	const { kState, kHeaders, kGuard, kRealm } = require_symbols$3();
	const { fetching: fetching$1 } = require_fetch();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util$5();
	const assert$2 = __require("assert");
	const { getGlobalDispatcher: getGlobalDispatcher$3 } = require_global();
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	* @typedef {Object} CacheBatchOperation
	* @property {'delete' | 'put'} type
	* @property {any} request
	* @property {any} response
	* @property {import('../../types/cache').CacheQueryOptions} options
	*/
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	* @typedef {[any, any][]} requestResponseList
	*/
	var Cache$1 = class Cache$1 {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
		* @type {requestResponseList}
		*/
		#relevantRequestResponseList;
		constructor() {
			if (arguments[0] !== kConstruct$1) webidl$4.illegalConstructor();
			this.#relevantRequestResponseList = arguments[1];
		}
		async match(request$2, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
			request$2 = webidl$4.converters.RequestInfo(request$2);
			options = webidl$4.converters.CacheQueryOptions(options);
			const p = await this.matchAll(request$2, options);
			if (p.length === 0) return;
			return p[0];
		}
		async matchAll(request$2 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$2 !== void 0) request$2 = webidl$4.converters.RequestInfo(request$2);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r = null;
			if (request$2 !== void 0) {
				if (request$2 instanceof Request$2) {
					r = request$2[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$2 === "string") r = new Request$2(request$2)[kState];
			}
			const responses = [];
			if (request$2 === void 0) for (const requestResponse of this.#relevantRequestResponseList) responses.push(requestResponse[1]);
			else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) responses.push(requestResponse[1]);
			}
			const responseList = [];
			for (const response of responses) {
				const responseObject = new Response$2(response.body?.source ?? null);
				const body = responseObject[kState].body;
				responseObject[kState] = response;
				responseObject[kState].body = body;
				responseObject[kHeaders][kHeadersList$2] = response.headersList;
				responseObject[kHeaders][kGuard] = "immutable";
				responseList.push(responseObject);
			}
			return Object.freeze(responseList);
		}
		async add(request$2) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
			request$2 = webidl$4.converters.RequestInfo(request$2);
			const requests = [request$2];
			const responseArrayPromise = this.addAll(requests);
			return await responseArrayPromise;
		}
		async addAll(requests) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
			requests = webidl$4.converters["sequence<RequestInfo>"](requests);
			const responsePromises = [];
			const requestList = [];
			for (const request$2 of requests) {
				if (typeof request$2 === "string") continue;
				const r = request$2[kState];
				if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme when method is not GET."
				});
			}
			/** @type {ReturnType<typeof fetching>[]} */
			const fetchControllers = [];
			for (const request$2 of requests) {
				const r = new Request$2(request$2)[kState];
				if (!urlIsHttpHttpsScheme(r.url)) throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme."
				});
				r.initiator = "fetch";
				r.destination = "subresource";
				requestList.push(r);
				const responsePromise = createDeferredPromise();
				fetchControllers.push(fetching$1({
					request: r,
					dispatcher: getGlobalDispatcher$3(),
					processResponse(response) {
						if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) responsePromise.reject(webidl$4.errors.exception({
							header: "Cache.addAll",
							message: "Received an invalid status code or the request failed."
						}));
						else if (response.headersList.contains("vary")) {
							const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
							for (const fieldValue of fieldValues$1) if (fieldValue === "*") {
								responsePromise.reject(webidl$4.errors.exception({
									header: "Cache.addAll",
									message: "invalid vary field value"
								}));
								for (const controller of fetchControllers) controller.abort();
								return;
							}
						}
					},
					processResponseEndOfBody(response) {
						if (response.aborted) {
							responsePromise.reject(new DOMException("aborted", "AbortError"));
							return;
						}
						responsePromise.resolve(response);
					}
				}));
				responsePromises.push(responsePromise.promise);
			}
			const p = Promise.all(responsePromises);
			const responses = await p;
			const operations = [];
			let index = 0;
			for (const response of responses) {
				/** @type {CacheBatchOperation} */
				const operation = {
					type: "put",
					request: requestList[index],
					response
				};
				operations.push(operation);
				index++;
			}
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(void 0);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async put(request$2, response) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
			request$2 = webidl$4.converters.RequestInfo(request$2);
			response = webidl$4.converters.Response(response);
			let innerRequest = null;
			if (request$2 instanceof Request$2) innerRequest = request$2[kState];
			else innerRequest = new Request$2(request$2)[kState];
			if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Expected an http/s scheme when method is not GET"
			});
			const innerResponse = response[kState];
			if (innerResponse.status === 206) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Got 206 status"
			});
			if (innerResponse.headersList.contains("vary")) {
				const fieldValues$1 = getFieldValues(innerResponse.headersList.get("vary"));
				for (const fieldValue of fieldValues$1) if (fieldValue === "*") throw webidl$4.errors.exception({
					header: "Cache.put",
					message: "Got * vary field value"
				});
			}
			if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Response body is locked or disturbed"
			});
			const clonedResponse = cloneResponse(innerResponse);
			const bodyReadPromise = createDeferredPromise();
			if (innerResponse.body != null) {
				const stream$2 = innerResponse.body.stream;
				const reader = stream$2.getReader();
				readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
			} else bodyReadPromise.resolve(void 0);
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "put",
				request: innerRequest,
				response: clonedResponse
			};
			operations.push(operation);
			const bytes = await bodyReadPromise.promise;
			if (clonedResponse.body != null) clonedResponse.body.source = bytes;
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve();
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async delete(request$2, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
			request$2 = webidl$4.converters.RequestInfo(request$2);
			options = webidl$4.converters.CacheQueryOptions(options);
			/**
			* @type {Request}
			*/
			let r = null;
			if (request$2 instanceof Request$2) {
				r = request$2[kState];
				if (r.method !== "GET" && !options.ignoreMethod) return false;
			} else {
				assert$2(typeof request$2 === "string");
				r = new Request$2(request$2)[kState];
			}
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "delete",
				request: r,
				options
			};
			operations.push(operation);
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			let requestResponses;
			try {
				requestResponses = this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(!!requestResponses?.length);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
		* @param {any} request
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @returns {readonly Request[]}
		*/
		async keys(request$2 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$2 !== void 0) request$2 = webidl$4.converters.RequestInfo(request$2);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r = null;
			if (request$2 !== void 0) {
				if (request$2 instanceof Request$2) {
					r = request$2[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$2 === "string") r = new Request$2(request$2)[kState];
			}
			const promise = createDeferredPromise();
			const requests = [];
			if (request$2 === void 0) for (const requestResponse of this.#relevantRequestResponseList) requests.push(requestResponse[0]);
			else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) requests.push(requestResponse[0]);
			}
			queueMicrotask(() => {
				const requestList = [];
				for (const request$3 of requests) {
					const requestObject = new Request$2("https://a");
					requestObject[kState] = request$3;
					requestObject[kHeaders][kHeadersList$2] = request$3.headersList;
					requestObject[kHeaders][kGuard] = "immutable";
					requestObject[kRealm] = request$3.client;
					requestList.push(requestObject);
				}
				promise.resolve(Object.freeze(requestList));
			});
			return promise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
		* @param {CacheBatchOperation[]} operations
		* @returns {requestResponseList}
		*/
		#batchCacheOperations(operations) {
			const cache = this.#relevantRequestResponseList;
			const backupCache = [...cache];
			const addedItems = [];
			const resultList = [];
			try {
				for (const operation of operations) {
					if (operation.type !== "delete" && operation.type !== "put") throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "operation type does not match \"delete\" or \"put\""
					});
					if (operation.type === "delete" && operation.response != null) throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "delete operation should not have an associated response"
					});
					if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException("???", "InvalidStateError");
					let requestResponses;
					if (operation.type === "delete") {
						requestResponses = this.#queryCache(operation.request, operation.options);
						if (requestResponses.length === 0) return [];
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$2(idx !== -1);
							cache.splice(idx, 1);
						}
					} else if (operation.type === "put") {
						if (operation.response == null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "put operation should have an associated response"
						});
						const r = operation.request;
						if (!urlIsHttpHttpsScheme(r.url)) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "expected http or https scheme"
						});
						if (r.method !== "GET") throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "not get method"
						});
						if (operation.options != null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "options must not be defined"
						});
						requestResponses = this.#queryCache(operation.request);
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$2(idx !== -1);
							cache.splice(idx, 1);
						}
						cache.push([operation.request, operation.response]);
						addedItems.push([operation.request, operation.response]);
					}
					resultList.push([operation.request, operation.response]);
				}
				return resultList;
			} catch (e) {
				this.#relevantRequestResponseList.length = 0;
				this.#relevantRequestResponseList = backupCache;
				throw e;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#query-cache
		* @param {any} requestQuery
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @param {requestResponseList} targetStorage
		* @returns {requestResponseList}
		*/
		#queryCache(requestQuery, options, targetStorage) {
			/** @type {requestResponseList} */
			const resultList = [];
			const storage = targetStorage ?? this.#relevantRequestResponseList;
			for (const requestResponse of storage) {
				const [cachedRequest, cachedResponse] = requestResponse;
				if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
			}
			return resultList;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
		* @param {any} requestQuery
		* @param {any} request
		* @param {any | null} response
		* @param {import('../../types/cache').CacheQueryOptions | undefined} options
		* @returns {boolean}
		*/
		#requestMatchesCachedItem(requestQuery, request$2, response = null, options) {
			const queryURL = new URL(requestQuery.url);
			const cachedURL = new URL(request$2.url);
			if (options?.ignoreSearch) {
				cachedURL.search = "";
				queryURL.search = "";
			}
			if (!urlEquals(queryURL, cachedURL, true)) return false;
			if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) return true;
			const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
			for (const fieldValue of fieldValues$1) {
				if (fieldValue === "*") return false;
				const requestValue = request$2.headersList.get(fieldValue);
				const queryValue = requestQuery.headersList.get(fieldValue);
				if (requestValue !== queryValue) return false;
			}
			return true;
		}
	};
	Object.defineProperties(Cache$1.prototype, {
		[Symbol.toStringTag]: {
			value: "Cache",
			configurable: true
		},
		match: kEnumerableProperty$3,
		matchAll: kEnumerableProperty$3,
		add: kEnumerableProperty$3,
		addAll: kEnumerableProperty$3,
		put: kEnumerableProperty$3,
		delete: kEnumerableProperty$3,
		keys: kEnumerableProperty$3
	});
	const cacheQueryOptionConverters = [
		{
			key: "ignoreSearch",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreMethod",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreVary",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		}
	];
	webidl$4.converters.CacheQueryOptions = webidl$4.dictionaryConverter(cacheQueryOptionConverters);
	webidl$4.converters.MultiCacheQueryOptions = webidl$4.dictionaryConverter([...cacheQueryOptionConverters, {
		key: "cacheName",
		converter: webidl$4.converters.DOMString
	}]);
	webidl$4.converters.Response = webidl$4.interfaceConverter(Response$2);
	webidl$4.converters["sequence<RequestInfo>"] = webidl$4.sequenceConverter(webidl$4.converters.RequestInfo);
	module.exports = { Cache: Cache$1 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cache/cachestorage.js"(exports, module) {
	const { kConstruct } = require_symbols$1();
	const { Cache } = require_cache();
	const { webidl: webidl$3 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$2 } = require_util$6();
	var CacheStorage = class CacheStorage {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
		* @type {Map<string, import('./cache').requestResponseList}
		*/
		#caches = /* @__PURE__ */ new Map();
		constructor() {
			if (arguments[0] !== kConstruct) webidl$3.illegalConstructor();
		}
		async match(request$2, options = {}) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
			request$2 = webidl$3.converters.RequestInfo(request$2);
			options = webidl$3.converters.MultiCacheQueryOptions(options);
			if (options.cacheName != null) {
				if (this.#caches.has(options.cacheName)) {
					const cacheList = this.#caches.get(options.cacheName);
					const cache = new Cache(kConstruct, cacheList);
					return await cache.match(request$2, options);
				}
			} else for (const cacheList of this.#caches.values()) {
				const cache = new Cache(kConstruct, cacheList);
				const response = await cache.match(request$2, options);
				if (response !== void 0) return response;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-has
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async has(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.has(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
		* @param {string} cacheName
		* @returns {Promise<Cache>}
		*/
		async open(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			if (this.#caches.has(cacheName)) {
				const cache$1 = this.#caches.get(cacheName);
				return new Cache(kConstruct, cache$1);
			}
			const cache = [];
			this.#caches.set(cacheName, cache);
			return new Cache(kConstruct, cache);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async delete(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.delete(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
		* @returns {string[]}
		*/
		async keys() {
			webidl$3.brandCheck(this, CacheStorage);
			const keys = this.#caches.keys();
			return [...keys];
		}
	};
	Object.defineProperties(CacheStorage.prototype, {
		[Symbol.toStringTag]: {
			value: "CacheStorage",
			configurable: true
		},
		match: kEnumerableProperty$2,
		has: kEnumerableProperty$2,
		open: kEnumerableProperty$2,
		delete: kEnumerableProperty$2,
		keys: kEnumerableProperty$2
	});
	module.exports = { CacheStorage };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/constants.js
var require_constants$2 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/constants.js"(exports, module) {
	const maxAttributeValueSize$1 = 1024;
	const maxNameValuePairSize$1 = 4096;
	module.exports = {
		maxAttributeValueSize: maxAttributeValueSize$1,
		maxNameValuePairSize: maxNameValuePairSize$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/util.js
var require_util$1 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/util.js"(exports, module) {
	const assert$1 = __require("assert");
	const { kHeadersList: kHeadersList$1 } = require_symbols$4();
	function isCTLExcludingHtab$1(value) {
		if (value.length === 0) return false;
		for (const char of value) {
			const code = char.charCodeAt(0);
			if (code >= 0 || code <= 8 || code >= 10 || code <= 31 || code === 127) return false;
		}
	}
	/**
	CHAR           = <any US-ASCII character (octets 0 - 127)>
	token          = 1*<any CHAR except CTLs or separators>
	separators     = "(" | ")" | "<" | ">" | "@"
	| "," | ";" | ":" | "\" | <">
	| "/" | "[" | "]" | "?" | "="
	| "{" | "}" | SP | HT
	* @param {string} name
	*/
	function validateCookieName(name) {
		for (const char of name) {
			const code = char.charCodeAt(0);
			if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") throw new Error("Invalid cookie name");
		}
	}
	/**
	cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	; US-ASCII characters excluding CTLs,
	; whitespace DQUOTE, comma, semicolon,
	; and backslash
	* @param {string} value
	*/
	function validateCookieValue(value) {
		for (const char of value) {
			const code = char.charCodeAt(0);
			if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) throw new Error("Invalid header value");
		}
	}
	/**
	* path-value        = <any CHAR except CTLs or ";">
	* @param {string} path
	*/
	function validateCookiePath(path$9) {
		for (const char of path$9) {
			const code = char.charCodeAt(0);
			if (code < 33 || char === ";") throw new Error("Invalid cookie path");
		}
	}
	/**
	* I have no idea why these values aren't allowed to be honest,
	* but Deno tests these. - Khafra
	* @param {string} domain
	*/
	function validateCookieDomain(domain) {
		if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) throw new Error("Invalid cookie domain");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	* @param {number|Date} date
	IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	; fixed length/zone/capitalization subset of the format
	; see Section 3.3 of [RFC5322]
	
	day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	/ %x54.75.65 ; "Tue", case-sensitive
	/ %x57.65.64 ; "Wed", case-sensitive
	/ %x54.68.75 ; "Thu", case-sensitive
	/ %x46.72.69 ; "Fri", case-sensitive
	/ %x53.61.74 ; "Sat", case-sensitive
	/ %x53.75.6E ; "Sun", case-sensitive
	date1        = day SP month SP year
	; e.g., 02 Jun 1982
	
	day          = 2DIGIT
	month        = %x4A.61.6E ; "Jan", case-sensitive
	/ %x46.65.62 ; "Feb", case-sensitive
	/ %x4D.61.72 ; "Mar", case-sensitive
	/ %x41.70.72 ; "Apr", case-sensitive
	/ %x4D.61.79 ; "May", case-sensitive
	/ %x4A.75.6E ; "Jun", case-sensitive
	/ %x4A.75.6C ; "Jul", case-sensitive
	/ %x41.75.67 ; "Aug", case-sensitive
	/ %x53.65.70 ; "Sep", case-sensitive
	/ %x4F.63.74 ; "Oct", case-sensitive
	/ %x4E.6F.76 ; "Nov", case-sensitive
	/ %x44.65.63 ; "Dec", case-sensitive
	year         = 4DIGIT
	
	GMT          = %x47.4D.54 ; "GMT", case-sensitive
	
	time-of-day  = hour ":" minute ":" second
	; 00:00:00 - 23:59:60 (leap second)
	
	hour         = 2DIGIT
	minute       = 2DIGIT
	second       = 2DIGIT
	*/
	function toIMFDate(date) {
		if (typeof date === "number") date = new Date(date);
		const days = [
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		];
		const months = [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		];
		const dayName = days[date.getUTCDay()];
		const day = date.getUTCDate().toString().padStart(2, "0");
		const month = months[date.getUTCMonth()];
		const year = date.getUTCFullYear();
		const hour = date.getUTCHours().toString().padStart(2, "0");
		const minute = date.getUTCMinutes().toString().padStart(2, "0");
		const second = date.getUTCSeconds().toString().padStart(2, "0");
		return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
	}
	/**
	max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	; In practice, both expires-av and max-age-av
	; are limited to dates representable by the
	; user agent.
	* @param {number} maxAge
	*/
	function validateCookieMaxAge(maxAge) {
		if (maxAge < 0) throw new Error("Invalid cookie max-age");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	* @param {import('./index').Cookie} cookie
	*/
	function stringify$2(cookie) {
		if (cookie.name.length === 0) return null;
		validateCookieName(cookie.name);
		validateCookieValue(cookie.value);
		const out = [`${cookie.name}=${cookie.value}`];
		if (cookie.name.startsWith("__Secure-")) cookie.secure = true;
		if (cookie.name.startsWith("__Host-")) {
			cookie.secure = true;
			cookie.domain = null;
			cookie.path = "/";
		}
		if (cookie.secure) out.push("Secure");
		if (cookie.httpOnly) out.push("HttpOnly");
		if (typeof cookie.maxAge === "number") {
			validateCookieMaxAge(cookie.maxAge);
			out.push(`Max-Age=${cookie.maxAge}`);
		}
		if (cookie.domain) {
			validateCookieDomain(cookie.domain);
			out.push(`Domain=${cookie.domain}`);
		}
		if (cookie.path) {
			validateCookiePath(cookie.path);
			out.push(`Path=${cookie.path}`);
		}
		if (cookie.expires && cookie.expires.toString() !== "Invalid Date") out.push(`Expires=${toIMFDate(cookie.expires)}`);
		if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
		for (const part of cookie.unparsed) {
			if (!part.includes("=")) throw new Error("Invalid unparsed");
			const [key, ...value] = part.split("=");
			out.push(`${key.trim()}=${value.join("=")}`);
		}
		return out.join("; ");
	}
	let kHeadersListNode;
	function getHeadersList$1(headers) {
		if (headers[kHeadersList$1]) return headers[kHeadersList$1];
		if (!kHeadersListNode) {
			kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol) => symbol.description === "headers list");
			assert$1(kHeadersListNode, "Headers cannot be parsed");
		}
		const headersList = headers[kHeadersListNode];
		assert$1(headersList);
		return headersList;
	}
	module.exports = {
		isCTLExcludingHtab: isCTLExcludingHtab$1,
		stringify: stringify$2,
		getHeadersList: getHeadersList$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/parse.js
var require_parse$1 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/parse.js"(exports, module) {
	const { maxNameValuePairSize, maxAttributeValueSize } = require_constants$2();
	const { isCTLExcludingHtab } = require_util$1();
	const { collectASequenceOfCodePointsFast } = require_dataURL();
	const assert = __require("assert");
	/**
	* @description Parses the field-value attributes of a set-cookie header string.
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} header
	* @returns if the header is invalid, null will be returned
	*/
	function parseSetCookie$1(header) {
		if (isCTLExcludingHtab(header)) return null;
		let nameValuePair = "";
		let unparsedAttributes = "";
		let name = "";
		let value = "";
		if (header.includes(";")) {
			const position = { position: 0 };
			nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
			unparsedAttributes = header.slice(position.position);
		} else nameValuePair = header;
		if (!nameValuePair.includes("=")) value = nameValuePair;
		else {
			const position = { position: 0 };
			name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
			value = nameValuePair.slice(position.position + 1);
		}
		name = name.trim();
		value = value.trim();
		if (name.length + value.length > maxNameValuePairSize) return null;
		return {
			name,
			value,
			...parseUnparsedAttributes(unparsedAttributes)
		};
	}
	/**
	* Parses the remaining attributes of a set-cookie header
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} unparsedAttributes
	* @param {[Object.<string, unknown>]={}} cookieAttributeList
	*/
	function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
		if (unparsedAttributes.length === 0) return cookieAttributeList;
		assert(unparsedAttributes[0] === ";");
		unparsedAttributes = unparsedAttributes.slice(1);
		let cookieAv = "";
		if (unparsedAttributes.includes(";")) {
			cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
			unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
		} else {
			cookieAv = unparsedAttributes;
			unparsedAttributes = "";
		}
		let attributeName = "";
		let attributeValue = "";
		if (cookieAv.includes("=")) {
			const position = { position: 0 };
			attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
			attributeValue = cookieAv.slice(position.position + 1);
		} else attributeName = cookieAv;
		attributeName = attributeName.trim();
		attributeValue = attributeValue.trim();
		if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
		const attributeNameLowercase = attributeName.toLowerCase();
		if (attributeNameLowercase === "expires") {
			const expiryTime = new Date(attributeValue);
			cookieAttributeList.expires = expiryTime;
		} else if (attributeNameLowercase === "max-age") {
			const charCode = attributeValue.charCodeAt(0);
			if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			const deltaSeconds = Number(attributeValue);
			cookieAttributeList.maxAge = deltaSeconds;
		} else if (attributeNameLowercase === "domain") {
			let cookieDomain = attributeValue;
			if (cookieDomain[0] === ".") cookieDomain = cookieDomain.slice(1);
			cookieDomain = cookieDomain.toLowerCase();
			cookieAttributeList.domain = cookieDomain;
		} else if (attributeNameLowercase === "path") {
			let cookiePath = "";
			if (attributeValue.length === 0 || attributeValue[0] !== "/") cookiePath = "/";
			else cookiePath = attributeValue;
			cookieAttributeList.path = cookiePath;
		} else if (attributeNameLowercase === "secure") cookieAttributeList.secure = true;
		else if (attributeNameLowercase === "httponly") cookieAttributeList.httpOnly = true;
		else if (attributeNameLowercase === "samesite") {
			let enforcement = "Default";
			const attributeValueLowercase = attributeValue.toLowerCase();
			if (attributeValueLowercase.includes("none")) enforcement = "None";
			if (attributeValueLowercase.includes("strict")) enforcement = "Strict";
			if (attributeValueLowercase.includes("lax")) enforcement = "Lax";
			cookieAttributeList.sameSite = enforcement;
		} else {
			cookieAttributeList.unparsed ??= [];
			cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
		}
		return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
	}
	module.exports = {
		parseSetCookie: parseSetCookie$1,
		parseUnparsedAttributes
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/cookies/index.js"(exports, module) {
	const { parseSetCookie } = require_parse$1();
	const { stringify: stringify$1, getHeadersList } = require_util$1();
	const { webidl: webidl$2 } = require_webidl();
	const { Headers: Headers$4 } = require_headers();
	/**
	* @typedef {Object} Cookie
	* @property {string} name
	* @property {string} value
	* @property {Date|number|undefined} expires
	* @property {number|undefined} maxAge
	* @property {string|undefined} domain
	* @property {string|undefined} path
	* @property {boolean|undefined} secure
	* @property {boolean|undefined} httpOnly
	* @property {'Strict'|'Lax'|'None'} sameSite
	* @property {string[]} unparsed
	*/
	/**
	* @param {Headers} headers
	* @returns {Record<string, string>}
	*/
	function getCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getCookies" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		const cookie = headers.get("cookie");
		const out = {};
		if (!cookie) return out;
		for (const piece of cookie.split(";")) {
			const [name, ...value] = piece.split("=");
			out[name.trim()] = value.join("=");
		}
		return out;
	}
	/**
	* @param {Headers} headers
	* @param {string} name
	* @param {{ path?: string, domain?: string }|undefined} attributes
	* @returns {void}
	*/
	function deleteCookie(headers, name, attributes) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		name = webidl$2.converters.DOMString(name);
		attributes = webidl$2.converters.DeleteCookieAttributes(attributes);
		setCookie(headers, {
			name,
			value: "",
			expires: /* @__PURE__ */ new Date(0),
			...attributes
		});
	}
	/**
	* @param {Headers} headers
	* @returns {Cookie[]}
	*/
	function getSetCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		const cookies = getHeadersList(headers).cookies;
		if (!cookies) return [];
		return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
	}
	/**
	* @param {Headers} headers
	* @param {Cookie} cookie
	* @returns {void}
	*/
	function setCookie(headers, cookie) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "setCookie" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		cookie = webidl$2.converters.Cookie(cookie);
		const str$1 = stringify$1(cookie);
		if (str$1) headers.append("Set-Cookie", stringify$1(cookie));
	}
	webidl$2.converters.DeleteCookieAttributes = webidl$2.dictionaryConverter([{
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "path",
		defaultValue: null
	}, {
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "domain",
		defaultValue: null
	}]);
	webidl$2.converters.Cookie = webidl$2.dictionaryConverter([
		{
			converter: webidl$2.converters.DOMString,
			key: "name"
		},
		{
			converter: webidl$2.converters.DOMString,
			key: "value"
		},
		{
			converter: webidl$2.nullableConverter((value) => {
				if (typeof value === "number") return webidl$2.converters["unsigned long long"](value);
				return new Date(value);
			}),
			key: "expires",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters["long long"]),
			key: "maxAge",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "domain",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "path",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "secure",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "httpOnly",
			defaultValue: null
		},
		{
			converter: webidl$2.converters.USVString,
			key: "sameSite",
			allowedValues: [
				"Strict",
				"Lax",
				"None"
			]
		},
		{
			converter: webidl$2.sequenceConverter(webidl$2.converters.DOMString),
			key: "unparsed",
			defaultValue: []
		}
	]);
	module.exports = {
		getCookies,
		deleteCookie,
		getSetCookies,
		setCookie
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/constants.js
var require_constants$1 = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/constants.js"(exports, module) {
	const uid$1 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$1 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	const states$4 = {
		CONNECTING: 0,
		OPEN: 1,
		CLOSING: 2,
		CLOSED: 3
	};
	const opcodes$3 = {
		CONTINUATION: 0,
		TEXT: 1,
		BINARY: 2,
		CLOSE: 8,
		PING: 9,
		PONG: 10
	};
	const maxUnsigned16Bit$1 = 2 ** 16 - 1;
	const parserStates$1 = {
		INFO: 0,
		PAYLOADLENGTH_16: 2,
		PAYLOADLENGTH_64: 3,
		READ_DATA: 4
	};
	const emptyBuffer$2 = Buffer.allocUnsafe(0);
	module.exports = {
		uid: uid$1,
		staticPropertyDescriptors: staticPropertyDescriptors$1,
		states: states$4,
		opcodes: opcodes$3,
		maxUnsigned16Bit: maxUnsigned16Bit$1,
		parserStates: parserStates$1,
		emptyBuffer: emptyBuffer$2
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/symbols.js
var require_symbols = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/symbols.js"(exports, module) {
	module.exports = {
		kWebSocketURL: Symbol("url"),
		kReadyState: Symbol("ready state"),
		kController: Symbol("controller"),
		kResponse: Symbol("response"),
		kBinaryType: Symbol("binary type"),
		kSentClose: Symbol("sent close"),
		kReceivedClose: Symbol("received close"),
		kByteParser: Symbol("byte parser")
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/events.js"(exports, module) {
	const { webidl: webidl$1 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$1 } = require_util$6();
	const { MessagePort } = __require("worker_threads");
	/**
	* @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	*/
	var MessageEvent$1 = class MessageEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.MessageEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get data() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.data;
		}
		get origin() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.origin;
		}
		get lastEventId() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.lastEventId;
		}
		get source() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.source;
		}
		get ports() {
			webidl$1.brandCheck(this, MessageEvent$1);
			if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
			return this.#eventInit.ports;
		}
		initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
			webidl$1.brandCheck(this, MessageEvent$1);
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
			return new MessageEvent$1(type, {
				bubbles,
				cancelable,
				data,
				origin,
				lastEventId,
				source,
				ports
			});
		}
	};
	/**
	* @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	*/
	var CloseEvent$1 = class CloseEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.CloseEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get wasClean() {
			webidl$1.brandCheck(this, CloseEvent$1);
			return this.#eventInit.wasClean;
		}
		get code() {
			webidl$1.brandCheck(this, CloseEvent$1);
			return this.#eventInit.code;
		}
		get reason() {
			webidl$1.brandCheck(this, CloseEvent$1);
			return this.#eventInit.reason;
		}
	};
	var ErrorEvent$1 = class ErrorEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
			super(type, eventInitDict);
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.ErrorEventInit(eventInitDict ?? {});
			this.#eventInit = eventInitDict;
		}
		get message() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.message;
		}
		get filename() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.filename;
		}
		get lineno() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.lineno;
		}
		get colno() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.colno;
		}
		get error() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.error;
		}
	};
	Object.defineProperties(MessageEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "MessageEvent",
			configurable: true
		},
		data: kEnumerableProperty$1,
		origin: kEnumerableProperty$1,
		lastEventId: kEnumerableProperty$1,
		source: kEnumerableProperty$1,
		ports: kEnumerableProperty$1,
		initMessageEvent: kEnumerableProperty$1
	});
	Object.defineProperties(CloseEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "CloseEvent",
			configurable: true
		},
		reason: kEnumerableProperty$1,
		code: kEnumerableProperty$1,
		wasClean: kEnumerableProperty$1
	});
	Object.defineProperties(ErrorEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "ErrorEvent",
			configurable: true
		},
		message: kEnumerableProperty$1,
		filename: kEnumerableProperty$1,
		lineno: kEnumerableProperty$1,
		colno: kEnumerableProperty$1,
		error: kEnumerableProperty$1
	});
	webidl$1.converters.MessagePort = webidl$1.interfaceConverter(MessagePort);
	webidl$1.converters["sequence<MessagePort>"] = webidl$1.sequenceConverter(webidl$1.converters.MessagePort);
	const eventInit = [
		{
			key: "bubbles",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		}
	];
	webidl$1.converters.MessageEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "data",
			converter: webidl$1.converters.any,
			defaultValue: null
		},
		{
			key: "origin",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lastEventId",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "source",
			converter: webidl$1.nullableConverter(webidl$1.converters.MessagePort),
			defaultValue: null
		},
		{
			key: "ports",
			converter: webidl$1.converters["sequence<MessagePort>"],
			get defaultValue() {
				return [];
			}
		}
	]);
	webidl$1.converters.CloseEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "wasClean",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "code",
			converter: webidl$1.converters["unsigned short"],
			defaultValue: 0
		},
		{
			key: "reason",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		}
	]);
	webidl$1.converters.ErrorEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "message",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "filename",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lineno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "colno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "error",
			converter: webidl$1.converters.any
		}
	]);
	module.exports = {
		MessageEvent: MessageEvent$1,
		CloseEvent: CloseEvent$1,
		ErrorEvent: ErrorEvent$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/util.js
var require_util = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/util.js"(exports, module) {
	const { kReadyState: kReadyState$3, kController: kController$1, kResponse: kResponse$2, kBinaryType: kBinaryType$1, kWebSocketURL: kWebSocketURL$1 } = require_symbols();
	const { states: states$3, opcodes: opcodes$2 } = require_constants$1();
	const { MessageEvent, ErrorEvent } = require_events();
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isEstablished$1(ws) {
		return ws[kReadyState$3] === states$3.OPEN;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosing$1(ws) {
		return ws[kReadyState$3] === states$3.CLOSING;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosed(ws) {
		return ws[kReadyState$3] === states$3.CLOSED;
	}
	/**
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e
	* @param {EventTarget} target
	* @param {EventInit | undefined} eventInitDict
	*/
	function fireEvent$2(e, target, eventConstructor = Event, eventInitDict) {
		const event = new eventConstructor(e, eventInitDict);
		target.dispatchEvent(event);
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @param {import('./websocket').WebSocket} ws
	* @param {number} type Opcode
	* @param {Buffer} data application data
	*/
	function websocketMessageReceived$1(ws, type, data) {
		if (ws[kReadyState$3] !== states$3.OPEN) return;
		let dataForEvent;
		if (type === opcodes$2.TEXT) try {
			dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
		} catch {
			failWebsocketConnection$3(ws, "Received invalid UTF-8 in text frame.");
			return;
		}
		else if (type === opcodes$2.BINARY) if (ws[kBinaryType$1] === "blob") dataForEvent = new Blob([data]);
		else dataForEvent = new Uint8Array(data).buffer;
		fireEvent$2("message", ws, MessageEvent, {
			origin: ws[kWebSocketURL$1].origin,
			data: dataForEvent
		});
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455
	* @see https://datatracker.ietf.org/doc/html/rfc2616
	* @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	* @param {string} protocol
	*/
	function isValidSubprotocol$1(protocol) {
		if (protocol.length === 0) return false;
		for (const char of protocol) {
			const code = char.charCodeAt(0);
			if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9) return false;
		}
		return true;
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	* @param {number} code
	*/
	function isValidStatusCode$1(code) {
		if (code >= 1e3 && code < 1015) return code !== 1004 && code !== 1005 && code !== 1006;
		return code >= 3e3 && code <= 4999;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @param {string|undefined} reason
	*/
	function failWebsocketConnection$3(ws, reason) {
		const { [kController$1]: controller, [kResponse$2]: response } = ws;
		controller.abort();
		if (response?.socket && !response.socket.destroyed) response.socket.destroy();
		if (reason) fireEvent$2("error", ws, ErrorEvent, { error: new Error(reason) });
	}
	module.exports = {
		isEstablished: isEstablished$1,
		isClosing: isClosing$1,
		isClosed,
		fireEvent: fireEvent$2,
		isValidSubprotocol: isValidSubprotocol$1,
		isValidStatusCode: isValidStatusCode$1,
		failWebsocketConnection: failWebsocketConnection$3,
		websocketMessageReceived: websocketMessageReceived$1
	};
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/connection.js"(exports, module) {
	const diagnosticsChannel$1 = __require("diagnostics_channel");
	const { uid, states: states$2 } = require_constants$1();
	const { kReadyState: kReadyState$2, kSentClose: kSentClose$2, kByteParser: kByteParser$1, kReceivedClose: kReceivedClose$1 } = require_symbols();
	const { fireEvent: fireEvent$1, failWebsocketConnection: failWebsocketConnection$2 } = require_util();
	const { CloseEvent } = require_events();
	const { makeRequest } = require_request();
	const { fetching } = require_fetch();
	const { Headers: Headers$3 } = require_headers();
	const { getGlobalDispatcher: getGlobalDispatcher$2 } = require_global();
	const { kHeadersList } = require_symbols$4();
	const channels$1 = {};
	channels$1.open = diagnosticsChannel$1.channel("undici:websocket:open");
	channels$1.close = diagnosticsChannel$1.channel("undici:websocket:close");
	channels$1.socketError = diagnosticsChannel$1.channel("undici:websocket:socket_error");
	/** @type {import('crypto')} */
	let crypto$1;
	try {
		crypto$1 = __require("crypto");
	} catch {}
	/**
	* @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	* @param {URL} url
	* @param {string|string[]} protocols
	* @param {import('./websocket').WebSocket} ws
	* @param {(response: any) => void} onEstablish
	* @param {Partial<import('../../types/websocket').WebSocketInit>} options
	*/
	function establishWebSocketConnection$1(url, protocols, ws, onEstablish, options) {
		const requestURL = url;
		requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
		const request$2 = makeRequest({
			urlList: [requestURL],
			serviceWorkers: "none",
			referrer: "no-referrer",
			mode: "websocket",
			credentials: "include",
			cache: "no-store",
			redirect: "error"
		});
		if (options.headers) {
			const headersList = new Headers$3(options.headers)[kHeadersList];
			request$2.headersList = headersList;
		}
		const keyValue = crypto$1.randomBytes(16).toString("base64");
		request$2.headersList.append("sec-websocket-key", keyValue);
		request$2.headersList.append("sec-websocket-version", "13");
		for (const protocol of protocols) request$2.headersList.append("sec-websocket-protocol", protocol);
		const permessageDeflate = "";
		const controller = fetching({
			request: request$2,
			useParallelQueue: true,
			dispatcher: options.dispatcher ?? getGlobalDispatcher$2(),
			processResponse(response) {
				if (response.type === "error" || response.status !== 101) {
					failWebsocketConnection$2(ws, "Received network error or non-101 status code.");
					return;
				}
				if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Server did not respond with sent protocols.");
					return;
				}
				if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
					failWebsocketConnection$2(ws, "Server did not set Upgrade header to \"websocket\".");
					return;
				}
				if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
					failWebsocketConnection$2(ws, "Server did not set Connection header to \"upgrade\".");
					return;
				}
				const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
				const digest = crypto$1.createHash("sha1").update(keyValue + uid).digest("base64");
				if (secWSAccept !== digest) {
					failWebsocketConnection$2(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
					return;
				}
				const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
				if (secExtension !== null && secExtension !== permessageDeflate) {
					failWebsocketConnection$2(ws, "Received different permessage-deflate than the one set.");
					return;
				}
				const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
				if (secProtocol !== null && secProtocol !== request$2.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Protocol was not set in the opening handshake.");
					return;
				}
				response.socket.on("data", onSocketData);
				response.socket.on("close", onSocketClose);
				response.socket.on("error", onSocketError);
				if (channels$1.open.hasSubscribers) channels$1.open.publish({
					address: response.socket.address(),
					protocol: secProtocol,
					extensions: secExtension
				});
				onEstablish(response);
			}
		});
		return controller;
	}
	/**
	* @param {Buffer} chunk
	*/
	function onSocketData(chunk) {
		if (!this.ws[kByteParser$1].write(chunk)) this.pause();
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	*/
	function onSocketClose() {
		const { ws } = this;
		const wasClean = ws[kSentClose$2] && ws[kReceivedClose$1];
		let code = 1005;
		let reason = "";
		const result = ws[kByteParser$1].closingInfo;
		if (result) {
			code = result.code ?? 1005;
			reason = result.reason;
		} else if (!ws[kSentClose$2]) code = 1006;
		ws[kReadyState$2] = states$2.CLOSED;
		fireEvent$1("close", ws, CloseEvent, {
			wasClean,
			code,
			reason
		});
		if (channels$1.close.hasSubscribers) channels$1.close.publish({
			websocket: ws,
			code,
			reason
		});
	}
	function onSocketError(error$1) {
		const { ws } = this;
		ws[kReadyState$2] = states$2.CLOSING;
		if (channels$1.socketError.hasSubscribers) channels$1.socketError.publish(error$1);
		this.destroy();
	}
	module.exports = { establishWebSocketConnection: establishWebSocketConnection$1 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/frame.js"(exports, module) {
	const { maxUnsigned16Bit } = require_constants$1();
	/** @type {import('crypto')} */
	let crypto;
	try {
		crypto = __require("crypto");
	} catch {}
	var WebsocketFrameSend$2 = class {
		/**
		* @param {Buffer|undefined} data
		*/
		constructor(data) {
			this.frameData = data;
			this.maskKey = crypto.randomBytes(4);
		}
		createFrame(opcode) {
			const bodyLength$1 = this.frameData?.byteLength ?? 0;
			/** @type {number} */
			let payloadLength = bodyLength$1;
			let offset = 6;
			if (bodyLength$1 > maxUnsigned16Bit) {
				offset += 8;
				payloadLength = 127;
			} else if (bodyLength$1 > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const buffer = Buffer.allocUnsafe(bodyLength$1 + offset);
			buffer[0] = buffer[1] = 0;
			buffer[0] |= 128;
			buffer[0] = (buffer[0] & 240) + opcode;
			/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
			buffer[offset - 4] = this.maskKey[0];
			buffer[offset - 3] = this.maskKey[1];
			buffer[offset - 2] = this.maskKey[2];
			buffer[offset - 1] = this.maskKey[3];
			buffer[1] = payloadLength;
			if (payloadLength === 126) buffer.writeUInt16BE(bodyLength$1, 2);
			else if (payloadLength === 127) {
				buffer[2] = buffer[3] = 0;
				buffer.writeUIntBE(bodyLength$1, 4, 6);
			}
			buffer[1] |= 128;
			for (let i$1 = 0; i$1 < bodyLength$1; i$1++) buffer[offset + i$1] = this.frameData[i$1] ^ this.maskKey[i$1 % 4];
			return buffer;
		}
	};
	module.exports = { WebsocketFrameSend: WebsocketFrameSend$2 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/receiver.js"(exports, module) {
	const { Writable: Writable$1 } = __require("stream");
	const diagnosticsChannel = __require("diagnostics_channel");
	const { parserStates, opcodes: opcodes$1, states: states$1, emptyBuffer: emptyBuffer$1 } = require_constants$1();
	const { kReadyState: kReadyState$1, kSentClose: kSentClose$1, kResponse: kResponse$1, kReceivedClose } = require_symbols();
	const { isValidStatusCode, failWebsocketConnection: failWebsocketConnection$1, websocketMessageReceived } = require_util();
	const { WebsocketFrameSend: WebsocketFrameSend$1 } = require_frame();
	const channels = {};
	channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
	channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
	var ByteParser$1 = class extends Writable$1 {
		#buffers = [];
		#byteOffset = 0;
		#state = parserStates.INFO;
		#info = {};
		#fragments = [];
		constructor(ws) {
			super();
			this.ws = ws;
		}
		/**
		* @param {Buffer} chunk
		* @param {() => void} callback
		*/
		_write(chunk, _, callback) {
			this.#buffers.push(chunk);
			this.#byteOffset += chunk.length;
			this.run(callback);
		}
		/**
		* Runs whenever a new chunk is received.
		* Callback is called whenever there are no more chunks buffering,
		* or not enough bytes are buffered to parse.
		*/
		run(callback) {
			while (true) {
				if (this.#state === parserStates.INFO) {
					if (this.#byteOffset < 2) return callback();
					const buffer = this.consume(2);
					this.#info.fin = (buffer[0] & 128) !== 0;
					this.#info.opcode = buffer[0] & 15;
					this.#info.originalOpcode ??= this.#info.opcode;
					this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes$1.CONTINUATION;
					if (this.#info.fragmented && this.#info.opcode !== opcodes$1.BINARY && this.#info.opcode !== opcodes$1.TEXT) {
						failWebsocketConnection$1(this.ws, "Invalid frame type was fragmented.");
						return;
					}
					const payloadLength = buffer[1] & 127;
					if (payloadLength <= 125) {
						this.#info.payloadLength = payloadLength;
						this.#state = parserStates.READ_DATA;
					} else if (payloadLength === 126) this.#state = parserStates.PAYLOADLENGTH_16;
					else if (payloadLength === 127) this.#state = parserStates.PAYLOADLENGTH_64;
					if (this.#info.fragmented && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Fragmented frame exceeded 125 bytes.");
						return;
					} else if ((this.#info.opcode === opcodes$1.PING || this.#info.opcode === opcodes$1.PONG || this.#info.opcode === opcodes$1.CLOSE) && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Payload length for control frame exceeded 125 bytes.");
						return;
					} else if (this.#info.opcode === opcodes$1.CLOSE) {
						if (payloadLength === 1) {
							failWebsocketConnection$1(this.ws, "Received close frame with a 1-byte body.");
							return;
						}
						const body = this.consume(payloadLength);
						this.#info.closeInfo = this.parseCloseBody(false, body);
						if (!this.ws[kSentClose$1]) {
							const body$1 = Buffer.allocUnsafe(2);
							body$1.writeUInt16BE(this.#info.closeInfo.code, 0);
							const closeFrame = new WebsocketFrameSend$1(body$1);
							this.ws[kResponse$1].socket.write(closeFrame.createFrame(opcodes$1.CLOSE), (err) => {
								if (!err) this.ws[kSentClose$1] = true;
							});
						}
						this.ws[kReadyState$1] = states$1.CLOSING;
						this.ws[kReceivedClose] = true;
						this.end();
						return;
					} else if (this.#info.opcode === opcodes$1.PING) {
						const body = this.consume(payloadLength);
						if (!this.ws[kReceivedClose]) {
							const frame = new WebsocketFrameSend$1(body);
							this.ws[kResponse$1].socket.write(frame.createFrame(opcodes$1.PONG));
							if (channels.ping.hasSubscribers) channels.ping.publish({ payload: body });
						}
						this.#state = parserStates.INFO;
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					} else if (this.#info.opcode === opcodes$1.PONG) {
						const body = this.consume(payloadLength);
						if (channels.pong.hasSubscribers) channels.pong.publish({ payload: body });
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					}
				} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
					if (this.#byteOffset < 2) return callback();
					const buffer = this.consume(2);
					this.#info.payloadLength = buffer.readUInt16BE(0);
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
					if (this.#byteOffset < 8) return callback();
					const buffer = this.consume(8);
					const upper = buffer.readUInt32BE(0);
					if (upper > 2 ** 31 - 1) {
						failWebsocketConnection$1(this.ws, "Received payload length > 2^31 bytes.");
						return;
					}
					const lower = buffer.readUInt32BE(4);
					this.#info.payloadLength = (upper << 8) + lower;
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.READ_DATA) {
					if (this.#byteOffset < this.#info.payloadLength) return callback();
					else if (this.#byteOffset >= this.#info.payloadLength) {
						const body = this.consume(this.#info.payloadLength);
						this.#fragments.push(body);
						if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes$1.CONTINUATION) {
							const fullMessage = Buffer.concat(this.#fragments);
							websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
							this.#info = {};
							this.#fragments.length = 0;
						}
						this.#state = parserStates.INFO;
					}
				}
				if (this.#byteOffset > 0) continue;
				else {
					callback();
					break;
				}
			}
		}
		/**
		* Take n bytes from the buffered Buffers
		* @param {number} n
		* @returns {Buffer|null}
		*/
		consume(n$1) {
			if (n$1 > this.#byteOffset) return null;
			else if (n$1 === 0) return emptyBuffer$1;
			if (this.#buffers[0].length === n$1) {
				this.#byteOffset -= this.#buffers[0].length;
				return this.#buffers.shift();
			}
			const buffer = Buffer.allocUnsafe(n$1);
			let offset = 0;
			while (offset !== n$1) {
				const next = this.#buffers[0];
				const { length } = next;
				if (length + offset === n$1) {
					buffer.set(this.#buffers.shift(), offset);
					break;
				} else if (length + offset > n$1) {
					buffer.set(next.subarray(0, n$1 - offset), offset);
					this.#buffers[0] = next.subarray(n$1 - offset);
					break;
				} else {
					buffer.set(this.#buffers.shift(), offset);
					offset += next.length;
				}
			}
			this.#byteOffset -= n$1;
			return buffer;
		}
		parseCloseBody(onlyCode, data) {
			/** @type {number|undefined} */
			let code;
			if (data.length >= 2) code = data.readUInt16BE(0);
			if (onlyCode) {
				if (!isValidStatusCode(code)) return null;
				return { code };
			}
			/** @type {Buffer} */
			let reason = data.subarray(2);
			if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) reason = reason.subarray(3);
			if (code !== void 0 && !isValidStatusCode(code)) return null;
			try {
				reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
			} catch {
				return null;
			}
			return {
				code,
				reason
			};
		}
		get closingInfo() {
			return this.#info.closeInfo;
		}
	};
	module.exports = { ByteParser: ByteParser$1 };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/lib/websocket/websocket.js"(exports, module) {
	const { webidl } = require_webidl();
	const { DOMException: DOMException$1 } = require_constants$4();
	const { URLSerializer } = require_dataURL();
	const { getGlobalOrigin } = require_global$1();
	const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants$1();
	const { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = require_symbols();
	const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util();
	const { establishWebSocketConnection } = require_connection();
	const { WebsocketFrameSend } = require_frame();
	const { ByteParser } = require_receiver();
	const { kEnumerableProperty, isBlobLike: isBlobLike$1 } = require_util$6();
	const { getGlobalDispatcher: getGlobalDispatcher$1 } = require_global();
	const { types } = __require("util");
	let experimentalWarned = false;
	var WebSocket = class WebSocket extends EventTarget {
		#events = {
			open: null,
			error: null,
			close: null,
			message: null
		};
		#bufferedAmount = 0;
		#protocol = "";
		#extensions = "";
		/**
		* @param {string} url
		* @param {string|string[]} protocols
		*/
		constructor(url, protocols = []) {
			super();
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
			if (!experimentalWarned) {
				experimentalWarned = true;
				process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" });
			}
			const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
			url = webidl.converters.USVString(url);
			protocols = options.protocols;
			const baseURL = getGlobalOrigin();
			let urlRecord;
			try {
				urlRecord = new URL(url, baseURL);
			} catch (e) {
				throw new DOMException$1(e, "SyntaxError");
			}
			if (urlRecord.protocol === "http:") urlRecord.protocol = "ws:";
			else if (urlRecord.protocol === "https:") urlRecord.protocol = "wss:";
			if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") throw new DOMException$1(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
			if (urlRecord.hash || urlRecord.href.endsWith("#")) throw new DOMException$1("Got fragment", "SyntaxError");
			if (typeof protocols === "string") protocols = [protocols];
			if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) throw new DOMException$1("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) throw new DOMException$1("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			this[kWebSocketURL] = new URL(urlRecord.href);
			this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options);
			this[kReadyState] = WebSocket.CONNECTING;
			this[kBinaryType] = "blob";
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-close
		* @param {number|undefined} code
		* @param {string|undefined} reason
		*/
		close(code = void 0, reason = void 0) {
			webidl.brandCheck(this, WebSocket);
			if (code !== void 0) code = webidl.converters["unsigned short"](code, { clamp: true });
			if (reason !== void 0) reason = webidl.converters.USVString(reason);
			if (code !== void 0) {
				if (code !== 1e3 && (code < 3e3 || code > 4999)) throw new DOMException$1("invalid code", "InvalidAccessError");
			}
			let reasonByteLength = 0;
			if (reason !== void 0) {
				reasonByteLength = Buffer.byteLength(reason);
				if (reasonByteLength > 123) throw new DOMException$1(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
			}
			if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {} else if (!isEstablished(this)) {
				failWebsocketConnection(this, "Connection was closed before it was established.");
				this[kReadyState] = WebSocket.CLOSING;
			} else if (!isClosing(this)) {
				const frame = new WebsocketFrameSend();
				if (code !== void 0 && reason === void 0) {
					frame.frameData = Buffer.allocUnsafe(2);
					frame.frameData.writeUInt16BE(code, 0);
				} else if (code !== void 0 && reason !== void 0) {
					frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
					frame.frameData.writeUInt16BE(code, 0);
					frame.frameData.write(reason, 2, "utf-8");
				} else frame.frameData = emptyBuffer;
				/** @type {import('stream').Duplex} */
				const socket = this[kResponse].socket;
				socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
					if (!err) this[kSentClose] = true;
				});
				this[kReadyState] = states.CLOSING;
			} else this[kReadyState] = WebSocket.CLOSING;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-send
		* @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
		*/
		send(data) {
			webidl.brandCheck(this, WebSocket);
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
			data = webidl.converters.WebSocketSendData(data);
			if (this[kReadyState] === WebSocket.CONNECTING) throw new DOMException$1("Sent before connected.", "InvalidStateError");
			if (!isEstablished(this) || isClosing(this)) return;
			/** @type {import('stream').Duplex} */
			const socket = this[kResponse].socket;
			if (typeof data === "string") {
				const value = Buffer.from(data);
				const frame = new WebsocketFrameSend(value);
				const buffer = frame.createFrame(opcodes.TEXT);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (types.isArrayBuffer(data)) {
				const value = Buffer.from(data);
				const frame = new WebsocketFrameSend(value);
				const buffer = frame.createFrame(opcodes.BINARY);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (ArrayBuffer.isView(data)) {
				const ab = Buffer.from(data, data.byteOffset, data.byteLength);
				const frame = new WebsocketFrameSend(ab);
				const buffer = frame.createFrame(opcodes.BINARY);
				this.#bufferedAmount += ab.byteLength;
				socket.write(buffer, () => {
					this.#bufferedAmount -= ab.byteLength;
				});
			} else if (isBlobLike$1(data)) {
				const frame = new WebsocketFrameSend();
				data.arrayBuffer().then((ab) => {
					const value = Buffer.from(ab);
					frame.frameData = value;
					const buffer = frame.createFrame(opcodes.BINARY);
					this.#bufferedAmount += value.byteLength;
					socket.write(buffer, () => {
						this.#bufferedAmount -= value.byteLength;
					});
				});
			}
		}
		get readyState() {
			webidl.brandCheck(this, WebSocket);
			return this[kReadyState];
		}
		get bufferedAmount() {
			webidl.brandCheck(this, WebSocket);
			return this.#bufferedAmount;
		}
		get url() {
			webidl.brandCheck(this, WebSocket);
			return URLSerializer(this[kWebSocketURL]);
		}
		get extensions() {
			webidl.brandCheck(this, WebSocket);
			return this.#extensions;
		}
		get protocol() {
			webidl.brandCheck(this, WebSocket);
			return this.#protocol;
		}
		get onopen() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.open;
		}
		set onopen(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.open) this.removeEventListener("open", this.#events.open);
			if (typeof fn === "function") {
				this.#events.open = fn;
				this.addEventListener("open", fn);
			} else this.#events.open = null;
		}
		get onerror() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.error) this.removeEventListener("error", this.#events.error);
			if (typeof fn === "function") {
				this.#events.error = fn;
				this.addEventListener("error", fn);
			} else this.#events.error = null;
		}
		get onclose() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.close;
		}
		set onclose(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.close) this.removeEventListener("close", this.#events.close);
			if (typeof fn === "function") {
				this.#events.close = fn;
				this.addEventListener("close", fn);
			} else this.#events.close = null;
		}
		get onmessage() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.message;
		}
		set onmessage(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.message) this.removeEventListener("message", this.#events.message);
			if (typeof fn === "function") {
				this.#events.message = fn;
				this.addEventListener("message", fn);
			} else this.#events.message = null;
		}
		get binaryType() {
			webidl.brandCheck(this, WebSocket);
			return this[kBinaryType];
		}
		set binaryType(type) {
			webidl.brandCheck(this, WebSocket);
			if (type !== "blob" && type !== "arraybuffer") this[kBinaryType] = "blob";
			else this[kBinaryType] = type;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
		*/
		#onConnectionEstablished(response) {
			this[kResponse] = response;
			const parser = new ByteParser(this);
			parser.on("drain", function onParserDrain() {
				this.ws[kResponse].socket.resume();
			});
			response.socket.ws = this;
			this[kByteParser] = parser;
			this[kReadyState] = states.OPEN;
			const extensions = response.headersList.get("sec-websocket-extensions");
			if (extensions !== null) this.#extensions = extensions;
			const protocol = response.headersList.get("sec-websocket-protocol");
			if (protocol !== null) this.#protocol = protocol;
			fireEvent("open", this);
		}
	};
	WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
	WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
	WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
	WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
	Object.defineProperties(WebSocket.prototype, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors,
		url: kEnumerableProperty,
		readyState: kEnumerableProperty,
		bufferedAmount: kEnumerableProperty,
		onopen: kEnumerableProperty,
		onerror: kEnumerableProperty,
		onclose: kEnumerableProperty,
		close: kEnumerableProperty,
		onmessage: kEnumerableProperty,
		binaryType: kEnumerableProperty,
		send: kEnumerableProperty,
		extensions: kEnumerableProperty,
		protocol: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "WebSocket",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(WebSocket, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors
	});
	webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
	webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
		if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) return webidl.converters["sequence<DOMString>"](V);
		return webidl.converters.DOMString(V);
	};
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
		{
			key: "protocols",
			converter: webidl.converters["DOMString or sequence<DOMString>"],
			get defaultValue() {
				return [];
			}
		},
		{
			key: "dispatcher",
			converter: (V) => V,
			get defaultValue() {
				return getGlobalDispatcher$1();
			}
		},
		{
			key: "headers",
			converter: webidl.nullableConverter(webidl.converters.HeadersInit)
		}
	]);
	webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
		if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
		return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
	};
	webidl.converters.WebSocketSendData = function(V) {
		if (webidl.util.Type(V) === "Object") {
			if (isBlobLike$1(V)) return webidl.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V);
		}
		return webidl.converters.USVString(V);
	};
	module.exports = { WebSocket };
} });

//#endregion
//#region node_modules/.pnpm/undici@5.28.5/node_modules/undici/index.js
var require_undici = __commonJS({ "node_modules/.pnpm/undici@5.28.5/node_modules/undici/index.js"(exports, module) {
	const Client = require_client();
	const Dispatcher = require_dispatcher();
	const errors = require_errors();
	const Pool = require_pool();
	const BalancedPool = require_balanced_pool();
	const Agent$1 = require_agent$1();
	const util$1 = require_util$6();
	const { InvalidArgumentError } = errors;
	const api = require_api();
	const buildConnector = require_connect();
	const MockClient = require_mock_client();
	const MockAgent = require_mock_agent();
	const MockPool = require_mock_pool();
	const mockErrors = require_mock_errors();
	const ProxyAgent = require_proxy_agent();
	const RetryHandler = require_RetryHandler();
	const { getGlobalDispatcher, setGlobalDispatcher } = require_global();
	const DecoratorHandler = require_DecoratorHandler();
	const RedirectHandler = require_RedirectHandler();
	const createRedirectInterceptor = require_redirectInterceptor();
	let hasCrypto;
	try {
		__require("crypto");
		hasCrypto = true;
	} catch {
		hasCrypto = false;
	}
	Object.assign(Dispatcher.prototype, api);
	module.exports.Dispatcher = Dispatcher;
	module.exports.Client = Client;
	module.exports.Pool = Pool;
	module.exports.BalancedPool = BalancedPool;
	module.exports.Agent = Agent$1;
	module.exports.ProxyAgent = ProxyAgent;
	module.exports.RetryHandler = RetryHandler;
	module.exports.DecoratorHandler = DecoratorHandler;
	module.exports.RedirectHandler = RedirectHandler;
	module.exports.createRedirectInterceptor = createRedirectInterceptor;
	module.exports.buildConnector = buildConnector;
	module.exports.errors = errors;
	function makeDispatcher(fn) {
		return (url, opts, handler$1) => {
			if (typeof opts === "function") {
				handler$1 = opts;
				opts = null;
			}
			if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) throw new InvalidArgumentError("invalid url");
			if (opts != null && typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (opts && opts.path != null) {
				if (typeof opts.path !== "string") throw new InvalidArgumentError("invalid opts.path");
				let path$9 = opts.path;
				if (!opts.path.startsWith("/")) path$9 = `/${path$9}`;
				url = new URL(util$1.parseOrigin(url).origin + path$9);
			} else {
				if (!opts) opts = typeof url === "object" ? url : {};
				url = util$1.parseURL(url);
			}
			const { agent, dispatcher = getGlobalDispatcher() } = opts;
			if (agent) throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
			return fn.call(dispatcher, {
				...opts,
				origin: url.origin,
				path: url.search ? `${url.pathname}${url.search}` : url.pathname,
				method: opts.method || (opts.body ? "PUT" : "GET")
			}, handler$1);
		};
	}
	module.exports.setGlobalDispatcher = setGlobalDispatcher;
	module.exports.getGlobalDispatcher = getGlobalDispatcher;
	if (util$1.nodeMajor > 16 || util$1.nodeMajor === 16 && util$1.nodeMinor >= 8) {
		let fetchImpl = null;
		module.exports.fetch = async function fetch$3(resource) {
			if (!fetchImpl) fetchImpl = require_fetch().fetch;
			try {
				return await fetchImpl(...arguments);
			} catch (err) {
				if (typeof err === "object") Error.captureStackTrace(err, this);
				throw err;
			}
		};
		module.exports.Headers = require_headers().Headers;
		module.exports.Response = require_response().Response;
		module.exports.Request = require_request().Request;
		module.exports.FormData = require_formdata().FormData;
		module.exports.File = require_file().File;
		module.exports.FileReader = require_filereader().FileReader;
		const { setGlobalOrigin: setGlobalOrigin$1, getGlobalOrigin: getGlobalOrigin$5 } = require_global$1();
		module.exports.setGlobalOrigin = setGlobalOrigin$1;
		module.exports.getGlobalOrigin = getGlobalOrigin$5;
		const { CacheStorage: CacheStorage$1 } = require_cachestorage();
		const { kConstruct: kConstruct$5 } = require_symbols$1();
		module.exports.caches = new CacheStorage$1(kConstruct$5);
	}
	if (util$1.nodeMajor >= 16) {
		const { deleteCookie: deleteCookie$1, getCookies: getCookies$1, getSetCookies: getSetCookies$1, setCookie: setCookie$1 } = require_cookies();
		module.exports.deleteCookie = deleteCookie$1;
		module.exports.getCookies = getCookies$1;
		module.exports.getSetCookies = getSetCookies$1;
		module.exports.setCookie = setCookie$1;
		const { parseMIMEType: parseMIMEType$4, serializeAMimeType: serializeAMimeType$5 } = require_dataURL();
		module.exports.parseMIMEType = parseMIMEType$4;
		module.exports.serializeAMimeType = serializeAMimeType$5;
	}
	if (util$1.nodeMajor >= 18 && hasCrypto) {
		const { WebSocket: WebSocket$1 } = require_websocket();
		module.exports.WebSocket = WebSocket$1;
	}
	module.exports.request = makeDispatcher(api.request);
	module.exports.stream = makeDispatcher(api.stream);
	module.exports.pipeline = makeDispatcher(api.pipeline);
	module.exports.connect = makeDispatcher(api.connect);
	module.exports.upgrade = makeDispatcher(api.upgrade);
	module.exports.MockClient = MockClient;
	module.exports.MockPool = MockPool;
	module.exports.MockAgent = MockAgent;
	module.exports.mockErrors = mockErrors;
} });

//#endregion
//#region node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/index.js
var require_lib$2 = __commonJS({ "node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/index.js"(exports) {
	var __createBinding$10 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$10 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$10 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$10(result, mod, k);
		}
		__setModuleDefault$10(result, mod);
		return result;
	};
	var __awaiter$10 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
	const http$1 = __importStar$10(__require("http"));
	const https$1 = __importStar$10(__require("https"));
	const pm = __importStar$10(require_proxy());
	const tunnel = __importStar$10(require_tunnel());
	const undici_1$1 = require_undici();
	var HttpCodes;
	(function(HttpCodes$1) {
		HttpCodes$1[HttpCodes$1["OK"] = 200] = "OK";
		HttpCodes$1[HttpCodes$1["MultipleChoices"] = 300] = "MultipleChoices";
		HttpCodes$1[HttpCodes$1["MovedPermanently"] = 301] = "MovedPermanently";
		HttpCodes$1[HttpCodes$1["ResourceMoved"] = 302] = "ResourceMoved";
		HttpCodes$1[HttpCodes$1["SeeOther"] = 303] = "SeeOther";
		HttpCodes$1[HttpCodes$1["NotModified"] = 304] = "NotModified";
		HttpCodes$1[HttpCodes$1["UseProxy"] = 305] = "UseProxy";
		HttpCodes$1[HttpCodes$1["SwitchProxy"] = 306] = "SwitchProxy";
		HttpCodes$1[HttpCodes$1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
		HttpCodes$1[HttpCodes$1["PermanentRedirect"] = 308] = "PermanentRedirect";
		HttpCodes$1[HttpCodes$1["BadRequest"] = 400] = "BadRequest";
		HttpCodes$1[HttpCodes$1["Unauthorized"] = 401] = "Unauthorized";
		HttpCodes$1[HttpCodes$1["PaymentRequired"] = 402] = "PaymentRequired";
		HttpCodes$1[HttpCodes$1["Forbidden"] = 403] = "Forbidden";
		HttpCodes$1[HttpCodes$1["NotFound"] = 404] = "NotFound";
		HttpCodes$1[HttpCodes$1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
		HttpCodes$1[HttpCodes$1["NotAcceptable"] = 406] = "NotAcceptable";
		HttpCodes$1[HttpCodes$1["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
		HttpCodes$1[HttpCodes$1["RequestTimeout"] = 408] = "RequestTimeout";
		HttpCodes$1[HttpCodes$1["Conflict"] = 409] = "Conflict";
		HttpCodes$1[HttpCodes$1["Gone"] = 410] = "Gone";
		HttpCodes$1[HttpCodes$1["TooManyRequests"] = 429] = "TooManyRequests";
		HttpCodes$1[HttpCodes$1["InternalServerError"] = 500] = "InternalServerError";
		HttpCodes$1[HttpCodes$1["NotImplemented"] = 501] = "NotImplemented";
		HttpCodes$1[HttpCodes$1["BadGateway"] = 502] = "BadGateway";
		HttpCodes$1[HttpCodes$1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
		HttpCodes$1[HttpCodes$1["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
	var Headers$2;
	(function(Headers$9) {
		Headers$9["Accept"] = "accept";
		Headers$9["ContentType"] = "content-type";
	})(Headers$2 || (exports.Headers = Headers$2 = {}));
	var MediaTypes;
	(function(MediaTypes$1) {
		MediaTypes$1["ApplicationJson"] = "application/json";
	})(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
	/**
	* Returns the proxy URL, depending upon the supplied url and proxy environment variables.
	* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	*/
	function getProxyUrl(serverUrl) {
		const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
		return proxyUrl ? proxyUrl.href : "";
	}
	exports.getProxyUrl = getProxyUrl;
	const HttpRedirectCodes = [
		HttpCodes.MovedPermanently,
		HttpCodes.ResourceMoved,
		HttpCodes.SeeOther,
		HttpCodes.TemporaryRedirect,
		HttpCodes.PermanentRedirect
	];
	const HttpResponseRetryCodes = [
		HttpCodes.BadGateway,
		HttpCodes.ServiceUnavailable,
		HttpCodes.GatewayTimeout
	];
	const RetryableHttpVerbs = [
		"OPTIONS",
		"GET",
		"DELETE",
		"HEAD"
	];
	const ExponentialBackoffCeiling = 10;
	const ExponentialBackoffTimeSlice = 5;
	var HttpClientError = class HttpClientError extends Error {
		constructor(message, statusCode) {
			super(message);
			this.name = "HttpClientError";
			this.statusCode = statusCode;
			Object.setPrototypeOf(this, HttpClientError.prototype);
		}
	};
	exports.HttpClientError = HttpClientError;
	var HttpClientResponse = class {
		constructor(message) {
			this.message = message;
		}
		readBody() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					let output = Buffer.alloc(0);
					this.message.on("data", (chunk) => {
						output = Buffer.concat([output, chunk]);
					});
					this.message.on("end", () => {
						resolve(output.toString());
					});
				}));
			});
		}
		readBodyBuffer() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					const chunks = [];
					this.message.on("data", (chunk) => {
						chunks.push(chunk);
					});
					this.message.on("end", () => {
						resolve(Buffer.concat(chunks));
					});
				}));
			});
		}
	};
	exports.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
		const parsedUrl = new URL(requestUrl);
		return parsedUrl.protocol === "https:";
	}
	exports.isHttps = isHttps;
	var HttpClient = class {
		constructor(userAgent$1, handlers, requestOptions) {
			this._ignoreSslError = false;
			this._allowRedirects = true;
			this._allowRedirectDowngrade = false;
			this._maxRedirects = 50;
			this._allowRetries = false;
			this._maxRetries = 1;
			this._keepAlive = false;
			this._disposed = false;
			this.userAgent = userAgent$1;
			this.handlers = handlers || [];
			this.requestOptions = requestOptions;
			if (requestOptions) {
				if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;
				this._socketTimeout = requestOptions.socketTimeout;
				if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;
				if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
				if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
				if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;
				if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;
				if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;
			}
		}
		options(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
			});
		}
		get(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("GET", requestUrl, null, additionalHeaders || {});
			});
		}
		del(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("DELETE", requestUrl, null, additionalHeaders || {});
			});
		}
		post(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("POST", requestUrl, data, additionalHeaders || {});
			});
		}
		patch(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PATCH", requestUrl, data, additionalHeaders || {});
			});
		}
		put(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PUT", requestUrl, data, additionalHeaders || {});
			});
		}
		head(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("HEAD", requestUrl, null, additionalHeaders || {});
			});
		}
		sendStream(verb, requestUrl, stream$2, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request(verb, requestUrl, stream$2, additionalHeaders);
			});
		}
		/**
		* Gets a typed object from an endpoint
		* Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
		*/
		getJson(requestUrl, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				const res = yield this.get(requestUrl, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		postJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.post(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		putJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.put(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		patchJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.patch(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		/**
		* Makes a raw http request.
		* All other methods such as get, post, patch, and request ultimately call this.
		* Prefer get, del, post and patch
		*/
		request(verb, requestUrl, data, headers) {
			return __awaiter$10(this, void 0, void 0, function* () {
				if (this._disposed) throw new Error("Client has already been disposed.");
				const parsedUrl = new URL(requestUrl);
				let info$1 = this._prepareRequest(verb, parsedUrl, headers);
				const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
				let numTries = 0;
				let response;
				do {
					response = yield this.requestRaw(info$1, data);
					if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
						let authenticationHandler;
						for (const handler$1 of this.handlers) if (handler$1.canHandleAuthentication(response)) {
							authenticationHandler = handler$1;
							break;
						}
						if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info$1, data);
						else return response;
					}
					let redirectsRemaining = this._maxRedirects;
					while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
						const redirectUrl = response.message.headers["location"];
						if (!redirectUrl) break;
						const parsedRedirectUrl = new URL(redirectUrl);
						if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
						yield response.readBody();
						if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
							for (const header in headers) if (header.toLowerCase() === "authorization") delete headers[header];
						}
						info$1 = this._prepareRequest(verb, parsedRedirectUrl, headers);
						response = yield this.requestRaw(info$1, data);
						redirectsRemaining--;
					}
					if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) return response;
					numTries += 1;
					if (numTries < maxTries) {
						yield response.readBody();
						yield this._performExponentialBackoff(numTries);
					}
				} while (numTries < maxTries);
				return response;
			});
		}
		/**
		* Needs to be called if keepAlive is set to true in request options.
		*/
		dispose() {
			if (this._agent) this._agent.destroy();
			this._disposed = true;
		}
		/**
		* Raw request.
		* @param info
		* @param data
		*/
		requestRaw(info$1, data) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => {
					function callbackForResult(err, res) {
						if (err) reject(err);
						else if (!res) reject(/* @__PURE__ */ new Error("Unknown error"));
						else resolve(res);
					}
					this.requestRawWithCallback(info$1, data, callbackForResult);
				});
			});
		}
		/**
		* Raw request with callback.
		* @param info
		* @param data
		* @param onResult
		*/
		requestRawWithCallback(info$1, data, onResult) {
			if (typeof data === "string") {
				if (!info$1.options.headers) info$1.options.headers = {};
				info$1.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
			}
			let callbackCalled = false;
			function handleResult$1(err, res) {
				if (!callbackCalled) {
					callbackCalled = true;
					onResult(err, res);
				}
			}
			const req = info$1.httpModule.request(info$1.options, (msg) => {
				const res = new HttpClientResponse(msg);
				handleResult$1(void 0, res);
			});
			let socket;
			req.on("socket", (sock) => {
				socket = sock;
			});
			req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
				if (socket) socket.end();
				handleResult$1(/* @__PURE__ */ new Error(`Request timeout: ${info$1.options.path}`));
			});
			req.on("error", function(err) {
				handleResult$1(err);
			});
			if (data && typeof data === "string") req.write(data, "utf8");
			if (data && typeof data !== "string") {
				data.on("close", function() {
					req.end();
				});
				data.pipe(req);
			} else req.end();
		}
		/**
		* Gets an http agent. This function is useful when you need an http agent that handles
		* routing through a proxy server - depending upon the url and proxy environment variables.
		* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
		*/
		getAgent(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			return this._getAgent(parsedUrl);
		}
		getAgentDispatcher(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (!useProxy) return;
			return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
		}
		_prepareRequest(method, requestUrl, headers) {
			const info$1 = {};
			info$1.parsedUrl = requestUrl;
			const usingSsl = info$1.parsedUrl.protocol === "https:";
			info$1.httpModule = usingSsl ? https$1 : http$1;
			const defaultPort$1 = usingSsl ? 443 : 80;
			info$1.options = {};
			info$1.options.host = info$1.parsedUrl.hostname;
			info$1.options.port = info$1.parsedUrl.port ? parseInt(info$1.parsedUrl.port) : defaultPort$1;
			info$1.options.path = (info$1.parsedUrl.pathname || "") + (info$1.parsedUrl.search || "");
			info$1.options.method = method;
			info$1.options.headers = this._mergeHeaders(headers);
			if (this.userAgent != null) info$1.options.headers["user-agent"] = this.userAgent;
			info$1.options.agent = this._getAgent(info$1.parsedUrl);
			if (this.handlers) for (const handler$1 of this.handlers) handler$1.prepareRequest(info$1.options);
			return info$1;
		}
		_mergeHeaders(headers) {
			if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys$1(this.requestOptions.headers), lowercaseKeys$1(headers || {}));
			return lowercaseKeys$1(headers || {});
		}
		_getExistingOrDefaultHeader(additionalHeaders, header, _default) {
			let clientHeader;
			if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys$1(this.requestOptions.headers)[header];
			return additionalHeaders[header] || clientHeader || _default;
		}
		_getAgent(parsedUrl) {
			let agent;
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (this._keepAlive && useProxy) agent = this._proxyAgent;
			if (!useProxy) agent = this._agent;
			if (agent) return agent;
			const usingSsl = parsedUrl.protocol === "https:";
			let maxSockets = 100;
			if (this.requestOptions) maxSockets = this.requestOptions.maxSockets || http$1.globalAgent.maxSockets;
			if (proxyUrl && proxyUrl.hostname) {
				const agentOptions = {
					maxSockets,
					keepAlive: this._keepAlive,
					proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && { proxyAuth: `${proxyUrl.username}:${proxyUrl.password}` }), {
						host: proxyUrl.hostname,
						port: proxyUrl.port
					})
				};
				let tunnelAgent;
				const overHttps = proxyUrl.protocol === "https:";
				if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
				else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
				agent = tunnelAgent(agentOptions);
				this._proxyAgent = agent;
			}
			if (!agent) {
				const options = {
					keepAlive: this._keepAlive,
					maxSockets
				};
				agent = usingSsl ? new https$1.Agent(options) : new http$1.Agent(options);
				this._agent = agent;
			}
			if (usingSsl && this._ignoreSslError) agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
			return agent;
		}
		_getProxyAgentDispatcher(parsedUrl, proxyUrl) {
			let proxyAgent;
			if (this._keepAlive) proxyAgent = this._proxyAgentDispatcher;
			if (proxyAgent) return proxyAgent;
			const usingSsl = parsedUrl.protocol === "https:";
			proxyAgent = new undici_1$1.ProxyAgent(Object.assign({
				uri: proxyUrl.href,
				pipelining: !this._keepAlive ? 0 : 1
			}, (proxyUrl.username || proxyUrl.password) && { token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}` }));
			this._proxyAgentDispatcher = proxyAgent;
			if (usingSsl && this._ignoreSslError) proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, { rejectUnauthorized: false });
			return proxyAgent;
		}
		_performExponentialBackoff(retryNumber) {
			return __awaiter$10(this, void 0, void 0, function* () {
				retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
				const ms$2 = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
				return new Promise((resolve) => setTimeout(() => resolve(), ms$2));
			});
		}
		_processResponse(res, options) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => __awaiter$10(this, void 0, void 0, function* () {
					const statusCode = res.message.statusCode || 0;
					const response = {
						statusCode,
						result: null,
						headers: {}
					};
					if (statusCode === HttpCodes.NotFound) resolve(response);
					function dateTimeDeserializer(key, value) {
						if (typeof value === "string") {
							const a$1 = new Date(value);
							if (!isNaN(a$1.valueOf())) return a$1;
						}
						return value;
					}
					let obj;
					let contents;
					try {
						contents = yield res.readBody();
						if (contents && contents.length > 0) {
							if (options && options.deserializeDates) obj = JSON.parse(contents, dateTimeDeserializer);
							else obj = JSON.parse(contents);
							response.result = obj;
						}
						response.headers = res.message.headers;
					} catch (err) {}
					if (statusCode > 299) {
						let msg;
						if (obj && obj.message) msg = obj.message;
						else if (contents && contents.length > 0) msg = contents;
						else msg = `Failed request: (${statusCode})`;
						const err = new HttpClientError(msg, statusCode);
						err.result = response.result;
						reject(err);
					} else resolve(response);
				}));
			});
		}
	};
	exports.HttpClient = HttpClient;
	const lowercaseKeys$1 = (obj) => Object.keys(obj).reduce((c$1, k) => (c$1[k.toLowerCase()] = obj[k], c$1), {});
} });

//#endregion
//#region node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({ "node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/auth.js"(exports) {
	var __awaiter$9 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
	var BasicCredentialHandler = class {
		constructor(username, password) {
			this.username = username;
			this.password = password;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BasicCredentialHandler = BasicCredentialHandler;
	var BearerCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Bearer ${this.token}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BearerCredentialHandler = BearerCredentialHandler;
	var PersonalAccessTokenCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
} });

//#endregion
//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js"(exports) {
	var __awaiter$8 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OidcClient = void 0;
	const http_client_1 = require_lib$2();
	const auth_1 = require_auth();
	const core_1$1 = require_core();
	var OidcClient = class OidcClient {
		static createHttpClient(allowRetry = true, maxRetry = 10) {
			const requestOptions = {
				allowRetries: allowRetry,
				maxRetries: maxRetry
			};
			return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
		}
		static getRequestToken() {
			const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
			if (!token) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
			return token;
		}
		static getIDTokenUrl() {
			const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
			if (!runtimeUrl) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
			return runtimeUrl;
		}
		static getCall(id_token_url) {
			var _a$2;
			return __awaiter$8(this, void 0, void 0, function* () {
				const httpclient = OidcClient.createHttpClient();
				const res = yield httpclient.getJson(id_token_url).catch((error$1) => {
					throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error$1.statusCode}\n 
        Error Message: ${error$1.message}`);
				});
				const id_token = (_a$2 = res.result) === null || _a$2 === void 0 ? void 0 : _a$2.value;
				if (!id_token) throw new Error("Response json body do not have ID Token field");
				return id_token;
			});
		}
		static getIDToken(audience) {
			return __awaiter$8(this, void 0, void 0, function* () {
				try {
					let id_token_url = OidcClient.getIDTokenUrl();
					if (audience) {
						const encodedAudience = encodeURIComponent(audience);
						id_token_url = `${id_token_url}&audience=${encodedAudience}`;
					}
					(0, core_1$1.debug)(`ID token url is ${id_token_url}`);
					const id_token = yield OidcClient.getCall(id_token_url);
					(0, core_1$1.setSecret)(id_token);
					return id_token;
				} catch (error$1) {
					throw new Error(`Error message: ${error$1.message}`);
				}
			});
		}
	};
	exports.OidcClient = OidcClient;
} });

//#endregion
//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js"(exports) {
	var __awaiter$7 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
	const os_1$2 = __require("os");
	const fs_1$1 = __require("fs");
	const { access, appendFile: appendFile$1, writeFile: writeFile$1 } = fs_1$1.promises;
	exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
	exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
	var Summary = class {
		constructor() {
			this._buffer = "";
		}
		/**
		* Finds the summary file path from the environment, rejects if env var is not found or file does not exist
		* Also checks r/w permissions.
		*
		* @returns step summary file path
		*/
		filePath() {
			return __awaiter$7(this, void 0, void 0, function* () {
				if (this._filePath) return this._filePath;
				const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
				if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
				try {
					yield access(pathFromEnv, fs_1$1.constants.R_OK | fs_1$1.constants.W_OK);
				} catch (_a$2) {
					throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
				}
				this._filePath = pathFromEnv;
				return this._filePath;
			});
		}
		/**
		* Wraps content in an HTML tag, adding any HTML attributes
		*
		* @param {string} tag HTML tag to wrap
		* @param {string | null} content content within the tag
		* @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
		*
		* @returns {string} content wrapped in HTML element
		*/
		wrap(tag, content, attrs = {}) {
			const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
			if (!content) return `<${tag}${htmlAttrs}>`;
			return `<${tag}${htmlAttrs}>${content}</${tag}>`;
		}
		/**
		* Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
		*
		* @param {SummaryWriteOptions} [options] (optional) options for write operation
		*
		* @returns {Promise<Summary>} summary instance
		*/
		write(options) {
			return __awaiter$7(this, void 0, void 0, function* () {
				const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
				const filePath = yield this.filePath();
				const writeFunc = overwrite ? writeFile$1 : appendFile$1;
				yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
				return this.emptyBuffer();
			});
		}
		/**
		* Clears the summary buffer and wipes the summary file
		*
		* @returns {Summary} summary instance
		*/
		clear() {
			return __awaiter$7(this, void 0, void 0, function* () {
				return this.emptyBuffer().write({ overwrite: true });
			});
		}
		/**
		* Returns the current summary buffer as a string
		*
		* @returns {string} string of summary buffer
		*/
		stringify() {
			return this._buffer;
		}
		/**
		* If the summary buffer is empty
		*
		* @returns {boolen} true if the buffer is empty
		*/
		isEmptyBuffer() {
			return this._buffer.length === 0;
		}
		/**
		* Resets the summary buffer without writing to summary file
		*
		* @returns {Summary} summary instance
		*/
		emptyBuffer() {
			this._buffer = "";
			return this;
		}
		/**
		* Adds raw text to the summary buffer
		*
		* @param {string} text content to add
		* @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addRaw(text, addEOL = false) {
			this._buffer += text;
			return addEOL ? this.addEOL() : this;
		}
		/**
		* Adds the operating system-specific end-of-line marker to the buffer
		*
		* @returns {Summary} summary instance
		*/
		addEOL() {
			return this.addRaw(os_1$2.EOL);
		}
		/**
		* Adds an HTML codeblock to the summary buffer
		*
		* @param {string} code content to render within fenced code block
		* @param {string} lang (optional) language to syntax highlight code
		*
		* @returns {Summary} summary instance
		*/
		addCodeBlock(code, lang) {
			const attrs = Object.assign({}, lang && { lang });
			const element = this.wrap("pre", this.wrap("code", code), attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML list to the summary buffer
		*
		* @param {string[]} items list of items to render
		* @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addList(items, ordered = false) {
			const tag = ordered ? "ol" : "ul";
			const listItems = items.map((item) => this.wrap("li", item)).join("");
			const element = this.wrap(tag, listItems);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML table to the summary buffer
		*
		* @param {SummaryTableCell[]} rows table rows
		*
		* @returns {Summary} summary instance
		*/
		addTable(rows) {
			const tableBody = rows.map((row) => {
				const cells = row.map((cell) => {
					if (typeof cell === "string") return this.wrap("td", cell);
					const { header, data, colspan, rowspan } = cell;
					const tag = header ? "th" : "td";
					const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
					return this.wrap(tag, data, attrs);
				}).join("");
				return this.wrap("tr", cells);
			}).join("");
			const element = this.wrap("table", tableBody);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds a collapsable HTML details element to the summary buffer
		*
		* @param {string} label text for the closed state
		* @param {string} content collapsable content
		*
		* @returns {Summary} summary instance
		*/
		addDetails(label, content) {
			const element = this.wrap("details", this.wrap("summary", label) + content);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML image tag to the summary buffer
		*
		* @param {string} src path to the image you to embed
		* @param {string} alt text description of the image
		* @param {SummaryImageOptions} options (optional) addition image attributes
		*
		* @returns {Summary} summary instance
		*/
		addImage(src, alt, options) {
			const { width, height } = options || {};
			const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
			const element = this.wrap("img", null, Object.assign({
				src,
				alt
			}, attrs));
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML section heading element
		*
		* @param {string} text heading text
		* @param {number | string} [level=1] (optional) the heading level, default: 1
		*
		* @returns {Summary} summary instance
		*/
		addHeading(text, level) {
			const tag = `h${level}`;
			const allowedTag = [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			].includes(tag) ? tag : "h1";
			const element = this.wrap(allowedTag, text);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML thematic break (<hr>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addSeparator() {
			const element = this.wrap("hr", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML line break (<br>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addBreak() {
			const element = this.wrap("br", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML blockquote to the summary buffer
		*
		* @param {string} text quote text
		* @param {string} cite (optional) citation url
		*
		* @returns {Summary} summary instance
		*/
		addQuote(text, cite) {
			const attrs = Object.assign({}, cite && { cite });
			const element = this.wrap("blockquote", text, attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML anchor tag to the summary buffer
		*
		* @param {string} text link text/content
		* @param {string} href hyperlink
		*
		* @returns {Summary} summary instance
		*/
		addLink(text, href) {
			const element = this.wrap("a", text, { href });
			return this.addRaw(element).addEOL();
		}
	};
	const _summary = new Summary();
	/**
	* @deprecated use `core.summary`
	*/
	exports.markdownSummary = _summary;
	exports.summary = _summary;
} });

//#endregion
//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js"(exports) {
	var __createBinding$9 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$9 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$9 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$9(result, mod, k);
		}
		__setModuleDefault$9(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
	const path$8 = __importStar$9(__require("path"));
	/**
	* toPosixPath converts the given path to the posix form. On Windows, \\ will be
	* replaced with /.
	*
	* @param pth. Path to transform.
	* @return string Posix path.
	*/
	function toPosixPath(pth) {
		return pth.replace(/[\\]/g, "/");
	}
	exports.toPosixPath = toPosixPath;
	/**
	* toWin32Path converts the given path to the win32 form. On Linux, / will be
	* replaced with \\.
	*
	* @param pth. Path to transform.
	* @return string Win32 path.
	*/
	function toWin32Path(pth) {
		return pth.replace(/[/]/g, "\\");
	}
	exports.toWin32Path = toWin32Path;
	/**
	* toPlatformPath converts the given path to a platform-specific path. It does
	* this by replacing instances of / and \ with the platform-specific path
	* separator.
	*
	* @param pth The path to platformize.
	* @return string The platform-specific path.
	*/
	function toPlatformPath(pth) {
		return pth.replace(/[/\\]/g, path$8.sep);
	}
	exports.toPlatformPath = toPlatformPath;
} });

//#endregion
//#region node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({ "node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js"(exports) {
	var __createBinding$8 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o$1, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$8 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$8 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$8(result, mod, k);
		}
		__setModuleDefault$8(result, mod);
		return result;
	};
	var __awaiter$6 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var _a$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
	const fs$4 = __importStar$8(__require("fs"));
	const path$7 = __importStar$8(__require("path"));
	_a$1 = fs$4.promises, exports.chmod = _a$1.chmod, exports.copyFile = _a$1.copyFile, exports.lstat = _a$1.lstat, exports.mkdir = _a$1.mkdir, exports.open = _a$1.open, exports.readdir = _a$1.readdir, exports.readlink = _a$1.readlink, exports.rename = _a$1.rename, exports.rm = _a$1.rm, exports.rmdir = _a$1.rmdir, exports.stat = _a$1.stat, exports.symlink = _a$1.symlink, exports.unlink = _a$1.unlink;
	exports.IS_WINDOWS = process.platform === "win32";
	exports.UV_FS_O_EXLOCK = 268435456;
	exports.READONLY = fs$4.constants.O_RDONLY;
	function exists(fsPath) {
		return __awaiter$6(this, void 0, void 0, function* () {
			try {
				yield exports.stat(fsPath);
			} catch (err) {
				if (err.code === "ENOENT") return false;
				throw err;
			}
			return true;
		});
	}
	exports.exists = exists;
	function isDirectory(fsPath, useStat = false) {
		return __awaiter$6(this, void 0, void 0, function* () {
			const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
			return stats.isDirectory();
		});
	}
	exports.isDirectory = isDirectory;
	/**
	* On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
	* \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
	*/
	function isRooted(p) {
		p = normalizeSeparators(p);
		if (!p) throw new Error("isRooted() parameter \"p\" cannot be empty");
		if (exports.IS_WINDOWS) return p.startsWith("\\") || /^[A-Z]:/i.test(p);
		return p.startsWith("/");
	}
	exports.isRooted = isRooted;
	/**
	* Best effort attempt to determine whether a file exists and is executable.
	* @param filePath    file path to check
	* @param extensions  additional file extensions to try
	* @return if file exists and is executable, returns the file path. otherwise empty string.
	*/
	function tryGetExecutablePath(filePath, extensions) {
		return __awaiter$6(this, void 0, void 0, function* () {
			let stats = void 0;
			try {
				stats = yield exports.stat(filePath);
			} catch (err) {
				if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
			}
			if (stats && stats.isFile()) {
				if (exports.IS_WINDOWS) {
					const upperExt = path$7.extname(filePath).toUpperCase();
					if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) return filePath;
				} else if (isUnixExecutable(stats)) return filePath;
			}
			const originalFilePath = filePath;
			for (const extension of extensions) {
				filePath = originalFilePath + extension;
				stats = void 0;
				try {
					stats = yield exports.stat(filePath);
				} catch (err) {
					if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
				}
				if (stats && stats.isFile()) {
					if (exports.IS_WINDOWS) {
						try {
							const directory = path$7.dirname(filePath);
							const upperName = path$7.basename(filePath).toUpperCase();
							for (const actualName of yield exports.readdir(directory)) if (upperName === actualName.toUpperCase()) {
								filePath = path$7.join(directory, actualName);
								break;
							}
						} catch (err) {
							console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
						}
						return filePath;
					} else if (isUnixExecutable(stats)) return filePath;
				}
			}
			return "";
		});
	}
	exports.tryGetExecutablePath = tryGetExecutablePath;
	function normalizeSeparators(p) {
		p = p || "";
		if (exports.IS_WINDOWS) {
			p = p.replace(/\//g, "\\");
			return p.replace(/\\\\+/g, "\\");
		}
		return p.replace(/\/\/+/g, "/");
	}
	function isUnixExecutable(stats) {
		return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
	}
	function getCmdPath() {
		var _a$2;
		return (_a$2 = process.env["COMSPEC"]) !== null && _a$2 !== void 0 ? _a$2 : `cmd.exe`;
	}
	exports.getCmdPath = getCmdPath;
} });

//#endregion
//#region node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js
var require_io = __commonJS({ "node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js"(exports) {
	var __createBinding$7 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o$1, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$7 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$7 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$7(result, mod, k);
		}
		__setModuleDefault$7(result, mod);
		return result;
	};
	var __awaiter$5 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
	const assert_1 = __require("assert");
	const path$6 = __importStar$7(__require("path"));
	const ioUtil$1 = __importStar$7(require_io_util());
	/**
	* Copies a file or folder.
	* Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See CopyOptions.
	*/
	function cp$1(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const { force, recursive, copySourceDirectory } = readCopyOptions(options);
			const destStat = (yield ioUtil$1.exists(dest)) ? yield ioUtil$1.stat(dest) : null;
			if (destStat && destStat.isFile() && !force) return;
			const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path$6.join(dest, path$6.basename(source)) : dest;
			if (!(yield ioUtil$1.exists(source))) throw new Error(`no such file or directory: ${source}`);
			const sourceStat = yield ioUtil$1.stat(source);
			if (sourceStat.isDirectory()) if (!recursive) throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
			else yield cpDirRecursive(source, newDest, 0, force);
			else {
				if (path$6.relative(source, newDest) === "") throw new Error(`'${newDest}' and '${source}' are the same file`);
				yield copyFile(source, newDest, force);
			}
		});
	}
	exports.cp = cp$1;
	/**
	* Moves a path.
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See MoveOptions.
	*/
	function mv(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (yield ioUtil$1.exists(dest)) {
				let destExists = true;
				if (yield ioUtil$1.isDirectory(dest)) {
					dest = path$6.join(dest, path$6.basename(source));
					destExists = yield ioUtil$1.exists(dest);
				}
				if (destExists) if (options.force == null || options.force) yield rmRF(dest);
				else throw new Error("Destination already exists");
			}
			yield mkdirP(path$6.dirname(dest));
			yield ioUtil$1.rename(source, dest);
		});
	}
	exports.mv = mv;
	/**
	* Remove a path recursively with force
	*
	* @param inputPath path to remove
	*/
	function rmRF(inputPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (ioUtil$1.IS_WINDOWS) {
				if (/[*"<>|]/.test(inputPath)) throw new Error("File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows");
			}
			try {
				yield ioUtil$1.rm(inputPath, {
					force: true,
					maxRetries: 3,
					recursive: true,
					retryDelay: 300
				});
			} catch (err) {
				throw new Error(`File was unable to be removed ${err}`);
			}
		});
	}
	exports.rmRF = rmRF;
	/**
	* Make a directory.  Creates the full path with folders in between
	* Will throw if it fails
	*
	* @param   fsPath        path to create
	* @returns Promise<void>
	*/
	function mkdirP(fsPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			assert_1.ok(fsPath, "a path argument must be provided");
			yield ioUtil$1.mkdir(fsPath, { recursive: true });
		});
	}
	exports.mkdirP = mkdirP;
	/**
	* Returns path of a tool had the tool actually been invoked.  Resolves via paths.
	* If you check and the tool does not exist, it will throw.
	*
	* @param     tool              name of the tool
	* @param     check             whether to check if tool exists
	* @returns   Promise<string>   path to tool
	*/
	function which$2(tool, check) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			if (check) {
				const result = yield which$2(tool, false);
				if (!result) if (ioUtil$1.IS_WINDOWS) throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
				else throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
				return result;
			}
			const matches = yield findInPath(tool);
			if (matches && matches.length > 0) return matches[0];
			return "";
		});
	}
	exports.which = which$2;
	/**
	* Returns a list of all occurrences of the given tool on the system path.
	*
	* @returns   Promise<string[]>  the paths of the tool
	*/
	function findInPath(tool) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			const extensions = [];
			if (ioUtil$1.IS_WINDOWS && process.env["PATHEXT"]) {
				for (const extension of process.env["PATHEXT"].split(path$6.delimiter)) if (extension) extensions.push(extension);
			}
			if (ioUtil$1.isRooted(tool)) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(tool, extensions);
				if (filePath) return [filePath];
				return [];
			}
			if (tool.includes(path$6.sep)) return [];
			const directories = [];
			if (process.env.PATH) {
				for (const p of process.env.PATH.split(path$6.delimiter)) if (p) directories.push(p);
			}
			const matches = [];
			for (const directory of directories) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(path$6.join(directory, tool), extensions);
				if (filePath) matches.push(filePath);
			}
			return matches;
		});
	}
	exports.findInPath = findInPath;
	function readCopyOptions(options) {
		const force = options.force == null ? true : options.force;
		const recursive = Boolean(options.recursive);
		const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
		return {
			force,
			recursive,
			copySourceDirectory
		};
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (currentDepth >= 255) return;
			currentDepth++;
			yield mkdirP(destDir);
			const files = yield ioUtil$1.readdir(sourceDir);
			for (const fileName of files) {
				const srcFile = `${sourceDir}/${fileName}`;
				const destFile = `${destDir}/${fileName}`;
				const srcFileStat = yield ioUtil$1.lstat(srcFile);
				if (srcFileStat.isDirectory()) yield cpDirRecursive(srcFile, destFile, currentDepth, force);
				else yield copyFile(srcFile, destFile, force);
			}
			yield ioUtil$1.chmod(destDir, (yield ioUtil$1.stat(sourceDir)).mode);
		});
	}
	function copyFile(srcFile, destFile, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if ((yield ioUtil$1.lstat(srcFile)).isSymbolicLink()) {
				try {
					yield ioUtil$1.lstat(destFile);
					yield ioUtil$1.unlink(destFile);
				} catch (e) {
					if (e.code === "EPERM") {
						yield ioUtil$1.chmod(destFile, "0666");
						yield ioUtil$1.unlink(destFile);
					}
				}
				const symlinkFull = yield ioUtil$1.readlink(srcFile);
				yield ioUtil$1.symlink(symlinkFull, destFile, ioUtil$1.IS_WINDOWS ? "junction" : null);
			} else if (!(yield ioUtil$1.exists(destFile)) || force) yield ioUtil$1.copyFile(srcFile, destFile);
		});
	}
} });

//#endregion
//#region node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({ "node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js"(exports) {
	var __createBinding$6 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o$1, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$6 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$6 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$6(result, mod, k);
		}
		__setModuleDefault$6(result, mod);
		return result;
	};
	var __awaiter$4 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.argStringToArray = exports.ToolRunner = void 0;
	const os$1 = __importStar$6(__require("os"));
	const events = __importStar$6(__require("events"));
	const child = __importStar$6(__require("child_process"));
	const path$5 = __importStar$6(__require("path"));
	const io = __importStar$6(require_io());
	const ioUtil = __importStar$6(require_io_util());
	const timers_1 = __require("timers");
	const IS_WINDOWS = process.platform === "win32";
	var ToolRunner = class extends events.EventEmitter {
		constructor(toolPath, args, options) {
			super();
			if (!toolPath) throw new Error("Parameter 'toolPath' cannot be null or empty.");
			this.toolPath = toolPath;
			this.args = args || [];
			this.options = options || {};
		}
		_debug(message) {
			if (this.options.listeners && this.options.listeners.debug) this.options.listeners.debug(message);
		}
		_getCommandString(options, noPrefix) {
			const toolPath = this._getSpawnFileName();
			const args = this._getSpawnArgs(options);
			let cmd = noPrefix ? "" : "[command]";
			if (IS_WINDOWS) if (this._isCmdFile()) {
				cmd += toolPath;
				for (const a$1 of args) cmd += ` ${a$1}`;
			} else if (options.windowsVerbatimArguments) {
				cmd += `"${toolPath}"`;
				for (const a$1 of args) cmd += ` ${a$1}`;
			} else {
				cmd += this._windowsQuoteCmdArg(toolPath);
				for (const a$1 of args) cmd += ` ${this._windowsQuoteCmdArg(a$1)}`;
			}
			else {
				cmd += toolPath;
				for (const a$1 of args) cmd += ` ${a$1}`;
			}
			return cmd;
		}
		_processLineBuffer(data, strBuffer, onLine) {
			try {
				let s$1 = strBuffer + data.toString();
				let n$1 = s$1.indexOf(os$1.EOL);
				while (n$1 > -1) {
					const line = s$1.substring(0, n$1);
					onLine(line);
					s$1 = s$1.substring(n$1 + os$1.EOL.length);
					n$1 = s$1.indexOf(os$1.EOL);
				}
				return s$1;
			} catch (err) {
				this._debug(`error processing line. Failed with error ${err}`);
				return "";
			}
		}
		_getSpawnFileName() {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) return process.env["COMSPEC"] || "cmd.exe";
			}
			return this.toolPath;
		}
		_getSpawnArgs(options) {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) {
					let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
					for (const a$1 of this.args) {
						argline += " ";
						argline += options.windowsVerbatimArguments ? a$1 : this._windowsQuoteCmdArg(a$1);
					}
					argline += "\"";
					return [argline];
				}
			}
			return this.args;
		}
		_endsWith(str$1, end) {
			return str$1.endsWith(end);
		}
		_isCmdFile() {
			const upperToolPath = this.toolPath.toUpperCase();
			return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
		}
		_windowsQuoteCmdArg(arg) {
			if (!this._isCmdFile()) return this._uvQuoteCmdArg(arg);
			if (!arg) return "\"\"";
			const cmdSpecialChars = [
				" ",
				"	",
				"&",
				"(",
				")",
				"[",
				"]",
				"{",
				"}",
				"^",
				"=",
				";",
				"!",
				"'",
				"+",
				",",
				"`",
				"~",
				"|",
				"<",
				">",
				"\""
			];
			let needsQuotes = false;
			for (const char of arg) if (cmdSpecialChars.some((x) => x === char)) {
				needsQuotes = true;
				break;
			}
			if (!needsQuotes) return arg;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$1 = arg.length; i$1 > 0; i$1--) {
				reverse += arg[i$1 - 1];
				if (quoteHit && arg[i$1 - 1] === "\\") reverse += "\\";
				else if (arg[i$1 - 1] === "\"") {
					quoteHit = true;
					reverse += "\"";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_uvQuoteCmdArg(arg) {
			if (!arg) return "\"\"";
			if (!arg.includes(" ") && !arg.includes("	") && !arg.includes("\"")) return arg;
			if (!arg.includes("\"") && !arg.includes("\\")) return `"${arg}"`;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$1 = arg.length; i$1 > 0; i$1--) {
				reverse += arg[i$1 - 1];
				if (quoteHit && arg[i$1 - 1] === "\\") reverse += "\\";
				else if (arg[i$1 - 1] === "\"") {
					quoteHit = true;
					reverse += "\\";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_cloneExecOptions(options) {
			options = options || {};
			const result = {
				cwd: options.cwd || process.cwd(),
				env: options.env || process.env,
				silent: options.silent || false,
				windowsVerbatimArguments: options.windowsVerbatimArguments || false,
				failOnStdErr: options.failOnStdErr || false,
				ignoreReturnCode: options.ignoreReturnCode || false,
				delay: options.delay || 1e4
			};
			result.outStream = options.outStream || process.stdout;
			result.errStream = options.errStream || process.stderr;
			return result;
		}
		_getSpawnOptions(options, toolPath) {
			options = options || {};
			const result = {};
			result.cwd = options.cwd;
			result.env = options.env;
			result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
			if (options.windowsVerbatimArguments) result.argv0 = `"${toolPath}"`;
			return result;
		}
		/**
		* Exec a tool.
		* Output will be streamed to the live console.
		* Returns promise with return code
		*
		* @param     tool     path to tool to exec
		* @param     options  optional exec options.  See ExecOptions
		* @returns   number
		*/
		exec() {
			return __awaiter$4(this, void 0, void 0, function* () {
				if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) this.toolPath = path$5.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
				this.toolPath = yield io.which(this.toolPath, true);
				return new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
					this._debug(`exec tool: ${this.toolPath}`);
					this._debug("arguments:");
					for (const arg of this.args) this._debug(`   ${arg}`);
					const optionsNonNull = this._cloneExecOptions(this.options);
					if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os$1.EOL);
					const state = new ExecState(optionsNonNull, this.toolPath);
					state.on("debug", (message) => {
						this._debug(message);
					});
					if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) return reject(/* @__PURE__ */ new Error(`The cwd: ${this.options.cwd} does not exist!`));
					const fileName = this._getSpawnFileName();
					const cp$2 = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
					let stdbuffer = "";
					if (cp$2.stdout) cp$2.stdout.on("data", (data) => {
						if (this.options.listeners && this.options.listeners.stdout) this.options.listeners.stdout(data);
						if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(data);
						stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.stdline) this.options.listeners.stdline(line);
						});
					});
					let errbuffer = "";
					if (cp$2.stderr) cp$2.stderr.on("data", (data) => {
						state.processStderr = true;
						if (this.options.listeners && this.options.listeners.stderr) this.options.listeners.stderr(data);
						if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
							const s$1 = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
							s$1.write(data);
						}
						errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.errline) this.options.listeners.errline(line);
						});
					});
					cp$2.on("error", (err) => {
						state.processError = err.message;
						state.processExited = true;
						state.processClosed = true;
						state.CheckComplete();
					});
					cp$2.on("exit", (code) => {
						state.processExitCode = code;
						state.processExited = true;
						this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					cp$2.on("close", (code) => {
						state.processExitCode = code;
						state.processExited = true;
						state.processClosed = true;
						this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					state.on("done", (error$1, exitCode) => {
						if (stdbuffer.length > 0) this.emit("stdline", stdbuffer);
						if (errbuffer.length > 0) this.emit("errline", errbuffer);
						cp$2.removeAllListeners();
						if (error$1) reject(error$1);
						else resolve(exitCode);
					});
					if (this.options.input) {
						if (!cp$2.stdin) throw new Error("child process missing stdin");
						cp$2.stdin.end(this.options.input);
					}
				}));
			});
		}
	};
	exports.ToolRunner = ToolRunner;
	/**
	* Convert an arg string to an array of args. Handles escaping
	*
	* @param    argString   string of arguments
	* @returns  string[]    array of arguments
	*/
	function argStringToArray(argString) {
		const args = [];
		let inQuotes = false;
		let escaped = false;
		let arg = "";
		function append(c$1) {
			if (escaped && c$1 !== "\"") arg += "\\";
			arg += c$1;
			escaped = false;
		}
		for (let i$1 = 0; i$1 < argString.length; i$1++) {
			const c$1 = argString.charAt(i$1);
			if (c$1 === "\"") {
				if (!escaped) inQuotes = !inQuotes;
				else append(c$1);
				continue;
			}
			if (c$1 === "\\" && escaped) {
				append(c$1);
				continue;
			}
			if (c$1 === "\\" && inQuotes) {
				escaped = true;
				continue;
			}
			if (c$1 === " " && !inQuotes) {
				if (arg.length > 0) {
					args.push(arg);
					arg = "";
				}
				continue;
			}
			append(c$1);
		}
		if (arg.length > 0) args.push(arg.trim());
		return args;
	}
	exports.argStringToArray = argStringToArray;
	var ExecState = class ExecState extends events.EventEmitter {
		constructor(options, toolPath) {
			super();
			this.processClosed = false;
			this.processError = "";
			this.processExitCode = 0;
			this.processExited = false;
			this.processStderr = false;
			this.delay = 1e4;
			this.done = false;
			this.timeout = null;
			if (!toolPath) throw new Error("toolPath must not be empty");
			this.options = options;
			this.toolPath = toolPath;
			if (options.delay) this.delay = options.delay;
		}
		CheckComplete() {
			if (this.done) return;
			if (this.processClosed) this._setResult();
			else if (this.processExited) this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
		}
		_debug(message) {
			this.emit("debug", message);
		}
		_setResult() {
			let error$1;
			if (this.processExited) {
				if (this.processError) error$1 = /* @__PURE__ */ new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
				else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) error$1 = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
				else if (this.processStderr && this.options.failOnStdErr) error$1 = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
			}
			if (this.timeout) {
				clearTimeout(this.timeout);
				this.timeout = null;
			}
			this.done = true;
			this.emit("done", error$1, this.processExitCode);
		}
		static HandleTimeout(state) {
			if (state.done) return;
			if (!state.processClosed && state.processExited) {
				const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
				state._debug(message);
			}
			state._setResult();
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({ "node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js"(exports) {
	var __createBinding$5 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o$1, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$5 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$5 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$5(result, mod, k);
		}
		__setModuleDefault$5(result, mod);
		return result;
	};
	var __awaiter$3 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getExecOutput = exports.exec = void 0;
	const string_decoder_1 = __require("string_decoder");
	const tr = __importStar$5(require_toolrunner());
	/**
	* Exec a command.
	* Output will be streamed to the live console.
	* Returns promise with return code
	*
	* @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
	* @param     args               optional arguments for tool. Escaping is handled by the lib.
	* @param     options            optional exec options.  See ExecOptions
	* @returns   Promise<number>    exit code
	*/
	function exec$1(commandLine, args, options) {
		return __awaiter$3(this, void 0, void 0, function* () {
			const commandArgs = tr.argStringToArray(commandLine);
			if (commandArgs.length === 0) throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
			const toolPath = commandArgs[0];
			args = commandArgs.slice(1).concat(args || []);
			const runner = new tr.ToolRunner(toolPath, args, options);
			return runner.exec();
		});
	}
	exports.exec = exec$1;
	/**
	* Exec a command and get the output.
	* Output will be streamed to the live console.
	* Returns promise with the exit code and collected stdout and stderr
	*
	* @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
	* @param     args                  optional arguments for tool. Escaping is handled by the lib.
	* @param     options               optional exec options.  See ExecOptions
	* @returns   Promise<ExecOutput>   exit code, stdout, and stderr
	*/
	function getExecOutput(commandLine, args, options) {
		var _a$2, _b;
		return __awaiter$3(this, void 0, void 0, function* () {
			let stdout$1 = "";
			let stderr = "";
			const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
			const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
			const originalStdoutListener = (_a$2 = options === null || options === void 0 ? void 0 : options.listeners) === null || _a$2 === void 0 ? void 0 : _a$2.stdout;
			const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
			const stdErrListener = (data) => {
				stderr += stderrDecoder.write(data);
				if (originalStdErrListener) originalStdErrListener(data);
			};
			const stdOutListener = (data) => {
				stdout$1 += stdoutDecoder.write(data);
				if (originalStdoutListener) originalStdoutListener(data);
			};
			const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), {
				stdout: stdOutListener,
				stderr: stdErrListener
			});
			const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
			stdout$1 += stdoutDecoder.end();
			stderr += stderrDecoder.end();
			return {
				exitCode,
				stdout: stdout$1,
				stderr
			};
		});
	}
	exports.getExecOutput = getExecOutput;
} });

//#endregion
//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js"(exports) {
	var __createBinding$4 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$4 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$4 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
		}
		__setModuleDefault$4(result, mod);
		return result;
	};
	var __awaiter$2 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
	const os_1$1 = __importDefault(__require("os"));
	const exec = __importStar$4(require_exec());
	const getWindowsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout: version } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Version\"", void 0, { silent: true });
		const { stdout: name } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Caption\"", void 0, { silent: true });
		return {
			name: name.trim(),
			version: version.trim()
		};
	});
	const getMacOsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		var _a$2, _b, _c, _d;
		const { stdout: stdout$1 } = yield exec.getExecOutput("sw_vers", void 0, { silent: true });
		const version = (_b = (_a$2 = stdout$1.match(/ProductVersion:\s*(.+)/)) === null || _a$2 === void 0 ? void 0 : _a$2[1]) !== null && _b !== void 0 ? _b : "";
		const name = (_d = (_c = stdout$1.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
		return {
			name,
			version
		};
	});
	const getLinuxInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout: stdout$1 } = yield exec.getExecOutput("lsb_release", [
			"-i",
			"-r",
			"-s"
		], { silent: true });
		const [name, version] = stdout$1.trim().split("\n");
		return {
			name,
			version
		};
	});
	exports.platform = os_1$1.default.platform();
	exports.arch = os_1$1.default.arch();
	exports.isWindows = exports.platform === "win32";
	exports.isMacOS = exports.platform === "darwin";
	exports.isLinux = exports.platform === "linux";
	function getDetails() {
		return __awaiter$2(this, void 0, void 0, function* () {
			return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
				platform: exports.platform,
				arch: exports.arch,
				isWindows: exports.isWindows,
				isMacOS: exports.isMacOS,
				isLinux: exports.isLinux
			});
		});
	}
	exports.getDetails = getDetails;
} });

//#endregion
//#region node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js
var require_core = __commonJS({ "node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"(exports) {
	var __createBinding$3 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$3 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$3 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
		}
		__setModuleDefault$3(result, mod);
		return result;
	};
	var __awaiter$1 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
	const command_1 = require_command();
	const file_command_1 = require_file_command();
	const utils_1$1 = require_utils$4();
	const os = __importStar$3(__require("os"));
	const path$4 = __importStar$3(__require("path"));
	const oidc_utils_1 = require_oidc_utils();
	/**
	* The code to exit an action
	*/
	var ExitCode;
	(function(ExitCode$1) {
		/**
		* A code indicating that the action was successful
		*/
		ExitCode$1[ExitCode$1["Success"] = 0] = "Success";
		/**
		* A code indicating that the action was a failure
		*/
		ExitCode$1[ExitCode$1["Failure"] = 1] = "Failure";
	})(ExitCode || (exports.ExitCode = ExitCode = {}));
	/**
	* Sets env variable for this action and future actions in the job
	* @param name the name of the variable to set
	* @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
	*/
	function exportVariable(name, val) {
		const convertedVal = (0, utils_1$1.toCommandValue)(val);
		process.env[name] = convertedVal;
		const filePath = process.env["GITHUB_ENV"] || "";
		if (filePath) return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
		(0, command_1.issueCommand)("set-env", { name }, convertedVal);
	}
	exports.exportVariable = exportVariable;
	/**
	* Registers a secret which will get masked from logs
	* @param secret value of the secret
	*/
	function setSecret(secret) {
		(0, command_1.issueCommand)("add-mask", {}, secret);
	}
	exports.setSecret = setSecret;
	/**
	* Prepends inputPath to the PATH (for this action and future actions)
	* @param inputPath
	*/
	function addPath(inputPath) {
		const filePath = process.env["GITHUB_PATH"] || "";
		if (filePath) (0, file_command_1.issueFileCommand)("PATH", inputPath);
		else (0, command_1.issueCommand)("add-path", {}, inputPath);
		process.env["PATH"] = `${inputPath}${path$4.delimiter}${process.env["PATH"]}`;
	}
	exports.addPath = addPath;
	/**
	* Gets the value of an input.
	* Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
	* Returns an empty string if the value is not defined.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string
	*/
	function getInput(name, options) {
		const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
		if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
		if (options && options.trimWhitespace === false) return val;
		return val.trim();
	}
	exports.getInput = getInput;
	/**
	* Gets the values of an multiline input.  Each value is also trimmed.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string[]
	*
	*/
	function getMultilineInput(name, options) {
		const inputs = getInput(name, options).split("\n").filter((x) => x !== "");
		if (options && options.trimWhitespace === false) return inputs;
		return inputs.map((input) => input.trim());
	}
	exports.getMultilineInput = getMultilineInput;
	/**
	* Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
	* Support boolean input list: `true | True | TRUE | false | False | FALSE` .
	* The return value is also in boolean type.
	* ref: https://yaml.org/spec/1.2/spec.html#id2804923
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   boolean
	*/
	function getBooleanInput(name, options) {
		const trueValue = [
			"true",
			"True",
			"TRUE"
		];
		const falseValue = [
			"false",
			"False",
			"FALSE"
		];
		const val = getInput(name, options);
		if (trueValue.includes(val)) return true;
		if (falseValue.includes(val)) return false;
		throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\nSupport boolean input list: \`true | True | TRUE | false | False | FALSE\``);
	}
	exports.getBooleanInput = getBooleanInput;
	/**
	* Sets the value of an output.
	*
	* @param     name     name of the output to set
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function setOutput(name, value) {
		const filePath = process.env["GITHUB_OUTPUT"] || "";
		if (filePath) return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
		process.stdout.write(os.EOL);
		(0, command_1.issueCommand)("set-output", { name }, (0, utils_1$1.toCommandValue)(value));
	}
	exports.setOutput = setOutput;
	/**
	* Enables or disables the echoing of commands into stdout for the rest of the step.
	* Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
	*
	*/
	function setCommandEcho(enabled) {
		(0, command_1.issue)("echo", enabled ? "on" : "off");
	}
	exports.setCommandEcho = setCommandEcho;
	/**
	* Sets the action status to failed.
	* When the action exits it will be with an exit code of 1
	* @param message add error issue message
	*/
	function setFailed(message) {
		process.exitCode = ExitCode.Failure;
		error(message);
	}
	exports.setFailed = setFailed;
	/**
	* Gets whether Actions Step Debug is on or not
	*/
	function isDebug() {
		return process.env["RUNNER_DEBUG"] === "1";
	}
	exports.isDebug = isDebug;
	/**
	* Writes debug message to user log
	* @param message debug message
	*/
	function debug$2(message) {
		(0, command_1.issueCommand)("debug", {}, message);
	}
	exports.debug = debug$2;
	/**
	* Adds an error issue
	* @param message error issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function error(message, properties = {}) {
		(0, command_1.issueCommand)("error", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.error = error;
	/**
	* Adds a warning issue
	* @param message warning issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function warning(message, properties = {}) {
		(0, command_1.issueCommand)("warning", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.warning = warning;
	/**
	* Adds a notice issue
	* @param message notice issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function notice(message, properties = {}) {
		(0, command_1.issueCommand)("notice", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.notice = notice;
	/**
	* Writes info to log with console.log.
	* @param message info message
	*/
	function info(message) {
		process.stdout.write(message + os.EOL);
	}
	exports.info = info;
	/**
	* Begin an output group.
	*
	* Output until the next `groupEnd` will be foldable in this group
	*
	* @param name The name of the output group
	*/
	function startGroup(name) {
		(0, command_1.issue)("group", name);
	}
	exports.startGroup = startGroup;
	/**
	* End an output group.
	*/
	function endGroup() {
		(0, command_1.issue)("endgroup");
	}
	exports.endGroup = endGroup;
	/**
	* Wrap an asynchronous function call in a group.
	*
	* Returns the same type as the function itself.
	*
	* @param name The name of the group
	* @param fn The function to wrap in the group
	*/
	function group(name, fn) {
		return __awaiter$1(this, void 0, void 0, function* () {
			startGroup(name);
			let result;
			try {
				result = yield fn();
			} finally {
				endGroup();
			}
			return result;
		});
	}
	exports.group = group;
	/**
	* Saves state for current action, the state can only be retrieved by this action's post job execution.
	*
	* @param     name     name of the state to store
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function saveState(name, value) {
		const filePath = process.env["GITHUB_STATE"] || "";
		if (filePath) return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
		(0, command_1.issueCommand)("save-state", { name }, (0, utils_1$1.toCommandValue)(value));
	}
	exports.saveState = saveState;
	/**
	* Gets the value of an state set by this action's main execution.
	*
	* @param     name     name of the state to get
	* @returns   string
	*/
	function getState(name) {
		return process.env[`STATE_${name}`] || "";
	}
	exports.getState = getState;
	function getIDToken(aud) {
		return __awaiter$1(this, void 0, void 0, function* () {
			return yield oidc_utils_1.OidcClient.getIDToken(aud);
		});
	}
	exports.getIDToken = getIDToken;
	/**
	* Summary exports
	*/
	var summary_1 = require_summary();
	Object.defineProperty(exports, "summary", {
		enumerable: true,
		get: function() {
			return summary_1.summary;
		}
	});
	/**
	* @deprecated use core.summary
	*/
	var summary_2 = require_summary();
	Object.defineProperty(exports, "markdownSummary", {
		enumerable: true,
		get: function() {
			return summary_2.markdownSummary;
		}
	});
	/**
	* Path exports
	*/
	var path_utils_1 = require_path_utils();
	Object.defineProperty(exports, "toPosixPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPosixPath;
		}
	});
	Object.defineProperty(exports, "toWin32Path", {
		enumerable: true,
		get: function() {
			return path_utils_1.toWin32Path;
		}
	});
	Object.defineProperty(exports, "toPlatformPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPlatformPath;
		}
	});
	/**
	* Platform utilities exports
	*/
	exports.platform = __importStar$3(require_platform());
} });

//#endregion
//#region node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/context.js
var require_context = __commonJS({ "node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/context.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Context = void 0;
	const fs_1 = __require("fs");
	const os_1 = __require("os");
	var Context$2 = class {
		/**
		* Hydrate the context from the environment
		*/
		constructor() {
			var _a$2, _b, _c;
			this.payload = {};
			if (process.env.GITHUB_EVENT_PATH) if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
			else {
				const path$9 = process.env.GITHUB_EVENT_PATH;
				process.stdout.write(`GITHUB_EVENT_PATH ${path$9} does not exist${os_1.EOL}`);
			}
			this.eventName = process.env.GITHUB_EVENT_NAME;
			this.sha = process.env.GITHUB_SHA;
			this.ref = process.env.GITHUB_REF;
			this.workflow = process.env.GITHUB_WORKFLOW;
			this.action = process.env.GITHUB_ACTION;
			this.actor = process.env.GITHUB_ACTOR;
			this.job = process.env.GITHUB_JOB;
			this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
			this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
			this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
			this.apiUrl = (_a$2 = process.env.GITHUB_API_URL) !== null && _a$2 !== void 0 ? _a$2 : `https://api.github.com`;
			this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
			this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
		}
		get issue() {
			const payload = this.payload;
			return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
		}
		get repo() {
			if (process.env.GITHUB_REPOSITORY) {
				const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
				return {
					owner,
					repo
				};
			}
			if (this.payload.repository) return {
				owner: this.payload.repository.owner.login,
				repo: this.payload.repository.name
			};
			throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
		}
	};
	exports.Context = Context$2;
} });

//#endregion
//#region node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/internal/utils.js
var require_utils$2 = __commonJS({ "node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/internal/utils.js"(exports) {
	var __createBinding$2 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$2 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$2 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
		}
		__setModuleDefault$2(result, mod);
		return result;
	};
	var __awaiter = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = void 0;
	const httpClient = __importStar$2(require_lib$2());
	const undici_1 = require_undici();
	function getAuthString(token, options) {
		if (!token && !options.auth) throw new Error("Parameter token or opts.auth is required");
		else if (token && options.auth) throw new Error("Parameters token and opts.auth may not both be specified");
		return typeof options.auth === "string" ? options.auth : `token ${token}`;
	}
	exports.getAuthString = getAuthString;
	function getProxyAgent(destinationUrl) {
		const hc = new httpClient.HttpClient();
		return hc.getAgent(destinationUrl);
	}
	exports.getProxyAgent = getProxyAgent;
	function getProxyAgentDispatcher(destinationUrl) {
		const hc = new httpClient.HttpClient();
		return hc.getAgentDispatcher(destinationUrl);
	}
	exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
	function getProxyFetch(destinationUrl) {
		const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
		const proxyFetch = (url, opts) => __awaiter(this, void 0, void 0, function* () {
			return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
		});
		return proxyFetch;
	}
	exports.getProxyFetch = getProxyFetch;
	function getApiBaseUrl() {
		return process.env["GITHUB_API_URL"] || "https://api.github.com";
	}
	exports.getApiBaseUrl = getApiBaseUrl;
} });

//#endregion
//#region node_modules/.pnpm/universal-user-agent@6.0.1/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node$9 = __commonJS({ "node_modules/.pnpm/universal-user-agent@6.0.1/node_modules/universal-user-agent/dist-node/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function getUserAgent() {
		if (typeof navigator === "object" && "userAgent" in navigator) return navigator.userAgent;
		if (typeof process === "object" && process.version !== void 0) return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
		return "<environment undetectable>";
	}
	exports.getUserAgent = getUserAgent;
} });

//#endregion
//#region node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({ "node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/register.js"(exports, module) {
	module.exports = register$1;
	function register$1(state, name, method, options) {
		if (typeof method !== "function") throw new Error("method for before hook must be a function");
		if (!options) options = {};
		if (Array.isArray(name)) return name.reverse().reduce(function(callback, name$1) {
			return register$1.bind(null, state, name$1, callback, options);
		}, method)();
		return Promise.resolve().then(function() {
			if (!state.registry[name]) return method(options);
			return state.registry[name].reduce(function(method$1, registered) {
				return registered.hook.bind(null, method$1, options);
			}, method)();
		});
	}
} });

//#endregion
//#region node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({ "node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/add.js"(exports, module) {
	module.exports = addHook$1;
	function addHook$1(state, kind$1, name, hook$1) {
		var orig = hook$1;
		if (!state.registry[name]) state.registry[name] = [];
		if (kind$1 === "before") hook$1 = function(method, options) {
			return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
		};
		if (kind$1 === "after") hook$1 = function(method, options) {
			var result;
			return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
				result = result_;
				return orig(result, options);
			}).then(function() {
				return result;
			});
		};
		if (kind$1 === "error") hook$1 = function(method, options) {
			return Promise.resolve().then(method.bind(null, options)).catch(function(error$1) {
				return orig(error$1, options);
			});
		};
		state.registry[name].push({
			hook: hook$1,
			orig
		});
	}
} });

//#endregion
//#region node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({ "node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/remove.js"(exports, module) {
	module.exports = removeHook$1;
	function removeHook$1(state, name, method) {
		if (!state.registry[name]) return;
		var index = state.registry[name].map(function(registered) {
			return registered.orig;
		}).indexOf(method);
		if (index === -1) return;
		state.registry[name].splice(index, 1);
	}
} });

//#endregion
//#region node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({ "node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/index.js"(exports, module) {
	var register = require_register();
	var addHook = require_add();
	var removeHook = require_remove();
	var bind = Function.bind;
	var bindable = bind.bind(bind);
	function bindApi(hook$1, state, name) {
		var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
		hook$1.api = { remove: removeHookRef };
		hook$1.remove = removeHookRef;
		[
			"before",
			"error",
			"after",
			"wrap"
		].forEach(function(kind$1) {
			var args = name ? [
				state,
				kind$1,
				name
			] : [state, kind$1];
			hook$1[kind$1] = hook$1.api[kind$1] = bindable(addHook, null).apply(null, args);
		});
	}
	function HookSingular() {
		var singularHookName = "h";
		var singularHookState = { registry: {} };
		var singularHook = register.bind(null, singularHookState, singularHookName);
		bindApi(singularHook, singularHookState, singularHookName);
		return singularHook;
	}
	function HookCollection() {
		var state = { registry: {} };
		var hook$1 = register.bind(null, state);
		bindApi(hook$1, state);
		return hook$1;
	}
	var collectionHookDeprecationMessageDisplayed = false;
	function Hook() {
		if (!collectionHookDeprecationMessageDisplayed) {
			console.warn("[before-after-hook]: \"Hook()\" repurposing warning, use \"Hook.Collection()\". Read more: https://git.io/upgrade-before-after-hook-to-1.4");
			collectionHookDeprecationMessageDisplayed = true;
		}
		return HookCollection();
	}
	Hook.Singular = HookSingular.bind();
	Hook.Collection = HookCollection.bind();
	module.exports = Hook;
	module.exports.Hook = Hook;
	module.exports.Singular = Hook.Singular;
	module.exports.Collection = Hook.Collection;
} });

//#endregion
//#region node_modules/.pnpm/@octokit+endpoint@9.0.6/node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node$8 = __commonJS({ "node_modules/.pnpm/@octokit+endpoint@9.0.6/node_modules/@octokit/endpoint/dist-node/index.js"(exports, module) {
	var __defProp$7 = Object.defineProperty;
	var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$7 = Object.getOwnPropertyNames;
	var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
	var __export$7 = (target, all) => {
		for (var name in all) __defProp$7(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$7 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$7(from)) if (!__hasOwnProp$7.call(to, key) && key !== except) __defProp$7(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$7(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$7 = (mod) => __copyProps$7(__defProp$7({}, "__esModule", { value: true }), mod);
	var dist_src_exports$6 = {};
	__export$7(dist_src_exports$6, { endpoint: () => endpoint });
	module.exports = __toCommonJS$7(dist_src_exports$6);
	var import_universal_user_agent$3 = require_dist_node$9();
	var VERSION$6 = "9.0.6";
	var userAgent = `octokit-endpoint.js/${VERSION$6} ${(0, import_universal_user_agent$3.getUserAgent)()}`;
	var DEFAULTS = {
		method: "GET",
		baseUrl: "https://api.github.com",
		headers: {
			accept: "application/vnd.github.v3+json",
			"user-agent": userAgent
		},
		mediaType: { format: "" }
	};
	function lowercaseKeys(object) {
		if (!object) return {};
		return Object.keys(object).reduce((newObj, key) => {
			newObj[key.toLowerCase()] = object[key];
			return newObj;
		}, {});
	}
	function isPlainObject$3(value) {
		if (typeof value !== "object" || value === null) return false;
		if (Object.prototype.toString.call(value) !== "[object Object]") return false;
		const proto = Object.getPrototypeOf(value);
		if (proto === null) return true;
		const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
	}
	function mergeDeep(defaults$1, options) {
		const result = Object.assign({}, defaults$1);
		Object.keys(options).forEach((key) => {
			if (isPlainObject$3(options[key])) if (!(key in defaults$1)) Object.assign(result, { [key]: options[key] });
			else result[key] = mergeDeep(defaults$1[key], options[key]);
			else Object.assign(result, { [key]: options[key] });
		});
		return result;
	}
	function removeUndefinedProperties(obj) {
		for (const key in obj) if (obj[key] === void 0) delete obj[key];
		return obj;
	}
	function merge(defaults$1, route, options) {
		if (typeof route === "string") {
			let [method, url] = route.split(" ");
			options = Object.assign(url ? {
				method,
				url
			} : { url: method }, options);
		} else options = Object.assign({}, route);
		options.headers = lowercaseKeys(options.headers);
		removeUndefinedProperties(options);
		removeUndefinedProperties(options.headers);
		const mergedOptions = mergeDeep(defaults$1 || {}, options);
		if (options.url === "/graphql") {
			if (defaults$1 && defaults$1.mediaType.previews?.length) mergedOptions.mediaType.previews = defaults$1.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
			mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
		}
		return mergedOptions;
	}
	function addQueryParameters(url, parameters) {
		const separator = /\?/.test(url) ? "&" : "?";
		const names = Object.keys(parameters);
		if (names.length === 0) return url;
		return url + separator + names.map((name) => {
			if (name === "q") return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
			return `${name}=${encodeURIComponent(parameters[name])}`;
		}).join("&");
	}
	var urlVariableRegex = /\{[^{}}]+\}/g;
	function removeNonChars(variableName) {
		return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
	}
	function extractUrlVariableNames(url) {
		const matches = url.match(urlVariableRegex);
		if (!matches) return [];
		return matches.map(removeNonChars).reduce((a$1, b) => a$1.concat(b), []);
	}
	function omit(object, keysToOmit) {
		const result = { __proto__: null };
		for (const key of Object.keys(object)) if (keysToOmit.indexOf(key) === -1) result[key] = object[key];
		return result;
	}
	function encodeReserved(str$1) {
		return str$1.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
			if (!/%[0-9A-Fa-f]/.test(part)) part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
			return part;
		}).join("");
	}
	function encodeUnreserved(str$1) {
		return encodeURIComponent(str$1).replace(/[!'()*]/g, function(c$1) {
			return "%" + c$1.charCodeAt(0).toString(16).toUpperCase();
		});
	}
	function encodeValue(operator, value, key) {
		value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
		if (key) return encodeUnreserved(key) + "=" + value;
		else return value;
	}
	function isDefined(value) {
		return value !== void 0 && value !== null;
	}
	function isKeyOperator(operator) {
		return operator === ";" || operator === "&" || operator === "?";
	}
	function getValues(context$1, operator, key, modifier) {
		var value = context$1[key], result = [];
		if (isDefined(value) && value !== "") if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
			value = value.toString();
			if (modifier && modifier !== "*") value = value.substring(0, parseInt(modifier, 10));
			result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
		} else if (modifier === "*") if (Array.isArray(value)) value.filter(isDefined).forEach(function(value2) {
			result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
		});
		else Object.keys(value).forEach(function(k) {
			if (isDefined(value[k])) result.push(encodeValue(operator, value[k], k));
		});
		else {
			const tmp = [];
			if (Array.isArray(value)) value.filter(isDefined).forEach(function(value2) {
				tmp.push(encodeValue(operator, value2));
			});
			else Object.keys(value).forEach(function(k) {
				if (isDefined(value[k])) {
					tmp.push(encodeUnreserved(k));
					tmp.push(encodeValue(operator, value[k].toString()));
				}
			});
			if (isKeyOperator(operator)) result.push(encodeUnreserved(key) + "=" + tmp.join(","));
			else if (tmp.length !== 0) result.push(tmp.join(","));
		}
		else if (operator === ";") {
			if (isDefined(value)) result.push(encodeUnreserved(key));
		} else if (value === "" && (operator === "&" || operator === "?")) result.push(encodeUnreserved(key) + "=");
		else if (value === "") result.push("");
		return result;
	}
	function parseUrl(template) {
		return { expand: expand.bind(null, template) };
	}
	function expand(template, context$1) {
		var operators = [
			"+",
			"#",
			".",
			"/",
			";",
			"?",
			"&"
		];
		template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
			if (expression) {
				let operator = "";
				const values = [];
				if (operators.indexOf(expression.charAt(0)) !== -1) {
					operator = expression.charAt(0);
					expression = expression.substr(1);
				}
				expression.split(/,/g).forEach(function(variable) {
					var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
					values.push(getValues(context$1, operator, tmp[1], tmp[2] || tmp[3]));
				});
				if (operator && operator !== "+") {
					var separator = ",";
					if (operator === "?") separator = "&";
					else if (operator !== "#") separator = operator;
					return (values.length !== 0 ? operator : "") + values.join(separator);
				} else return values.join(",");
			} else return encodeReserved(literal);
		});
		if (template === "/") return template;
		else return template.replace(/\/$/, "");
	}
	function parse$3(options) {
		let method = options.method.toUpperCase();
		let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
		let headers = Object.assign({}, options.headers);
		let body;
		let parameters = omit(options, [
			"method",
			"baseUrl",
			"url",
			"headers",
			"request",
			"mediaType"
		]);
		const urlVariableNames = extractUrlVariableNames(url);
		url = parseUrl(url).expand(parameters);
		if (!/^http/.test(url)) url = options.baseUrl + url;
		const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
		const remainingParameters = omit(parameters, omittedParameters);
		const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
		if (!isBinaryRequest) {
			if (options.mediaType.format) headers.accept = headers.accept.split(/,/).map((format$1) => format$1.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
			if (url.endsWith("/graphql")) {
				if (options.mediaType.previews?.length) {
					const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
					headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
						const format$1 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
						return `application/vnd.github.${preview}-preview${format$1}`;
					}).join(",");
				}
			}
		}
		if (["GET", "HEAD"].includes(method)) url = addQueryParameters(url, remainingParameters);
		else if ("data" in remainingParameters) body = remainingParameters.data;
		else if (Object.keys(remainingParameters).length) body = remainingParameters;
		if (!headers["content-type"] && typeof body !== "undefined") headers["content-type"] = "application/json; charset=utf-8";
		if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") body = "";
		return Object.assign({
			method,
			url,
			headers
		}, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
	}
	function endpointWithDefaults(defaults$1, route, options) {
		return parse$3(merge(defaults$1, route, options));
	}
	function withDefaults$2(oldDefaults, newDefaults) {
		const DEFAULTS2 = merge(oldDefaults, newDefaults);
		const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
		return Object.assign(endpoint2, {
			DEFAULTS: DEFAULTS2,
			defaults: withDefaults$2.bind(null, DEFAULTS2),
			merge: merge.bind(null, DEFAULTS2),
			parse: parse$3
		});
	}
	var endpoint = withDefaults$2(null, DEFAULTS);
} });

//#endregion
//#region node_modules/.pnpm/deprecation@2.3.1/node_modules/deprecation/dist-node/index.js
var require_dist_node$7 = __commonJS({ "node_modules/.pnpm/deprecation@2.3.1/node_modules/deprecation/dist-node/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Deprecation = class extends Error {
		constructor(message) {
			super(message);
			/* istanbul ignore next */
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "Deprecation";
		}
	};
	exports.Deprecation = Deprecation;
} });

//#endregion
//#region node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({ "node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module) {
	module.exports = wrappy$1;
	function wrappy$1(fn, cb) {
		if (fn && cb) return wrappy$1(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i$1 = 0; i$1 < args.length; i$1++) args[i$1] = arguments[i$1];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
} });

//#endregion
//#region node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS({ "node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module) {
	var wrappy = require_wrappy();
	module.exports = wrappy(once$1);
	module.exports.strict = wrappy(onceStrict);
	once$1.proto = once$1(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once$1(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once$1(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		var name = fn.name || "Function wrapped with `once`";
		f.onceError = name + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
} });

//#endregion
//#region node_modules/.pnpm/@octokit+request-error@5.1.1/node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node$6 = __commonJS({ "node_modules/.pnpm/@octokit+request-error@5.1.1/node_modules/@octokit/request-error/dist-node/index.js"(exports, module) {
	var __create = Object.create;
	var __defProp$6 = Object.defineProperty;
	var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$6 = Object.getOwnPropertyNames;
	var __getProtoOf = Object.getPrototypeOf;
	var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
	var __export$6 = (target, all) => {
		for (var name in all) __defProp$6(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$6 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$6(from)) if (!__hasOwnProp$6.call(to, key) && key !== except) __defProp$6(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$6(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps$6(isNodeMode || !mod || !mod.__esModule ? __defProp$6(target, "default", {
		value: mod,
		enumerable: true
	}) : target, mod));
	var __toCommonJS$6 = (mod) => __copyProps$6(__defProp$6({}, "__esModule", { value: true }), mod);
	var dist_src_exports$5 = {};
	__export$6(dist_src_exports$5, { RequestError: () => RequestError });
	module.exports = __toCommonJS$6(dist_src_exports$5);
	var import_deprecation = require_dist_node$7();
	var import_once = __toESM$1(require_once());
	var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
	var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
	var RequestError = class extends Error {
		constructor(message, statusCode, options) {
			super(message);
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "HttpError";
			this.status = statusCode;
			let headers;
			if ("headers" in options && typeof options.headers !== "undefined") headers = options.headers;
			if ("response" in options) {
				this.response = options.response;
				headers = options.response.headers;
			}
			const requestCopy = Object.assign({}, options.request);
			if (options.request.headers.authorization) requestCopy.headers = Object.assign({}, options.request.headers, { authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]") });
			requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
			this.request = requestCopy;
			Object.defineProperty(this, "code", { get() {
				logOnceCode(new import_deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
				return statusCode;
			} });
			Object.defineProperty(this, "headers", { get() {
				logOnceHeaders(new import_deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
				return headers || {};
			} });
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/@octokit+request@8.4.1/node_modules/@octokit/request/dist-node/index.js
var require_dist_node$5 = __commonJS({ "node_modules/.pnpm/@octokit+request@8.4.1/node_modules/@octokit/request/dist-node/index.js"(exports, module) {
	var __defProp$5 = Object.defineProperty;
	var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$5 = Object.getOwnPropertyNames;
	var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
	var __export$5 = (target, all) => {
		for (var name in all) __defProp$5(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$5 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$5(from)) if (!__hasOwnProp$5.call(to, key) && key !== except) __defProp$5(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$5(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$5 = (mod) => __copyProps$5(__defProp$5({}, "__esModule", { value: true }), mod);
	var dist_src_exports$4 = {};
	__export$5(dist_src_exports$4, { request: () => request });
	module.exports = __toCommonJS$5(dist_src_exports$4);
	var import_endpoint = require_dist_node$8();
	var import_universal_user_agent$2 = require_dist_node$9();
	var VERSION$5 = "8.4.1";
	function isPlainObject$2(value) {
		if (typeof value !== "object" || value === null) return false;
		if (Object.prototype.toString.call(value) !== "[object Object]") return false;
		const proto = Object.getPrototypeOf(value);
		if (proto === null) return true;
		const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
	}
	var import_request_error = require_dist_node$6();
	function getBufferResponse(response) {
		return response.arrayBuffer();
	}
	function fetchWrapper(requestOptions) {
		var _a$2, _b, _c, _d;
		const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
		const parseSuccessResponseBody = ((_a$2 = requestOptions.request) == null ? void 0 : _a$2.parseSuccessResponseBody) !== false;
		if (isPlainObject$2(requestOptions.body) || Array.isArray(requestOptions.body)) requestOptions.body = JSON.stringify(requestOptions.body);
		let headers = {};
		let status;
		let url;
		let { fetch: fetch$3 } = globalThis;
		if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) fetch$3 = requestOptions.request.fetch;
		if (!fetch$3) throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
		return fetch$3(requestOptions.url, {
			method: requestOptions.method,
			body: requestOptions.body,
			redirect: (_c = requestOptions.request) == null ? void 0 : _c.redirect,
			headers: requestOptions.headers,
			signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
			...requestOptions.body && { duplex: "half" }
		}).then(async (response) => {
			url = response.url;
			status = response.status;
			for (const keyAndValue of response.headers) headers[keyAndValue[0]] = keyAndValue[1];
			if ("deprecation" in headers) {
				const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
				const deprecationLink = matches && matches.pop();
				log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
			}
			if (status === 204 || status === 205) return;
			if (requestOptions.method === "HEAD") {
				if (status < 400) return;
				throw new import_request_error.RequestError(response.statusText, status, {
					response: {
						url,
						status,
						headers,
						data: void 0
					},
					request: requestOptions
				});
			}
			if (status === 304) throw new import_request_error.RequestError("Not modified", status, {
				response: {
					url,
					status,
					headers,
					data: await getResponseData(response)
				},
				request: requestOptions
			});
			if (status >= 400) {
				const data = await getResponseData(response);
				const error$1 = new import_request_error.RequestError(toErrorMessage(data), status, {
					response: {
						url,
						status,
						headers,
						data
					},
					request: requestOptions
				});
				throw error$1;
			}
			return parseSuccessResponseBody ? await getResponseData(response) : response.body;
		}).then((data) => {
			return {
				status,
				url,
				headers,
				data
			};
		}).catch((error$1) => {
			if (error$1 instanceof import_request_error.RequestError) throw error$1;
			else if (error$1.name === "AbortError") throw error$1;
			let message = error$1.message;
			if (error$1.name === "TypeError" && "cause" in error$1) {
				if (error$1.cause instanceof Error) message = error$1.cause.message;
				else if (typeof error$1.cause === "string") message = error$1.cause;
			}
			throw new import_request_error.RequestError(message, 500, { request: requestOptions });
		});
	}
	async function getResponseData(response) {
		const contentType = response.headers.get("content-type");
		if (/application\/json/.test(contentType)) return response.json().catch(() => response.text()).catch(() => "");
		if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) return response.text();
		return getBufferResponse(response);
	}
	function toErrorMessage(data) {
		if (typeof data === "string") return data;
		let suffix;
		if ("documentation_url" in data) suffix = ` - ${data.documentation_url}`;
		else suffix = "";
		if ("message" in data) {
			if (Array.isArray(data.errors)) return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
			return `${data.message}${suffix}`;
		}
		return `Unknown error: ${JSON.stringify(data)}`;
	}
	function withDefaults$1(oldEndpoint, newDefaults) {
		const endpoint2 = oldEndpoint.defaults(newDefaults);
		const newApi = function(route, parameters) {
			const endpointOptions = endpoint2.merge(route, parameters);
			if (!endpointOptions.request || !endpointOptions.request.hook) return fetchWrapper(endpoint2.parse(endpointOptions));
			const request2 = (route2, parameters2) => {
				return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
			};
			Object.assign(request2, {
				endpoint: endpoint2,
				defaults: withDefaults$1.bind(null, endpoint2)
			});
			return endpointOptions.request.hook(request2, endpointOptions);
		};
		return Object.assign(newApi, {
			endpoint: endpoint2,
			defaults: withDefaults$1.bind(null, endpoint2)
		});
	}
	var request = withDefaults$1(import_endpoint.endpoint, { headers: { "user-agent": `octokit-request.js/${VERSION$5} ${(0, import_universal_user_agent$2.getUserAgent)()}` } });
} });

//#endregion
//#region node_modules/.pnpm/@octokit+graphql@7.1.1/node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node$4 = __commonJS({ "node_modules/.pnpm/@octokit+graphql@7.1.1/node_modules/@octokit/graphql/dist-node/index.js"(exports, module) {
	var __defProp$4 = Object.defineProperty;
	var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$4 = Object.getOwnPropertyNames;
	var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
	var __export$4 = (target, all) => {
		for (var name in all) __defProp$4(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$4 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$4(from)) if (!__hasOwnProp$4.call(to, key) && key !== except) __defProp$4(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$4(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$4 = (mod) => __copyProps$4(__defProp$4({}, "__esModule", { value: true }), mod);
	var index_exports = {};
	__export$4(index_exports, {
		GraphqlResponseError: () => GraphqlResponseError,
		graphql: () => graphql2,
		withCustomRequest: () => withCustomRequest
	});
	module.exports = __toCommonJS$4(index_exports);
	var import_request3 = require_dist_node$5();
	var import_universal_user_agent$1 = require_dist_node$9();
	var VERSION$4 = "7.1.1";
	var import_request2 = require_dist_node$5();
	var import_request$1 = require_dist_node$5();
	function _buildMessageForResponseErrors(data) {
		return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
	}
	var GraphqlResponseError = class extends Error {
		constructor(request2, headers, response) {
			super(_buildMessageForResponseErrors(response));
			this.request = request2;
			this.headers = headers;
			this.response = response;
			this.name = "GraphqlResponseError";
			this.errors = response.errors;
			this.data = response.data;
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
		}
	};
	var NON_VARIABLE_OPTIONS = [
		"method",
		"baseUrl",
		"url",
		"headers",
		"request",
		"query",
		"mediaType"
	];
	var FORBIDDEN_VARIABLE_OPTIONS = [
		"query",
		"method",
		"url"
	];
	var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
	function graphql(request2, query, options) {
		if (options) {
			if (typeof query === "string" && "query" in options) return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
			for (const key in options) {
				if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
				return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
			}
		}
		const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
		const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
			if (NON_VARIABLE_OPTIONS.includes(key)) {
				result[key] = parsedOptions[key];
				return result;
			}
			if (!result.variables) result.variables = {};
			result.variables[key] = parsedOptions[key];
			return result;
		}, {});
		const baseUrl$1 = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
		if (GHES_V3_SUFFIX_REGEX.test(baseUrl$1)) requestOptions.url = baseUrl$1.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
		return request2(requestOptions).then((response) => {
			if (response.data.errors) {
				const headers = {};
				for (const key of Object.keys(response.headers)) headers[key] = response.headers[key];
				throw new GraphqlResponseError(requestOptions, headers, response.data);
			}
			return response.data.data;
		});
	}
	function withDefaults(request2, newDefaults) {
		const newRequest = request2.defaults(newDefaults);
		const newApi = (query, options) => {
			return graphql(newRequest, query, options);
		};
		return Object.assign(newApi, {
			defaults: withDefaults.bind(null, newRequest),
			endpoint: newRequest.endpoint
		});
	}
	var graphql2 = withDefaults(import_request3.request, {
		headers: { "user-agent": `octokit-graphql.js/${VERSION$4} ${(0, import_universal_user_agent$1.getUserAgent)()}` },
		method: "POST",
		url: "/graphql"
	});
	function withCustomRequest(customRequest) {
		return withDefaults(customRequest, {
			method: "POST",
			url: "/graphql"
		});
	}
} });

//#endregion
//#region node_modules/.pnpm/@octokit+auth-token@4.0.0/node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node$3 = __commonJS({ "node_modules/.pnpm/@octokit+auth-token@4.0.0/node_modules/@octokit/auth-token/dist-node/index.js"(exports, module) {
	var __defProp$3 = Object.defineProperty;
	var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$3 = Object.getOwnPropertyNames;
	var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
	var __export$3 = (target, all) => {
		for (var name in all) __defProp$3(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$3 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$3(from)) if (!__hasOwnProp$3.call(to, key) && key !== except) __defProp$3(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$3(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$3 = (mod) => __copyProps$3(__defProp$3({}, "__esModule", { value: true }), mod);
	var dist_src_exports$3 = {};
	__export$3(dist_src_exports$3, { createTokenAuth: () => createTokenAuth });
	module.exports = __toCommonJS$3(dist_src_exports$3);
	var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
	var REGEX_IS_INSTALLATION = /^ghs_/;
	var REGEX_IS_USER_TO_SERVER = /^ghu_/;
	async function auth(token) {
		const isApp = token.split(/\./).length === 3;
		const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
		const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
		const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
		return {
			type: "token",
			token,
			tokenType
		};
	}
	function withAuthorizationPrefix(token) {
		if (token.split(/\./).length === 3) return `bearer ${token}`;
		return `token ${token}`;
	}
	async function hook(token, request$2, route, parameters) {
		const endpoint$1 = request$2.endpoint.merge(route, parameters);
		endpoint$1.headers.authorization = withAuthorizationPrefix(token);
		return request$2(endpoint$1);
	}
	var createTokenAuth = function createTokenAuth2(token) {
		if (!token) throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
		if (typeof token !== "string") throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
		token = token.replace(/^(token|bearer) +/i, "");
		return Object.assign(auth.bind(null, token), { hook: hook.bind(null, token) });
	};
} });

//#endregion
//#region node_modules/.pnpm/@octokit+core@5.2.0/node_modules/@octokit/core/dist-node/index.js
var require_dist_node$2 = __commonJS({ "node_modules/.pnpm/@octokit+core@5.2.0/node_modules/@octokit/core/dist-node/index.js"(exports, module) {
	var __defProp$2 = Object.defineProperty;
	var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$2 = Object.getOwnPropertyNames;
	var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
	var __export$2 = (target, all) => {
		for (var name in all) __defProp$2(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$2 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$2(from)) if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$2 = (mod) => __copyProps$2(__defProp$2({}, "__esModule", { value: true }), mod);
	var dist_src_exports$2 = {};
	__export$2(dist_src_exports$2, { Octokit: () => Octokit });
	module.exports = __toCommonJS$2(dist_src_exports$2);
	var import_universal_user_agent = require_dist_node$9();
	var import_before_after_hook = require_before_after_hook();
	var import_request = require_dist_node$5();
	var import_graphql = require_dist_node$4();
	var import_auth_token = require_dist_node$3();
	var VERSION$3 = "5.2.0";
	var noop$2 = () => {};
	var consoleWarn = console.warn.bind(console);
	var consoleError = console.error.bind(console);
	var userAgentTrail = `octokit-core.js/${VERSION$3} ${(0, import_universal_user_agent.getUserAgent)()}`;
	var Octokit = class {
		static {
			this.VERSION = VERSION$3;
		}
		static defaults(defaults$1) {
			const OctokitWithDefaults = class extends this {
				constructor(...args) {
					const options = args[0] || {};
					if (typeof defaults$1 === "function") {
						super(defaults$1(options));
						return;
					}
					super(Object.assign({}, defaults$1, options, options.userAgent && defaults$1.userAgent ? { userAgent: `${options.userAgent} ${defaults$1.userAgent}` } : null));
				}
			};
			return OctokitWithDefaults;
		}
		static {
			this.plugins = [];
		}
		/**
		* Attach a plugin (or many) to your Octokit instance.
		*
		* @example
		* const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
		*/
		static plugin(...newPlugins) {
			const currentPlugins = this.plugins;
			const NewOctokit = class extends this {
				static {
					this.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
				}
			};
			return NewOctokit;
		}
		constructor(options = {}) {
			const hook$1 = new import_before_after_hook.Collection();
			const requestDefaults = {
				baseUrl: import_request.request.endpoint.DEFAULTS.baseUrl,
				headers: {},
				request: Object.assign({}, options.request, { hook: hook$1.bind(null, "request") }),
				mediaType: {
					previews: [],
					format: ""
				}
			};
			requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
			if (options.baseUrl) requestDefaults.baseUrl = options.baseUrl;
			if (options.previews) requestDefaults.mediaType.previews = options.previews;
			if (options.timeZone) requestDefaults.headers["time-zone"] = options.timeZone;
			this.request = import_request.request.defaults(requestDefaults);
			this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults);
			this.log = Object.assign({
				debug: noop$2,
				info: noop$2,
				warn: consoleWarn,
				error: consoleError
			}, options.log);
			this.hook = hook$1;
			if (!options.authStrategy) if (!options.auth) this.auth = async () => ({ type: "unauthenticated" });
			else {
				const auth$1 = (0, import_auth_token.createTokenAuth)(options.auth);
				hook$1.wrap("request", auth$1.hook);
				this.auth = auth$1;
			}
			else {
				const { authStrategy,...otherOptions } = options;
				const auth$1 = authStrategy(Object.assign({
					request: this.request,
					log: this.log,
					octokit: this,
					octokitOptions: otherOptions
				}, options.auth));
				hook$1.wrap("request", auth$1.hook);
				this.auth = auth$1;
			}
			const classConstructor = this.constructor;
			for (let i$1 = 0; i$1 < classConstructor.plugins.length; ++i$1) Object.assign(this, classConstructor.plugins[i$1](this, options));
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@10.4.1_@octokit+core@5.2.0/node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node$1 = __commonJS({ "node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@10.4.1_@octokit+core@5.2.0/node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js"(exports, module) {
	var __defProp$1 = Object.defineProperty;
	var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$1 = Object.getOwnPropertyNames;
	var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
	var __export$1 = (target, all) => {
		for (var name in all) __defProp$1(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$1 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$1 = (mod) => __copyProps$1(__defProp$1({}, "__esModule", { value: true }), mod);
	var dist_src_exports$1 = {};
	__export$1(dist_src_exports$1, {
		legacyRestEndpointMethods: () => legacyRestEndpointMethods,
		restEndpointMethods: () => restEndpointMethods
	});
	module.exports = __toCommonJS$1(dist_src_exports$1);
	var VERSION$2 = "10.4.1";
	var Endpoints = {
		actions: {
			addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
			addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
			cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
			createEnvironmentVariable: ["POST /repositories/{repository_id}/environments/{environment_name}/variables"],
			createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			createOrgVariable: ["POST /orgs/{org}/actions/variables"],
			createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
			createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
			createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
			createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
			createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
			createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
			deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
			deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
			deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			deleteEnvironmentVariable: ["DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
			deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			deleteRepoVariable: ["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],
			deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
			deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
			deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
			downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
			downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
			downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
			downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
			forceCancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],
			generateRunnerJitconfigForOrg: ["POST /orgs/{org}/actions/runners/generate-jitconfig"],
			generateRunnerJitconfigForRepo: ["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],
			getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
			getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
			getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
			getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
			getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
			getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			getCustomOidcSubClaimForRepo: ["GET /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
			getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			getEnvironmentVariable: ["GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
			getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
			getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
			getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
			getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
			getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
			getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
			getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			getRepoPermissions: [
				"GET /repos/{owner}/{repo}/actions/permissions",
				{},
				{ renamed: ["actions", "getGithubActionsPermissionsRepository"] }
			],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
			getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
			getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
			getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
			getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
			getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
			getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
			getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
			getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
			listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
			listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
			listEnvironmentVariables: ["GET /repositories/{repository_id}/environments/{environment_name}/variables"],
			listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
			listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
			listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
			listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
			listOrgVariables: ["GET /orgs/{org}/actions/variables"],
			listRepoOrganizationSecrets: ["GET /repos/{owner}/{repo}/actions/organization-secrets"],
			listRepoOrganizationVariables: ["GET /repos/{owner}/{repo}/actions/organization-variables"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
			listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
			listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
			listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
			listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			listSelectedReposForOrgVariable: ["GET /orgs/{org}/actions/variables/{name}/repositories"],
			listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
			listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
			listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
			listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
			listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
			listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
			reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
			reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
			reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
			removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
			removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
			removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			reviewCustomGatesForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],
			reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
			setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
			setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			setCustomOidcSubClaimForRepo: ["PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
			setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
			setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
			setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories"],
			setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
			setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"],
			updateEnvironmentVariable: ["PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
			updateRepoVariable: ["PATCH /repos/{owner}/{repo}/actions/variables/{name}"]
		},
		activity: {
			checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
			deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
			deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
			getFeeds: ["GET /feeds"],
			getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
			getThread: ["GET /notifications/threads/{thread_id}"],
			getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
			listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
			listNotificationsForAuthenticatedUser: ["GET /notifications"],
			listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
			listPublicEvents: ["GET /events"],
			listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
			listPublicEventsForUser: ["GET /users/{username}/events/public"],
			listPublicOrgEvents: ["GET /orgs/{org}/events"],
			listReceivedEventsForUser: ["GET /users/{username}/received_events"],
			listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
			listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
			listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
			listReposStarredByAuthenticatedUser: ["GET /user/starred"],
			listReposStarredByUser: ["GET /users/{username}/starred"],
			listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
			listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
			listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
			listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
			markNotificationsAsRead: ["PUT /notifications"],
			markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
			markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
			markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
			setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
			setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
			starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
			unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
		},
		apps: {
			addRepoToInstallation: [
				"PUT /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
			],
			addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
			checkToken: ["POST /applications/{client_id}/token"],
			createFromManifest: ["POST /app-manifests/{code}/conversions"],
			createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
			deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
			deleteInstallation: ["DELETE /app/installations/{installation_id}"],
			deleteToken: ["DELETE /applications/{client_id}/token"],
			getAuthenticated: ["GET /app"],
			getBySlug: ["GET /apps/{app_slug}"],
			getInstallation: ["GET /app/installations/{installation_id}"],
			getOrgInstallation: ["GET /orgs/{org}/installation"],
			getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
			getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
			getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
			getUserInstallation: ["GET /users/{username}/installation"],
			getWebhookConfigForApp: ["GET /app/hook/config"],
			getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
			listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
			listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
			listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
			listInstallationRequestsForAuthenticatedApp: ["GET /app/installation-requests"],
			listInstallations: ["GET /app/installations"],
			listInstallationsForAuthenticatedUser: ["GET /user/installations"],
			listPlans: ["GET /marketplace_listing/plans"],
			listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
			listReposAccessibleToInstallation: ["GET /installation/repositories"],
			listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
			listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
			listWebhookDeliveries: ["GET /app/hook/deliveries"],
			redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
			removeRepoFromInstallation: [
				"DELETE /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
			],
			removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
			resetToken: ["PATCH /applications/{client_id}/token"],
			revokeInstallationAccessToken: ["DELETE /installation/token"],
			scopeToken: ["POST /applications/{client_id}/token/scoped"],
			suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
			unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
			updateWebhookConfigForApp: ["PATCH /app/hook/config"]
		},
		billing: {
			getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
			getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
			getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
			getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
			getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
			getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
		},
		checks: {
			create: ["POST /repos/{owner}/{repo}/check-runs"],
			createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
			get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
			getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
			listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
			listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
			listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
			listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
			rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
			rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
			setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
			update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
		},
		codeScanning: {
			deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
			getAlert: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
				{},
				{ renamedParameters: { alert_id: "alert_number" } }
			],
			getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
			getCodeqlDatabase: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
			getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
			getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
			listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
			listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
			listAlertsInstances: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
				{},
				{ renamed: ["codeScanning", "listAlertInstances"] }
			],
			listCodeqlDatabases: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],
			listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
			updateDefaultSetup: ["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],
			uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
		},
		codesOfConduct: {
			getAllCodesOfConduct: ["GET /codes_of_conduct"],
			getConductCode: ["GET /codes_of_conduct/{key}"]
		},
		codespaces: {
			addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			checkPermissionsForDevcontainer: ["GET /repos/{owner}/{repo}/codespaces/permissions_check"],
			codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
			createForAuthenticatedUser: ["POST /user/codespaces"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
			createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
			createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
			deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
			deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
			exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
			getCodespacesForUserInOrg: ["GET /orgs/{org}/members/{username}/codespaces"],
			getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
			getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
			getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
			getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
			listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
			listForAuthenticatedUser: ["GET /user/codespaces"],
			listInOrganization: [
				"GET /orgs/{org}/codespaces",
				{},
				{ renamedParameters: { org_id: "org" } }
			],
			listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
			listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
			listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
			listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			preFlightWithRepoForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/new"],
			publishForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/publish"],
			removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
			setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
			stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
			stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
			updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
		},
		copilot: {
			addCopilotSeatsForTeams: ["POST /orgs/{org}/copilot/billing/selected_teams"],
			addCopilotSeatsForUsers: ["POST /orgs/{org}/copilot/billing/selected_users"],
			cancelCopilotSeatAssignmentForTeams: ["DELETE /orgs/{org}/copilot/billing/selected_teams"],
			cancelCopilotSeatAssignmentForUsers: ["DELETE /orgs/{org}/copilot/billing/selected_users"],
			getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
			getCopilotSeatDetailsForUser: ["GET /orgs/{org}/members/{username}/copilot"],
			listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
		},
		dependabot: {
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
			getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/dependabot/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
			listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"]
		},
		dependencyGraph: {
			createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
			diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],
			exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
		},
		emojis: { get: ["GET /emojis"] },
		gists: {
			checkIsStarred: ["GET /gists/{gist_id}/star"],
			create: ["POST /gists"],
			createComment: ["POST /gists/{gist_id}/comments"],
			delete: ["DELETE /gists/{gist_id}"],
			deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
			fork: ["POST /gists/{gist_id}/forks"],
			get: ["GET /gists/{gist_id}"],
			getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
			getRevision: ["GET /gists/{gist_id}/{sha}"],
			list: ["GET /gists"],
			listComments: ["GET /gists/{gist_id}/comments"],
			listCommits: ["GET /gists/{gist_id}/commits"],
			listForUser: ["GET /users/{username}/gists"],
			listForks: ["GET /gists/{gist_id}/forks"],
			listPublic: ["GET /gists/public"],
			listStarred: ["GET /gists/starred"],
			star: ["PUT /gists/{gist_id}/star"],
			unstar: ["DELETE /gists/{gist_id}/star"],
			update: ["PATCH /gists/{gist_id}"],
			updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
		},
		git: {
			createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
			createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
			createRef: ["POST /repos/{owner}/{repo}/git/refs"],
			createTag: ["POST /repos/{owner}/{repo}/git/tags"],
			createTree: ["POST /repos/{owner}/{repo}/git/trees"],
			deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
			getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
			getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
			getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
			getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
			getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
			listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
			updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
		},
		gitignore: {
			getAllTemplates: ["GET /gitignore/templates"],
			getTemplate: ["GET /gitignore/templates/{name}"]
		},
		interactions: {
			getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
			getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
			getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
			getRestrictionsForYourPublicRepos: [
				"GET /user/interaction-limits",
				{},
				{ renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
			],
			removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
			removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
			removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
			removeRestrictionsForYourPublicRepos: [
				"DELETE /user/interaction-limits",
				{},
				{ renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
			],
			setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
			setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
			setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
			setRestrictionsForYourPublicRepos: [
				"PUT /user/interaction-limits",
				{},
				{ renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
			]
		},
		issues: {
			addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
			checkUserCanBeAssignedToIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],
			create: ["POST /repos/{owner}/{repo}/issues"],
			createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			createLabel: ["POST /repos/{owner}/{repo}/labels"],
			createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
			deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
			deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
			get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
			getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
			getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
			getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
			list: ["GET /issues"],
			listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
			listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
			listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
			listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
			listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
			listForAuthenticatedUser: ["GET /user/issues"],
			listForOrg: ["GET /orgs/{org}/issues"],
			listForRepo: ["GET /repos/{owner}/{repo}/issues"],
			listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
			listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
			listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
			lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
			setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
			updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
			updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
		},
		licenses: {
			get: ["GET /licenses/{license}"],
			getAllCommonlyUsed: ["GET /licenses"],
			getForRepo: ["GET /repos/{owner}/{repo}/license"]
		},
		markdown: {
			render: ["POST /markdown"],
			renderRaw: ["POST /markdown/raw", { headers: { "content-type": "text/plain; charset=utf-8" } }]
		},
		meta: {
			get: ["GET /meta"],
			getAllVersions: ["GET /versions"],
			getOctocat: ["GET /octocat"],
			getZen: ["GET /zen"],
			root: ["GET /"]
		},
		migrations: {
			cancelImport: [
				"DELETE /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import" }
			],
			deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
			deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
			downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
			getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
			getCommitAuthors: [
				"GET /repos/{owner}/{repo}/import/authors",
				{},
				{ deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors" }
			],
			getImportStatus: [
				"GET /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status" }
			],
			getLargeFiles: [
				"GET /repos/{owner}/{repo}/import/large_files",
				{},
				{ deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files" }
			],
			getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
			getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
			listForAuthenticatedUser: ["GET /user/migrations"],
			listForOrg: ["GET /orgs/{org}/migrations"],
			listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
			listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
			listReposForUser: [
				"GET /user/migrations/{migration_id}/repositories",
				{},
				{ renamed: ["migrations", "listReposForAuthenticatedUser"] }
			],
			mapCommitAuthor: [
				"PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
				{},
				{ deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author" }
			],
			setLfsPreference: [
				"PATCH /repos/{owner}/{repo}/import/lfs",
				{},
				{ deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference" }
			],
			startForAuthenticatedUser: ["POST /user/migrations"],
			startForOrg: ["POST /orgs/{org}/migrations"],
			startImport: [
				"PUT /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import" }
			],
			unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
			unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
			updateImport: [
				"PATCH /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import" }
			]
		},
		oidc: {
			getOidcCustomSubTemplateForOrg: ["GET /orgs/{org}/actions/oidc/customization/sub"],
			updateOidcCustomSubTemplateForOrg: ["PUT /orgs/{org}/actions/oidc/customization/sub"]
		},
		orgs: {
			addSecurityManagerTeam: ["PUT /orgs/{org}/security-managers/teams/{team_slug}"],
			assignTeamToOrgRole: ["PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			assignUserToOrgRole: ["PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			blockUser: ["PUT /orgs/{org}/blocks/{username}"],
			cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
			checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
			checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
			checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
			convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
			createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
			createInvitation: ["POST /orgs/{org}/invitations"],
			createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
			createOrUpdateCustomPropertiesValuesForRepos: ["PATCH /orgs/{org}/properties/values"],
			createOrUpdateCustomProperty: ["PUT /orgs/{org}/properties/schema/{custom_property_name}"],
			createWebhook: ["POST /orgs/{org}/hooks"],
			delete: ["DELETE /orgs/{org}"],
			deleteCustomOrganizationRole: ["DELETE /orgs/{org}/organization-roles/{role_id}"],
			deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
			enableOrDisableSecurityProductOnAllOrgRepos: ["POST /orgs/{org}/{security_product}/{enablement}"],
			get: ["GET /orgs/{org}"],
			getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
			getCustomProperty: ["GET /orgs/{org}/properties/schema/{custom_property_name}"],
			getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
			getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
			getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
			getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
			getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
			list: ["GET /organizations"],
			listAppInstallations: ["GET /orgs/{org}/installations"],
			listBlockedUsers: ["GET /orgs/{org}/blocks"],
			listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
			listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
			listForAuthenticatedUser: ["GET /user/orgs"],
			listForUser: ["GET /users/{username}/orgs"],
			listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
			listMembers: ["GET /orgs/{org}/members"],
			listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
			listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
			listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
			listOrgRoles: ["GET /orgs/{org}/organization-roles"],
			listOrganizationFineGrainedPermissions: ["GET /orgs/{org}/organization-fine-grained-permissions"],
			listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
			listPatGrantRepositories: ["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],
			listPatGrantRequestRepositories: ["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],
			listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
			listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
			listPendingInvitations: ["GET /orgs/{org}/invitations"],
			listPublicMembers: ["GET /orgs/{org}/public_members"],
			listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
			listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /orgs/{org}/hooks"],
			patchCustomOrganizationRole: ["PATCH /orgs/{org}/organization-roles/{role_id}"],
			pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeCustomProperty: ["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],
			removeMember: ["DELETE /orgs/{org}/members/{username}"],
			removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
			removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
			removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
			removeSecurityManagerTeam: ["DELETE /orgs/{org}/security-managers/teams/{team_slug}"],
			reviewPatGrantRequest: ["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],
			reviewPatGrantRequestsInBulk: ["POST /orgs/{org}/personal-access-token-requests"],
			revokeAllOrgRolesTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}"],
			revokeAllOrgRolesUser: ["DELETE /orgs/{org}/organization-roles/users/{username}"],
			revokeOrgRoleTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			revokeOrgRoleUser: ["DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
			setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
			unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
			update: ["PATCH /orgs/{org}"],
			updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
			updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
			updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
			updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
			updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
		},
		packages: {
			deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
			deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
			deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
			deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getAllPackageVersionsForAPackageOwnedByAnOrg: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
			],
			getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"] }
			],
			getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
			getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
			getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
			getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
			getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			listDockerMigrationConflictingPackagesForAuthenticatedUser: ["GET /user/docker/conflicts"],
			listDockerMigrationConflictingPackagesForOrganization: ["GET /orgs/{org}/docker/conflicts"],
			listDockerMigrationConflictingPackagesForUser: ["GET /users/{username}/docker/conflicts"],
			listPackagesForAuthenticatedUser: ["GET /user/packages"],
			listPackagesForOrganization: ["GET /orgs/{org}/packages"],
			listPackagesForUser: ["GET /users/{username}/packages"],
			restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
		},
		projects: {
			addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
			createCard: ["POST /projects/columns/{column_id}/cards"],
			createColumn: ["POST /projects/{project_id}/columns"],
			createForAuthenticatedUser: ["POST /user/projects"],
			createForOrg: ["POST /orgs/{org}/projects"],
			createForRepo: ["POST /repos/{owner}/{repo}/projects"],
			delete: ["DELETE /projects/{project_id}"],
			deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
			deleteColumn: ["DELETE /projects/columns/{column_id}"],
			get: ["GET /projects/{project_id}"],
			getCard: ["GET /projects/columns/cards/{card_id}"],
			getColumn: ["GET /projects/columns/{column_id}"],
			getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
			listCards: ["GET /projects/columns/{column_id}/cards"],
			listCollaborators: ["GET /projects/{project_id}/collaborators"],
			listColumns: ["GET /projects/{project_id}/columns"],
			listForOrg: ["GET /orgs/{org}/projects"],
			listForRepo: ["GET /repos/{owner}/{repo}/projects"],
			listForUser: ["GET /users/{username}/projects"],
			moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
			moveColumn: ["POST /projects/columns/{column_id}/moves"],
			removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
			update: ["PATCH /projects/{project_id}"],
			updateCard: ["PATCH /projects/columns/cards/{card_id}"],
			updateColumn: ["PATCH /projects/columns/{column_id}"]
		},
		pulls: {
			checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			create: ["POST /repos/{owner}/{repo}/pulls"],
			createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
			createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
			get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
			getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			list: ["GET /repos/{owner}/{repo}/pulls"],
			listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
			listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
			listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
			listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
			listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
			update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
			updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
			updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
		},
		rateLimit: { get: ["GET /rate_limit"] },
		reactions: {
			createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
			deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
			deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
			deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
			deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
			listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
		},
		repos: {
			acceptInvitation: [
				"PATCH /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
			],
			acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
			addAppAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
			addStatusCheckContexts: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			addTeamAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			addUserAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			cancelPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"],
			checkAutomatedSecurityFixes: ["GET /repos/{owner}/{repo}/automated-security-fixes"],
			checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
			checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
			codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
			compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
			compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
			createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
			createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
			createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
			createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
			createDeploymentBranchPolicy: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			createDeploymentProtectionRule: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
			createForAuthenticatedUser: ["POST /user/repos"],
			createFork: ["POST /repos/{owner}/{repo}/forks"],
			createInOrg: ["POST /orgs/{org}/repos"],
			createOrUpdateCustomPropertiesValues: ["PATCH /repos/{owner}/{repo}/properties/values"],
			createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
			createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
			createOrgRuleset: ["POST /orgs/{org}/rulesets"],
			createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
			createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
			createRelease: ["POST /repos/{owner}/{repo}/releases"],
			createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
			createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
			createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
			createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
			declineInvitation: [
				"DELETE /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
			],
			declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
			delete: ["DELETE /repos/{owner}/{repo}"],
			deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
			deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
			deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
			deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
			deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
			deleteDeploymentBranchPolicy: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
			deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
			deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
			deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
			deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
			deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
			deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
			disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
			disableDeploymentProtectionRule: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			disablePrivateVulnerabilityReporting: ["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],
			disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
			downloadArchive: [
				"GET /repos/{owner}/{repo}/zipball/{ref}",
				{},
				{ renamed: ["repos", "downloadZipballArchive"] }
			],
			downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
			downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
			enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
			enablePrivateVulnerabilityReporting: ["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],
			enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
			generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
			get: ["GET /repos/{owner}/{repo}"],
			getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			getAllDeploymentProtectionRules: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
			getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
			getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
			getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
			getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
			getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
			getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
			getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
			getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
			getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
			getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
			getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
			getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
			getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
			getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
			getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
			getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
			getCustomDeploymentProtectionRule: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
			getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
			getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
			getDeploymentBranchPolicy: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
			getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
			getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
			getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
			getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
			getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
			getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
			getOrgRulesets: ["GET /orgs/{org}/rulesets"],
			getPages: ["GET /repos/{owner}/{repo}/pages"],
			getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
			getPagesDeployment: ["GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"],
			getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
			getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
			getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
			getReadme: ["GET /repos/{owner}/{repo}/readme"],
			getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
			getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
			getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
			getRepoRuleSuite: ["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],
			getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
			getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
			getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
			getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
			getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
			getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
			getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
			getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
			getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
			listActivities: ["GET /repos/{owner}/{repo}/activity"],
			listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
			listBranches: ["GET /repos/{owner}/{repo}/branches"],
			listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
			listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
			listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
			listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
			listCommits: ["GET /repos/{owner}/{repo}/commits"],
			listContributors: ["GET /repos/{owner}/{repo}/contributors"],
			listCustomDeploymentRuleIntegrations: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],
			listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
			listDeploymentBranchPolicies: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
			listForAuthenticatedUser: ["GET /user/repos"],
			listForOrg: ["GET /orgs/{org}/repos"],
			listForUser: ["GET /users/{username}/repos"],
			listForks: ["GET /repos/{owner}/{repo}/forks"],
			listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
			listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
			listLanguages: ["GET /repos/{owner}/{repo}/languages"],
			listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
			listPublic: ["GET /repositories"],
			listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
			listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
			listReleases: ["GET /repos/{owner}/{repo}/releases"],
			listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
			listTags: ["GET /repos/{owner}/{repo}/tags"],
			listTeams: ["GET /repos/{owner}/{repo}/teams"],
			listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
			merge: ["POST /repos/{owner}/{repo}/merges"],
			mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
			pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeAppAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
			removeStatusCheckContexts: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			removeTeamAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			removeUserAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
			replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
			requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
			setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			setAppAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			setStatusCheckContexts: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			setTeamAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			setUserAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
			transfer: ["POST /repos/{owner}/{repo}/transfer"],
			update: ["PATCH /repos/{owner}/{repo}"],
			updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
			updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
			updateDeploymentBranchPolicy: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
			updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
			updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
			updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
			updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			updateStatusCheckPotection: [
				"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
				{},
				{ renamed: ["repos", "updateStatusCheckProtection"] }
			],
			updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
			updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", { baseUrl: "https://uploads.github.com" }]
		},
		search: {
			code: ["GET /search/code"],
			commits: ["GET /search/commits"],
			issuesAndPullRequests: ["GET /search/issues"],
			labels: ["GET /search/labels"],
			repos: ["GET /search/repositories"],
			topics: ["GET /search/topics"],
			users: ["GET /search/users"]
		},
		secretScanning: {
			getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
			listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
		},
		securityAdvisories: {
			createFork: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"],
			createPrivateVulnerabilityReport: ["POST /repos/{owner}/{repo}/security-advisories/reports"],
			createRepositoryAdvisory: ["POST /repos/{owner}/{repo}/security-advisories"],
			createRepositoryAdvisoryCveRequest: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],
			getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
			getRepositoryAdvisory: ["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
			listGlobalAdvisories: ["GET /advisories"],
			listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
			listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
			updateRepositoryAdvisory: ["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"]
		},
		teams: {
			addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			create: ["POST /orgs/{org}/teams"],
			createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
			deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
			getByName: ["GET /orgs/{org}/teams/{team_slug}"],
			getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			list: ["GET /orgs/{org}/teams"],
			listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
			listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
			listForAuthenticatedUser: ["GET /user/teams"],
			listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
			listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
			listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
			listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
			removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
		},
		users: {
			addEmailForAuthenticated: [
				"POST /user/emails",
				{},
				{ renamed: ["users", "addEmailForAuthenticatedUser"] }
			],
			addEmailForAuthenticatedUser: ["POST /user/emails"],
			addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
			block: ["PUT /user/blocks/{username}"],
			checkBlocked: ["GET /user/blocks/{username}"],
			checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
			checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
			createGpgKeyForAuthenticated: [
				"POST /user/gpg_keys",
				{},
				{ renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
			],
			createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
			createPublicSshKeyForAuthenticated: [
				"POST /user/keys",
				{},
				{ renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
			],
			createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
			createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
			deleteEmailForAuthenticated: [
				"DELETE /user/emails",
				{},
				{ renamed: ["users", "deleteEmailForAuthenticatedUser"] }
			],
			deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
			deleteGpgKeyForAuthenticated: [
				"DELETE /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
			],
			deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
			deletePublicSshKeyForAuthenticated: [
				"DELETE /user/keys/{key_id}",
				{},
				{ renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
			],
			deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
			deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
			deleteSshSigningKeyForAuthenticatedUser: ["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],
			follow: ["PUT /user/following/{username}"],
			getAuthenticated: ["GET /user"],
			getByUsername: ["GET /users/{username}"],
			getContextForUser: ["GET /users/{username}/hovercard"],
			getGpgKeyForAuthenticated: [
				"GET /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
			],
			getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
			getPublicSshKeyForAuthenticated: [
				"GET /user/keys/{key_id}",
				{},
				{ renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
			],
			getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
			getSshSigningKeyForAuthenticatedUser: ["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],
			list: ["GET /users"],
			listBlockedByAuthenticated: [
				"GET /user/blocks",
				{},
				{ renamed: ["users", "listBlockedByAuthenticatedUser"] }
			],
			listBlockedByAuthenticatedUser: ["GET /user/blocks"],
			listEmailsForAuthenticated: [
				"GET /user/emails",
				{},
				{ renamed: ["users", "listEmailsForAuthenticatedUser"] }
			],
			listEmailsForAuthenticatedUser: ["GET /user/emails"],
			listFollowedByAuthenticated: [
				"GET /user/following",
				{},
				{ renamed: ["users", "listFollowedByAuthenticatedUser"] }
			],
			listFollowedByAuthenticatedUser: ["GET /user/following"],
			listFollowersForAuthenticatedUser: ["GET /user/followers"],
			listFollowersForUser: ["GET /users/{username}/followers"],
			listFollowingForUser: ["GET /users/{username}/following"],
			listGpgKeysForAuthenticated: [
				"GET /user/gpg_keys",
				{},
				{ renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
			],
			listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
			listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
			listPublicEmailsForAuthenticated: [
				"GET /user/public_emails",
				{},
				{ renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
			],
			listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
			listPublicKeysForUser: ["GET /users/{username}/keys"],
			listPublicSshKeysForAuthenticated: [
				"GET /user/keys",
				{},
				{ renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
			],
			listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
			listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
			listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
			listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
			listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
			setPrimaryEmailVisibilityForAuthenticated: [
				"PATCH /user/email/visibility",
				{},
				{ renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
			],
			setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
			unblock: ["DELETE /user/blocks/{username}"],
			unfollow: ["DELETE /user/following/{username}"],
			updateAuthenticated: ["PATCH /user"]
		}
	};
	var endpoints_default = Endpoints;
	var endpointMethodsMap = /* @__PURE__ */ new Map();
	for (const [scope, endpoints] of Object.entries(endpoints_default)) for (const [methodName, endpoint$1] of Object.entries(endpoints)) {
		const [route, defaults$1, decorations] = endpoint$1;
		const [method, url] = route.split(/ /);
		const endpointDefaults = Object.assign({
			method,
			url
		}, defaults$1);
		if (!endpointMethodsMap.has(scope)) endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
		endpointMethodsMap.get(scope).set(methodName, {
			scope,
			methodName,
			endpointDefaults,
			decorations
		});
	}
	var handler = {
		has({ scope }, methodName) {
			return endpointMethodsMap.get(scope).has(methodName);
		},
		getOwnPropertyDescriptor(target, methodName) {
			return {
				value: this.get(target, methodName),
				configurable: true,
				writable: true,
				enumerable: true
			};
		},
		defineProperty(target, methodName, descriptor) {
			Object.defineProperty(target.cache, methodName, descriptor);
			return true;
		},
		deleteProperty(target, methodName) {
			delete target.cache[methodName];
			return true;
		},
		ownKeys({ scope }) {
			return [...endpointMethodsMap.get(scope).keys()];
		},
		set(target, methodName, value) {
			return target.cache[methodName] = value;
		},
		get({ octokit, scope, cache }, methodName) {
			if (cache[methodName]) return cache[methodName];
			const method = endpointMethodsMap.get(scope).get(methodName);
			if (!method) return void 0;
			const { endpointDefaults, decorations } = method;
			if (decorations) cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
			else cache[methodName] = octokit.request.defaults(endpointDefaults);
			return cache[methodName];
		}
	};
	function endpointsToMethods(octokit) {
		const newMethods = {};
		for (const scope of endpointMethodsMap.keys()) newMethods[scope] = new Proxy({
			octokit,
			scope,
			cache: {}
		}, handler);
		return newMethods;
	}
	function decorate(octokit, scope, methodName, defaults$1, decorations) {
		const requestWithDefaults = octokit.request.defaults(defaults$1);
		function withDecorations(...args) {
			let options = requestWithDefaults.endpoint.merge(...args);
			if (decorations.mapToData) {
				options = Object.assign({}, options, {
					data: options[decorations.mapToData],
					[decorations.mapToData]: void 0
				});
				return requestWithDefaults(options);
			}
			if (decorations.renamed) {
				const [newScope, newMethodName] = decorations.renamed;
				octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
			}
			if (decorations.deprecated) octokit.log.warn(decorations.deprecated);
			if (decorations.renamedParameters) {
				const options2 = requestWithDefaults.endpoint.merge(...args);
				for (const [name, alias] of Object.entries(decorations.renamedParameters)) if (name in options2) {
					octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
					if (!(alias in options2)) options2[alias] = options2[name];
					delete options2[name];
				}
				return requestWithDefaults(options2);
			}
			return requestWithDefaults(...args);
		}
		return Object.assign(withDecorations, requestWithDefaults);
	}
	function restEndpointMethods(octokit) {
		const api$1 = endpointsToMethods(octokit);
		return { rest: api$1 };
	}
	restEndpointMethods.VERSION = VERSION$2;
	function legacyRestEndpointMethods(octokit) {
		const api$1 = endpointsToMethods(octokit);
		return {
			...api$1,
			rest: api$1
		};
	}
	legacyRestEndpointMethods.VERSION = VERSION$2;
} });

//#endregion
//#region node_modules/.pnpm/@octokit+plugin-paginate-rest@9.2.2_@octokit+core@5.2.0/node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node = __commonJS({ "node_modules/.pnpm/@octokit+plugin-paginate-rest@9.2.2_@octokit+core@5.2.0/node_modules/@octokit/plugin-paginate-rest/dist-node/index.js"(exports, module) {
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __export = (target, all) => {
		for (var name in all) __defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
	var dist_src_exports = {};
	__export(dist_src_exports, {
		composePaginateRest: () => composePaginateRest,
		isPaginatingEndpoint: () => isPaginatingEndpoint,
		paginateRest: () => paginateRest,
		paginatingEndpoints: () => paginatingEndpoints
	});
	module.exports = __toCommonJS(dist_src_exports);
	var VERSION$1 = "9.2.2";
	function normalizePaginatedListResponse(response) {
		if (!response.data) return {
			...response,
			data: []
		};
		const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
		if (!responseNeedsNormalization) return response;
		const incompleteResults = response.data.incomplete_results;
		const repositorySelection = response.data.repository_selection;
		const totalCount = response.data.total_count;
		delete response.data.incomplete_results;
		delete response.data.repository_selection;
		delete response.data.total_count;
		const namespaceKey = Object.keys(response.data)[0];
		const data = response.data[namespaceKey];
		response.data = data;
		if (typeof incompleteResults !== "undefined") response.data.incomplete_results = incompleteResults;
		if (typeof repositorySelection !== "undefined") response.data.repository_selection = repositorySelection;
		response.data.total_count = totalCount;
		return response;
	}
	function iterator(octokit, route, parameters) {
		const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
		const requestMethod = typeof route === "function" ? route : octokit.request;
		const method = options.method;
		const headers = options.headers;
		let url = options.url;
		return { [Symbol.asyncIterator]: () => ({ async next() {
			if (!url) return { done: true };
			try {
				const response = await requestMethod({
					method,
					url,
					headers
				});
				const normalizedResponse = normalizePaginatedListResponse(response);
				url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
				return { value: normalizedResponse };
			} catch (error$1) {
				if (error$1.status !== 409) throw error$1;
				url = "";
				return { value: {
					status: 200,
					headers: {},
					data: []
				} };
			}
		} }) };
	}
	function paginate(octokit, route, parameters, mapFn) {
		if (typeof parameters === "function") {
			mapFn = parameters;
			parameters = void 0;
		}
		return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
	}
	function gather(octokit, results, iterator2, mapFn) {
		return iterator2.next().then((result) => {
			if (result.done) return results;
			let earlyExit = false;
			function done() {
				earlyExit = true;
			}
			results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
			if (earlyExit) return results;
			return gather(octokit, results, iterator2, mapFn);
		});
	}
	var composePaginateRest = Object.assign(paginate, { iterator });
	var paginatingEndpoints = [
		"GET /advisories",
		"GET /app/hook/deliveries",
		"GET /app/installation-requests",
		"GET /app/installations",
		"GET /assignments/{assignment_id}/accepted_assignments",
		"GET /classrooms",
		"GET /classrooms/{classroom_id}/assignments",
		"GET /enterprises/{enterprise}/dependabot/alerts",
		"GET /enterprises/{enterprise}/secret-scanning/alerts",
		"GET /events",
		"GET /gists",
		"GET /gists/public",
		"GET /gists/starred",
		"GET /gists/{gist_id}/comments",
		"GET /gists/{gist_id}/commits",
		"GET /gists/{gist_id}/forks",
		"GET /installation/repositories",
		"GET /issues",
		"GET /licenses",
		"GET /marketplace_listing/plans",
		"GET /marketplace_listing/plans/{plan_id}/accounts",
		"GET /marketplace_listing/stubbed/plans",
		"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
		"GET /networks/{owner}/{repo}/events",
		"GET /notifications",
		"GET /organizations",
		"GET /orgs/{org}/actions/cache/usage-by-repository",
		"GET /orgs/{org}/actions/permissions/repositories",
		"GET /orgs/{org}/actions/runners",
		"GET /orgs/{org}/actions/secrets",
		"GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/actions/variables",
		"GET /orgs/{org}/actions/variables/{name}/repositories",
		"GET /orgs/{org}/blocks",
		"GET /orgs/{org}/code-scanning/alerts",
		"GET /orgs/{org}/codespaces",
		"GET /orgs/{org}/codespaces/secrets",
		"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/copilot/billing/seats",
		"GET /orgs/{org}/dependabot/alerts",
		"GET /orgs/{org}/dependabot/secrets",
		"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/events",
		"GET /orgs/{org}/failed_invitations",
		"GET /orgs/{org}/hooks",
		"GET /orgs/{org}/hooks/{hook_id}/deliveries",
		"GET /orgs/{org}/installations",
		"GET /orgs/{org}/invitations",
		"GET /orgs/{org}/invitations/{invitation_id}/teams",
		"GET /orgs/{org}/issues",
		"GET /orgs/{org}/members",
		"GET /orgs/{org}/members/{username}/codespaces",
		"GET /orgs/{org}/migrations",
		"GET /orgs/{org}/migrations/{migration_id}/repositories",
		"GET /orgs/{org}/organization-roles/{role_id}/teams",
		"GET /orgs/{org}/organization-roles/{role_id}/users",
		"GET /orgs/{org}/outside_collaborators",
		"GET /orgs/{org}/packages",
		"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
		"GET /orgs/{org}/personal-access-token-requests",
		"GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
		"GET /orgs/{org}/personal-access-tokens",
		"GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
		"GET /orgs/{org}/projects",
		"GET /orgs/{org}/properties/values",
		"GET /orgs/{org}/public_members",
		"GET /orgs/{org}/repos",
		"GET /orgs/{org}/rulesets",
		"GET /orgs/{org}/rulesets/rule-suites",
		"GET /orgs/{org}/secret-scanning/alerts",
		"GET /orgs/{org}/security-advisories",
		"GET /orgs/{org}/teams",
		"GET /orgs/{org}/teams/{team_slug}/discussions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/invitations",
		"GET /orgs/{org}/teams/{team_slug}/members",
		"GET /orgs/{org}/teams/{team_slug}/projects",
		"GET /orgs/{org}/teams/{team_slug}/repos",
		"GET /orgs/{org}/teams/{team_slug}/teams",
		"GET /projects/columns/{column_id}/cards",
		"GET /projects/{project_id}/collaborators",
		"GET /projects/{project_id}/columns",
		"GET /repos/{owner}/{repo}/actions/artifacts",
		"GET /repos/{owner}/{repo}/actions/caches",
		"GET /repos/{owner}/{repo}/actions/organization-secrets",
		"GET /repos/{owner}/{repo}/actions/organization-variables",
		"GET /repos/{owner}/{repo}/actions/runners",
		"GET /repos/{owner}/{repo}/actions/runs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
		"GET /repos/{owner}/{repo}/actions/secrets",
		"GET /repos/{owner}/{repo}/actions/variables",
		"GET /repos/{owner}/{repo}/actions/workflows",
		"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
		"GET /repos/{owner}/{repo}/activity",
		"GET /repos/{owner}/{repo}/assignees",
		"GET /repos/{owner}/{repo}/branches",
		"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
		"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
		"GET /repos/{owner}/{repo}/code-scanning/alerts",
		"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
		"GET /repos/{owner}/{repo}/code-scanning/analyses",
		"GET /repos/{owner}/{repo}/codespaces",
		"GET /repos/{owner}/{repo}/codespaces/devcontainers",
		"GET /repos/{owner}/{repo}/codespaces/secrets",
		"GET /repos/{owner}/{repo}/collaborators",
		"GET /repos/{owner}/{repo}/comments",
		"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/commits",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
		"GET /repos/{owner}/{repo}/commits/{ref}/status",
		"GET /repos/{owner}/{repo}/commits/{ref}/statuses",
		"GET /repos/{owner}/{repo}/contributors",
		"GET /repos/{owner}/{repo}/dependabot/alerts",
		"GET /repos/{owner}/{repo}/dependabot/secrets",
		"GET /repos/{owner}/{repo}/deployments",
		"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
		"GET /repos/{owner}/{repo}/environments",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
		"GET /repos/{owner}/{repo}/events",
		"GET /repos/{owner}/{repo}/forks",
		"GET /repos/{owner}/{repo}/hooks",
		"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
		"GET /repos/{owner}/{repo}/invitations",
		"GET /repos/{owner}/{repo}/issues",
		"GET /repos/{owner}/{repo}/issues/comments",
		"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/issues/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
		"GET /repos/{owner}/{repo}/keys",
		"GET /repos/{owner}/{repo}/labels",
		"GET /repos/{owner}/{repo}/milestones",
		"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
		"GET /repos/{owner}/{repo}/notifications",
		"GET /repos/{owner}/{repo}/pages/builds",
		"GET /repos/{owner}/{repo}/projects",
		"GET /repos/{owner}/{repo}/pulls",
		"GET /repos/{owner}/{repo}/pulls/comments",
		"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
		"GET /repos/{owner}/{repo}/releases",
		"GET /repos/{owner}/{repo}/releases/{release_id}/assets",
		"GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
		"GET /repos/{owner}/{repo}/rules/branches/{branch}",
		"GET /repos/{owner}/{repo}/rulesets",
		"GET /repos/{owner}/{repo}/rulesets/rule-suites",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
		"GET /repos/{owner}/{repo}/security-advisories",
		"GET /repos/{owner}/{repo}/stargazers",
		"GET /repos/{owner}/{repo}/subscribers",
		"GET /repos/{owner}/{repo}/tags",
		"GET /repos/{owner}/{repo}/teams",
		"GET /repos/{owner}/{repo}/topics",
		"GET /repositories",
		"GET /repositories/{repository_id}/environments/{environment_name}/secrets",
		"GET /repositories/{repository_id}/environments/{environment_name}/variables",
		"GET /search/code",
		"GET /search/commits",
		"GET /search/issues",
		"GET /search/labels",
		"GET /search/repositories",
		"GET /search/topics",
		"GET /search/users",
		"GET /teams/{team_id}/discussions",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /teams/{team_id}/discussions/{discussion_number}/reactions",
		"GET /teams/{team_id}/invitations",
		"GET /teams/{team_id}/members",
		"GET /teams/{team_id}/projects",
		"GET /teams/{team_id}/repos",
		"GET /teams/{team_id}/teams",
		"GET /user/blocks",
		"GET /user/codespaces",
		"GET /user/codespaces/secrets",
		"GET /user/emails",
		"GET /user/followers",
		"GET /user/following",
		"GET /user/gpg_keys",
		"GET /user/installations",
		"GET /user/installations/{installation_id}/repositories",
		"GET /user/issues",
		"GET /user/keys",
		"GET /user/marketplace_purchases",
		"GET /user/marketplace_purchases/stubbed",
		"GET /user/memberships/orgs",
		"GET /user/migrations",
		"GET /user/migrations/{migration_id}/repositories",
		"GET /user/orgs",
		"GET /user/packages",
		"GET /user/packages/{package_type}/{package_name}/versions",
		"GET /user/public_emails",
		"GET /user/repos",
		"GET /user/repository_invitations",
		"GET /user/social_accounts",
		"GET /user/ssh_signing_keys",
		"GET /user/starred",
		"GET /user/subscriptions",
		"GET /user/teams",
		"GET /users",
		"GET /users/{username}/events",
		"GET /users/{username}/events/orgs/{org}",
		"GET /users/{username}/events/public",
		"GET /users/{username}/followers",
		"GET /users/{username}/following",
		"GET /users/{username}/gists",
		"GET /users/{username}/gpg_keys",
		"GET /users/{username}/keys",
		"GET /users/{username}/orgs",
		"GET /users/{username}/packages",
		"GET /users/{username}/projects",
		"GET /users/{username}/received_events",
		"GET /users/{username}/received_events/public",
		"GET /users/{username}/repos",
		"GET /users/{username}/social_accounts",
		"GET /users/{username}/ssh_signing_keys",
		"GET /users/{username}/starred",
		"GET /users/{username}/subscriptions"
	];
	function isPaginatingEndpoint(arg) {
		if (typeof arg === "string") return paginatingEndpoints.includes(arg);
		else return false;
	}
	function paginateRest(octokit) {
		return { paginate: Object.assign(paginate.bind(null, octokit), { iterator: iterator.bind(null, octokit) }) };
	}
	paginateRest.VERSION = VERSION$1;
} });

//#endregion
//#region node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/utils.js
var require_utils$1 = __commonJS({ "node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/utils.js"(exports) {
	var __createBinding$1 = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault$1 = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$1 = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
		}
		__setModuleDefault$1(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
	const Context$1 = __importStar$1(require_context());
	const Utils = __importStar$1(require_utils$2());
	const core_1 = require_dist_node$2();
	const plugin_rest_endpoint_methods_1 = require_dist_node$1();
	const plugin_paginate_rest_1 = require_dist_node();
	exports.context = new Context$1.Context();
	const baseUrl = Utils.getApiBaseUrl();
	exports.defaults = {
		baseUrl,
		request: {
			agent: Utils.getProxyAgent(baseUrl),
			fetch: Utils.getProxyFetch(baseUrl)
		}
	};
	exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
	/**
	* Convience function to correctly format Octokit Options to pass into the constructor.
	*
	* @param     token    the repo PAT or GITHUB_TOKEN
	* @param     options  other options to set
	*/
	function getOctokitOptions(token, options) {
		const opts = Object.assign({}, options || {});
		const auth$1 = Utils.getAuthString(token, opts);
		if (auth$1) opts.auth = auth$1;
		return opts;
	}
	exports.getOctokitOptions = getOctokitOptions;
} });

//#endregion
//#region node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/github.js
var require_github = __commonJS({ "node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/github.js"(exports) {
	var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	} : function(o$1, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$1[k];
	});
	var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	} : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokit = exports.context = void 0;
	const Context = __importStar(require_context());
	const utils_1 = require_utils$1();
	exports.context = new Context.Context();
	/**
	* Returns a hydrated octokit ready to use for GitHub Actions
	*
	* @param     token    the repo PAT or GITHUB_TOKEN
	* @param     options  other options to set
	*/
	function getOctokit$1(token, options, ...additionalPlugins) {
		const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
		return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
	}
	exports.getOctokit = getOctokit$1;
} });

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/internal/qs/formats.mjs
const default_format = "RFC3986";
const formatters = {
	RFC1738: (v) => String(v).replace(/%20/g, "+"),
	RFC3986: (v) => String(v)
};
const RFC1738 = "RFC1738";

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/internal/qs/utils.mjs
const is_array$1 = Array.isArray;
const hex_table = (() => {
	const array = [];
	for (let i$1 = 0; i$1 < 256; ++i$1) array.push("%" + ((i$1 < 16 ? "0" : "") + i$1.toString(16)).toUpperCase());
	return array;
})();
const limit = 1024;
const encode = (str$1, _defaultEncoder, charset, _kind, format$1) => {
	if (str$1.length === 0) return str$1;
	let string = str$1;
	if (typeof str$1 === "symbol") string = Symbol.prototype.toString.call(str$1);
	else if (typeof str$1 !== "string") string = String(str$1);
	if (charset === "iso-8859-1") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
		return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
	});
	let out = "";
	for (let j = 0; j < string.length; j += limit) {
		const segment = string.length >= limit ? string.slice(j, j + limit) : string;
		const arr = [];
		for (let i$1 = 0; i$1 < segment.length; ++i$1) {
			let c$1 = segment.charCodeAt(i$1);
			if (c$1 === 45 || c$1 === 46 || c$1 === 95 || c$1 === 126 || c$1 >= 48 && c$1 <= 57 || c$1 >= 65 && c$1 <= 90 || c$1 >= 97 && c$1 <= 122 || format$1 === RFC1738 && (c$1 === 40 || c$1 === 41)) {
				arr[arr.length] = segment.charAt(i$1);
				continue;
			}
			if (c$1 < 128) {
				arr[arr.length] = hex_table[c$1];
				continue;
			}
			if (c$1 < 2048) {
				arr[arr.length] = hex_table[192 | c$1 >> 6] + hex_table[128 | c$1 & 63];
				continue;
			}
			if (c$1 < 55296 || c$1 >= 57344) {
				arr[arr.length] = hex_table[224 | c$1 >> 12] + hex_table[128 | c$1 >> 6 & 63] + hex_table[128 | c$1 & 63];
				continue;
			}
			i$1 += 1;
			c$1 = 65536 + ((c$1 & 1023) << 10 | segment.charCodeAt(i$1) & 1023);
			arr[arr.length] = hex_table[240 | c$1 >> 18] + hex_table[128 | c$1 >> 12 & 63] + hex_table[128 | c$1 >> 6 & 63] + hex_table[128 | c$1 & 63];
		}
		out += arr.join("");
	}
	return out;
};
function is_buffer(obj) {
	if (!obj || typeof obj !== "object") return false;
	return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
	if (is_array$1(val)) {
		const mapped = [];
		for (let i$1 = 0; i$1 < val.length; i$1 += 1) mapped.push(fn(val[i$1]));
		return mapped;
	}
	return fn(val);
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/internal/qs/stringify.mjs
const has = Object.prototype.hasOwnProperty;
const array_prefix_generators = {
	brackets(prefix) {
		return String(prefix) + "[]";
	},
	comma: "comma",
	indices(prefix, key) {
		return String(prefix) + "[" + key + "]";
	},
	repeat(prefix) {
		return String(prefix);
	}
};
const is_array = Array.isArray;
const push = Array.prototype.push;
const push_to_array = function(arr, value_or_array) {
	push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);
};
const to_ISO = Date.prototype.toISOString;
const defaults = {
	addQueryPrefix: false,
	allowDots: false,
	allowEmptyArrays: false,
	arrayFormat: "indices",
	charset: "utf-8",
	charsetSentinel: false,
	delimiter: "&",
	encode: true,
	encodeDotInKeys: false,
	encoder: encode,
	encodeValuesOnly: false,
	format: default_format,
	formatter: formatters[default_format],
	indices: false,
	serializeDate(date) {
		return to_ISO.call(date);
	},
	skipNulls: false,
	strictNullHandling: false
};
function is_non_nullish_primitive(v) {
	return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
const sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder$2, filter, sort, allowDots, serializeDate, format$1, formatter, encodeValuesOnly, charset, sideChannel) {
	let obj = object;
	let tmp_sc = sideChannel;
	let step = 0;
	let find_flag = false;
	while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
		const pos = tmp_sc.get(object);
		step += 1;
		if (typeof pos !== "undefined") if (pos === step) throw new RangeError("Cyclic object value");
		else find_flag = true;
		if (typeof tmp_sc.get(sentinel) === "undefined") step = 0;
	}
	if (typeof filter === "function") obj = filter(prefix, obj);
	else if (obj instanceof Date) obj = serializeDate?.(obj);
	else if (generateArrayPrefix === "comma" && is_array(obj)) obj = maybe_map(obj, function(value) {
		if (value instanceof Date) return serializeDate?.(value);
		return value;
	});
	if (obj === null) {
		if (strictNullHandling) return encoder$2 && !encodeValuesOnly ? encoder$2(prefix, defaults.encoder, charset, "key", format$1) : prefix;
		obj = "";
	}
	if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
		if (encoder$2) {
			const key_value = encodeValuesOnly ? prefix : encoder$2(prefix, defaults.encoder, charset, "key", format$1);
			return [formatter?.(key_value) + "=" + formatter?.(encoder$2(obj, defaults.encoder, charset, "value", format$1))];
		}
		return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
	}
	const values = [];
	if (typeof obj === "undefined") return values;
	let obj_keys;
	if (generateArrayPrefix === "comma" && is_array(obj)) {
		if (encodeValuesOnly && encoder$2) obj = maybe_map(obj, encoder$2);
		obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
	} else if (is_array(filter)) obj_keys = filter;
	else {
		const keys = Object.keys(obj);
		obj_keys = sort ? keys.sort(sort) : keys;
	}
	const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
	const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
	if (allowEmptyArrays && is_array(obj) && obj.length === 0) return adjusted_prefix + "[]";
	for (let j = 0; j < obj_keys.length; ++j) {
		const key = obj_keys[j];
		const value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
		if (skipNulls && value === null) continue;
		const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
		const key_prefix = is_array(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
		sideChannel.set(object, step);
		const valueSideChannel = /* @__PURE__ */ new WeakMap();
		valueSideChannel.set(sentinel, sideChannel);
		push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && is_array(obj) ? null : encoder$2, filter, sort, allowDots, serializeDate, format$1, formatter, encodeValuesOnly, charset, valueSideChannel));
	}
	return values;
}
function normalize_stringify_options(opts = defaults) {
	if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
	if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
	if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
	const charset = opts.charset || defaults.charset;
	if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
	let format$1 = default_format;
	if (typeof opts.format !== "undefined") {
		if (!has.call(formatters, opts.format)) throw new TypeError("Unknown format option provided.");
		format$1 = opts.format;
	}
	const formatter = formatters[format$1];
	let filter = defaults.filter;
	if (typeof opts.filter === "function" || is_array(opts.filter)) filter = opts.filter;
	let arrayFormat;
	if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) arrayFormat = opts.arrayFormat;
	else if ("indices" in opts) arrayFormat = opts.indices ? "indices" : "repeat";
	else arrayFormat = defaults.arrayFormat;
	if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
	const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
	return {
		addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
		allowDots,
		allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
		arrayFormat,
		charset,
		charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
		commaRoundTrip: !!opts.commaRoundTrip,
		delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
		encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
		encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
		encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
		encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
		filter,
		format: format$1,
		formatter,
		serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
		skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
		sort: typeof opts.sort === "function" ? opts.sort : null,
		strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
	};
}
function stringify(object, opts = {}) {
	let obj = object;
	const options = normalize_stringify_options(opts);
	let obj_keys;
	let filter;
	if (typeof options.filter === "function") {
		filter = options.filter;
		obj = filter("", obj);
	} else if (is_array(options.filter)) {
		filter = options.filter;
		obj_keys = filter;
	}
	const keys = [];
	if (typeof obj !== "object" || obj === null) return "";
	const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
	const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
	if (!obj_keys) obj_keys = Object.keys(obj);
	if (options.sort) obj_keys.sort(options.sort);
	const sideChannel = /* @__PURE__ */ new WeakMap();
	for (let i$1 = 0; i$1 < obj_keys.length; ++i$1) {
		const key = obj_keys[i$1];
		if (options.skipNulls && obj[key] === null) continue;
		push_to_array(keys, inner_stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
	}
	const joined = keys.join(options.delimiter);
	let prefix = options.addQueryPrefix === true ? "?" : "";
	if (options.charsetSentinel) if (options.charset === "iso-8859-1") prefix += "utf8=%26%2310003%3B&";
	else prefix += "utf8=%E2%9C%93&";
	return joined.length > 0 ? prefix + joined : "";
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/version.mjs
const VERSION = "4.93.0";

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/_shims/registry.mjs
let auto = false;
let kind = void 0;
let fetch = void 0;
let Request$1 = void 0;
let Response$1 = void 0;
let Headers$1 = void 0;
let FormData = void 0;
let Blob$3 = void 0;
let File$1 = void 0;
let ReadableStream$1 = void 0;
let getMultipartRequestOptions = void 0;
let getDefaultAgent = void 0;
let fileFromPath = void 0;
let isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
	if (auto) throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
	if (kind) throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
	auto = options.auto;
	kind = shims.kind;
	fetch = shims.fetch;
	Request$1 = shims.Request;
	Response$1 = shims.Response;
	Headers$1 = shims.Headers;
	FormData = shims.FormData;
	Blob$3 = shims.Blob;
	File$1 = shims.File;
	ReadableStream$1 = shims.ReadableStream;
	getMultipartRequestOptions = shims.getMultipartRequestOptions;
	getDefaultAgent = shims.getDefaultAgent;
	fileFromPath = shims.fileFromPath;
	isFsReadStream = shims.isFsReadStream;
}

//#endregion
//#region node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js
var require_lib$1 = __commonJS({ "node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js"(exports, module) {
	var conversions$1 = {};
	module.exports = conversions$1;
	function sign(x) {
		return x < 0 ? -1 : 1;
	}
	function evenRound(x) {
		if (x % 1 === .5 && (x & 1) === 0) return Math.floor(x);
		else return Math.round(x);
	}
	function createNumberConversion(bitLength, typeOpts) {
		if (!typeOpts.unsigned) --bitLength;
		const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
		const upperBound = Math.pow(2, bitLength) - 1;
		const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
		const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
		return function(V, opts) {
			if (!opts) opts = {};
			let x = +V;
			if (opts.enforceRange) {
				if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
				x = sign(x) * Math.floor(Math.abs(x));
				if (x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
				return x;
			}
			if (!isNaN(x) && opts.clamp) {
				x = evenRound(x);
				if (x < lowerBound) x = lowerBound;
				if (x > upperBound) x = upperBound;
				return x;
			}
			if (!Number.isFinite(x) || x === 0) return 0;
			x = sign(x) * Math.floor(Math.abs(x));
			x = x % moduloVal;
			if (!typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
			else if (typeOpts.unsigned) {
				if (x < 0) x += moduloVal;
				else if (x === -0) return 0;
			}
			return x;
		};
	}
	conversions$1["void"] = function() {
		return void 0;
	};
	conversions$1["boolean"] = function(val) {
		return !!val;
	};
	conversions$1["byte"] = createNumberConversion(8, { unsigned: false });
	conversions$1["octet"] = createNumberConversion(8, { unsigned: true });
	conversions$1["short"] = createNumberConversion(16, { unsigned: false });
	conversions$1["unsigned short"] = createNumberConversion(16, { unsigned: true });
	conversions$1["long"] = createNumberConversion(32, { unsigned: false });
	conversions$1["unsigned long"] = createNumberConversion(32, { unsigned: true });
	conversions$1["long long"] = createNumberConversion(32, {
		unsigned: false,
		moduloBitLength: 64
	});
	conversions$1["unsigned long long"] = createNumberConversion(32, {
		unsigned: true,
		moduloBitLength: 64
	});
	conversions$1["double"] = function(V) {
		const x = +V;
		if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
		return x;
	};
	conversions$1["unrestricted double"] = function(V) {
		const x = +V;
		if (isNaN(x)) throw new TypeError("Argument is NaN");
		return x;
	};
	conversions$1["float"] = conversions$1["double"];
	conversions$1["unrestricted float"] = conversions$1["unrestricted double"];
	conversions$1["DOMString"] = function(V, opts) {
		if (!opts) opts = {};
		if (opts.treatNullAsEmptyString && V === null) return "";
		return String(V);
	};
	conversions$1["ByteString"] = function(V, opts) {
		const x = String(V);
		let c$1 = void 0;
		for (let i$1 = 0; (c$1 = x.codePointAt(i$1)) !== void 0; ++i$1) if (c$1 > 255) throw new TypeError("Argument is not a valid bytestring");
		return x;
	};
	conversions$1["USVString"] = function(V) {
		const S = String(V);
		const n$1 = S.length;
		const U = [];
		for (let i$1 = 0; i$1 < n$1; ++i$1) {
			const c$1 = S.charCodeAt(i$1);
			if (c$1 < 55296 || c$1 > 57343) U.push(String.fromCodePoint(c$1));
			else if (56320 <= c$1 && c$1 <= 57343) U.push(String.fromCodePoint(65533));
			else if (i$1 === n$1 - 1) U.push(String.fromCodePoint(65533));
			else {
				const d$1 = S.charCodeAt(i$1 + 1);
				if (56320 <= d$1 && d$1 <= 57343) {
					const a$1 = c$1 & 1023;
					const b = d$1 & 1023;
					U.push(String.fromCodePoint(65536 + 1024 * a$1 + b));
					++i$1;
				} else U.push(String.fromCodePoint(65533));
			}
		}
		return U.join("");
	};
	conversions$1["Date"] = function(V, opts) {
		if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
		if (isNaN(V)) return void 0;
		return V;
	};
	conversions$1["RegExp"] = function(V, opts) {
		if (!(V instanceof RegExp)) V = new RegExp(V);
		return V;
	};
} });

//#endregion
//#region node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({ "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js"(exports, module) {
	module.exports.mixin = function mixin(target, source) {
		const keys = Object.getOwnPropertyNames(source);
		for (let i$1 = 0; i$1 < keys.length; ++i$1) Object.defineProperty(target, keys[i$1], Object.getOwnPropertyDescriptor(source, keys[i$1]));
	};
	module.exports.wrapperSymbol = Symbol("wrapper");
	module.exports.implSymbol = Symbol("impl");
	module.exports.wrapperForImpl = function(impl$1) {
		return impl$1[module.exports.wrapperSymbol];
	};
	module.exports.implForWrapper = function(wrapper) {
		return wrapper[module.exports.implSymbol];
	};
} });

//#endregion
//#region node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({ "node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json"(exports, module) {
	module.exports = [
		[[0, 44], "disallowed_STD3_valid"],
		[[45, 46], "valid"],
		[[47, 47], "disallowed_STD3_valid"],
		[[48, 57], "valid"],
		[[58, 64], "disallowed_STD3_valid"],
		[
			[65, 65],
			"mapped",
			[97]
		],
		[
			[66, 66],
			"mapped",
			[98]
		],
		[
			[67, 67],
			"mapped",
			[99]
		],
		[
			[68, 68],
			"mapped",
			[100]
		],
		[
			[69, 69],
			"mapped",
			[101]
		],
		[
			[70, 70],
			"mapped",
			[102]
		],
		[
			[71, 71],
			"mapped",
			[103]
		],
		[
			[72, 72],
			"mapped",
			[104]
		],
		[
			[73, 73],
			"mapped",
			[105]
		],
		[
			[74, 74],
			"mapped",
			[106]
		],
		[
			[75, 75],
			"mapped",
			[107]
		],
		[
			[76, 76],
			"mapped",
			[108]
		],
		[
			[77, 77],
			"mapped",
			[109]
		],
		[
			[78, 78],
			"mapped",
			[110]
		],
		[
			[79, 79],
			"mapped",
			[111]
		],
		[
			[80, 80],
			"mapped",
			[112]
		],
		[
			[81, 81],
			"mapped",
			[113]
		],
		[
			[82, 82],
			"mapped",
			[114]
		],
		[
			[83, 83],
			"mapped",
			[115]
		],
		[
			[84, 84],
			"mapped",
			[116]
		],
		[
			[85, 85],
			"mapped",
			[117]
		],
		[
			[86, 86],
			"mapped",
			[118]
		],
		[
			[87, 87],
			"mapped",
			[119]
		],
		[
			[88, 88],
			"mapped",
			[120]
		],
		[
			[89, 89],
			"mapped",
			[121]
		],
		[
			[90, 90],
			"mapped",
			[122]
		],
		[[91, 96], "disallowed_STD3_valid"],
		[[97, 122], "valid"],
		[[123, 127], "disallowed_STD3_valid"],
		[[128, 159], "disallowed"],
		[
			[160, 160],
			"disallowed_STD3_mapped",
			[32]
		],
		[
			[161, 167],
			"valid",
			[],
			"NV8"
		],
		[
			[168, 168],
			"disallowed_STD3_mapped",
			[32, 776]
		],
		[
			[169, 169],
			"valid",
			[],
			"NV8"
		],
		[
			[170, 170],
			"mapped",
			[97]
		],
		[
			[171, 172],
			"valid",
			[],
			"NV8"
		],
		[[173, 173], "ignored"],
		[
			[174, 174],
			"valid",
			[],
			"NV8"
		],
		[
			[175, 175],
			"disallowed_STD3_mapped",
			[32, 772]
		],
		[
			[176, 177],
			"valid",
			[],
			"NV8"
		],
		[
			[178, 178],
			"mapped",
			[50]
		],
		[
			[179, 179],
			"mapped",
			[51]
		],
		[
			[180, 180],
			"disallowed_STD3_mapped",
			[32, 769]
		],
		[
			[181, 181],
			"mapped",
			[956]
		],
		[
			[182, 182],
			"valid",
			[],
			"NV8"
		],
		[[183, 183], "valid"],
		[
			[184, 184],
			"disallowed_STD3_mapped",
			[32, 807]
		],
		[
			[185, 185],
			"mapped",
			[49]
		],
		[
			[186, 186],
			"mapped",
			[111]
		],
		[
			[187, 187],
			"valid",
			[],
			"NV8"
		],
		[
			[188, 188],
			"mapped",
			[
				49,
				8260,
				52
			]
		],
		[
			[189, 189],
			"mapped",
			[
				49,
				8260,
				50
			]
		],
		[
			[190, 190],
			"mapped",
			[
				51,
				8260,
				52
			]
		],
		[
			[191, 191],
			"valid",
			[],
			"NV8"
		],
		[
			[192, 192],
			"mapped",
			[224]
		],
		[
			[193, 193],
			"mapped",
			[225]
		],
		[
			[194, 194],
			"mapped",
			[226]
		],
		[
			[195, 195],
			"mapped",
			[227]
		],
		[
			[196, 196],
			"mapped",
			[228]
		],
		[
			[197, 197],
			"mapped",
			[229]
		],
		[
			[198, 198],
			"mapped",
			[230]
		],
		[
			[199, 199],
			"mapped",
			[231]
		],
		[
			[200, 200],
			"mapped",
			[232]
		],
		[
			[201, 201],
			"mapped",
			[233]
		],
		[
			[202, 202],
			"mapped",
			[234]
		],
		[
			[203, 203],
			"mapped",
			[235]
		],
		[
			[204, 204],
			"mapped",
			[236]
		],
		[
			[205, 205],
			"mapped",
			[237]
		],
		[
			[206, 206],
			"mapped",
			[238]
		],
		[
			[207, 207],
			"mapped",
			[239]
		],
		[
			[208, 208],
			"mapped",
			[240]
		],
		[
			[209, 209],
			"mapped",
			[241]
		],
		[
			[210, 210],
			"mapped",
			[242]
		],
		[
			[211, 211],
			"mapped",
			[243]
		],
		[
			[212, 212],
			"mapped",
			[244]
		],
		[
			[213, 213],
			"mapped",
			[245]
		],
		[
			[214, 214],
			"mapped",
			[246]
		],
		[
			[215, 215],
			"valid",
			[],
			"NV8"
		],
		[
			[216, 216],
			"mapped",
			[248]
		],
		[
			[217, 217],
			"mapped",
			[249]
		],
		[
			[218, 218],
			"mapped",
			[250]
		],
		[
			[219, 219],
			"mapped",
			[251]
		],
		[
			[220, 220],
			"mapped",
			[252]
		],
		[
			[221, 221],
			"mapped",
			[253]
		],
		[
			[222, 222],
			"mapped",
			[254]
		],
		[
			[223, 223],
			"deviation",
			[115, 115]
		],
		[[224, 246], "valid"],
		[
			[247, 247],
			"valid",
			[],
			"NV8"
		],
		[[248, 255], "valid"],
		[
			[256, 256],
			"mapped",
			[257]
		],
		[[257, 257], "valid"],
		[
			[258, 258],
			"mapped",
			[259]
		],
		[[259, 259], "valid"],
		[
			[260, 260],
			"mapped",
			[261]
		],
		[[261, 261], "valid"],
		[
			[262, 262],
			"mapped",
			[263]
		],
		[[263, 263], "valid"],
		[
			[264, 264],
			"mapped",
			[265]
		],
		[[265, 265], "valid"],
		[
			[266, 266],
			"mapped",
			[267]
		],
		[[267, 267], "valid"],
		[
			[268, 268],
			"mapped",
			[269]
		],
		[[269, 269], "valid"],
		[
			[270, 270],
			"mapped",
			[271]
		],
		[[271, 271], "valid"],
		[
			[272, 272],
			"mapped",
			[273]
		],
		[[273, 273], "valid"],
		[
			[274, 274],
			"mapped",
			[275]
		],
		[[275, 275], "valid"],
		[
			[276, 276],
			"mapped",
			[277]
		],
		[[277, 277], "valid"],
		[
			[278, 278],
			"mapped",
			[279]
		],
		[[279, 279], "valid"],
		[
			[280, 280],
			"mapped",
			[281]
		],
		[[281, 281], "valid"],
		[
			[282, 282],
			"mapped",
			[283]
		],
		[[283, 283], "valid"],
		[
			[284, 284],
			"mapped",
			[285]
		],
		[[285, 285], "valid"],
		[
			[286, 286],
			"mapped",
			[287]
		],
		[[287, 287], "valid"],
		[
			[288, 288],
			"mapped",
			[289]
		],
		[[289, 289], "valid"],
		[
			[290, 290],
			"mapped",
			[291]
		],
		[[291, 291], "valid"],
		[
			[292, 292],
			"mapped",
			[293]
		],
		[[293, 293], "valid"],
		[
			[294, 294],
			"mapped",
			[295]
		],
		[[295, 295], "valid"],
		[
			[296, 296],
			"mapped",
			[297]
		],
		[[297, 297], "valid"],
		[
			[298, 298],
			"mapped",
			[299]
		],
		[[299, 299], "valid"],
		[
			[300, 300],
			"mapped",
			[301]
		],
		[[301, 301], "valid"],
		[
			[302, 302],
			"mapped",
			[303]
		],
		[[303, 303], "valid"],
		[
			[304, 304],
			"mapped",
			[105, 775]
		],
		[[305, 305], "valid"],
		[
			[306, 307],
			"mapped",
			[105, 106]
		],
		[
			[308, 308],
			"mapped",
			[309]
		],
		[[309, 309], "valid"],
		[
			[310, 310],
			"mapped",
			[311]
		],
		[[311, 312], "valid"],
		[
			[313, 313],
			"mapped",
			[314]
		],
		[[314, 314], "valid"],
		[
			[315, 315],
			"mapped",
			[316]
		],
		[[316, 316], "valid"],
		[
			[317, 317],
			"mapped",
			[318]
		],
		[[318, 318], "valid"],
		[
			[319, 320],
			"mapped",
			[108, 183]
		],
		[
			[321, 321],
			"mapped",
			[322]
		],
		[[322, 322], "valid"],
		[
			[323, 323],
			"mapped",
			[324]
		],
		[[324, 324], "valid"],
		[
			[325, 325],
			"mapped",
			[326]
		],
		[[326, 326], "valid"],
		[
			[327, 327],
			"mapped",
			[328]
		],
		[[328, 328], "valid"],
		[
			[329, 329],
			"mapped",
			[700, 110]
		],
		[
			[330, 330],
			"mapped",
			[331]
		],
		[[331, 331], "valid"],
		[
			[332, 332],
			"mapped",
			[333]
		],
		[[333, 333], "valid"],
		[
			[334, 334],
			"mapped",
			[335]
		],
		[[335, 335], "valid"],
		[
			[336, 336],
			"mapped",
			[337]
		],
		[[337, 337], "valid"],
		[
			[338, 338],
			"mapped",
			[339]
		],
		[[339, 339], "valid"],
		[
			[340, 340],
			"mapped",
			[341]
		],
		[[341, 341], "valid"],
		[
			[342, 342],
			"mapped",
			[343]
		],
		[[343, 343], "valid"],
		[
			[344, 344],
			"mapped",
			[345]
		],
		[[345, 345], "valid"],
		[
			[346, 346],
			"mapped",
			[347]
		],
		[[347, 347], "valid"],
		[
			[348, 348],
			"mapped",
			[349]
		],
		[[349, 349], "valid"],
		[
			[350, 350],
			"mapped",
			[351]
		],
		[[351, 351], "valid"],
		[
			[352, 352],
			"mapped",
			[353]
		],
		[[353, 353], "valid"],
		[
			[354, 354],
			"mapped",
			[355]
		],
		[[355, 355], "valid"],
		[
			[356, 356],
			"mapped",
			[357]
		],
		[[357, 357], "valid"],
		[
			[358, 358],
			"mapped",
			[359]
		],
		[[359, 359], "valid"],
		[
			[360, 360],
			"mapped",
			[361]
		],
		[[361, 361], "valid"],
		[
			[362, 362],
			"mapped",
			[363]
		],
		[[363, 363], "valid"],
		[
			[364, 364],
			"mapped",
			[365]
		],
		[[365, 365], "valid"],
		[
			[366, 366],
			"mapped",
			[367]
		],
		[[367, 367], "valid"],
		[
			[368, 368],
			"mapped",
			[369]
		],
		[[369, 369], "valid"],
		[
			[370, 370],
			"mapped",
			[371]
		],
		[[371, 371], "valid"],
		[
			[372, 372],
			"mapped",
			[373]
		],
		[[373, 373], "valid"],
		[
			[374, 374],
			"mapped",
			[375]
		],
		[[375, 375], "valid"],
		[
			[376, 376],
			"mapped",
			[255]
		],
		[
			[377, 377],
			"mapped",
			[378]
		],
		[[378, 378], "valid"],
		[
			[379, 379],
			"mapped",
			[380]
		],
		[[380, 380], "valid"],
		[
			[381, 381],
			"mapped",
			[382]
		],
		[[382, 382], "valid"],
		[
			[383, 383],
			"mapped",
			[115]
		],
		[[384, 384], "valid"],
		[
			[385, 385],
			"mapped",
			[595]
		],
		[
			[386, 386],
			"mapped",
			[387]
		],
		[[387, 387], "valid"],
		[
			[388, 388],
			"mapped",
			[389]
		],
		[[389, 389], "valid"],
		[
			[390, 390],
			"mapped",
			[596]
		],
		[
			[391, 391],
			"mapped",
			[392]
		],
		[[392, 392], "valid"],
		[
			[393, 393],
			"mapped",
			[598]
		],
		[
			[394, 394],
			"mapped",
			[599]
		],
		[
			[395, 395],
			"mapped",
			[396]
		],
		[[396, 397], "valid"],
		[
			[398, 398],
			"mapped",
			[477]
		],
		[
			[399, 399],
			"mapped",
			[601]
		],
		[
			[400, 400],
			"mapped",
			[603]
		],
		[
			[401, 401],
			"mapped",
			[402]
		],
		[[402, 402], "valid"],
		[
			[403, 403],
			"mapped",
			[608]
		],
		[
			[404, 404],
			"mapped",
			[611]
		],
		[[405, 405], "valid"],
		[
			[406, 406],
			"mapped",
			[617]
		],
		[
			[407, 407],
			"mapped",
			[616]
		],
		[
			[408, 408],
			"mapped",
			[409]
		],
		[[409, 411], "valid"],
		[
			[412, 412],
			"mapped",
			[623]
		],
		[
			[413, 413],
			"mapped",
			[626]
		],
		[[414, 414], "valid"],
		[
			[415, 415],
			"mapped",
			[629]
		],
		[
			[416, 416],
			"mapped",
			[417]
		],
		[[417, 417], "valid"],
		[
			[418, 418],
			"mapped",
			[419]
		],
		[[419, 419], "valid"],
		[
			[420, 420],
			"mapped",
			[421]
		],
		[[421, 421], "valid"],
		[
			[422, 422],
			"mapped",
			[640]
		],
		[
			[423, 423],
			"mapped",
			[424]
		],
		[[424, 424], "valid"],
		[
			[425, 425],
			"mapped",
			[643]
		],
		[[426, 427], "valid"],
		[
			[428, 428],
			"mapped",
			[429]
		],
		[[429, 429], "valid"],
		[
			[430, 430],
			"mapped",
			[648]
		],
		[
			[431, 431],
			"mapped",
			[432]
		],
		[[432, 432], "valid"],
		[
			[433, 433],
			"mapped",
			[650]
		],
		[
			[434, 434],
			"mapped",
			[651]
		],
		[
			[435, 435],
			"mapped",
			[436]
		],
		[[436, 436], "valid"],
		[
			[437, 437],
			"mapped",
			[438]
		],
		[[438, 438], "valid"],
		[
			[439, 439],
			"mapped",
			[658]
		],
		[
			[440, 440],
			"mapped",
			[441]
		],
		[[441, 443], "valid"],
		[
			[444, 444],
			"mapped",
			[445]
		],
		[[445, 451], "valid"],
		[
			[452, 454],
			"mapped",
			[100, 382]
		],
		[
			[455, 457],
			"mapped",
			[108, 106]
		],
		[
			[458, 460],
			"mapped",
			[110, 106]
		],
		[
			[461, 461],
			"mapped",
			[462]
		],
		[[462, 462], "valid"],
		[
			[463, 463],
			"mapped",
			[464]
		],
		[[464, 464], "valid"],
		[
			[465, 465],
			"mapped",
			[466]
		],
		[[466, 466], "valid"],
		[
			[467, 467],
			"mapped",
			[468]
		],
		[[468, 468], "valid"],
		[
			[469, 469],
			"mapped",
			[470]
		],
		[[470, 470], "valid"],
		[
			[471, 471],
			"mapped",
			[472]
		],
		[[472, 472], "valid"],
		[
			[473, 473],
			"mapped",
			[474]
		],
		[[474, 474], "valid"],
		[
			[475, 475],
			"mapped",
			[476]
		],
		[[476, 477], "valid"],
		[
			[478, 478],
			"mapped",
			[479]
		],
		[[479, 479], "valid"],
		[
			[480, 480],
			"mapped",
			[481]
		],
		[[481, 481], "valid"],
		[
			[482, 482],
			"mapped",
			[483]
		],
		[[483, 483], "valid"],
		[
			[484, 484],
			"mapped",
			[485]
		],
		[[485, 485], "valid"],
		[
			[486, 486],
			"mapped",
			[487]
		],
		[[487, 487], "valid"],
		[
			[488, 488],
			"mapped",
			[489]
		],
		[[489, 489], "valid"],
		[
			[490, 490],
			"mapped",
			[491]
		],
		[[491, 491], "valid"],
		[
			[492, 492],
			"mapped",
			[493]
		],
		[[493, 493], "valid"],
		[
			[494, 494],
			"mapped",
			[495]
		],
		[[495, 496], "valid"],
		[
			[497, 499],
			"mapped",
			[100, 122]
		],
		[
			[500, 500],
			"mapped",
			[501]
		],
		[[501, 501], "valid"],
		[
			[502, 502],
			"mapped",
			[405]
		],
		[
			[503, 503],
			"mapped",
			[447]
		],
		[
			[504, 504],
			"mapped",
			[505]
		],
		[[505, 505], "valid"],
		[
			[506, 506],
			"mapped",
			[507]
		],
		[[507, 507], "valid"],
		[
			[508, 508],
			"mapped",
			[509]
		],
		[[509, 509], "valid"],
		[
			[510, 510],
			"mapped",
			[511]
		],
		[[511, 511], "valid"],
		[
			[512, 512],
			"mapped",
			[513]
		],
		[[513, 513], "valid"],
		[
			[514, 514],
			"mapped",
			[515]
		],
		[[515, 515], "valid"],
		[
			[516, 516],
			"mapped",
			[517]
		],
		[[517, 517], "valid"],
		[
			[518, 518],
			"mapped",
			[519]
		],
		[[519, 519], "valid"],
		[
			[520, 520],
			"mapped",
			[521]
		],
		[[521, 521], "valid"],
		[
			[522, 522],
			"mapped",
			[523]
		],
		[[523, 523], "valid"],
		[
			[524, 524],
			"mapped",
			[525]
		],
		[[525, 525], "valid"],
		[
			[526, 526],
			"mapped",
			[527]
		],
		[[527, 527], "valid"],
		[
			[528, 528],
			"mapped",
			[529]
		],
		[[529, 529], "valid"],
		[
			[530, 530],
			"mapped",
			[531]
		],
		[[531, 531], "valid"],
		[
			[532, 532],
			"mapped",
			[533]
		],
		[[533, 533], "valid"],
		[
			[534, 534],
			"mapped",
			[535]
		],
		[[535, 535], "valid"],
		[
			[536, 536],
			"mapped",
			[537]
		],
		[[537, 537], "valid"],
		[
			[538, 538],
			"mapped",
			[539]
		],
		[[539, 539], "valid"],
		[
			[540, 540],
			"mapped",
			[541]
		],
		[[541, 541], "valid"],
		[
			[542, 542],
			"mapped",
			[543]
		],
		[[543, 543], "valid"],
		[
			[544, 544],
			"mapped",
			[414]
		],
		[[545, 545], "valid"],
		[
			[546, 546],
			"mapped",
			[547]
		],
		[[547, 547], "valid"],
		[
			[548, 548],
			"mapped",
			[549]
		],
		[[549, 549], "valid"],
		[
			[550, 550],
			"mapped",
			[551]
		],
		[[551, 551], "valid"],
		[
			[552, 552],
			"mapped",
			[553]
		],
		[[553, 553], "valid"],
		[
			[554, 554],
			"mapped",
			[555]
		],
		[[555, 555], "valid"],
		[
			[556, 556],
			"mapped",
			[557]
		],
		[[557, 557], "valid"],
		[
			[558, 558],
			"mapped",
			[559]
		],
		[[559, 559], "valid"],
		[
			[560, 560],
			"mapped",
			[561]
		],
		[[561, 561], "valid"],
		[
			[562, 562],
			"mapped",
			[563]
		],
		[[563, 563], "valid"],
		[[564, 566], "valid"],
		[[567, 569], "valid"],
		[
			[570, 570],
			"mapped",
			[11365]
		],
		[
			[571, 571],
			"mapped",
			[572]
		],
		[[572, 572], "valid"],
		[
			[573, 573],
			"mapped",
			[410]
		],
		[
			[574, 574],
			"mapped",
			[11366]
		],
		[[575, 576], "valid"],
		[
			[577, 577],
			"mapped",
			[578]
		],
		[[578, 578], "valid"],
		[
			[579, 579],
			"mapped",
			[384]
		],
		[
			[580, 580],
			"mapped",
			[649]
		],
		[
			[581, 581],
			"mapped",
			[652]
		],
		[
			[582, 582],
			"mapped",
			[583]
		],
		[[583, 583], "valid"],
		[
			[584, 584],
			"mapped",
			[585]
		],
		[[585, 585], "valid"],
		[
			[586, 586],
			"mapped",
			[587]
		],
		[[587, 587], "valid"],
		[
			[588, 588],
			"mapped",
			[589]
		],
		[[589, 589], "valid"],
		[
			[590, 590],
			"mapped",
			[591]
		],
		[[591, 591], "valid"],
		[[592, 680], "valid"],
		[[681, 685], "valid"],
		[[686, 687], "valid"],
		[
			[688, 688],
			"mapped",
			[104]
		],
		[
			[689, 689],
			"mapped",
			[614]
		],
		[
			[690, 690],
			"mapped",
			[106]
		],
		[
			[691, 691],
			"mapped",
			[114]
		],
		[
			[692, 692],
			"mapped",
			[633]
		],
		[
			[693, 693],
			"mapped",
			[635]
		],
		[
			[694, 694],
			"mapped",
			[641]
		],
		[
			[695, 695],
			"mapped",
			[119]
		],
		[
			[696, 696],
			"mapped",
			[121]
		],
		[[697, 705], "valid"],
		[
			[706, 709],
			"valid",
			[],
			"NV8"
		],
		[[710, 721], "valid"],
		[
			[722, 727],
			"valid",
			[],
			"NV8"
		],
		[
			[728, 728],
			"disallowed_STD3_mapped",
			[32, 774]
		],
		[
			[729, 729],
			"disallowed_STD3_mapped",
			[32, 775]
		],
		[
			[730, 730],
			"disallowed_STD3_mapped",
			[32, 778]
		],
		[
			[731, 731],
			"disallowed_STD3_mapped",
			[32, 808]
		],
		[
			[732, 732],
			"disallowed_STD3_mapped",
			[32, 771]
		],
		[
			[733, 733],
			"disallowed_STD3_mapped",
			[32, 779]
		],
		[
			[734, 734],
			"valid",
			[],
			"NV8"
		],
		[
			[735, 735],
			"valid",
			[],
			"NV8"
		],
		[
			[736, 736],
			"mapped",
			[611]
		],
		[
			[737, 737],
			"mapped",
			[108]
		],
		[
			[738, 738],
			"mapped",
			[115]
		],
		[
			[739, 739],
			"mapped",
			[120]
		],
		[
			[740, 740],
			"mapped",
			[661]
		],
		[
			[741, 745],
			"valid",
			[],
			"NV8"
		],
		[
			[746, 747],
			"valid",
			[],
			"NV8"
		],
		[[748, 748], "valid"],
		[
			[749, 749],
			"valid",
			[],
			"NV8"
		],
		[[750, 750], "valid"],
		[
			[751, 767],
			"valid",
			[],
			"NV8"
		],
		[[768, 831], "valid"],
		[
			[832, 832],
			"mapped",
			[768]
		],
		[
			[833, 833],
			"mapped",
			[769]
		],
		[[834, 834], "valid"],
		[
			[835, 835],
			"mapped",
			[787]
		],
		[
			[836, 836],
			"mapped",
			[776, 769]
		],
		[
			[837, 837],
			"mapped",
			[953]
		],
		[[838, 846], "valid"],
		[[847, 847], "ignored"],
		[[848, 855], "valid"],
		[[856, 860], "valid"],
		[[861, 863], "valid"],
		[[864, 865], "valid"],
		[[866, 866], "valid"],
		[[867, 879], "valid"],
		[
			[880, 880],
			"mapped",
			[881]
		],
		[[881, 881], "valid"],
		[
			[882, 882],
			"mapped",
			[883]
		],
		[[883, 883], "valid"],
		[
			[884, 884],
			"mapped",
			[697]
		],
		[[885, 885], "valid"],
		[
			[886, 886],
			"mapped",
			[887]
		],
		[[887, 887], "valid"],
		[[888, 889], "disallowed"],
		[
			[890, 890],
			"disallowed_STD3_mapped",
			[32, 953]
		],
		[[891, 893], "valid"],
		[
			[894, 894],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[895, 895],
			"mapped",
			[1011]
		],
		[[896, 899], "disallowed"],
		[
			[900, 900],
			"disallowed_STD3_mapped",
			[32, 769]
		],
		[
			[901, 901],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				769
			]
		],
		[
			[902, 902],
			"mapped",
			[940]
		],
		[
			[903, 903],
			"mapped",
			[183]
		],
		[
			[904, 904],
			"mapped",
			[941]
		],
		[
			[905, 905],
			"mapped",
			[942]
		],
		[
			[906, 906],
			"mapped",
			[943]
		],
		[[907, 907], "disallowed"],
		[
			[908, 908],
			"mapped",
			[972]
		],
		[[909, 909], "disallowed"],
		[
			[910, 910],
			"mapped",
			[973]
		],
		[
			[911, 911],
			"mapped",
			[974]
		],
		[[912, 912], "valid"],
		[
			[913, 913],
			"mapped",
			[945]
		],
		[
			[914, 914],
			"mapped",
			[946]
		],
		[
			[915, 915],
			"mapped",
			[947]
		],
		[
			[916, 916],
			"mapped",
			[948]
		],
		[
			[917, 917],
			"mapped",
			[949]
		],
		[
			[918, 918],
			"mapped",
			[950]
		],
		[
			[919, 919],
			"mapped",
			[951]
		],
		[
			[920, 920],
			"mapped",
			[952]
		],
		[
			[921, 921],
			"mapped",
			[953]
		],
		[
			[922, 922],
			"mapped",
			[954]
		],
		[
			[923, 923],
			"mapped",
			[955]
		],
		[
			[924, 924],
			"mapped",
			[956]
		],
		[
			[925, 925],
			"mapped",
			[957]
		],
		[
			[926, 926],
			"mapped",
			[958]
		],
		[
			[927, 927],
			"mapped",
			[959]
		],
		[
			[928, 928],
			"mapped",
			[960]
		],
		[
			[929, 929],
			"mapped",
			[961]
		],
		[[930, 930], "disallowed"],
		[
			[931, 931],
			"mapped",
			[963]
		],
		[
			[932, 932],
			"mapped",
			[964]
		],
		[
			[933, 933],
			"mapped",
			[965]
		],
		[
			[934, 934],
			"mapped",
			[966]
		],
		[
			[935, 935],
			"mapped",
			[967]
		],
		[
			[936, 936],
			"mapped",
			[968]
		],
		[
			[937, 937],
			"mapped",
			[969]
		],
		[
			[938, 938],
			"mapped",
			[970]
		],
		[
			[939, 939],
			"mapped",
			[971]
		],
		[[940, 961], "valid"],
		[
			[962, 962],
			"deviation",
			[963]
		],
		[[963, 974], "valid"],
		[
			[975, 975],
			"mapped",
			[983]
		],
		[
			[976, 976],
			"mapped",
			[946]
		],
		[
			[977, 977],
			"mapped",
			[952]
		],
		[
			[978, 978],
			"mapped",
			[965]
		],
		[
			[979, 979],
			"mapped",
			[973]
		],
		[
			[980, 980],
			"mapped",
			[971]
		],
		[
			[981, 981],
			"mapped",
			[966]
		],
		[
			[982, 982],
			"mapped",
			[960]
		],
		[[983, 983], "valid"],
		[
			[984, 984],
			"mapped",
			[985]
		],
		[[985, 985], "valid"],
		[
			[986, 986],
			"mapped",
			[987]
		],
		[[987, 987], "valid"],
		[
			[988, 988],
			"mapped",
			[989]
		],
		[[989, 989], "valid"],
		[
			[990, 990],
			"mapped",
			[991]
		],
		[[991, 991], "valid"],
		[
			[992, 992],
			"mapped",
			[993]
		],
		[[993, 993], "valid"],
		[
			[994, 994],
			"mapped",
			[995]
		],
		[[995, 995], "valid"],
		[
			[996, 996],
			"mapped",
			[997]
		],
		[[997, 997], "valid"],
		[
			[998, 998],
			"mapped",
			[999]
		],
		[[999, 999], "valid"],
		[
			[1e3, 1e3],
			"mapped",
			[1001]
		],
		[[1001, 1001], "valid"],
		[
			[1002, 1002],
			"mapped",
			[1003]
		],
		[[1003, 1003], "valid"],
		[
			[1004, 1004],
			"mapped",
			[1005]
		],
		[[1005, 1005], "valid"],
		[
			[1006, 1006],
			"mapped",
			[1007]
		],
		[[1007, 1007], "valid"],
		[
			[1008, 1008],
			"mapped",
			[954]
		],
		[
			[1009, 1009],
			"mapped",
			[961]
		],
		[
			[1010, 1010],
			"mapped",
			[963]
		],
		[[1011, 1011], "valid"],
		[
			[1012, 1012],
			"mapped",
			[952]
		],
		[
			[1013, 1013],
			"mapped",
			[949]
		],
		[
			[1014, 1014],
			"valid",
			[],
			"NV8"
		],
		[
			[1015, 1015],
			"mapped",
			[1016]
		],
		[[1016, 1016], "valid"],
		[
			[1017, 1017],
			"mapped",
			[963]
		],
		[
			[1018, 1018],
			"mapped",
			[1019]
		],
		[[1019, 1019], "valid"],
		[[1020, 1020], "valid"],
		[
			[1021, 1021],
			"mapped",
			[891]
		],
		[
			[1022, 1022],
			"mapped",
			[892]
		],
		[
			[1023, 1023],
			"mapped",
			[893]
		],
		[
			[1024, 1024],
			"mapped",
			[1104]
		],
		[
			[1025, 1025],
			"mapped",
			[1105]
		],
		[
			[1026, 1026],
			"mapped",
			[1106]
		],
		[
			[1027, 1027],
			"mapped",
			[1107]
		],
		[
			[1028, 1028],
			"mapped",
			[1108]
		],
		[
			[1029, 1029],
			"mapped",
			[1109]
		],
		[
			[1030, 1030],
			"mapped",
			[1110]
		],
		[
			[1031, 1031],
			"mapped",
			[1111]
		],
		[
			[1032, 1032],
			"mapped",
			[1112]
		],
		[
			[1033, 1033],
			"mapped",
			[1113]
		],
		[
			[1034, 1034],
			"mapped",
			[1114]
		],
		[
			[1035, 1035],
			"mapped",
			[1115]
		],
		[
			[1036, 1036],
			"mapped",
			[1116]
		],
		[
			[1037, 1037],
			"mapped",
			[1117]
		],
		[
			[1038, 1038],
			"mapped",
			[1118]
		],
		[
			[1039, 1039],
			"mapped",
			[1119]
		],
		[
			[1040, 1040],
			"mapped",
			[1072]
		],
		[
			[1041, 1041],
			"mapped",
			[1073]
		],
		[
			[1042, 1042],
			"mapped",
			[1074]
		],
		[
			[1043, 1043],
			"mapped",
			[1075]
		],
		[
			[1044, 1044],
			"mapped",
			[1076]
		],
		[
			[1045, 1045],
			"mapped",
			[1077]
		],
		[
			[1046, 1046],
			"mapped",
			[1078]
		],
		[
			[1047, 1047],
			"mapped",
			[1079]
		],
		[
			[1048, 1048],
			"mapped",
			[1080]
		],
		[
			[1049, 1049],
			"mapped",
			[1081]
		],
		[
			[1050, 1050],
			"mapped",
			[1082]
		],
		[
			[1051, 1051],
			"mapped",
			[1083]
		],
		[
			[1052, 1052],
			"mapped",
			[1084]
		],
		[
			[1053, 1053],
			"mapped",
			[1085]
		],
		[
			[1054, 1054],
			"mapped",
			[1086]
		],
		[
			[1055, 1055],
			"mapped",
			[1087]
		],
		[
			[1056, 1056],
			"mapped",
			[1088]
		],
		[
			[1057, 1057],
			"mapped",
			[1089]
		],
		[
			[1058, 1058],
			"mapped",
			[1090]
		],
		[
			[1059, 1059],
			"mapped",
			[1091]
		],
		[
			[1060, 1060],
			"mapped",
			[1092]
		],
		[
			[1061, 1061],
			"mapped",
			[1093]
		],
		[
			[1062, 1062],
			"mapped",
			[1094]
		],
		[
			[1063, 1063],
			"mapped",
			[1095]
		],
		[
			[1064, 1064],
			"mapped",
			[1096]
		],
		[
			[1065, 1065],
			"mapped",
			[1097]
		],
		[
			[1066, 1066],
			"mapped",
			[1098]
		],
		[
			[1067, 1067],
			"mapped",
			[1099]
		],
		[
			[1068, 1068],
			"mapped",
			[1100]
		],
		[
			[1069, 1069],
			"mapped",
			[1101]
		],
		[
			[1070, 1070],
			"mapped",
			[1102]
		],
		[
			[1071, 1071],
			"mapped",
			[1103]
		],
		[[1072, 1103], "valid"],
		[[1104, 1104], "valid"],
		[[1105, 1116], "valid"],
		[[1117, 1117], "valid"],
		[[1118, 1119], "valid"],
		[
			[1120, 1120],
			"mapped",
			[1121]
		],
		[[1121, 1121], "valid"],
		[
			[1122, 1122],
			"mapped",
			[1123]
		],
		[[1123, 1123], "valid"],
		[
			[1124, 1124],
			"mapped",
			[1125]
		],
		[[1125, 1125], "valid"],
		[
			[1126, 1126],
			"mapped",
			[1127]
		],
		[[1127, 1127], "valid"],
		[
			[1128, 1128],
			"mapped",
			[1129]
		],
		[[1129, 1129], "valid"],
		[
			[1130, 1130],
			"mapped",
			[1131]
		],
		[[1131, 1131], "valid"],
		[
			[1132, 1132],
			"mapped",
			[1133]
		],
		[[1133, 1133], "valid"],
		[
			[1134, 1134],
			"mapped",
			[1135]
		],
		[[1135, 1135], "valid"],
		[
			[1136, 1136],
			"mapped",
			[1137]
		],
		[[1137, 1137], "valid"],
		[
			[1138, 1138],
			"mapped",
			[1139]
		],
		[[1139, 1139], "valid"],
		[
			[1140, 1140],
			"mapped",
			[1141]
		],
		[[1141, 1141], "valid"],
		[
			[1142, 1142],
			"mapped",
			[1143]
		],
		[[1143, 1143], "valid"],
		[
			[1144, 1144],
			"mapped",
			[1145]
		],
		[[1145, 1145], "valid"],
		[
			[1146, 1146],
			"mapped",
			[1147]
		],
		[[1147, 1147], "valid"],
		[
			[1148, 1148],
			"mapped",
			[1149]
		],
		[[1149, 1149], "valid"],
		[
			[1150, 1150],
			"mapped",
			[1151]
		],
		[[1151, 1151], "valid"],
		[
			[1152, 1152],
			"mapped",
			[1153]
		],
		[[1153, 1153], "valid"],
		[
			[1154, 1154],
			"valid",
			[],
			"NV8"
		],
		[[1155, 1158], "valid"],
		[[1159, 1159], "valid"],
		[
			[1160, 1161],
			"valid",
			[],
			"NV8"
		],
		[
			[1162, 1162],
			"mapped",
			[1163]
		],
		[[1163, 1163], "valid"],
		[
			[1164, 1164],
			"mapped",
			[1165]
		],
		[[1165, 1165], "valid"],
		[
			[1166, 1166],
			"mapped",
			[1167]
		],
		[[1167, 1167], "valid"],
		[
			[1168, 1168],
			"mapped",
			[1169]
		],
		[[1169, 1169], "valid"],
		[
			[1170, 1170],
			"mapped",
			[1171]
		],
		[[1171, 1171], "valid"],
		[
			[1172, 1172],
			"mapped",
			[1173]
		],
		[[1173, 1173], "valid"],
		[
			[1174, 1174],
			"mapped",
			[1175]
		],
		[[1175, 1175], "valid"],
		[
			[1176, 1176],
			"mapped",
			[1177]
		],
		[[1177, 1177], "valid"],
		[
			[1178, 1178],
			"mapped",
			[1179]
		],
		[[1179, 1179], "valid"],
		[
			[1180, 1180],
			"mapped",
			[1181]
		],
		[[1181, 1181], "valid"],
		[
			[1182, 1182],
			"mapped",
			[1183]
		],
		[[1183, 1183], "valid"],
		[
			[1184, 1184],
			"mapped",
			[1185]
		],
		[[1185, 1185], "valid"],
		[
			[1186, 1186],
			"mapped",
			[1187]
		],
		[[1187, 1187], "valid"],
		[
			[1188, 1188],
			"mapped",
			[1189]
		],
		[[1189, 1189], "valid"],
		[
			[1190, 1190],
			"mapped",
			[1191]
		],
		[[1191, 1191], "valid"],
		[
			[1192, 1192],
			"mapped",
			[1193]
		],
		[[1193, 1193], "valid"],
		[
			[1194, 1194],
			"mapped",
			[1195]
		],
		[[1195, 1195], "valid"],
		[
			[1196, 1196],
			"mapped",
			[1197]
		],
		[[1197, 1197], "valid"],
		[
			[1198, 1198],
			"mapped",
			[1199]
		],
		[[1199, 1199], "valid"],
		[
			[1200, 1200],
			"mapped",
			[1201]
		],
		[[1201, 1201], "valid"],
		[
			[1202, 1202],
			"mapped",
			[1203]
		],
		[[1203, 1203], "valid"],
		[
			[1204, 1204],
			"mapped",
			[1205]
		],
		[[1205, 1205], "valid"],
		[
			[1206, 1206],
			"mapped",
			[1207]
		],
		[[1207, 1207], "valid"],
		[
			[1208, 1208],
			"mapped",
			[1209]
		],
		[[1209, 1209], "valid"],
		[
			[1210, 1210],
			"mapped",
			[1211]
		],
		[[1211, 1211], "valid"],
		[
			[1212, 1212],
			"mapped",
			[1213]
		],
		[[1213, 1213], "valid"],
		[
			[1214, 1214],
			"mapped",
			[1215]
		],
		[[1215, 1215], "valid"],
		[[1216, 1216], "disallowed"],
		[
			[1217, 1217],
			"mapped",
			[1218]
		],
		[[1218, 1218], "valid"],
		[
			[1219, 1219],
			"mapped",
			[1220]
		],
		[[1220, 1220], "valid"],
		[
			[1221, 1221],
			"mapped",
			[1222]
		],
		[[1222, 1222], "valid"],
		[
			[1223, 1223],
			"mapped",
			[1224]
		],
		[[1224, 1224], "valid"],
		[
			[1225, 1225],
			"mapped",
			[1226]
		],
		[[1226, 1226], "valid"],
		[
			[1227, 1227],
			"mapped",
			[1228]
		],
		[[1228, 1228], "valid"],
		[
			[1229, 1229],
			"mapped",
			[1230]
		],
		[[1230, 1230], "valid"],
		[[1231, 1231], "valid"],
		[
			[1232, 1232],
			"mapped",
			[1233]
		],
		[[1233, 1233], "valid"],
		[
			[1234, 1234],
			"mapped",
			[1235]
		],
		[[1235, 1235], "valid"],
		[
			[1236, 1236],
			"mapped",
			[1237]
		],
		[[1237, 1237], "valid"],
		[
			[1238, 1238],
			"mapped",
			[1239]
		],
		[[1239, 1239], "valid"],
		[
			[1240, 1240],
			"mapped",
			[1241]
		],
		[[1241, 1241], "valid"],
		[
			[1242, 1242],
			"mapped",
			[1243]
		],
		[[1243, 1243], "valid"],
		[
			[1244, 1244],
			"mapped",
			[1245]
		],
		[[1245, 1245], "valid"],
		[
			[1246, 1246],
			"mapped",
			[1247]
		],
		[[1247, 1247], "valid"],
		[
			[1248, 1248],
			"mapped",
			[1249]
		],
		[[1249, 1249], "valid"],
		[
			[1250, 1250],
			"mapped",
			[1251]
		],
		[[1251, 1251], "valid"],
		[
			[1252, 1252],
			"mapped",
			[1253]
		],
		[[1253, 1253], "valid"],
		[
			[1254, 1254],
			"mapped",
			[1255]
		],
		[[1255, 1255], "valid"],
		[
			[1256, 1256],
			"mapped",
			[1257]
		],
		[[1257, 1257], "valid"],
		[
			[1258, 1258],
			"mapped",
			[1259]
		],
		[[1259, 1259], "valid"],
		[
			[1260, 1260],
			"mapped",
			[1261]
		],
		[[1261, 1261], "valid"],
		[
			[1262, 1262],
			"mapped",
			[1263]
		],
		[[1263, 1263], "valid"],
		[
			[1264, 1264],
			"mapped",
			[1265]
		],
		[[1265, 1265], "valid"],
		[
			[1266, 1266],
			"mapped",
			[1267]
		],
		[[1267, 1267], "valid"],
		[
			[1268, 1268],
			"mapped",
			[1269]
		],
		[[1269, 1269], "valid"],
		[
			[1270, 1270],
			"mapped",
			[1271]
		],
		[[1271, 1271], "valid"],
		[
			[1272, 1272],
			"mapped",
			[1273]
		],
		[[1273, 1273], "valid"],
		[
			[1274, 1274],
			"mapped",
			[1275]
		],
		[[1275, 1275], "valid"],
		[
			[1276, 1276],
			"mapped",
			[1277]
		],
		[[1277, 1277], "valid"],
		[
			[1278, 1278],
			"mapped",
			[1279]
		],
		[[1279, 1279], "valid"],
		[
			[1280, 1280],
			"mapped",
			[1281]
		],
		[[1281, 1281], "valid"],
		[
			[1282, 1282],
			"mapped",
			[1283]
		],
		[[1283, 1283], "valid"],
		[
			[1284, 1284],
			"mapped",
			[1285]
		],
		[[1285, 1285], "valid"],
		[
			[1286, 1286],
			"mapped",
			[1287]
		],
		[[1287, 1287], "valid"],
		[
			[1288, 1288],
			"mapped",
			[1289]
		],
		[[1289, 1289], "valid"],
		[
			[1290, 1290],
			"mapped",
			[1291]
		],
		[[1291, 1291], "valid"],
		[
			[1292, 1292],
			"mapped",
			[1293]
		],
		[[1293, 1293], "valid"],
		[
			[1294, 1294],
			"mapped",
			[1295]
		],
		[[1295, 1295], "valid"],
		[
			[1296, 1296],
			"mapped",
			[1297]
		],
		[[1297, 1297], "valid"],
		[
			[1298, 1298],
			"mapped",
			[1299]
		],
		[[1299, 1299], "valid"],
		[
			[1300, 1300],
			"mapped",
			[1301]
		],
		[[1301, 1301], "valid"],
		[
			[1302, 1302],
			"mapped",
			[1303]
		],
		[[1303, 1303], "valid"],
		[
			[1304, 1304],
			"mapped",
			[1305]
		],
		[[1305, 1305], "valid"],
		[
			[1306, 1306],
			"mapped",
			[1307]
		],
		[[1307, 1307], "valid"],
		[
			[1308, 1308],
			"mapped",
			[1309]
		],
		[[1309, 1309], "valid"],
		[
			[1310, 1310],
			"mapped",
			[1311]
		],
		[[1311, 1311], "valid"],
		[
			[1312, 1312],
			"mapped",
			[1313]
		],
		[[1313, 1313], "valid"],
		[
			[1314, 1314],
			"mapped",
			[1315]
		],
		[[1315, 1315], "valid"],
		[
			[1316, 1316],
			"mapped",
			[1317]
		],
		[[1317, 1317], "valid"],
		[
			[1318, 1318],
			"mapped",
			[1319]
		],
		[[1319, 1319], "valid"],
		[
			[1320, 1320],
			"mapped",
			[1321]
		],
		[[1321, 1321], "valid"],
		[
			[1322, 1322],
			"mapped",
			[1323]
		],
		[[1323, 1323], "valid"],
		[
			[1324, 1324],
			"mapped",
			[1325]
		],
		[[1325, 1325], "valid"],
		[
			[1326, 1326],
			"mapped",
			[1327]
		],
		[[1327, 1327], "valid"],
		[[1328, 1328], "disallowed"],
		[
			[1329, 1329],
			"mapped",
			[1377]
		],
		[
			[1330, 1330],
			"mapped",
			[1378]
		],
		[
			[1331, 1331],
			"mapped",
			[1379]
		],
		[
			[1332, 1332],
			"mapped",
			[1380]
		],
		[
			[1333, 1333],
			"mapped",
			[1381]
		],
		[
			[1334, 1334],
			"mapped",
			[1382]
		],
		[
			[1335, 1335],
			"mapped",
			[1383]
		],
		[
			[1336, 1336],
			"mapped",
			[1384]
		],
		[
			[1337, 1337],
			"mapped",
			[1385]
		],
		[
			[1338, 1338],
			"mapped",
			[1386]
		],
		[
			[1339, 1339],
			"mapped",
			[1387]
		],
		[
			[1340, 1340],
			"mapped",
			[1388]
		],
		[
			[1341, 1341],
			"mapped",
			[1389]
		],
		[
			[1342, 1342],
			"mapped",
			[1390]
		],
		[
			[1343, 1343],
			"mapped",
			[1391]
		],
		[
			[1344, 1344],
			"mapped",
			[1392]
		],
		[
			[1345, 1345],
			"mapped",
			[1393]
		],
		[
			[1346, 1346],
			"mapped",
			[1394]
		],
		[
			[1347, 1347],
			"mapped",
			[1395]
		],
		[
			[1348, 1348],
			"mapped",
			[1396]
		],
		[
			[1349, 1349],
			"mapped",
			[1397]
		],
		[
			[1350, 1350],
			"mapped",
			[1398]
		],
		[
			[1351, 1351],
			"mapped",
			[1399]
		],
		[
			[1352, 1352],
			"mapped",
			[1400]
		],
		[
			[1353, 1353],
			"mapped",
			[1401]
		],
		[
			[1354, 1354],
			"mapped",
			[1402]
		],
		[
			[1355, 1355],
			"mapped",
			[1403]
		],
		[
			[1356, 1356],
			"mapped",
			[1404]
		],
		[
			[1357, 1357],
			"mapped",
			[1405]
		],
		[
			[1358, 1358],
			"mapped",
			[1406]
		],
		[
			[1359, 1359],
			"mapped",
			[1407]
		],
		[
			[1360, 1360],
			"mapped",
			[1408]
		],
		[
			[1361, 1361],
			"mapped",
			[1409]
		],
		[
			[1362, 1362],
			"mapped",
			[1410]
		],
		[
			[1363, 1363],
			"mapped",
			[1411]
		],
		[
			[1364, 1364],
			"mapped",
			[1412]
		],
		[
			[1365, 1365],
			"mapped",
			[1413]
		],
		[
			[1366, 1366],
			"mapped",
			[1414]
		],
		[[1367, 1368], "disallowed"],
		[[1369, 1369], "valid"],
		[
			[1370, 1375],
			"valid",
			[],
			"NV8"
		],
		[[1376, 1376], "disallowed"],
		[[1377, 1414], "valid"],
		[
			[1415, 1415],
			"mapped",
			[1381, 1410]
		],
		[[1416, 1416], "disallowed"],
		[
			[1417, 1417],
			"valid",
			[],
			"NV8"
		],
		[
			[1418, 1418],
			"valid",
			[],
			"NV8"
		],
		[[1419, 1420], "disallowed"],
		[
			[1421, 1422],
			"valid",
			[],
			"NV8"
		],
		[
			[1423, 1423],
			"valid",
			[],
			"NV8"
		],
		[[1424, 1424], "disallowed"],
		[[1425, 1441], "valid"],
		[[1442, 1442], "valid"],
		[[1443, 1455], "valid"],
		[[1456, 1465], "valid"],
		[[1466, 1466], "valid"],
		[[1467, 1469], "valid"],
		[
			[1470, 1470],
			"valid",
			[],
			"NV8"
		],
		[[1471, 1471], "valid"],
		[
			[1472, 1472],
			"valid",
			[],
			"NV8"
		],
		[[1473, 1474], "valid"],
		[
			[1475, 1475],
			"valid",
			[],
			"NV8"
		],
		[[1476, 1476], "valid"],
		[[1477, 1477], "valid"],
		[
			[1478, 1478],
			"valid",
			[],
			"NV8"
		],
		[[1479, 1479], "valid"],
		[[1480, 1487], "disallowed"],
		[[1488, 1514], "valid"],
		[[1515, 1519], "disallowed"],
		[[1520, 1524], "valid"],
		[[1525, 1535], "disallowed"],
		[[1536, 1539], "disallowed"],
		[[1540, 1540], "disallowed"],
		[[1541, 1541], "disallowed"],
		[
			[1542, 1546],
			"valid",
			[],
			"NV8"
		],
		[
			[1547, 1547],
			"valid",
			[],
			"NV8"
		],
		[
			[1548, 1548],
			"valid",
			[],
			"NV8"
		],
		[
			[1549, 1551],
			"valid",
			[],
			"NV8"
		],
		[[1552, 1557], "valid"],
		[[1558, 1562], "valid"],
		[
			[1563, 1563],
			"valid",
			[],
			"NV8"
		],
		[[1564, 1564], "disallowed"],
		[[1565, 1565], "disallowed"],
		[
			[1566, 1566],
			"valid",
			[],
			"NV8"
		],
		[
			[1567, 1567],
			"valid",
			[],
			"NV8"
		],
		[[1568, 1568], "valid"],
		[[1569, 1594], "valid"],
		[[1595, 1599], "valid"],
		[
			[1600, 1600],
			"valid",
			[],
			"NV8"
		],
		[[1601, 1618], "valid"],
		[[1619, 1621], "valid"],
		[[1622, 1624], "valid"],
		[[1625, 1630], "valid"],
		[[1631, 1631], "valid"],
		[[1632, 1641], "valid"],
		[
			[1642, 1645],
			"valid",
			[],
			"NV8"
		],
		[[1646, 1647], "valid"],
		[[1648, 1652], "valid"],
		[
			[1653, 1653],
			"mapped",
			[1575, 1652]
		],
		[
			[1654, 1654],
			"mapped",
			[1608, 1652]
		],
		[
			[1655, 1655],
			"mapped",
			[1735, 1652]
		],
		[
			[1656, 1656],
			"mapped",
			[1610, 1652]
		],
		[[1657, 1719], "valid"],
		[[1720, 1721], "valid"],
		[[1722, 1726], "valid"],
		[[1727, 1727], "valid"],
		[[1728, 1742], "valid"],
		[[1743, 1743], "valid"],
		[[1744, 1747], "valid"],
		[
			[1748, 1748],
			"valid",
			[],
			"NV8"
		],
		[[1749, 1756], "valid"],
		[[1757, 1757], "disallowed"],
		[
			[1758, 1758],
			"valid",
			[],
			"NV8"
		],
		[[1759, 1768], "valid"],
		[
			[1769, 1769],
			"valid",
			[],
			"NV8"
		],
		[[1770, 1773], "valid"],
		[[1774, 1775], "valid"],
		[[1776, 1785], "valid"],
		[[1786, 1790], "valid"],
		[[1791, 1791], "valid"],
		[
			[1792, 1805],
			"valid",
			[],
			"NV8"
		],
		[[1806, 1806], "disallowed"],
		[[1807, 1807], "disallowed"],
		[[1808, 1836], "valid"],
		[[1837, 1839], "valid"],
		[[1840, 1866], "valid"],
		[[1867, 1868], "disallowed"],
		[[1869, 1871], "valid"],
		[[1872, 1901], "valid"],
		[[1902, 1919], "valid"],
		[[1920, 1968], "valid"],
		[[1969, 1969], "valid"],
		[[1970, 1983], "disallowed"],
		[[1984, 2037], "valid"],
		[
			[2038, 2042],
			"valid",
			[],
			"NV8"
		],
		[[2043, 2047], "disallowed"],
		[[2048, 2093], "valid"],
		[[2094, 2095], "disallowed"],
		[
			[2096, 2110],
			"valid",
			[],
			"NV8"
		],
		[[2111, 2111], "disallowed"],
		[[2112, 2139], "valid"],
		[[2140, 2141], "disallowed"],
		[
			[2142, 2142],
			"valid",
			[],
			"NV8"
		],
		[[2143, 2207], "disallowed"],
		[[2208, 2208], "valid"],
		[[2209, 2209], "valid"],
		[[2210, 2220], "valid"],
		[[2221, 2226], "valid"],
		[[2227, 2228], "valid"],
		[[2229, 2274], "disallowed"],
		[[2275, 2275], "valid"],
		[[2276, 2302], "valid"],
		[[2303, 2303], "valid"],
		[[2304, 2304], "valid"],
		[[2305, 2307], "valid"],
		[[2308, 2308], "valid"],
		[[2309, 2361], "valid"],
		[[2362, 2363], "valid"],
		[[2364, 2381], "valid"],
		[[2382, 2382], "valid"],
		[[2383, 2383], "valid"],
		[[2384, 2388], "valid"],
		[[2389, 2389], "valid"],
		[[2390, 2391], "valid"],
		[
			[2392, 2392],
			"mapped",
			[2325, 2364]
		],
		[
			[2393, 2393],
			"mapped",
			[2326, 2364]
		],
		[
			[2394, 2394],
			"mapped",
			[2327, 2364]
		],
		[
			[2395, 2395],
			"mapped",
			[2332, 2364]
		],
		[
			[2396, 2396],
			"mapped",
			[2337, 2364]
		],
		[
			[2397, 2397],
			"mapped",
			[2338, 2364]
		],
		[
			[2398, 2398],
			"mapped",
			[2347, 2364]
		],
		[
			[2399, 2399],
			"mapped",
			[2351, 2364]
		],
		[[2400, 2403], "valid"],
		[
			[2404, 2405],
			"valid",
			[],
			"NV8"
		],
		[[2406, 2415], "valid"],
		[
			[2416, 2416],
			"valid",
			[],
			"NV8"
		],
		[[2417, 2418], "valid"],
		[[2419, 2423], "valid"],
		[[2424, 2424], "valid"],
		[[2425, 2426], "valid"],
		[[2427, 2428], "valid"],
		[[2429, 2429], "valid"],
		[[2430, 2431], "valid"],
		[[2432, 2432], "valid"],
		[[2433, 2435], "valid"],
		[[2436, 2436], "disallowed"],
		[[2437, 2444], "valid"],
		[[2445, 2446], "disallowed"],
		[[2447, 2448], "valid"],
		[[2449, 2450], "disallowed"],
		[[2451, 2472], "valid"],
		[[2473, 2473], "disallowed"],
		[[2474, 2480], "valid"],
		[[2481, 2481], "disallowed"],
		[[2482, 2482], "valid"],
		[[2483, 2485], "disallowed"],
		[[2486, 2489], "valid"],
		[[2490, 2491], "disallowed"],
		[[2492, 2492], "valid"],
		[[2493, 2493], "valid"],
		[[2494, 2500], "valid"],
		[[2501, 2502], "disallowed"],
		[[2503, 2504], "valid"],
		[[2505, 2506], "disallowed"],
		[[2507, 2509], "valid"],
		[[2510, 2510], "valid"],
		[[2511, 2518], "disallowed"],
		[[2519, 2519], "valid"],
		[[2520, 2523], "disallowed"],
		[
			[2524, 2524],
			"mapped",
			[2465, 2492]
		],
		[
			[2525, 2525],
			"mapped",
			[2466, 2492]
		],
		[[2526, 2526], "disallowed"],
		[
			[2527, 2527],
			"mapped",
			[2479, 2492]
		],
		[[2528, 2531], "valid"],
		[[2532, 2533], "disallowed"],
		[[2534, 2545], "valid"],
		[
			[2546, 2554],
			"valid",
			[],
			"NV8"
		],
		[
			[2555, 2555],
			"valid",
			[],
			"NV8"
		],
		[[2556, 2560], "disallowed"],
		[[2561, 2561], "valid"],
		[[2562, 2562], "valid"],
		[[2563, 2563], "valid"],
		[[2564, 2564], "disallowed"],
		[[2565, 2570], "valid"],
		[[2571, 2574], "disallowed"],
		[[2575, 2576], "valid"],
		[[2577, 2578], "disallowed"],
		[[2579, 2600], "valid"],
		[[2601, 2601], "disallowed"],
		[[2602, 2608], "valid"],
		[[2609, 2609], "disallowed"],
		[[2610, 2610], "valid"],
		[
			[2611, 2611],
			"mapped",
			[2610, 2620]
		],
		[[2612, 2612], "disallowed"],
		[[2613, 2613], "valid"],
		[
			[2614, 2614],
			"mapped",
			[2616, 2620]
		],
		[[2615, 2615], "disallowed"],
		[[2616, 2617], "valid"],
		[[2618, 2619], "disallowed"],
		[[2620, 2620], "valid"],
		[[2621, 2621], "disallowed"],
		[[2622, 2626], "valid"],
		[[2627, 2630], "disallowed"],
		[[2631, 2632], "valid"],
		[[2633, 2634], "disallowed"],
		[[2635, 2637], "valid"],
		[[2638, 2640], "disallowed"],
		[[2641, 2641], "valid"],
		[[2642, 2648], "disallowed"],
		[
			[2649, 2649],
			"mapped",
			[2582, 2620]
		],
		[
			[2650, 2650],
			"mapped",
			[2583, 2620]
		],
		[
			[2651, 2651],
			"mapped",
			[2588, 2620]
		],
		[[2652, 2652], "valid"],
		[[2653, 2653], "disallowed"],
		[
			[2654, 2654],
			"mapped",
			[2603, 2620]
		],
		[[2655, 2661], "disallowed"],
		[[2662, 2676], "valid"],
		[[2677, 2677], "valid"],
		[[2678, 2688], "disallowed"],
		[[2689, 2691], "valid"],
		[[2692, 2692], "disallowed"],
		[[2693, 2699], "valid"],
		[[2700, 2700], "valid"],
		[[2701, 2701], "valid"],
		[[2702, 2702], "disallowed"],
		[[2703, 2705], "valid"],
		[[2706, 2706], "disallowed"],
		[[2707, 2728], "valid"],
		[[2729, 2729], "disallowed"],
		[[2730, 2736], "valid"],
		[[2737, 2737], "disallowed"],
		[[2738, 2739], "valid"],
		[[2740, 2740], "disallowed"],
		[[2741, 2745], "valid"],
		[[2746, 2747], "disallowed"],
		[[2748, 2757], "valid"],
		[[2758, 2758], "disallowed"],
		[[2759, 2761], "valid"],
		[[2762, 2762], "disallowed"],
		[[2763, 2765], "valid"],
		[[2766, 2767], "disallowed"],
		[[2768, 2768], "valid"],
		[[2769, 2783], "disallowed"],
		[[2784, 2784], "valid"],
		[[2785, 2787], "valid"],
		[[2788, 2789], "disallowed"],
		[[2790, 2799], "valid"],
		[
			[2800, 2800],
			"valid",
			[],
			"NV8"
		],
		[
			[2801, 2801],
			"valid",
			[],
			"NV8"
		],
		[[2802, 2808], "disallowed"],
		[[2809, 2809], "valid"],
		[[2810, 2816], "disallowed"],
		[[2817, 2819], "valid"],
		[[2820, 2820], "disallowed"],
		[[2821, 2828], "valid"],
		[[2829, 2830], "disallowed"],
		[[2831, 2832], "valid"],
		[[2833, 2834], "disallowed"],
		[[2835, 2856], "valid"],
		[[2857, 2857], "disallowed"],
		[[2858, 2864], "valid"],
		[[2865, 2865], "disallowed"],
		[[2866, 2867], "valid"],
		[[2868, 2868], "disallowed"],
		[[2869, 2869], "valid"],
		[[2870, 2873], "valid"],
		[[2874, 2875], "disallowed"],
		[[2876, 2883], "valid"],
		[[2884, 2884], "valid"],
		[[2885, 2886], "disallowed"],
		[[2887, 2888], "valid"],
		[[2889, 2890], "disallowed"],
		[[2891, 2893], "valid"],
		[[2894, 2901], "disallowed"],
		[[2902, 2903], "valid"],
		[[2904, 2907], "disallowed"],
		[
			[2908, 2908],
			"mapped",
			[2849, 2876]
		],
		[
			[2909, 2909],
			"mapped",
			[2850, 2876]
		],
		[[2910, 2910], "disallowed"],
		[[2911, 2913], "valid"],
		[[2914, 2915], "valid"],
		[[2916, 2917], "disallowed"],
		[[2918, 2927], "valid"],
		[
			[2928, 2928],
			"valid",
			[],
			"NV8"
		],
		[[2929, 2929], "valid"],
		[
			[2930, 2935],
			"valid",
			[],
			"NV8"
		],
		[[2936, 2945], "disallowed"],
		[[2946, 2947], "valid"],
		[[2948, 2948], "disallowed"],
		[[2949, 2954], "valid"],
		[[2955, 2957], "disallowed"],
		[[2958, 2960], "valid"],
		[[2961, 2961], "disallowed"],
		[[2962, 2965], "valid"],
		[[2966, 2968], "disallowed"],
		[[2969, 2970], "valid"],
		[[2971, 2971], "disallowed"],
		[[2972, 2972], "valid"],
		[[2973, 2973], "disallowed"],
		[[2974, 2975], "valid"],
		[[2976, 2978], "disallowed"],
		[[2979, 2980], "valid"],
		[[2981, 2983], "disallowed"],
		[[2984, 2986], "valid"],
		[[2987, 2989], "disallowed"],
		[[2990, 2997], "valid"],
		[[2998, 2998], "valid"],
		[[2999, 3001], "valid"],
		[[3002, 3005], "disallowed"],
		[[3006, 3010], "valid"],
		[[3011, 3013], "disallowed"],
		[[3014, 3016], "valid"],
		[[3017, 3017], "disallowed"],
		[[3018, 3021], "valid"],
		[[3022, 3023], "disallowed"],
		[[3024, 3024], "valid"],
		[[3025, 3030], "disallowed"],
		[[3031, 3031], "valid"],
		[[3032, 3045], "disallowed"],
		[[3046, 3046], "valid"],
		[[3047, 3055], "valid"],
		[
			[3056, 3058],
			"valid",
			[],
			"NV8"
		],
		[
			[3059, 3066],
			"valid",
			[],
			"NV8"
		],
		[[3067, 3071], "disallowed"],
		[[3072, 3072], "valid"],
		[[3073, 3075], "valid"],
		[[3076, 3076], "disallowed"],
		[[3077, 3084], "valid"],
		[[3085, 3085], "disallowed"],
		[[3086, 3088], "valid"],
		[[3089, 3089], "disallowed"],
		[[3090, 3112], "valid"],
		[[3113, 3113], "disallowed"],
		[[3114, 3123], "valid"],
		[[3124, 3124], "valid"],
		[[3125, 3129], "valid"],
		[[3130, 3132], "disallowed"],
		[[3133, 3133], "valid"],
		[[3134, 3140], "valid"],
		[[3141, 3141], "disallowed"],
		[[3142, 3144], "valid"],
		[[3145, 3145], "disallowed"],
		[[3146, 3149], "valid"],
		[[3150, 3156], "disallowed"],
		[[3157, 3158], "valid"],
		[[3159, 3159], "disallowed"],
		[[3160, 3161], "valid"],
		[[3162, 3162], "valid"],
		[[3163, 3167], "disallowed"],
		[[3168, 3169], "valid"],
		[[3170, 3171], "valid"],
		[[3172, 3173], "disallowed"],
		[[3174, 3183], "valid"],
		[[3184, 3191], "disallowed"],
		[
			[3192, 3199],
			"valid",
			[],
			"NV8"
		],
		[[3200, 3200], "disallowed"],
		[[3201, 3201], "valid"],
		[[3202, 3203], "valid"],
		[[3204, 3204], "disallowed"],
		[[3205, 3212], "valid"],
		[[3213, 3213], "disallowed"],
		[[3214, 3216], "valid"],
		[[3217, 3217], "disallowed"],
		[[3218, 3240], "valid"],
		[[3241, 3241], "disallowed"],
		[[3242, 3251], "valid"],
		[[3252, 3252], "disallowed"],
		[[3253, 3257], "valid"],
		[[3258, 3259], "disallowed"],
		[[3260, 3261], "valid"],
		[[3262, 3268], "valid"],
		[[3269, 3269], "disallowed"],
		[[3270, 3272], "valid"],
		[[3273, 3273], "disallowed"],
		[[3274, 3277], "valid"],
		[[3278, 3284], "disallowed"],
		[[3285, 3286], "valid"],
		[[3287, 3293], "disallowed"],
		[[3294, 3294], "valid"],
		[[3295, 3295], "disallowed"],
		[[3296, 3297], "valid"],
		[[3298, 3299], "valid"],
		[[3300, 3301], "disallowed"],
		[[3302, 3311], "valid"],
		[[3312, 3312], "disallowed"],
		[[3313, 3314], "valid"],
		[[3315, 3328], "disallowed"],
		[[3329, 3329], "valid"],
		[[3330, 3331], "valid"],
		[[3332, 3332], "disallowed"],
		[[3333, 3340], "valid"],
		[[3341, 3341], "disallowed"],
		[[3342, 3344], "valid"],
		[[3345, 3345], "disallowed"],
		[[3346, 3368], "valid"],
		[[3369, 3369], "valid"],
		[[3370, 3385], "valid"],
		[[3386, 3386], "valid"],
		[[3387, 3388], "disallowed"],
		[[3389, 3389], "valid"],
		[[3390, 3395], "valid"],
		[[3396, 3396], "valid"],
		[[3397, 3397], "disallowed"],
		[[3398, 3400], "valid"],
		[[3401, 3401], "disallowed"],
		[[3402, 3405], "valid"],
		[[3406, 3406], "valid"],
		[[3407, 3414], "disallowed"],
		[[3415, 3415], "valid"],
		[[3416, 3422], "disallowed"],
		[[3423, 3423], "valid"],
		[[3424, 3425], "valid"],
		[[3426, 3427], "valid"],
		[[3428, 3429], "disallowed"],
		[[3430, 3439], "valid"],
		[
			[3440, 3445],
			"valid",
			[],
			"NV8"
		],
		[[3446, 3448], "disallowed"],
		[
			[3449, 3449],
			"valid",
			[],
			"NV8"
		],
		[[3450, 3455], "valid"],
		[[3456, 3457], "disallowed"],
		[[3458, 3459], "valid"],
		[[3460, 3460], "disallowed"],
		[[3461, 3478], "valid"],
		[[3479, 3481], "disallowed"],
		[[3482, 3505], "valid"],
		[[3506, 3506], "disallowed"],
		[[3507, 3515], "valid"],
		[[3516, 3516], "disallowed"],
		[[3517, 3517], "valid"],
		[[3518, 3519], "disallowed"],
		[[3520, 3526], "valid"],
		[[3527, 3529], "disallowed"],
		[[3530, 3530], "valid"],
		[[3531, 3534], "disallowed"],
		[[3535, 3540], "valid"],
		[[3541, 3541], "disallowed"],
		[[3542, 3542], "valid"],
		[[3543, 3543], "disallowed"],
		[[3544, 3551], "valid"],
		[[3552, 3557], "disallowed"],
		[[3558, 3567], "valid"],
		[[3568, 3569], "disallowed"],
		[[3570, 3571], "valid"],
		[
			[3572, 3572],
			"valid",
			[],
			"NV8"
		],
		[[3573, 3584], "disallowed"],
		[[3585, 3634], "valid"],
		[
			[3635, 3635],
			"mapped",
			[3661, 3634]
		],
		[[3636, 3642], "valid"],
		[[3643, 3646], "disallowed"],
		[
			[3647, 3647],
			"valid",
			[],
			"NV8"
		],
		[[3648, 3662], "valid"],
		[
			[3663, 3663],
			"valid",
			[],
			"NV8"
		],
		[[3664, 3673], "valid"],
		[
			[3674, 3675],
			"valid",
			[],
			"NV8"
		],
		[[3676, 3712], "disallowed"],
		[[3713, 3714], "valid"],
		[[3715, 3715], "disallowed"],
		[[3716, 3716], "valid"],
		[[3717, 3718], "disallowed"],
		[[3719, 3720], "valid"],
		[[3721, 3721], "disallowed"],
		[[3722, 3722], "valid"],
		[[3723, 3724], "disallowed"],
		[[3725, 3725], "valid"],
		[[3726, 3731], "disallowed"],
		[[3732, 3735], "valid"],
		[[3736, 3736], "disallowed"],
		[[3737, 3743], "valid"],
		[[3744, 3744], "disallowed"],
		[[3745, 3747], "valid"],
		[[3748, 3748], "disallowed"],
		[[3749, 3749], "valid"],
		[[3750, 3750], "disallowed"],
		[[3751, 3751], "valid"],
		[[3752, 3753], "disallowed"],
		[[3754, 3755], "valid"],
		[[3756, 3756], "disallowed"],
		[[3757, 3762], "valid"],
		[
			[3763, 3763],
			"mapped",
			[3789, 3762]
		],
		[[3764, 3769], "valid"],
		[[3770, 3770], "disallowed"],
		[[3771, 3773], "valid"],
		[[3774, 3775], "disallowed"],
		[[3776, 3780], "valid"],
		[[3781, 3781], "disallowed"],
		[[3782, 3782], "valid"],
		[[3783, 3783], "disallowed"],
		[[3784, 3789], "valid"],
		[[3790, 3791], "disallowed"],
		[[3792, 3801], "valid"],
		[[3802, 3803], "disallowed"],
		[
			[3804, 3804],
			"mapped",
			[3755, 3737]
		],
		[
			[3805, 3805],
			"mapped",
			[3755, 3745]
		],
		[[3806, 3807], "valid"],
		[[3808, 3839], "disallowed"],
		[[3840, 3840], "valid"],
		[
			[3841, 3850],
			"valid",
			[],
			"NV8"
		],
		[[3851, 3851], "valid"],
		[
			[3852, 3852],
			"mapped",
			[3851]
		],
		[
			[3853, 3863],
			"valid",
			[],
			"NV8"
		],
		[[3864, 3865], "valid"],
		[
			[3866, 3871],
			"valid",
			[],
			"NV8"
		],
		[[3872, 3881], "valid"],
		[
			[3882, 3892],
			"valid",
			[],
			"NV8"
		],
		[[3893, 3893], "valid"],
		[
			[3894, 3894],
			"valid",
			[],
			"NV8"
		],
		[[3895, 3895], "valid"],
		[
			[3896, 3896],
			"valid",
			[],
			"NV8"
		],
		[[3897, 3897], "valid"],
		[
			[3898, 3901],
			"valid",
			[],
			"NV8"
		],
		[[3902, 3906], "valid"],
		[
			[3907, 3907],
			"mapped",
			[3906, 4023]
		],
		[[3908, 3911], "valid"],
		[[3912, 3912], "disallowed"],
		[[3913, 3916], "valid"],
		[
			[3917, 3917],
			"mapped",
			[3916, 4023]
		],
		[[3918, 3921], "valid"],
		[
			[3922, 3922],
			"mapped",
			[3921, 4023]
		],
		[[3923, 3926], "valid"],
		[
			[3927, 3927],
			"mapped",
			[3926, 4023]
		],
		[[3928, 3931], "valid"],
		[
			[3932, 3932],
			"mapped",
			[3931, 4023]
		],
		[[3933, 3944], "valid"],
		[
			[3945, 3945],
			"mapped",
			[3904, 4021]
		],
		[[3946, 3946], "valid"],
		[[3947, 3948], "valid"],
		[[3949, 3952], "disallowed"],
		[[3953, 3954], "valid"],
		[
			[3955, 3955],
			"mapped",
			[3953, 3954]
		],
		[[3956, 3956], "valid"],
		[
			[3957, 3957],
			"mapped",
			[3953, 3956]
		],
		[
			[3958, 3958],
			"mapped",
			[4018, 3968]
		],
		[
			[3959, 3959],
			"mapped",
			[
				4018,
				3953,
				3968
			]
		],
		[
			[3960, 3960],
			"mapped",
			[4019, 3968]
		],
		[
			[3961, 3961],
			"mapped",
			[
				4019,
				3953,
				3968
			]
		],
		[[3962, 3968], "valid"],
		[
			[3969, 3969],
			"mapped",
			[3953, 3968]
		],
		[[3970, 3972], "valid"],
		[
			[3973, 3973],
			"valid",
			[],
			"NV8"
		],
		[[3974, 3979], "valid"],
		[[3980, 3983], "valid"],
		[[3984, 3986], "valid"],
		[
			[3987, 3987],
			"mapped",
			[3986, 4023]
		],
		[[3988, 3989], "valid"],
		[[3990, 3990], "valid"],
		[[3991, 3991], "valid"],
		[[3992, 3992], "disallowed"],
		[[3993, 3996], "valid"],
		[
			[3997, 3997],
			"mapped",
			[3996, 4023]
		],
		[[3998, 4001], "valid"],
		[
			[4002, 4002],
			"mapped",
			[4001, 4023]
		],
		[[4003, 4006], "valid"],
		[
			[4007, 4007],
			"mapped",
			[4006, 4023]
		],
		[[4008, 4011], "valid"],
		[
			[4012, 4012],
			"mapped",
			[4011, 4023]
		],
		[[4013, 4013], "valid"],
		[[4014, 4016], "valid"],
		[[4017, 4023], "valid"],
		[[4024, 4024], "valid"],
		[
			[4025, 4025],
			"mapped",
			[3984, 4021]
		],
		[[4026, 4028], "valid"],
		[[4029, 4029], "disallowed"],
		[
			[4030, 4037],
			"valid",
			[],
			"NV8"
		],
		[[4038, 4038], "valid"],
		[
			[4039, 4044],
			"valid",
			[],
			"NV8"
		],
		[[4045, 4045], "disallowed"],
		[
			[4046, 4046],
			"valid",
			[],
			"NV8"
		],
		[
			[4047, 4047],
			"valid",
			[],
			"NV8"
		],
		[
			[4048, 4049],
			"valid",
			[],
			"NV8"
		],
		[
			[4050, 4052],
			"valid",
			[],
			"NV8"
		],
		[
			[4053, 4056],
			"valid",
			[],
			"NV8"
		],
		[
			[4057, 4058],
			"valid",
			[],
			"NV8"
		],
		[[4059, 4095], "disallowed"],
		[[4096, 4129], "valid"],
		[[4130, 4130], "valid"],
		[[4131, 4135], "valid"],
		[[4136, 4136], "valid"],
		[[4137, 4138], "valid"],
		[[4139, 4139], "valid"],
		[[4140, 4146], "valid"],
		[[4147, 4149], "valid"],
		[[4150, 4153], "valid"],
		[[4154, 4159], "valid"],
		[[4160, 4169], "valid"],
		[
			[4170, 4175],
			"valid",
			[],
			"NV8"
		],
		[[4176, 4185], "valid"],
		[[4186, 4249], "valid"],
		[[4250, 4253], "valid"],
		[
			[4254, 4255],
			"valid",
			[],
			"NV8"
		],
		[[4256, 4293], "disallowed"],
		[[4294, 4294], "disallowed"],
		[
			[4295, 4295],
			"mapped",
			[11559]
		],
		[[4296, 4300], "disallowed"],
		[
			[4301, 4301],
			"mapped",
			[11565]
		],
		[[4302, 4303], "disallowed"],
		[[4304, 4342], "valid"],
		[[4343, 4344], "valid"],
		[[4345, 4346], "valid"],
		[
			[4347, 4347],
			"valid",
			[],
			"NV8"
		],
		[
			[4348, 4348],
			"mapped",
			[4316]
		],
		[[4349, 4351], "valid"],
		[
			[4352, 4441],
			"valid",
			[],
			"NV8"
		],
		[
			[4442, 4446],
			"valid",
			[],
			"NV8"
		],
		[[4447, 4448], "disallowed"],
		[
			[4449, 4514],
			"valid",
			[],
			"NV8"
		],
		[
			[4515, 4519],
			"valid",
			[],
			"NV8"
		],
		[
			[4520, 4601],
			"valid",
			[],
			"NV8"
		],
		[
			[4602, 4607],
			"valid",
			[],
			"NV8"
		],
		[[4608, 4614], "valid"],
		[[4615, 4615], "valid"],
		[[4616, 4678], "valid"],
		[[4679, 4679], "valid"],
		[[4680, 4680], "valid"],
		[[4681, 4681], "disallowed"],
		[[4682, 4685], "valid"],
		[[4686, 4687], "disallowed"],
		[[4688, 4694], "valid"],
		[[4695, 4695], "disallowed"],
		[[4696, 4696], "valid"],
		[[4697, 4697], "disallowed"],
		[[4698, 4701], "valid"],
		[[4702, 4703], "disallowed"],
		[[4704, 4742], "valid"],
		[[4743, 4743], "valid"],
		[[4744, 4744], "valid"],
		[[4745, 4745], "disallowed"],
		[[4746, 4749], "valid"],
		[[4750, 4751], "disallowed"],
		[[4752, 4782], "valid"],
		[[4783, 4783], "valid"],
		[[4784, 4784], "valid"],
		[[4785, 4785], "disallowed"],
		[[4786, 4789], "valid"],
		[[4790, 4791], "disallowed"],
		[[4792, 4798], "valid"],
		[[4799, 4799], "disallowed"],
		[[4800, 4800], "valid"],
		[[4801, 4801], "disallowed"],
		[[4802, 4805], "valid"],
		[[4806, 4807], "disallowed"],
		[[4808, 4814], "valid"],
		[[4815, 4815], "valid"],
		[[4816, 4822], "valid"],
		[[4823, 4823], "disallowed"],
		[[4824, 4846], "valid"],
		[[4847, 4847], "valid"],
		[[4848, 4878], "valid"],
		[[4879, 4879], "valid"],
		[[4880, 4880], "valid"],
		[[4881, 4881], "disallowed"],
		[[4882, 4885], "valid"],
		[[4886, 4887], "disallowed"],
		[[4888, 4894], "valid"],
		[[4895, 4895], "valid"],
		[[4896, 4934], "valid"],
		[[4935, 4935], "valid"],
		[[4936, 4954], "valid"],
		[[4955, 4956], "disallowed"],
		[[4957, 4958], "valid"],
		[[4959, 4959], "valid"],
		[
			[4960, 4960],
			"valid",
			[],
			"NV8"
		],
		[
			[4961, 4988],
			"valid",
			[],
			"NV8"
		],
		[[4989, 4991], "disallowed"],
		[[4992, 5007], "valid"],
		[
			[5008, 5017],
			"valid",
			[],
			"NV8"
		],
		[[5018, 5023], "disallowed"],
		[[5024, 5108], "valid"],
		[[5109, 5109], "valid"],
		[[5110, 5111], "disallowed"],
		[
			[5112, 5112],
			"mapped",
			[5104]
		],
		[
			[5113, 5113],
			"mapped",
			[5105]
		],
		[
			[5114, 5114],
			"mapped",
			[5106]
		],
		[
			[5115, 5115],
			"mapped",
			[5107]
		],
		[
			[5116, 5116],
			"mapped",
			[5108]
		],
		[
			[5117, 5117],
			"mapped",
			[5109]
		],
		[[5118, 5119], "disallowed"],
		[
			[5120, 5120],
			"valid",
			[],
			"NV8"
		],
		[[5121, 5740], "valid"],
		[
			[5741, 5742],
			"valid",
			[],
			"NV8"
		],
		[[5743, 5750], "valid"],
		[[5751, 5759], "valid"],
		[[5760, 5760], "disallowed"],
		[[5761, 5786], "valid"],
		[
			[5787, 5788],
			"valid",
			[],
			"NV8"
		],
		[[5789, 5791], "disallowed"],
		[[5792, 5866], "valid"],
		[
			[5867, 5872],
			"valid",
			[],
			"NV8"
		],
		[[5873, 5880], "valid"],
		[[5881, 5887], "disallowed"],
		[[5888, 5900], "valid"],
		[[5901, 5901], "disallowed"],
		[[5902, 5908], "valid"],
		[[5909, 5919], "disallowed"],
		[[5920, 5940], "valid"],
		[
			[5941, 5942],
			"valid",
			[],
			"NV8"
		],
		[[5943, 5951], "disallowed"],
		[[5952, 5971], "valid"],
		[[5972, 5983], "disallowed"],
		[[5984, 5996], "valid"],
		[[5997, 5997], "disallowed"],
		[[5998, 6e3], "valid"],
		[[6001, 6001], "disallowed"],
		[[6002, 6003], "valid"],
		[[6004, 6015], "disallowed"],
		[[6016, 6067], "valid"],
		[[6068, 6069], "disallowed"],
		[[6070, 6099], "valid"],
		[
			[6100, 6102],
			"valid",
			[],
			"NV8"
		],
		[[6103, 6103], "valid"],
		[
			[6104, 6107],
			"valid",
			[],
			"NV8"
		],
		[[6108, 6108], "valid"],
		[[6109, 6109], "valid"],
		[[6110, 6111], "disallowed"],
		[[6112, 6121], "valid"],
		[[6122, 6127], "disallowed"],
		[
			[6128, 6137],
			"valid",
			[],
			"NV8"
		],
		[[6138, 6143], "disallowed"],
		[
			[6144, 6149],
			"valid",
			[],
			"NV8"
		],
		[[6150, 6150], "disallowed"],
		[
			[6151, 6154],
			"valid",
			[],
			"NV8"
		],
		[[6155, 6157], "ignored"],
		[[6158, 6158], "disallowed"],
		[[6159, 6159], "disallowed"],
		[[6160, 6169], "valid"],
		[[6170, 6175], "disallowed"],
		[[6176, 6263], "valid"],
		[[6264, 6271], "disallowed"],
		[[6272, 6313], "valid"],
		[[6314, 6314], "valid"],
		[[6315, 6319], "disallowed"],
		[[6320, 6389], "valid"],
		[[6390, 6399], "disallowed"],
		[[6400, 6428], "valid"],
		[[6429, 6430], "valid"],
		[[6431, 6431], "disallowed"],
		[[6432, 6443], "valid"],
		[[6444, 6447], "disallowed"],
		[[6448, 6459], "valid"],
		[[6460, 6463], "disallowed"],
		[
			[6464, 6464],
			"valid",
			[],
			"NV8"
		],
		[[6465, 6467], "disallowed"],
		[
			[6468, 6469],
			"valid",
			[],
			"NV8"
		],
		[[6470, 6509], "valid"],
		[[6510, 6511], "disallowed"],
		[[6512, 6516], "valid"],
		[[6517, 6527], "disallowed"],
		[[6528, 6569], "valid"],
		[[6570, 6571], "valid"],
		[[6572, 6575], "disallowed"],
		[[6576, 6601], "valid"],
		[[6602, 6607], "disallowed"],
		[[6608, 6617], "valid"],
		[
			[6618, 6618],
			"valid",
			[],
			"XV8"
		],
		[[6619, 6621], "disallowed"],
		[
			[6622, 6623],
			"valid",
			[],
			"NV8"
		],
		[
			[6624, 6655],
			"valid",
			[],
			"NV8"
		],
		[[6656, 6683], "valid"],
		[[6684, 6685], "disallowed"],
		[
			[6686, 6687],
			"valid",
			[],
			"NV8"
		],
		[[6688, 6750], "valid"],
		[[6751, 6751], "disallowed"],
		[[6752, 6780], "valid"],
		[[6781, 6782], "disallowed"],
		[[6783, 6793], "valid"],
		[[6794, 6799], "disallowed"],
		[[6800, 6809], "valid"],
		[[6810, 6815], "disallowed"],
		[
			[6816, 6822],
			"valid",
			[],
			"NV8"
		],
		[[6823, 6823], "valid"],
		[
			[6824, 6829],
			"valid",
			[],
			"NV8"
		],
		[[6830, 6831], "disallowed"],
		[[6832, 6845], "valid"],
		[
			[6846, 6846],
			"valid",
			[],
			"NV8"
		],
		[[6847, 6911], "disallowed"],
		[[6912, 6987], "valid"],
		[[6988, 6991], "disallowed"],
		[[6992, 7001], "valid"],
		[
			[7002, 7018],
			"valid",
			[],
			"NV8"
		],
		[[7019, 7027], "valid"],
		[
			[7028, 7036],
			"valid",
			[],
			"NV8"
		],
		[[7037, 7039], "disallowed"],
		[[7040, 7082], "valid"],
		[[7083, 7085], "valid"],
		[[7086, 7097], "valid"],
		[[7098, 7103], "valid"],
		[[7104, 7155], "valid"],
		[[7156, 7163], "disallowed"],
		[
			[7164, 7167],
			"valid",
			[],
			"NV8"
		],
		[[7168, 7223], "valid"],
		[[7224, 7226], "disallowed"],
		[
			[7227, 7231],
			"valid",
			[],
			"NV8"
		],
		[[7232, 7241], "valid"],
		[[7242, 7244], "disallowed"],
		[[7245, 7293], "valid"],
		[
			[7294, 7295],
			"valid",
			[],
			"NV8"
		],
		[[7296, 7359], "disallowed"],
		[
			[7360, 7367],
			"valid",
			[],
			"NV8"
		],
		[[7368, 7375], "disallowed"],
		[[7376, 7378], "valid"],
		[
			[7379, 7379],
			"valid",
			[],
			"NV8"
		],
		[[7380, 7410], "valid"],
		[[7411, 7414], "valid"],
		[[7415, 7415], "disallowed"],
		[[7416, 7417], "valid"],
		[[7418, 7423], "disallowed"],
		[[7424, 7467], "valid"],
		[
			[7468, 7468],
			"mapped",
			[97]
		],
		[
			[7469, 7469],
			"mapped",
			[230]
		],
		[
			[7470, 7470],
			"mapped",
			[98]
		],
		[[7471, 7471], "valid"],
		[
			[7472, 7472],
			"mapped",
			[100]
		],
		[
			[7473, 7473],
			"mapped",
			[101]
		],
		[
			[7474, 7474],
			"mapped",
			[477]
		],
		[
			[7475, 7475],
			"mapped",
			[103]
		],
		[
			[7476, 7476],
			"mapped",
			[104]
		],
		[
			[7477, 7477],
			"mapped",
			[105]
		],
		[
			[7478, 7478],
			"mapped",
			[106]
		],
		[
			[7479, 7479],
			"mapped",
			[107]
		],
		[
			[7480, 7480],
			"mapped",
			[108]
		],
		[
			[7481, 7481],
			"mapped",
			[109]
		],
		[
			[7482, 7482],
			"mapped",
			[110]
		],
		[[7483, 7483], "valid"],
		[
			[7484, 7484],
			"mapped",
			[111]
		],
		[
			[7485, 7485],
			"mapped",
			[547]
		],
		[
			[7486, 7486],
			"mapped",
			[112]
		],
		[
			[7487, 7487],
			"mapped",
			[114]
		],
		[
			[7488, 7488],
			"mapped",
			[116]
		],
		[
			[7489, 7489],
			"mapped",
			[117]
		],
		[
			[7490, 7490],
			"mapped",
			[119]
		],
		[
			[7491, 7491],
			"mapped",
			[97]
		],
		[
			[7492, 7492],
			"mapped",
			[592]
		],
		[
			[7493, 7493],
			"mapped",
			[593]
		],
		[
			[7494, 7494],
			"mapped",
			[7426]
		],
		[
			[7495, 7495],
			"mapped",
			[98]
		],
		[
			[7496, 7496],
			"mapped",
			[100]
		],
		[
			[7497, 7497],
			"mapped",
			[101]
		],
		[
			[7498, 7498],
			"mapped",
			[601]
		],
		[
			[7499, 7499],
			"mapped",
			[603]
		],
		[
			[7500, 7500],
			"mapped",
			[604]
		],
		[
			[7501, 7501],
			"mapped",
			[103]
		],
		[[7502, 7502], "valid"],
		[
			[7503, 7503],
			"mapped",
			[107]
		],
		[
			[7504, 7504],
			"mapped",
			[109]
		],
		[
			[7505, 7505],
			"mapped",
			[331]
		],
		[
			[7506, 7506],
			"mapped",
			[111]
		],
		[
			[7507, 7507],
			"mapped",
			[596]
		],
		[
			[7508, 7508],
			"mapped",
			[7446]
		],
		[
			[7509, 7509],
			"mapped",
			[7447]
		],
		[
			[7510, 7510],
			"mapped",
			[112]
		],
		[
			[7511, 7511],
			"mapped",
			[116]
		],
		[
			[7512, 7512],
			"mapped",
			[117]
		],
		[
			[7513, 7513],
			"mapped",
			[7453]
		],
		[
			[7514, 7514],
			"mapped",
			[623]
		],
		[
			[7515, 7515],
			"mapped",
			[118]
		],
		[
			[7516, 7516],
			"mapped",
			[7461]
		],
		[
			[7517, 7517],
			"mapped",
			[946]
		],
		[
			[7518, 7518],
			"mapped",
			[947]
		],
		[
			[7519, 7519],
			"mapped",
			[948]
		],
		[
			[7520, 7520],
			"mapped",
			[966]
		],
		[
			[7521, 7521],
			"mapped",
			[967]
		],
		[
			[7522, 7522],
			"mapped",
			[105]
		],
		[
			[7523, 7523],
			"mapped",
			[114]
		],
		[
			[7524, 7524],
			"mapped",
			[117]
		],
		[
			[7525, 7525],
			"mapped",
			[118]
		],
		[
			[7526, 7526],
			"mapped",
			[946]
		],
		[
			[7527, 7527],
			"mapped",
			[947]
		],
		[
			[7528, 7528],
			"mapped",
			[961]
		],
		[
			[7529, 7529],
			"mapped",
			[966]
		],
		[
			[7530, 7530],
			"mapped",
			[967]
		],
		[[7531, 7531], "valid"],
		[[7532, 7543], "valid"],
		[
			[7544, 7544],
			"mapped",
			[1085]
		],
		[[7545, 7578], "valid"],
		[
			[7579, 7579],
			"mapped",
			[594]
		],
		[
			[7580, 7580],
			"mapped",
			[99]
		],
		[
			[7581, 7581],
			"mapped",
			[597]
		],
		[
			[7582, 7582],
			"mapped",
			[240]
		],
		[
			[7583, 7583],
			"mapped",
			[604]
		],
		[
			[7584, 7584],
			"mapped",
			[102]
		],
		[
			[7585, 7585],
			"mapped",
			[607]
		],
		[
			[7586, 7586],
			"mapped",
			[609]
		],
		[
			[7587, 7587],
			"mapped",
			[613]
		],
		[
			[7588, 7588],
			"mapped",
			[616]
		],
		[
			[7589, 7589],
			"mapped",
			[617]
		],
		[
			[7590, 7590],
			"mapped",
			[618]
		],
		[
			[7591, 7591],
			"mapped",
			[7547]
		],
		[
			[7592, 7592],
			"mapped",
			[669]
		],
		[
			[7593, 7593],
			"mapped",
			[621]
		],
		[
			[7594, 7594],
			"mapped",
			[7557]
		],
		[
			[7595, 7595],
			"mapped",
			[671]
		],
		[
			[7596, 7596],
			"mapped",
			[625]
		],
		[
			[7597, 7597],
			"mapped",
			[624]
		],
		[
			[7598, 7598],
			"mapped",
			[626]
		],
		[
			[7599, 7599],
			"mapped",
			[627]
		],
		[
			[7600, 7600],
			"mapped",
			[628]
		],
		[
			[7601, 7601],
			"mapped",
			[629]
		],
		[
			[7602, 7602],
			"mapped",
			[632]
		],
		[
			[7603, 7603],
			"mapped",
			[642]
		],
		[
			[7604, 7604],
			"mapped",
			[643]
		],
		[
			[7605, 7605],
			"mapped",
			[427]
		],
		[
			[7606, 7606],
			"mapped",
			[649]
		],
		[
			[7607, 7607],
			"mapped",
			[650]
		],
		[
			[7608, 7608],
			"mapped",
			[7452]
		],
		[
			[7609, 7609],
			"mapped",
			[651]
		],
		[
			[7610, 7610],
			"mapped",
			[652]
		],
		[
			[7611, 7611],
			"mapped",
			[122]
		],
		[
			[7612, 7612],
			"mapped",
			[656]
		],
		[
			[7613, 7613],
			"mapped",
			[657]
		],
		[
			[7614, 7614],
			"mapped",
			[658]
		],
		[
			[7615, 7615],
			"mapped",
			[952]
		],
		[[7616, 7619], "valid"],
		[[7620, 7626], "valid"],
		[[7627, 7654], "valid"],
		[[7655, 7669], "valid"],
		[[7670, 7675], "disallowed"],
		[[7676, 7676], "valid"],
		[[7677, 7677], "valid"],
		[[7678, 7679], "valid"],
		[
			[7680, 7680],
			"mapped",
			[7681]
		],
		[[7681, 7681], "valid"],
		[
			[7682, 7682],
			"mapped",
			[7683]
		],
		[[7683, 7683], "valid"],
		[
			[7684, 7684],
			"mapped",
			[7685]
		],
		[[7685, 7685], "valid"],
		[
			[7686, 7686],
			"mapped",
			[7687]
		],
		[[7687, 7687], "valid"],
		[
			[7688, 7688],
			"mapped",
			[7689]
		],
		[[7689, 7689], "valid"],
		[
			[7690, 7690],
			"mapped",
			[7691]
		],
		[[7691, 7691], "valid"],
		[
			[7692, 7692],
			"mapped",
			[7693]
		],
		[[7693, 7693], "valid"],
		[
			[7694, 7694],
			"mapped",
			[7695]
		],
		[[7695, 7695], "valid"],
		[
			[7696, 7696],
			"mapped",
			[7697]
		],
		[[7697, 7697], "valid"],
		[
			[7698, 7698],
			"mapped",
			[7699]
		],
		[[7699, 7699], "valid"],
		[
			[7700, 7700],
			"mapped",
			[7701]
		],
		[[7701, 7701], "valid"],
		[
			[7702, 7702],
			"mapped",
			[7703]
		],
		[[7703, 7703], "valid"],
		[
			[7704, 7704],
			"mapped",
			[7705]
		],
		[[7705, 7705], "valid"],
		[
			[7706, 7706],
			"mapped",
			[7707]
		],
		[[7707, 7707], "valid"],
		[
			[7708, 7708],
			"mapped",
			[7709]
		],
		[[7709, 7709], "valid"],
		[
			[7710, 7710],
			"mapped",
			[7711]
		],
		[[7711, 7711], "valid"],
		[
			[7712, 7712],
			"mapped",
			[7713]
		],
		[[7713, 7713], "valid"],
		[
			[7714, 7714],
			"mapped",
			[7715]
		],
		[[7715, 7715], "valid"],
		[
			[7716, 7716],
			"mapped",
			[7717]
		],
		[[7717, 7717], "valid"],
		[
			[7718, 7718],
			"mapped",
			[7719]
		],
		[[7719, 7719], "valid"],
		[
			[7720, 7720],
			"mapped",
			[7721]
		],
		[[7721, 7721], "valid"],
		[
			[7722, 7722],
			"mapped",
			[7723]
		],
		[[7723, 7723], "valid"],
		[
			[7724, 7724],
			"mapped",
			[7725]
		],
		[[7725, 7725], "valid"],
		[
			[7726, 7726],
			"mapped",
			[7727]
		],
		[[7727, 7727], "valid"],
		[
			[7728, 7728],
			"mapped",
			[7729]
		],
		[[7729, 7729], "valid"],
		[
			[7730, 7730],
			"mapped",
			[7731]
		],
		[[7731, 7731], "valid"],
		[
			[7732, 7732],
			"mapped",
			[7733]
		],
		[[7733, 7733], "valid"],
		[
			[7734, 7734],
			"mapped",
			[7735]
		],
		[[7735, 7735], "valid"],
		[
			[7736, 7736],
			"mapped",
			[7737]
		],
		[[7737, 7737], "valid"],
		[
			[7738, 7738],
			"mapped",
			[7739]
		],
		[[7739, 7739], "valid"],
		[
			[7740, 7740],
			"mapped",
			[7741]
		],
		[[7741, 7741], "valid"],
		[
			[7742, 7742],
			"mapped",
			[7743]
		],
		[[7743, 7743], "valid"],
		[
			[7744, 7744],
			"mapped",
			[7745]
		],
		[[7745, 7745], "valid"],
		[
			[7746, 7746],
			"mapped",
			[7747]
		],
		[[7747, 7747], "valid"],
		[
			[7748, 7748],
			"mapped",
			[7749]
		],
		[[7749, 7749], "valid"],
		[
			[7750, 7750],
			"mapped",
			[7751]
		],
		[[7751, 7751], "valid"],
		[
			[7752, 7752],
			"mapped",
			[7753]
		],
		[[7753, 7753], "valid"],
		[
			[7754, 7754],
			"mapped",
			[7755]
		],
		[[7755, 7755], "valid"],
		[
			[7756, 7756],
			"mapped",
			[7757]
		],
		[[7757, 7757], "valid"],
		[
			[7758, 7758],
			"mapped",
			[7759]
		],
		[[7759, 7759], "valid"],
		[
			[7760, 7760],
			"mapped",
			[7761]
		],
		[[7761, 7761], "valid"],
		[
			[7762, 7762],
			"mapped",
			[7763]
		],
		[[7763, 7763], "valid"],
		[
			[7764, 7764],
			"mapped",
			[7765]
		],
		[[7765, 7765], "valid"],
		[
			[7766, 7766],
			"mapped",
			[7767]
		],
		[[7767, 7767], "valid"],
		[
			[7768, 7768],
			"mapped",
			[7769]
		],
		[[7769, 7769], "valid"],
		[
			[7770, 7770],
			"mapped",
			[7771]
		],
		[[7771, 7771], "valid"],
		[
			[7772, 7772],
			"mapped",
			[7773]
		],
		[[7773, 7773], "valid"],
		[
			[7774, 7774],
			"mapped",
			[7775]
		],
		[[7775, 7775], "valid"],
		[
			[7776, 7776],
			"mapped",
			[7777]
		],
		[[7777, 7777], "valid"],
		[
			[7778, 7778],
			"mapped",
			[7779]
		],
		[[7779, 7779], "valid"],
		[
			[7780, 7780],
			"mapped",
			[7781]
		],
		[[7781, 7781], "valid"],
		[
			[7782, 7782],
			"mapped",
			[7783]
		],
		[[7783, 7783], "valid"],
		[
			[7784, 7784],
			"mapped",
			[7785]
		],
		[[7785, 7785], "valid"],
		[
			[7786, 7786],
			"mapped",
			[7787]
		],
		[[7787, 7787], "valid"],
		[
			[7788, 7788],
			"mapped",
			[7789]
		],
		[[7789, 7789], "valid"],
		[
			[7790, 7790],
			"mapped",
			[7791]
		],
		[[7791, 7791], "valid"],
		[
			[7792, 7792],
			"mapped",
			[7793]
		],
		[[7793, 7793], "valid"],
		[
			[7794, 7794],
			"mapped",
			[7795]
		],
		[[7795, 7795], "valid"],
		[
			[7796, 7796],
			"mapped",
			[7797]
		],
		[[7797, 7797], "valid"],
		[
			[7798, 7798],
			"mapped",
			[7799]
		],
		[[7799, 7799], "valid"],
		[
			[7800, 7800],
			"mapped",
			[7801]
		],
		[[7801, 7801], "valid"],
		[
			[7802, 7802],
			"mapped",
			[7803]
		],
		[[7803, 7803], "valid"],
		[
			[7804, 7804],
			"mapped",
			[7805]
		],
		[[7805, 7805], "valid"],
		[
			[7806, 7806],
			"mapped",
			[7807]
		],
		[[7807, 7807], "valid"],
		[
			[7808, 7808],
			"mapped",
			[7809]
		],
		[[7809, 7809], "valid"],
		[
			[7810, 7810],
			"mapped",
			[7811]
		],
		[[7811, 7811], "valid"],
		[
			[7812, 7812],
			"mapped",
			[7813]
		],
		[[7813, 7813], "valid"],
		[
			[7814, 7814],
			"mapped",
			[7815]
		],
		[[7815, 7815], "valid"],
		[
			[7816, 7816],
			"mapped",
			[7817]
		],
		[[7817, 7817], "valid"],
		[
			[7818, 7818],
			"mapped",
			[7819]
		],
		[[7819, 7819], "valid"],
		[
			[7820, 7820],
			"mapped",
			[7821]
		],
		[[7821, 7821], "valid"],
		[
			[7822, 7822],
			"mapped",
			[7823]
		],
		[[7823, 7823], "valid"],
		[
			[7824, 7824],
			"mapped",
			[7825]
		],
		[[7825, 7825], "valid"],
		[
			[7826, 7826],
			"mapped",
			[7827]
		],
		[[7827, 7827], "valid"],
		[
			[7828, 7828],
			"mapped",
			[7829]
		],
		[[7829, 7833], "valid"],
		[
			[7834, 7834],
			"mapped",
			[97, 702]
		],
		[
			[7835, 7835],
			"mapped",
			[7777]
		],
		[[7836, 7837], "valid"],
		[
			[7838, 7838],
			"mapped",
			[115, 115]
		],
		[[7839, 7839], "valid"],
		[
			[7840, 7840],
			"mapped",
			[7841]
		],
		[[7841, 7841], "valid"],
		[
			[7842, 7842],
			"mapped",
			[7843]
		],
		[[7843, 7843], "valid"],
		[
			[7844, 7844],
			"mapped",
			[7845]
		],
		[[7845, 7845], "valid"],
		[
			[7846, 7846],
			"mapped",
			[7847]
		],
		[[7847, 7847], "valid"],
		[
			[7848, 7848],
			"mapped",
			[7849]
		],
		[[7849, 7849], "valid"],
		[
			[7850, 7850],
			"mapped",
			[7851]
		],
		[[7851, 7851], "valid"],
		[
			[7852, 7852],
			"mapped",
			[7853]
		],
		[[7853, 7853], "valid"],
		[
			[7854, 7854],
			"mapped",
			[7855]
		],
		[[7855, 7855], "valid"],
		[
			[7856, 7856],
			"mapped",
			[7857]
		],
		[[7857, 7857], "valid"],
		[
			[7858, 7858],
			"mapped",
			[7859]
		],
		[[7859, 7859], "valid"],
		[
			[7860, 7860],
			"mapped",
			[7861]
		],
		[[7861, 7861], "valid"],
		[
			[7862, 7862],
			"mapped",
			[7863]
		],
		[[7863, 7863], "valid"],
		[
			[7864, 7864],
			"mapped",
			[7865]
		],
		[[7865, 7865], "valid"],
		[
			[7866, 7866],
			"mapped",
			[7867]
		],
		[[7867, 7867], "valid"],
		[
			[7868, 7868],
			"mapped",
			[7869]
		],
		[[7869, 7869], "valid"],
		[
			[7870, 7870],
			"mapped",
			[7871]
		],
		[[7871, 7871], "valid"],
		[
			[7872, 7872],
			"mapped",
			[7873]
		],
		[[7873, 7873], "valid"],
		[
			[7874, 7874],
			"mapped",
			[7875]
		],
		[[7875, 7875], "valid"],
		[
			[7876, 7876],
			"mapped",
			[7877]
		],
		[[7877, 7877], "valid"],
		[
			[7878, 7878],
			"mapped",
			[7879]
		],
		[[7879, 7879], "valid"],
		[
			[7880, 7880],
			"mapped",
			[7881]
		],
		[[7881, 7881], "valid"],
		[
			[7882, 7882],
			"mapped",
			[7883]
		],
		[[7883, 7883], "valid"],
		[
			[7884, 7884],
			"mapped",
			[7885]
		],
		[[7885, 7885], "valid"],
		[
			[7886, 7886],
			"mapped",
			[7887]
		],
		[[7887, 7887], "valid"],
		[
			[7888, 7888],
			"mapped",
			[7889]
		],
		[[7889, 7889], "valid"],
		[
			[7890, 7890],
			"mapped",
			[7891]
		],
		[[7891, 7891], "valid"],
		[
			[7892, 7892],
			"mapped",
			[7893]
		],
		[[7893, 7893], "valid"],
		[
			[7894, 7894],
			"mapped",
			[7895]
		],
		[[7895, 7895], "valid"],
		[
			[7896, 7896],
			"mapped",
			[7897]
		],
		[[7897, 7897], "valid"],
		[
			[7898, 7898],
			"mapped",
			[7899]
		],
		[[7899, 7899], "valid"],
		[
			[7900, 7900],
			"mapped",
			[7901]
		],
		[[7901, 7901], "valid"],
		[
			[7902, 7902],
			"mapped",
			[7903]
		],
		[[7903, 7903], "valid"],
		[
			[7904, 7904],
			"mapped",
			[7905]
		],
		[[7905, 7905], "valid"],
		[
			[7906, 7906],
			"mapped",
			[7907]
		],
		[[7907, 7907], "valid"],
		[
			[7908, 7908],
			"mapped",
			[7909]
		],
		[[7909, 7909], "valid"],
		[
			[7910, 7910],
			"mapped",
			[7911]
		],
		[[7911, 7911], "valid"],
		[
			[7912, 7912],
			"mapped",
			[7913]
		],
		[[7913, 7913], "valid"],
		[
			[7914, 7914],
			"mapped",
			[7915]
		],
		[[7915, 7915], "valid"],
		[
			[7916, 7916],
			"mapped",
			[7917]
		],
		[[7917, 7917], "valid"],
		[
			[7918, 7918],
			"mapped",
			[7919]
		],
		[[7919, 7919], "valid"],
		[
			[7920, 7920],
			"mapped",
			[7921]
		],
		[[7921, 7921], "valid"],
		[
			[7922, 7922],
			"mapped",
			[7923]
		],
		[[7923, 7923], "valid"],
		[
			[7924, 7924],
			"mapped",
			[7925]
		],
		[[7925, 7925], "valid"],
		[
			[7926, 7926],
			"mapped",
			[7927]
		],
		[[7927, 7927], "valid"],
		[
			[7928, 7928],
			"mapped",
			[7929]
		],
		[[7929, 7929], "valid"],
		[
			[7930, 7930],
			"mapped",
			[7931]
		],
		[[7931, 7931], "valid"],
		[
			[7932, 7932],
			"mapped",
			[7933]
		],
		[[7933, 7933], "valid"],
		[
			[7934, 7934],
			"mapped",
			[7935]
		],
		[[7935, 7935], "valid"],
		[[7936, 7943], "valid"],
		[
			[7944, 7944],
			"mapped",
			[7936]
		],
		[
			[7945, 7945],
			"mapped",
			[7937]
		],
		[
			[7946, 7946],
			"mapped",
			[7938]
		],
		[
			[7947, 7947],
			"mapped",
			[7939]
		],
		[
			[7948, 7948],
			"mapped",
			[7940]
		],
		[
			[7949, 7949],
			"mapped",
			[7941]
		],
		[
			[7950, 7950],
			"mapped",
			[7942]
		],
		[
			[7951, 7951],
			"mapped",
			[7943]
		],
		[[7952, 7957], "valid"],
		[[7958, 7959], "disallowed"],
		[
			[7960, 7960],
			"mapped",
			[7952]
		],
		[
			[7961, 7961],
			"mapped",
			[7953]
		],
		[
			[7962, 7962],
			"mapped",
			[7954]
		],
		[
			[7963, 7963],
			"mapped",
			[7955]
		],
		[
			[7964, 7964],
			"mapped",
			[7956]
		],
		[
			[7965, 7965],
			"mapped",
			[7957]
		],
		[[7966, 7967], "disallowed"],
		[[7968, 7975], "valid"],
		[
			[7976, 7976],
			"mapped",
			[7968]
		],
		[
			[7977, 7977],
			"mapped",
			[7969]
		],
		[
			[7978, 7978],
			"mapped",
			[7970]
		],
		[
			[7979, 7979],
			"mapped",
			[7971]
		],
		[
			[7980, 7980],
			"mapped",
			[7972]
		],
		[
			[7981, 7981],
			"mapped",
			[7973]
		],
		[
			[7982, 7982],
			"mapped",
			[7974]
		],
		[
			[7983, 7983],
			"mapped",
			[7975]
		],
		[[7984, 7991], "valid"],
		[
			[7992, 7992],
			"mapped",
			[7984]
		],
		[
			[7993, 7993],
			"mapped",
			[7985]
		],
		[
			[7994, 7994],
			"mapped",
			[7986]
		],
		[
			[7995, 7995],
			"mapped",
			[7987]
		],
		[
			[7996, 7996],
			"mapped",
			[7988]
		],
		[
			[7997, 7997],
			"mapped",
			[7989]
		],
		[
			[7998, 7998],
			"mapped",
			[7990]
		],
		[
			[7999, 7999],
			"mapped",
			[7991]
		],
		[[8e3, 8005], "valid"],
		[[8006, 8007], "disallowed"],
		[
			[8008, 8008],
			"mapped",
			[8e3]
		],
		[
			[8009, 8009],
			"mapped",
			[8001]
		],
		[
			[8010, 8010],
			"mapped",
			[8002]
		],
		[
			[8011, 8011],
			"mapped",
			[8003]
		],
		[
			[8012, 8012],
			"mapped",
			[8004]
		],
		[
			[8013, 8013],
			"mapped",
			[8005]
		],
		[[8014, 8015], "disallowed"],
		[[8016, 8023], "valid"],
		[[8024, 8024], "disallowed"],
		[
			[8025, 8025],
			"mapped",
			[8017]
		],
		[[8026, 8026], "disallowed"],
		[
			[8027, 8027],
			"mapped",
			[8019]
		],
		[[8028, 8028], "disallowed"],
		[
			[8029, 8029],
			"mapped",
			[8021]
		],
		[[8030, 8030], "disallowed"],
		[
			[8031, 8031],
			"mapped",
			[8023]
		],
		[[8032, 8039], "valid"],
		[
			[8040, 8040],
			"mapped",
			[8032]
		],
		[
			[8041, 8041],
			"mapped",
			[8033]
		],
		[
			[8042, 8042],
			"mapped",
			[8034]
		],
		[
			[8043, 8043],
			"mapped",
			[8035]
		],
		[
			[8044, 8044],
			"mapped",
			[8036]
		],
		[
			[8045, 8045],
			"mapped",
			[8037]
		],
		[
			[8046, 8046],
			"mapped",
			[8038]
		],
		[
			[8047, 8047],
			"mapped",
			[8039]
		],
		[[8048, 8048], "valid"],
		[
			[8049, 8049],
			"mapped",
			[940]
		],
		[[8050, 8050], "valid"],
		[
			[8051, 8051],
			"mapped",
			[941]
		],
		[[8052, 8052], "valid"],
		[
			[8053, 8053],
			"mapped",
			[942]
		],
		[[8054, 8054], "valid"],
		[
			[8055, 8055],
			"mapped",
			[943]
		],
		[[8056, 8056], "valid"],
		[
			[8057, 8057],
			"mapped",
			[972]
		],
		[[8058, 8058], "valid"],
		[
			[8059, 8059],
			"mapped",
			[973]
		],
		[[8060, 8060], "valid"],
		[
			[8061, 8061],
			"mapped",
			[974]
		],
		[[8062, 8063], "disallowed"],
		[
			[8064, 8064],
			"mapped",
			[7936, 953]
		],
		[
			[8065, 8065],
			"mapped",
			[7937, 953]
		],
		[
			[8066, 8066],
			"mapped",
			[7938, 953]
		],
		[
			[8067, 8067],
			"mapped",
			[7939, 953]
		],
		[
			[8068, 8068],
			"mapped",
			[7940, 953]
		],
		[
			[8069, 8069],
			"mapped",
			[7941, 953]
		],
		[
			[8070, 8070],
			"mapped",
			[7942, 953]
		],
		[
			[8071, 8071],
			"mapped",
			[7943, 953]
		],
		[
			[8072, 8072],
			"mapped",
			[7936, 953]
		],
		[
			[8073, 8073],
			"mapped",
			[7937, 953]
		],
		[
			[8074, 8074],
			"mapped",
			[7938, 953]
		],
		[
			[8075, 8075],
			"mapped",
			[7939, 953]
		],
		[
			[8076, 8076],
			"mapped",
			[7940, 953]
		],
		[
			[8077, 8077],
			"mapped",
			[7941, 953]
		],
		[
			[8078, 8078],
			"mapped",
			[7942, 953]
		],
		[
			[8079, 8079],
			"mapped",
			[7943, 953]
		],
		[
			[8080, 8080],
			"mapped",
			[7968, 953]
		],
		[
			[8081, 8081],
			"mapped",
			[7969, 953]
		],
		[
			[8082, 8082],
			"mapped",
			[7970, 953]
		],
		[
			[8083, 8083],
			"mapped",
			[7971, 953]
		],
		[
			[8084, 8084],
			"mapped",
			[7972, 953]
		],
		[
			[8085, 8085],
			"mapped",
			[7973, 953]
		],
		[
			[8086, 8086],
			"mapped",
			[7974, 953]
		],
		[
			[8087, 8087],
			"mapped",
			[7975, 953]
		],
		[
			[8088, 8088],
			"mapped",
			[7968, 953]
		],
		[
			[8089, 8089],
			"mapped",
			[7969, 953]
		],
		[
			[8090, 8090],
			"mapped",
			[7970, 953]
		],
		[
			[8091, 8091],
			"mapped",
			[7971, 953]
		],
		[
			[8092, 8092],
			"mapped",
			[7972, 953]
		],
		[
			[8093, 8093],
			"mapped",
			[7973, 953]
		],
		[
			[8094, 8094],
			"mapped",
			[7974, 953]
		],
		[
			[8095, 8095],
			"mapped",
			[7975, 953]
		],
		[
			[8096, 8096],
			"mapped",
			[8032, 953]
		],
		[
			[8097, 8097],
			"mapped",
			[8033, 953]
		],
		[
			[8098, 8098],
			"mapped",
			[8034, 953]
		],
		[
			[8099, 8099],
			"mapped",
			[8035, 953]
		],
		[
			[8100, 8100],
			"mapped",
			[8036, 953]
		],
		[
			[8101, 8101],
			"mapped",
			[8037, 953]
		],
		[
			[8102, 8102],
			"mapped",
			[8038, 953]
		],
		[
			[8103, 8103],
			"mapped",
			[8039, 953]
		],
		[
			[8104, 8104],
			"mapped",
			[8032, 953]
		],
		[
			[8105, 8105],
			"mapped",
			[8033, 953]
		],
		[
			[8106, 8106],
			"mapped",
			[8034, 953]
		],
		[
			[8107, 8107],
			"mapped",
			[8035, 953]
		],
		[
			[8108, 8108],
			"mapped",
			[8036, 953]
		],
		[
			[8109, 8109],
			"mapped",
			[8037, 953]
		],
		[
			[8110, 8110],
			"mapped",
			[8038, 953]
		],
		[
			[8111, 8111],
			"mapped",
			[8039, 953]
		],
		[[8112, 8113], "valid"],
		[
			[8114, 8114],
			"mapped",
			[8048, 953]
		],
		[
			[8115, 8115],
			"mapped",
			[945, 953]
		],
		[
			[8116, 8116],
			"mapped",
			[940, 953]
		],
		[[8117, 8117], "disallowed"],
		[[8118, 8118], "valid"],
		[
			[8119, 8119],
			"mapped",
			[8118, 953]
		],
		[
			[8120, 8120],
			"mapped",
			[8112]
		],
		[
			[8121, 8121],
			"mapped",
			[8113]
		],
		[
			[8122, 8122],
			"mapped",
			[8048]
		],
		[
			[8123, 8123],
			"mapped",
			[940]
		],
		[
			[8124, 8124],
			"mapped",
			[945, 953]
		],
		[
			[8125, 8125],
			"disallowed_STD3_mapped",
			[32, 787]
		],
		[
			[8126, 8126],
			"mapped",
			[953]
		],
		[
			[8127, 8127],
			"disallowed_STD3_mapped",
			[32, 787]
		],
		[
			[8128, 8128],
			"disallowed_STD3_mapped",
			[32, 834]
		],
		[
			[8129, 8129],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				834
			]
		],
		[
			[8130, 8130],
			"mapped",
			[8052, 953]
		],
		[
			[8131, 8131],
			"mapped",
			[951, 953]
		],
		[
			[8132, 8132],
			"mapped",
			[942, 953]
		],
		[[8133, 8133], "disallowed"],
		[[8134, 8134], "valid"],
		[
			[8135, 8135],
			"mapped",
			[8134, 953]
		],
		[
			[8136, 8136],
			"mapped",
			[8050]
		],
		[
			[8137, 8137],
			"mapped",
			[941]
		],
		[
			[8138, 8138],
			"mapped",
			[8052]
		],
		[
			[8139, 8139],
			"mapped",
			[942]
		],
		[
			[8140, 8140],
			"mapped",
			[951, 953]
		],
		[
			[8141, 8141],
			"disallowed_STD3_mapped",
			[
				32,
				787,
				768
			]
		],
		[
			[8142, 8142],
			"disallowed_STD3_mapped",
			[
				32,
				787,
				769
			]
		],
		[
			[8143, 8143],
			"disallowed_STD3_mapped",
			[
				32,
				787,
				834
			]
		],
		[[8144, 8146], "valid"],
		[
			[8147, 8147],
			"mapped",
			[912]
		],
		[[8148, 8149], "disallowed"],
		[[8150, 8151], "valid"],
		[
			[8152, 8152],
			"mapped",
			[8144]
		],
		[
			[8153, 8153],
			"mapped",
			[8145]
		],
		[
			[8154, 8154],
			"mapped",
			[8054]
		],
		[
			[8155, 8155],
			"mapped",
			[943]
		],
		[[8156, 8156], "disallowed"],
		[
			[8157, 8157],
			"disallowed_STD3_mapped",
			[
				32,
				788,
				768
			]
		],
		[
			[8158, 8158],
			"disallowed_STD3_mapped",
			[
				32,
				788,
				769
			]
		],
		[
			[8159, 8159],
			"disallowed_STD3_mapped",
			[
				32,
				788,
				834
			]
		],
		[[8160, 8162], "valid"],
		[
			[8163, 8163],
			"mapped",
			[944]
		],
		[[8164, 8167], "valid"],
		[
			[8168, 8168],
			"mapped",
			[8160]
		],
		[
			[8169, 8169],
			"mapped",
			[8161]
		],
		[
			[8170, 8170],
			"mapped",
			[8058]
		],
		[
			[8171, 8171],
			"mapped",
			[973]
		],
		[
			[8172, 8172],
			"mapped",
			[8165]
		],
		[
			[8173, 8173],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				768
			]
		],
		[
			[8174, 8174],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				769
			]
		],
		[
			[8175, 8175],
			"disallowed_STD3_mapped",
			[96]
		],
		[[8176, 8177], "disallowed"],
		[
			[8178, 8178],
			"mapped",
			[8060, 953]
		],
		[
			[8179, 8179],
			"mapped",
			[969, 953]
		],
		[
			[8180, 8180],
			"mapped",
			[974, 953]
		],
		[[8181, 8181], "disallowed"],
		[[8182, 8182], "valid"],
		[
			[8183, 8183],
			"mapped",
			[8182, 953]
		],
		[
			[8184, 8184],
			"mapped",
			[8056]
		],
		[
			[8185, 8185],
			"mapped",
			[972]
		],
		[
			[8186, 8186],
			"mapped",
			[8060]
		],
		[
			[8187, 8187],
			"mapped",
			[974]
		],
		[
			[8188, 8188],
			"mapped",
			[969, 953]
		],
		[
			[8189, 8189],
			"disallowed_STD3_mapped",
			[32, 769]
		],
		[
			[8190, 8190],
			"disallowed_STD3_mapped",
			[32, 788]
		],
		[[8191, 8191], "disallowed"],
		[
			[8192, 8202],
			"disallowed_STD3_mapped",
			[32]
		],
		[[8203, 8203], "ignored"],
		[
			[8204, 8205],
			"deviation",
			[]
		],
		[[8206, 8207], "disallowed"],
		[
			[8208, 8208],
			"valid",
			[],
			"NV8"
		],
		[
			[8209, 8209],
			"mapped",
			[8208]
		],
		[
			[8210, 8214],
			"valid",
			[],
			"NV8"
		],
		[
			[8215, 8215],
			"disallowed_STD3_mapped",
			[32, 819]
		],
		[
			[8216, 8227],
			"valid",
			[],
			"NV8"
		],
		[[8228, 8230], "disallowed"],
		[
			[8231, 8231],
			"valid",
			[],
			"NV8"
		],
		[[8232, 8238], "disallowed"],
		[
			[8239, 8239],
			"disallowed_STD3_mapped",
			[32]
		],
		[
			[8240, 8242],
			"valid",
			[],
			"NV8"
		],
		[
			[8243, 8243],
			"mapped",
			[8242, 8242]
		],
		[
			[8244, 8244],
			"mapped",
			[
				8242,
				8242,
				8242
			]
		],
		[
			[8245, 8245],
			"valid",
			[],
			"NV8"
		],
		[
			[8246, 8246],
			"mapped",
			[8245, 8245]
		],
		[
			[8247, 8247],
			"mapped",
			[
				8245,
				8245,
				8245
			]
		],
		[
			[8248, 8251],
			"valid",
			[],
			"NV8"
		],
		[
			[8252, 8252],
			"disallowed_STD3_mapped",
			[33, 33]
		],
		[
			[8253, 8253],
			"valid",
			[],
			"NV8"
		],
		[
			[8254, 8254],
			"disallowed_STD3_mapped",
			[32, 773]
		],
		[
			[8255, 8262],
			"valid",
			[],
			"NV8"
		],
		[
			[8263, 8263],
			"disallowed_STD3_mapped",
			[63, 63]
		],
		[
			[8264, 8264],
			"disallowed_STD3_mapped",
			[63, 33]
		],
		[
			[8265, 8265],
			"disallowed_STD3_mapped",
			[33, 63]
		],
		[
			[8266, 8269],
			"valid",
			[],
			"NV8"
		],
		[
			[8270, 8274],
			"valid",
			[],
			"NV8"
		],
		[
			[8275, 8276],
			"valid",
			[],
			"NV8"
		],
		[
			[8277, 8278],
			"valid",
			[],
			"NV8"
		],
		[
			[8279, 8279],
			"mapped",
			[
				8242,
				8242,
				8242,
				8242
			]
		],
		[
			[8280, 8286],
			"valid",
			[],
			"NV8"
		],
		[
			[8287, 8287],
			"disallowed_STD3_mapped",
			[32]
		],
		[[8288, 8288], "ignored"],
		[[8289, 8291], "disallowed"],
		[[8292, 8292], "ignored"],
		[[8293, 8293], "disallowed"],
		[[8294, 8297], "disallowed"],
		[[8298, 8303], "disallowed"],
		[
			[8304, 8304],
			"mapped",
			[48]
		],
		[
			[8305, 8305],
			"mapped",
			[105]
		],
		[[8306, 8307], "disallowed"],
		[
			[8308, 8308],
			"mapped",
			[52]
		],
		[
			[8309, 8309],
			"mapped",
			[53]
		],
		[
			[8310, 8310],
			"mapped",
			[54]
		],
		[
			[8311, 8311],
			"mapped",
			[55]
		],
		[
			[8312, 8312],
			"mapped",
			[56]
		],
		[
			[8313, 8313],
			"mapped",
			[57]
		],
		[
			[8314, 8314],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[8315, 8315],
			"mapped",
			[8722]
		],
		[
			[8316, 8316],
			"disallowed_STD3_mapped",
			[61]
		],
		[
			[8317, 8317],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[8318, 8318],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[8319, 8319],
			"mapped",
			[110]
		],
		[
			[8320, 8320],
			"mapped",
			[48]
		],
		[
			[8321, 8321],
			"mapped",
			[49]
		],
		[
			[8322, 8322],
			"mapped",
			[50]
		],
		[
			[8323, 8323],
			"mapped",
			[51]
		],
		[
			[8324, 8324],
			"mapped",
			[52]
		],
		[
			[8325, 8325],
			"mapped",
			[53]
		],
		[
			[8326, 8326],
			"mapped",
			[54]
		],
		[
			[8327, 8327],
			"mapped",
			[55]
		],
		[
			[8328, 8328],
			"mapped",
			[56]
		],
		[
			[8329, 8329],
			"mapped",
			[57]
		],
		[
			[8330, 8330],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[8331, 8331],
			"mapped",
			[8722]
		],
		[
			[8332, 8332],
			"disallowed_STD3_mapped",
			[61]
		],
		[
			[8333, 8333],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[8334, 8334],
			"disallowed_STD3_mapped",
			[41]
		],
		[[8335, 8335], "disallowed"],
		[
			[8336, 8336],
			"mapped",
			[97]
		],
		[
			[8337, 8337],
			"mapped",
			[101]
		],
		[
			[8338, 8338],
			"mapped",
			[111]
		],
		[
			[8339, 8339],
			"mapped",
			[120]
		],
		[
			[8340, 8340],
			"mapped",
			[601]
		],
		[
			[8341, 8341],
			"mapped",
			[104]
		],
		[
			[8342, 8342],
			"mapped",
			[107]
		],
		[
			[8343, 8343],
			"mapped",
			[108]
		],
		[
			[8344, 8344],
			"mapped",
			[109]
		],
		[
			[8345, 8345],
			"mapped",
			[110]
		],
		[
			[8346, 8346],
			"mapped",
			[112]
		],
		[
			[8347, 8347],
			"mapped",
			[115]
		],
		[
			[8348, 8348],
			"mapped",
			[116]
		],
		[[8349, 8351], "disallowed"],
		[
			[8352, 8359],
			"valid",
			[],
			"NV8"
		],
		[
			[8360, 8360],
			"mapped",
			[114, 115]
		],
		[
			[8361, 8362],
			"valid",
			[],
			"NV8"
		],
		[
			[8363, 8363],
			"valid",
			[],
			"NV8"
		],
		[
			[8364, 8364],
			"valid",
			[],
			"NV8"
		],
		[
			[8365, 8367],
			"valid",
			[],
			"NV8"
		],
		[
			[8368, 8369],
			"valid",
			[],
			"NV8"
		],
		[
			[8370, 8373],
			"valid",
			[],
			"NV8"
		],
		[
			[8374, 8376],
			"valid",
			[],
			"NV8"
		],
		[
			[8377, 8377],
			"valid",
			[],
			"NV8"
		],
		[
			[8378, 8378],
			"valid",
			[],
			"NV8"
		],
		[
			[8379, 8381],
			"valid",
			[],
			"NV8"
		],
		[
			[8382, 8382],
			"valid",
			[],
			"NV8"
		],
		[[8383, 8399], "disallowed"],
		[
			[8400, 8417],
			"valid",
			[],
			"NV8"
		],
		[
			[8418, 8419],
			"valid",
			[],
			"NV8"
		],
		[
			[8420, 8426],
			"valid",
			[],
			"NV8"
		],
		[
			[8427, 8427],
			"valid",
			[],
			"NV8"
		],
		[
			[8428, 8431],
			"valid",
			[],
			"NV8"
		],
		[
			[8432, 8432],
			"valid",
			[],
			"NV8"
		],
		[[8433, 8447], "disallowed"],
		[
			[8448, 8448],
			"disallowed_STD3_mapped",
			[
				97,
				47,
				99
			]
		],
		[
			[8449, 8449],
			"disallowed_STD3_mapped",
			[
				97,
				47,
				115
			]
		],
		[
			[8450, 8450],
			"mapped",
			[99]
		],
		[
			[8451, 8451],
			"mapped",
			[176, 99]
		],
		[
			[8452, 8452],
			"valid",
			[],
			"NV8"
		],
		[
			[8453, 8453],
			"disallowed_STD3_mapped",
			[
				99,
				47,
				111
			]
		],
		[
			[8454, 8454],
			"disallowed_STD3_mapped",
			[
				99,
				47,
				117
			]
		],
		[
			[8455, 8455],
			"mapped",
			[603]
		],
		[
			[8456, 8456],
			"valid",
			[],
			"NV8"
		],
		[
			[8457, 8457],
			"mapped",
			[176, 102]
		],
		[
			[8458, 8458],
			"mapped",
			[103]
		],
		[
			[8459, 8462],
			"mapped",
			[104]
		],
		[
			[8463, 8463],
			"mapped",
			[295]
		],
		[
			[8464, 8465],
			"mapped",
			[105]
		],
		[
			[8466, 8467],
			"mapped",
			[108]
		],
		[
			[8468, 8468],
			"valid",
			[],
			"NV8"
		],
		[
			[8469, 8469],
			"mapped",
			[110]
		],
		[
			[8470, 8470],
			"mapped",
			[110, 111]
		],
		[
			[8471, 8472],
			"valid",
			[],
			"NV8"
		],
		[
			[8473, 8473],
			"mapped",
			[112]
		],
		[
			[8474, 8474],
			"mapped",
			[113]
		],
		[
			[8475, 8477],
			"mapped",
			[114]
		],
		[
			[8478, 8479],
			"valid",
			[],
			"NV8"
		],
		[
			[8480, 8480],
			"mapped",
			[115, 109]
		],
		[
			[8481, 8481],
			"mapped",
			[
				116,
				101,
				108
			]
		],
		[
			[8482, 8482],
			"mapped",
			[116, 109]
		],
		[
			[8483, 8483],
			"valid",
			[],
			"NV8"
		],
		[
			[8484, 8484],
			"mapped",
			[122]
		],
		[
			[8485, 8485],
			"valid",
			[],
			"NV8"
		],
		[
			[8486, 8486],
			"mapped",
			[969]
		],
		[
			[8487, 8487],
			"valid",
			[],
			"NV8"
		],
		[
			[8488, 8488],
			"mapped",
			[122]
		],
		[
			[8489, 8489],
			"valid",
			[],
			"NV8"
		],
		[
			[8490, 8490],
			"mapped",
			[107]
		],
		[
			[8491, 8491],
			"mapped",
			[229]
		],
		[
			[8492, 8492],
			"mapped",
			[98]
		],
		[
			[8493, 8493],
			"mapped",
			[99]
		],
		[
			[8494, 8494],
			"valid",
			[],
			"NV8"
		],
		[
			[8495, 8496],
			"mapped",
			[101]
		],
		[
			[8497, 8497],
			"mapped",
			[102]
		],
		[[8498, 8498], "disallowed"],
		[
			[8499, 8499],
			"mapped",
			[109]
		],
		[
			[8500, 8500],
			"mapped",
			[111]
		],
		[
			[8501, 8501],
			"mapped",
			[1488]
		],
		[
			[8502, 8502],
			"mapped",
			[1489]
		],
		[
			[8503, 8503],
			"mapped",
			[1490]
		],
		[
			[8504, 8504],
			"mapped",
			[1491]
		],
		[
			[8505, 8505],
			"mapped",
			[105]
		],
		[
			[8506, 8506],
			"valid",
			[],
			"NV8"
		],
		[
			[8507, 8507],
			"mapped",
			[
				102,
				97,
				120
			]
		],
		[
			[8508, 8508],
			"mapped",
			[960]
		],
		[
			[8509, 8510],
			"mapped",
			[947]
		],
		[
			[8511, 8511],
			"mapped",
			[960]
		],
		[
			[8512, 8512],
			"mapped",
			[8721]
		],
		[
			[8513, 8516],
			"valid",
			[],
			"NV8"
		],
		[
			[8517, 8518],
			"mapped",
			[100]
		],
		[
			[8519, 8519],
			"mapped",
			[101]
		],
		[
			[8520, 8520],
			"mapped",
			[105]
		],
		[
			[8521, 8521],
			"mapped",
			[106]
		],
		[
			[8522, 8523],
			"valid",
			[],
			"NV8"
		],
		[
			[8524, 8524],
			"valid",
			[],
			"NV8"
		],
		[
			[8525, 8525],
			"valid",
			[],
			"NV8"
		],
		[[8526, 8526], "valid"],
		[
			[8527, 8527],
			"valid",
			[],
			"NV8"
		],
		[
			[8528, 8528],
			"mapped",
			[
				49,
				8260,
				55
			]
		],
		[
			[8529, 8529],
			"mapped",
			[
				49,
				8260,
				57
			]
		],
		[
			[8530, 8530],
			"mapped",
			[
				49,
				8260,
				49,
				48
			]
		],
		[
			[8531, 8531],
			"mapped",
			[
				49,
				8260,
				51
			]
		],
		[
			[8532, 8532],
			"mapped",
			[
				50,
				8260,
				51
			]
		],
		[
			[8533, 8533],
			"mapped",
			[
				49,
				8260,
				53
			]
		],
		[
			[8534, 8534],
			"mapped",
			[
				50,
				8260,
				53
			]
		],
		[
			[8535, 8535],
			"mapped",
			[
				51,
				8260,
				53
			]
		],
		[
			[8536, 8536],
			"mapped",
			[
				52,
				8260,
				53
			]
		],
		[
			[8537, 8537],
			"mapped",
			[
				49,
				8260,
				54
			]
		],
		[
			[8538, 8538],
			"mapped",
			[
				53,
				8260,
				54
			]
		],
		[
			[8539, 8539],
			"mapped",
			[
				49,
				8260,
				56
			]
		],
		[
			[8540, 8540],
			"mapped",
			[
				51,
				8260,
				56
			]
		],
		[
			[8541, 8541],
			"mapped",
			[
				53,
				8260,
				56
			]
		],
		[
			[8542, 8542],
			"mapped",
			[
				55,
				8260,
				56
			]
		],
		[
			[8543, 8543],
			"mapped",
			[49, 8260]
		],
		[
			[8544, 8544],
			"mapped",
			[105]
		],
		[
			[8545, 8545],
			"mapped",
			[105, 105]
		],
		[
			[8546, 8546],
			"mapped",
			[
				105,
				105,
				105
			]
		],
		[
			[8547, 8547],
			"mapped",
			[105, 118]
		],
		[
			[8548, 8548],
			"mapped",
			[118]
		],
		[
			[8549, 8549],
			"mapped",
			[118, 105]
		],
		[
			[8550, 8550],
			"mapped",
			[
				118,
				105,
				105
			]
		],
		[
			[8551, 8551],
			"mapped",
			[
				118,
				105,
				105,
				105
			]
		],
		[
			[8552, 8552],
			"mapped",
			[105, 120]
		],
		[
			[8553, 8553],
			"mapped",
			[120]
		],
		[
			[8554, 8554],
			"mapped",
			[120, 105]
		],
		[
			[8555, 8555],
			"mapped",
			[
				120,
				105,
				105
			]
		],
		[
			[8556, 8556],
			"mapped",
			[108]
		],
		[
			[8557, 8557],
			"mapped",
			[99]
		],
		[
			[8558, 8558],
			"mapped",
			[100]
		],
		[
			[8559, 8559],
			"mapped",
			[109]
		],
		[
			[8560, 8560],
			"mapped",
			[105]
		],
		[
			[8561, 8561],
			"mapped",
			[105, 105]
		],
		[
			[8562, 8562],
			"mapped",
			[
				105,
				105,
				105
			]
		],
		[
			[8563, 8563],
			"mapped",
			[105, 118]
		],
		[
			[8564, 8564],
			"mapped",
			[118]
		],
		[
			[8565, 8565],
			"mapped",
			[118, 105]
		],
		[
			[8566, 8566],
			"mapped",
			[
				118,
				105,
				105
			]
		],
		[
			[8567, 8567],
			"mapped",
			[
				118,
				105,
				105,
				105
			]
		],
		[
			[8568, 8568],
			"mapped",
			[105, 120]
		],
		[
			[8569, 8569],
			"mapped",
			[120]
		],
		[
			[8570, 8570],
			"mapped",
			[120, 105]
		],
		[
			[8571, 8571],
			"mapped",
			[
				120,
				105,
				105
			]
		],
		[
			[8572, 8572],
			"mapped",
			[108]
		],
		[
			[8573, 8573],
			"mapped",
			[99]
		],
		[
			[8574, 8574],
			"mapped",
			[100]
		],
		[
			[8575, 8575],
			"mapped",
			[109]
		],
		[
			[8576, 8578],
			"valid",
			[],
			"NV8"
		],
		[[8579, 8579], "disallowed"],
		[[8580, 8580], "valid"],
		[
			[8581, 8584],
			"valid",
			[],
			"NV8"
		],
		[
			[8585, 8585],
			"mapped",
			[
				48,
				8260,
				51
			]
		],
		[
			[8586, 8587],
			"valid",
			[],
			"NV8"
		],
		[[8588, 8591], "disallowed"],
		[
			[8592, 8682],
			"valid",
			[],
			"NV8"
		],
		[
			[8683, 8691],
			"valid",
			[],
			"NV8"
		],
		[
			[8692, 8703],
			"valid",
			[],
			"NV8"
		],
		[
			[8704, 8747],
			"valid",
			[],
			"NV8"
		],
		[
			[8748, 8748],
			"mapped",
			[8747, 8747]
		],
		[
			[8749, 8749],
			"mapped",
			[
				8747,
				8747,
				8747
			]
		],
		[
			[8750, 8750],
			"valid",
			[],
			"NV8"
		],
		[
			[8751, 8751],
			"mapped",
			[8750, 8750]
		],
		[
			[8752, 8752],
			"mapped",
			[
				8750,
				8750,
				8750
			]
		],
		[
			[8753, 8799],
			"valid",
			[],
			"NV8"
		],
		[[8800, 8800], "disallowed_STD3_valid"],
		[
			[8801, 8813],
			"valid",
			[],
			"NV8"
		],
		[[8814, 8815], "disallowed_STD3_valid"],
		[
			[8816, 8945],
			"valid",
			[],
			"NV8"
		],
		[
			[8946, 8959],
			"valid",
			[],
			"NV8"
		],
		[
			[8960, 8960],
			"valid",
			[],
			"NV8"
		],
		[
			[8961, 8961],
			"valid",
			[],
			"NV8"
		],
		[
			[8962, 9e3],
			"valid",
			[],
			"NV8"
		],
		[
			[9001, 9001],
			"mapped",
			[12296]
		],
		[
			[9002, 9002],
			"mapped",
			[12297]
		],
		[
			[9003, 9082],
			"valid",
			[],
			"NV8"
		],
		[
			[9083, 9083],
			"valid",
			[],
			"NV8"
		],
		[
			[9084, 9084],
			"valid",
			[],
			"NV8"
		],
		[
			[9085, 9114],
			"valid",
			[],
			"NV8"
		],
		[
			[9115, 9166],
			"valid",
			[],
			"NV8"
		],
		[
			[9167, 9168],
			"valid",
			[],
			"NV8"
		],
		[
			[9169, 9179],
			"valid",
			[],
			"NV8"
		],
		[
			[9180, 9191],
			"valid",
			[],
			"NV8"
		],
		[
			[9192, 9192],
			"valid",
			[],
			"NV8"
		],
		[
			[9193, 9203],
			"valid",
			[],
			"NV8"
		],
		[
			[9204, 9210],
			"valid",
			[],
			"NV8"
		],
		[[9211, 9215], "disallowed"],
		[
			[9216, 9252],
			"valid",
			[],
			"NV8"
		],
		[
			[9253, 9254],
			"valid",
			[],
			"NV8"
		],
		[[9255, 9279], "disallowed"],
		[
			[9280, 9290],
			"valid",
			[],
			"NV8"
		],
		[[9291, 9311], "disallowed"],
		[
			[9312, 9312],
			"mapped",
			[49]
		],
		[
			[9313, 9313],
			"mapped",
			[50]
		],
		[
			[9314, 9314],
			"mapped",
			[51]
		],
		[
			[9315, 9315],
			"mapped",
			[52]
		],
		[
			[9316, 9316],
			"mapped",
			[53]
		],
		[
			[9317, 9317],
			"mapped",
			[54]
		],
		[
			[9318, 9318],
			"mapped",
			[55]
		],
		[
			[9319, 9319],
			"mapped",
			[56]
		],
		[
			[9320, 9320],
			"mapped",
			[57]
		],
		[
			[9321, 9321],
			"mapped",
			[49, 48]
		],
		[
			[9322, 9322],
			"mapped",
			[49, 49]
		],
		[
			[9323, 9323],
			"mapped",
			[49, 50]
		],
		[
			[9324, 9324],
			"mapped",
			[49, 51]
		],
		[
			[9325, 9325],
			"mapped",
			[49, 52]
		],
		[
			[9326, 9326],
			"mapped",
			[49, 53]
		],
		[
			[9327, 9327],
			"mapped",
			[49, 54]
		],
		[
			[9328, 9328],
			"mapped",
			[49, 55]
		],
		[
			[9329, 9329],
			"mapped",
			[49, 56]
		],
		[
			[9330, 9330],
			"mapped",
			[49, 57]
		],
		[
			[9331, 9331],
			"mapped",
			[50, 48]
		],
		[
			[9332, 9332],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				41
			]
		],
		[
			[9333, 9333],
			"disallowed_STD3_mapped",
			[
				40,
				50,
				41
			]
		],
		[
			[9334, 9334],
			"disallowed_STD3_mapped",
			[
				40,
				51,
				41
			]
		],
		[
			[9335, 9335],
			"disallowed_STD3_mapped",
			[
				40,
				52,
				41
			]
		],
		[
			[9336, 9336],
			"disallowed_STD3_mapped",
			[
				40,
				53,
				41
			]
		],
		[
			[9337, 9337],
			"disallowed_STD3_mapped",
			[
				40,
				54,
				41
			]
		],
		[
			[9338, 9338],
			"disallowed_STD3_mapped",
			[
				40,
				55,
				41
			]
		],
		[
			[9339, 9339],
			"disallowed_STD3_mapped",
			[
				40,
				56,
				41
			]
		],
		[
			[9340, 9340],
			"disallowed_STD3_mapped",
			[
				40,
				57,
				41
			]
		],
		[
			[9341, 9341],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				48,
				41
			]
		],
		[
			[9342, 9342],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				49,
				41
			]
		],
		[
			[9343, 9343],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				50,
				41
			]
		],
		[
			[9344, 9344],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				51,
				41
			]
		],
		[
			[9345, 9345],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				52,
				41
			]
		],
		[
			[9346, 9346],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				53,
				41
			]
		],
		[
			[9347, 9347],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				54,
				41
			]
		],
		[
			[9348, 9348],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				55,
				41
			]
		],
		[
			[9349, 9349],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				56,
				41
			]
		],
		[
			[9350, 9350],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				57,
				41
			]
		],
		[
			[9351, 9351],
			"disallowed_STD3_mapped",
			[
				40,
				50,
				48,
				41
			]
		],
		[[9352, 9371], "disallowed"],
		[
			[9372, 9372],
			"disallowed_STD3_mapped",
			[
				40,
				97,
				41
			]
		],
		[
			[9373, 9373],
			"disallowed_STD3_mapped",
			[
				40,
				98,
				41
			]
		],
		[
			[9374, 9374],
			"disallowed_STD3_mapped",
			[
				40,
				99,
				41
			]
		],
		[
			[9375, 9375],
			"disallowed_STD3_mapped",
			[
				40,
				100,
				41
			]
		],
		[
			[9376, 9376],
			"disallowed_STD3_mapped",
			[
				40,
				101,
				41
			]
		],
		[
			[9377, 9377],
			"disallowed_STD3_mapped",
			[
				40,
				102,
				41
			]
		],
		[
			[9378, 9378],
			"disallowed_STD3_mapped",
			[
				40,
				103,
				41
			]
		],
		[
			[9379, 9379],
			"disallowed_STD3_mapped",
			[
				40,
				104,
				41
			]
		],
		[
			[9380, 9380],
			"disallowed_STD3_mapped",
			[
				40,
				105,
				41
			]
		],
		[
			[9381, 9381],
			"disallowed_STD3_mapped",
			[
				40,
				106,
				41
			]
		],
		[
			[9382, 9382],
			"disallowed_STD3_mapped",
			[
				40,
				107,
				41
			]
		],
		[
			[9383, 9383],
			"disallowed_STD3_mapped",
			[
				40,
				108,
				41
			]
		],
		[
			[9384, 9384],
			"disallowed_STD3_mapped",
			[
				40,
				109,
				41
			]
		],
		[
			[9385, 9385],
			"disallowed_STD3_mapped",
			[
				40,
				110,
				41
			]
		],
		[
			[9386, 9386],
			"disallowed_STD3_mapped",
			[
				40,
				111,
				41
			]
		],
		[
			[9387, 9387],
			"disallowed_STD3_mapped",
			[
				40,
				112,
				41
			]
		],
		[
			[9388, 9388],
			"disallowed_STD3_mapped",
			[
				40,
				113,
				41
			]
		],
		[
			[9389, 9389],
			"disallowed_STD3_mapped",
			[
				40,
				114,
				41
			]
		],
		[
			[9390, 9390],
			"disallowed_STD3_mapped",
			[
				40,
				115,
				41
			]
		],
		[
			[9391, 9391],
			"disallowed_STD3_mapped",
			[
				40,
				116,
				41
			]
		],
		[
			[9392, 9392],
			"disallowed_STD3_mapped",
			[
				40,
				117,
				41
			]
		],
		[
			[9393, 9393],
			"disallowed_STD3_mapped",
			[
				40,
				118,
				41
			]
		],
		[
			[9394, 9394],
			"disallowed_STD3_mapped",
			[
				40,
				119,
				41
			]
		],
		[
			[9395, 9395],
			"disallowed_STD3_mapped",
			[
				40,
				120,
				41
			]
		],
		[
			[9396, 9396],
			"disallowed_STD3_mapped",
			[
				40,
				121,
				41
			]
		],
		[
			[9397, 9397],
			"disallowed_STD3_mapped",
			[
				40,
				122,
				41
			]
		],
		[
			[9398, 9398],
			"mapped",
			[97]
		],
		[
			[9399, 9399],
			"mapped",
			[98]
		],
		[
			[9400, 9400],
			"mapped",
			[99]
		],
		[
			[9401, 9401],
			"mapped",
			[100]
		],
		[
			[9402, 9402],
			"mapped",
			[101]
		],
		[
			[9403, 9403],
			"mapped",
			[102]
		],
		[
			[9404, 9404],
			"mapped",
			[103]
		],
		[
			[9405, 9405],
			"mapped",
			[104]
		],
		[
			[9406, 9406],
			"mapped",
			[105]
		],
		[
			[9407, 9407],
			"mapped",
			[106]
		],
		[
			[9408, 9408],
			"mapped",
			[107]
		],
		[
			[9409, 9409],
			"mapped",
			[108]
		],
		[
			[9410, 9410],
			"mapped",
			[109]
		],
		[
			[9411, 9411],
			"mapped",
			[110]
		],
		[
			[9412, 9412],
			"mapped",
			[111]
		],
		[
			[9413, 9413],
			"mapped",
			[112]
		],
		[
			[9414, 9414],
			"mapped",
			[113]
		],
		[
			[9415, 9415],
			"mapped",
			[114]
		],
		[
			[9416, 9416],
			"mapped",
			[115]
		],
		[
			[9417, 9417],
			"mapped",
			[116]
		],
		[
			[9418, 9418],
			"mapped",
			[117]
		],
		[
			[9419, 9419],
			"mapped",
			[118]
		],
		[
			[9420, 9420],
			"mapped",
			[119]
		],
		[
			[9421, 9421],
			"mapped",
			[120]
		],
		[
			[9422, 9422],
			"mapped",
			[121]
		],
		[
			[9423, 9423],
			"mapped",
			[122]
		],
		[
			[9424, 9424],
			"mapped",
			[97]
		],
		[
			[9425, 9425],
			"mapped",
			[98]
		],
		[
			[9426, 9426],
			"mapped",
			[99]
		],
		[
			[9427, 9427],
			"mapped",
			[100]
		],
		[
			[9428, 9428],
			"mapped",
			[101]
		],
		[
			[9429, 9429],
			"mapped",
			[102]
		],
		[
			[9430, 9430],
			"mapped",
			[103]
		],
		[
			[9431, 9431],
			"mapped",
			[104]
		],
		[
			[9432, 9432],
			"mapped",
			[105]
		],
		[
			[9433, 9433],
			"mapped",
			[106]
		],
		[
			[9434, 9434],
			"mapped",
			[107]
		],
		[
			[9435, 9435],
			"mapped",
			[108]
		],
		[
			[9436, 9436],
			"mapped",
			[109]
		],
		[
			[9437, 9437],
			"mapped",
			[110]
		],
		[
			[9438, 9438],
			"mapped",
			[111]
		],
		[
			[9439, 9439],
			"mapped",
			[112]
		],
		[
			[9440, 9440],
			"mapped",
			[113]
		],
		[
			[9441, 9441],
			"mapped",
			[114]
		],
		[
			[9442, 9442],
			"mapped",
			[115]
		],
		[
			[9443, 9443],
			"mapped",
			[116]
		],
		[
			[9444, 9444],
			"mapped",
			[117]
		],
		[
			[9445, 9445],
			"mapped",
			[118]
		],
		[
			[9446, 9446],
			"mapped",
			[119]
		],
		[
			[9447, 9447],
			"mapped",
			[120]
		],
		[
			[9448, 9448],
			"mapped",
			[121]
		],
		[
			[9449, 9449],
			"mapped",
			[122]
		],
		[
			[9450, 9450],
			"mapped",
			[48]
		],
		[
			[9451, 9470],
			"valid",
			[],
			"NV8"
		],
		[
			[9471, 9471],
			"valid",
			[],
			"NV8"
		],
		[
			[9472, 9621],
			"valid",
			[],
			"NV8"
		],
		[
			[9622, 9631],
			"valid",
			[],
			"NV8"
		],
		[
			[9632, 9711],
			"valid",
			[],
			"NV8"
		],
		[
			[9712, 9719],
			"valid",
			[],
			"NV8"
		],
		[
			[9720, 9727],
			"valid",
			[],
			"NV8"
		],
		[
			[9728, 9747],
			"valid",
			[],
			"NV8"
		],
		[
			[9748, 9749],
			"valid",
			[],
			"NV8"
		],
		[
			[9750, 9751],
			"valid",
			[],
			"NV8"
		],
		[
			[9752, 9752],
			"valid",
			[],
			"NV8"
		],
		[
			[9753, 9753],
			"valid",
			[],
			"NV8"
		],
		[
			[9754, 9839],
			"valid",
			[],
			"NV8"
		],
		[
			[9840, 9841],
			"valid",
			[],
			"NV8"
		],
		[
			[9842, 9853],
			"valid",
			[],
			"NV8"
		],
		[
			[9854, 9855],
			"valid",
			[],
			"NV8"
		],
		[
			[9856, 9865],
			"valid",
			[],
			"NV8"
		],
		[
			[9866, 9873],
			"valid",
			[],
			"NV8"
		],
		[
			[9874, 9884],
			"valid",
			[],
			"NV8"
		],
		[
			[9885, 9885],
			"valid",
			[],
			"NV8"
		],
		[
			[9886, 9887],
			"valid",
			[],
			"NV8"
		],
		[
			[9888, 9889],
			"valid",
			[],
			"NV8"
		],
		[
			[9890, 9905],
			"valid",
			[],
			"NV8"
		],
		[
			[9906, 9906],
			"valid",
			[],
			"NV8"
		],
		[
			[9907, 9916],
			"valid",
			[],
			"NV8"
		],
		[
			[9917, 9919],
			"valid",
			[],
			"NV8"
		],
		[
			[9920, 9923],
			"valid",
			[],
			"NV8"
		],
		[
			[9924, 9933],
			"valid",
			[],
			"NV8"
		],
		[
			[9934, 9934],
			"valid",
			[],
			"NV8"
		],
		[
			[9935, 9953],
			"valid",
			[],
			"NV8"
		],
		[
			[9954, 9954],
			"valid",
			[],
			"NV8"
		],
		[
			[9955, 9955],
			"valid",
			[],
			"NV8"
		],
		[
			[9956, 9959],
			"valid",
			[],
			"NV8"
		],
		[
			[9960, 9983],
			"valid",
			[],
			"NV8"
		],
		[
			[9984, 9984],
			"valid",
			[],
			"NV8"
		],
		[
			[9985, 9988],
			"valid",
			[],
			"NV8"
		],
		[
			[9989, 9989],
			"valid",
			[],
			"NV8"
		],
		[
			[9990, 9993],
			"valid",
			[],
			"NV8"
		],
		[
			[9994, 9995],
			"valid",
			[],
			"NV8"
		],
		[
			[9996, 10023],
			"valid",
			[],
			"NV8"
		],
		[
			[10024, 10024],
			"valid",
			[],
			"NV8"
		],
		[
			[10025, 10059],
			"valid",
			[],
			"NV8"
		],
		[
			[10060, 10060],
			"valid",
			[],
			"NV8"
		],
		[
			[10061, 10061],
			"valid",
			[],
			"NV8"
		],
		[
			[10062, 10062],
			"valid",
			[],
			"NV8"
		],
		[
			[10063, 10066],
			"valid",
			[],
			"NV8"
		],
		[
			[10067, 10069],
			"valid",
			[],
			"NV8"
		],
		[
			[10070, 10070],
			"valid",
			[],
			"NV8"
		],
		[
			[10071, 10071],
			"valid",
			[],
			"NV8"
		],
		[
			[10072, 10078],
			"valid",
			[],
			"NV8"
		],
		[
			[10079, 10080],
			"valid",
			[],
			"NV8"
		],
		[
			[10081, 10087],
			"valid",
			[],
			"NV8"
		],
		[
			[10088, 10101],
			"valid",
			[],
			"NV8"
		],
		[
			[10102, 10132],
			"valid",
			[],
			"NV8"
		],
		[
			[10133, 10135],
			"valid",
			[],
			"NV8"
		],
		[
			[10136, 10159],
			"valid",
			[],
			"NV8"
		],
		[
			[10160, 10160],
			"valid",
			[],
			"NV8"
		],
		[
			[10161, 10174],
			"valid",
			[],
			"NV8"
		],
		[
			[10175, 10175],
			"valid",
			[],
			"NV8"
		],
		[
			[10176, 10182],
			"valid",
			[],
			"NV8"
		],
		[
			[10183, 10186],
			"valid",
			[],
			"NV8"
		],
		[
			[10187, 10187],
			"valid",
			[],
			"NV8"
		],
		[
			[10188, 10188],
			"valid",
			[],
			"NV8"
		],
		[
			[10189, 10189],
			"valid",
			[],
			"NV8"
		],
		[
			[10190, 10191],
			"valid",
			[],
			"NV8"
		],
		[
			[10192, 10219],
			"valid",
			[],
			"NV8"
		],
		[
			[10220, 10223],
			"valid",
			[],
			"NV8"
		],
		[
			[10224, 10239],
			"valid",
			[],
			"NV8"
		],
		[
			[10240, 10495],
			"valid",
			[],
			"NV8"
		],
		[
			[10496, 10763],
			"valid",
			[],
			"NV8"
		],
		[
			[10764, 10764],
			"mapped",
			[
				8747,
				8747,
				8747,
				8747
			]
		],
		[
			[10765, 10867],
			"valid",
			[],
			"NV8"
		],
		[
			[10868, 10868],
			"disallowed_STD3_mapped",
			[
				58,
				58,
				61
			]
		],
		[
			[10869, 10869],
			"disallowed_STD3_mapped",
			[61, 61]
		],
		[
			[10870, 10870],
			"disallowed_STD3_mapped",
			[
				61,
				61,
				61
			]
		],
		[
			[10871, 10971],
			"valid",
			[],
			"NV8"
		],
		[
			[10972, 10972],
			"mapped",
			[10973, 824]
		],
		[
			[10973, 11007],
			"valid",
			[],
			"NV8"
		],
		[
			[11008, 11021],
			"valid",
			[],
			"NV8"
		],
		[
			[11022, 11027],
			"valid",
			[],
			"NV8"
		],
		[
			[11028, 11034],
			"valid",
			[],
			"NV8"
		],
		[
			[11035, 11039],
			"valid",
			[],
			"NV8"
		],
		[
			[11040, 11043],
			"valid",
			[],
			"NV8"
		],
		[
			[11044, 11084],
			"valid",
			[],
			"NV8"
		],
		[
			[11085, 11087],
			"valid",
			[],
			"NV8"
		],
		[
			[11088, 11092],
			"valid",
			[],
			"NV8"
		],
		[
			[11093, 11097],
			"valid",
			[],
			"NV8"
		],
		[
			[11098, 11123],
			"valid",
			[],
			"NV8"
		],
		[[11124, 11125], "disallowed"],
		[
			[11126, 11157],
			"valid",
			[],
			"NV8"
		],
		[[11158, 11159], "disallowed"],
		[
			[11160, 11193],
			"valid",
			[],
			"NV8"
		],
		[[11194, 11196], "disallowed"],
		[
			[11197, 11208],
			"valid",
			[],
			"NV8"
		],
		[[11209, 11209], "disallowed"],
		[
			[11210, 11217],
			"valid",
			[],
			"NV8"
		],
		[[11218, 11243], "disallowed"],
		[
			[11244, 11247],
			"valid",
			[],
			"NV8"
		],
		[[11248, 11263], "disallowed"],
		[
			[11264, 11264],
			"mapped",
			[11312]
		],
		[
			[11265, 11265],
			"mapped",
			[11313]
		],
		[
			[11266, 11266],
			"mapped",
			[11314]
		],
		[
			[11267, 11267],
			"mapped",
			[11315]
		],
		[
			[11268, 11268],
			"mapped",
			[11316]
		],
		[
			[11269, 11269],
			"mapped",
			[11317]
		],
		[
			[11270, 11270],
			"mapped",
			[11318]
		],
		[
			[11271, 11271],
			"mapped",
			[11319]
		],
		[
			[11272, 11272],
			"mapped",
			[11320]
		],
		[
			[11273, 11273],
			"mapped",
			[11321]
		],
		[
			[11274, 11274],
			"mapped",
			[11322]
		],
		[
			[11275, 11275],
			"mapped",
			[11323]
		],
		[
			[11276, 11276],
			"mapped",
			[11324]
		],
		[
			[11277, 11277],
			"mapped",
			[11325]
		],
		[
			[11278, 11278],
			"mapped",
			[11326]
		],
		[
			[11279, 11279],
			"mapped",
			[11327]
		],
		[
			[11280, 11280],
			"mapped",
			[11328]
		],
		[
			[11281, 11281],
			"mapped",
			[11329]
		],
		[
			[11282, 11282],
			"mapped",
			[11330]
		],
		[
			[11283, 11283],
			"mapped",
			[11331]
		],
		[
			[11284, 11284],
			"mapped",
			[11332]
		],
		[
			[11285, 11285],
			"mapped",
			[11333]
		],
		[
			[11286, 11286],
			"mapped",
			[11334]
		],
		[
			[11287, 11287],
			"mapped",
			[11335]
		],
		[
			[11288, 11288],
			"mapped",
			[11336]
		],
		[
			[11289, 11289],
			"mapped",
			[11337]
		],
		[
			[11290, 11290],
			"mapped",
			[11338]
		],
		[
			[11291, 11291],
			"mapped",
			[11339]
		],
		[
			[11292, 11292],
			"mapped",
			[11340]
		],
		[
			[11293, 11293],
			"mapped",
			[11341]
		],
		[
			[11294, 11294],
			"mapped",
			[11342]
		],
		[
			[11295, 11295],
			"mapped",
			[11343]
		],
		[
			[11296, 11296],
			"mapped",
			[11344]
		],
		[
			[11297, 11297],
			"mapped",
			[11345]
		],
		[
			[11298, 11298],
			"mapped",
			[11346]
		],
		[
			[11299, 11299],
			"mapped",
			[11347]
		],
		[
			[11300, 11300],
			"mapped",
			[11348]
		],
		[
			[11301, 11301],
			"mapped",
			[11349]
		],
		[
			[11302, 11302],
			"mapped",
			[11350]
		],
		[
			[11303, 11303],
			"mapped",
			[11351]
		],
		[
			[11304, 11304],
			"mapped",
			[11352]
		],
		[
			[11305, 11305],
			"mapped",
			[11353]
		],
		[
			[11306, 11306],
			"mapped",
			[11354]
		],
		[
			[11307, 11307],
			"mapped",
			[11355]
		],
		[
			[11308, 11308],
			"mapped",
			[11356]
		],
		[
			[11309, 11309],
			"mapped",
			[11357]
		],
		[
			[11310, 11310],
			"mapped",
			[11358]
		],
		[[11311, 11311], "disallowed"],
		[[11312, 11358], "valid"],
		[[11359, 11359], "disallowed"],
		[
			[11360, 11360],
			"mapped",
			[11361]
		],
		[[11361, 11361], "valid"],
		[
			[11362, 11362],
			"mapped",
			[619]
		],
		[
			[11363, 11363],
			"mapped",
			[7549]
		],
		[
			[11364, 11364],
			"mapped",
			[637]
		],
		[[11365, 11366], "valid"],
		[
			[11367, 11367],
			"mapped",
			[11368]
		],
		[[11368, 11368], "valid"],
		[
			[11369, 11369],
			"mapped",
			[11370]
		],
		[[11370, 11370], "valid"],
		[
			[11371, 11371],
			"mapped",
			[11372]
		],
		[[11372, 11372], "valid"],
		[
			[11373, 11373],
			"mapped",
			[593]
		],
		[
			[11374, 11374],
			"mapped",
			[625]
		],
		[
			[11375, 11375],
			"mapped",
			[592]
		],
		[
			[11376, 11376],
			"mapped",
			[594]
		],
		[[11377, 11377], "valid"],
		[
			[11378, 11378],
			"mapped",
			[11379]
		],
		[[11379, 11379], "valid"],
		[[11380, 11380], "valid"],
		[
			[11381, 11381],
			"mapped",
			[11382]
		],
		[[11382, 11383], "valid"],
		[[11384, 11387], "valid"],
		[
			[11388, 11388],
			"mapped",
			[106]
		],
		[
			[11389, 11389],
			"mapped",
			[118]
		],
		[
			[11390, 11390],
			"mapped",
			[575]
		],
		[
			[11391, 11391],
			"mapped",
			[576]
		],
		[
			[11392, 11392],
			"mapped",
			[11393]
		],
		[[11393, 11393], "valid"],
		[
			[11394, 11394],
			"mapped",
			[11395]
		],
		[[11395, 11395], "valid"],
		[
			[11396, 11396],
			"mapped",
			[11397]
		],
		[[11397, 11397], "valid"],
		[
			[11398, 11398],
			"mapped",
			[11399]
		],
		[[11399, 11399], "valid"],
		[
			[11400, 11400],
			"mapped",
			[11401]
		],
		[[11401, 11401], "valid"],
		[
			[11402, 11402],
			"mapped",
			[11403]
		],
		[[11403, 11403], "valid"],
		[
			[11404, 11404],
			"mapped",
			[11405]
		],
		[[11405, 11405], "valid"],
		[
			[11406, 11406],
			"mapped",
			[11407]
		],
		[[11407, 11407], "valid"],
		[
			[11408, 11408],
			"mapped",
			[11409]
		],
		[[11409, 11409], "valid"],
		[
			[11410, 11410],
			"mapped",
			[11411]
		],
		[[11411, 11411], "valid"],
		[
			[11412, 11412],
			"mapped",
			[11413]
		],
		[[11413, 11413], "valid"],
		[
			[11414, 11414],
			"mapped",
			[11415]
		],
		[[11415, 11415], "valid"],
		[
			[11416, 11416],
			"mapped",
			[11417]
		],
		[[11417, 11417], "valid"],
		[
			[11418, 11418],
			"mapped",
			[11419]
		],
		[[11419, 11419], "valid"],
		[
			[11420, 11420],
			"mapped",
			[11421]
		],
		[[11421, 11421], "valid"],
		[
			[11422, 11422],
			"mapped",
			[11423]
		],
		[[11423, 11423], "valid"],
		[
			[11424, 11424],
			"mapped",
			[11425]
		],
		[[11425, 11425], "valid"],
		[
			[11426, 11426],
			"mapped",
			[11427]
		],
		[[11427, 11427], "valid"],
		[
			[11428, 11428],
			"mapped",
			[11429]
		],
		[[11429, 11429], "valid"],
		[
			[11430, 11430],
			"mapped",
			[11431]
		],
		[[11431, 11431], "valid"],
		[
			[11432, 11432],
			"mapped",
			[11433]
		],
		[[11433, 11433], "valid"],
		[
			[11434, 11434],
			"mapped",
			[11435]
		],
		[[11435, 11435], "valid"],
		[
			[11436, 11436],
			"mapped",
			[11437]
		],
		[[11437, 11437], "valid"],
		[
			[11438, 11438],
			"mapped",
			[11439]
		],
		[[11439, 11439], "valid"],
		[
			[11440, 11440],
			"mapped",
			[11441]
		],
		[[11441, 11441], "valid"],
		[
			[11442, 11442],
			"mapped",
			[11443]
		],
		[[11443, 11443], "valid"],
		[
			[11444, 11444],
			"mapped",
			[11445]
		],
		[[11445, 11445], "valid"],
		[
			[11446, 11446],
			"mapped",
			[11447]
		],
		[[11447, 11447], "valid"],
		[
			[11448, 11448],
			"mapped",
			[11449]
		],
		[[11449, 11449], "valid"],
		[
			[11450, 11450],
			"mapped",
			[11451]
		],
		[[11451, 11451], "valid"],
		[
			[11452, 11452],
			"mapped",
			[11453]
		],
		[[11453, 11453], "valid"],
		[
			[11454, 11454],
			"mapped",
			[11455]
		],
		[[11455, 11455], "valid"],
		[
			[11456, 11456],
			"mapped",
			[11457]
		],
		[[11457, 11457], "valid"],
		[
			[11458, 11458],
			"mapped",
			[11459]
		],
		[[11459, 11459], "valid"],
		[
			[11460, 11460],
			"mapped",
			[11461]
		],
		[[11461, 11461], "valid"],
		[
			[11462, 11462],
			"mapped",
			[11463]
		],
		[[11463, 11463], "valid"],
		[
			[11464, 11464],
			"mapped",
			[11465]
		],
		[[11465, 11465], "valid"],
		[
			[11466, 11466],
			"mapped",
			[11467]
		],
		[[11467, 11467], "valid"],
		[
			[11468, 11468],
			"mapped",
			[11469]
		],
		[[11469, 11469], "valid"],
		[
			[11470, 11470],
			"mapped",
			[11471]
		],
		[[11471, 11471], "valid"],
		[
			[11472, 11472],
			"mapped",
			[11473]
		],
		[[11473, 11473], "valid"],
		[
			[11474, 11474],
			"mapped",
			[11475]
		],
		[[11475, 11475], "valid"],
		[
			[11476, 11476],
			"mapped",
			[11477]
		],
		[[11477, 11477], "valid"],
		[
			[11478, 11478],
			"mapped",
			[11479]
		],
		[[11479, 11479], "valid"],
		[
			[11480, 11480],
			"mapped",
			[11481]
		],
		[[11481, 11481], "valid"],
		[
			[11482, 11482],
			"mapped",
			[11483]
		],
		[[11483, 11483], "valid"],
		[
			[11484, 11484],
			"mapped",
			[11485]
		],
		[[11485, 11485], "valid"],
		[
			[11486, 11486],
			"mapped",
			[11487]
		],
		[[11487, 11487], "valid"],
		[
			[11488, 11488],
			"mapped",
			[11489]
		],
		[[11489, 11489], "valid"],
		[
			[11490, 11490],
			"mapped",
			[11491]
		],
		[[11491, 11492], "valid"],
		[
			[11493, 11498],
			"valid",
			[],
			"NV8"
		],
		[
			[11499, 11499],
			"mapped",
			[11500]
		],
		[[11500, 11500], "valid"],
		[
			[11501, 11501],
			"mapped",
			[11502]
		],
		[[11502, 11505], "valid"],
		[
			[11506, 11506],
			"mapped",
			[11507]
		],
		[[11507, 11507], "valid"],
		[[11508, 11512], "disallowed"],
		[
			[11513, 11519],
			"valid",
			[],
			"NV8"
		],
		[[11520, 11557], "valid"],
		[[11558, 11558], "disallowed"],
		[[11559, 11559], "valid"],
		[[11560, 11564], "disallowed"],
		[[11565, 11565], "valid"],
		[[11566, 11567], "disallowed"],
		[[11568, 11621], "valid"],
		[[11622, 11623], "valid"],
		[[11624, 11630], "disallowed"],
		[
			[11631, 11631],
			"mapped",
			[11617]
		],
		[
			[11632, 11632],
			"valid",
			[],
			"NV8"
		],
		[[11633, 11646], "disallowed"],
		[[11647, 11647], "valid"],
		[[11648, 11670], "valid"],
		[[11671, 11679], "disallowed"],
		[[11680, 11686], "valid"],
		[[11687, 11687], "disallowed"],
		[[11688, 11694], "valid"],
		[[11695, 11695], "disallowed"],
		[[11696, 11702], "valid"],
		[[11703, 11703], "disallowed"],
		[[11704, 11710], "valid"],
		[[11711, 11711], "disallowed"],
		[[11712, 11718], "valid"],
		[[11719, 11719], "disallowed"],
		[[11720, 11726], "valid"],
		[[11727, 11727], "disallowed"],
		[[11728, 11734], "valid"],
		[[11735, 11735], "disallowed"],
		[[11736, 11742], "valid"],
		[[11743, 11743], "disallowed"],
		[[11744, 11775], "valid"],
		[
			[11776, 11799],
			"valid",
			[],
			"NV8"
		],
		[
			[11800, 11803],
			"valid",
			[],
			"NV8"
		],
		[
			[11804, 11805],
			"valid",
			[],
			"NV8"
		],
		[
			[11806, 11822],
			"valid",
			[],
			"NV8"
		],
		[[11823, 11823], "valid"],
		[
			[11824, 11824],
			"valid",
			[],
			"NV8"
		],
		[
			[11825, 11825],
			"valid",
			[],
			"NV8"
		],
		[
			[11826, 11835],
			"valid",
			[],
			"NV8"
		],
		[
			[11836, 11842],
			"valid",
			[],
			"NV8"
		],
		[[11843, 11903], "disallowed"],
		[
			[11904, 11929],
			"valid",
			[],
			"NV8"
		],
		[[11930, 11930], "disallowed"],
		[
			[11931, 11934],
			"valid",
			[],
			"NV8"
		],
		[
			[11935, 11935],
			"mapped",
			[27597]
		],
		[
			[11936, 12018],
			"valid",
			[],
			"NV8"
		],
		[
			[12019, 12019],
			"mapped",
			[40863]
		],
		[[12020, 12031], "disallowed"],
		[
			[12032, 12032],
			"mapped",
			[19968]
		],
		[
			[12033, 12033],
			"mapped",
			[20008]
		],
		[
			[12034, 12034],
			"mapped",
			[20022]
		],
		[
			[12035, 12035],
			"mapped",
			[20031]
		],
		[
			[12036, 12036],
			"mapped",
			[20057]
		],
		[
			[12037, 12037],
			"mapped",
			[20101]
		],
		[
			[12038, 12038],
			"mapped",
			[20108]
		],
		[
			[12039, 12039],
			"mapped",
			[20128]
		],
		[
			[12040, 12040],
			"mapped",
			[20154]
		],
		[
			[12041, 12041],
			"mapped",
			[20799]
		],
		[
			[12042, 12042],
			"mapped",
			[20837]
		],
		[
			[12043, 12043],
			"mapped",
			[20843]
		],
		[
			[12044, 12044],
			"mapped",
			[20866]
		],
		[
			[12045, 12045],
			"mapped",
			[20886]
		],
		[
			[12046, 12046],
			"mapped",
			[20907]
		],
		[
			[12047, 12047],
			"mapped",
			[20960]
		],
		[
			[12048, 12048],
			"mapped",
			[20981]
		],
		[
			[12049, 12049],
			"mapped",
			[20992]
		],
		[
			[12050, 12050],
			"mapped",
			[21147]
		],
		[
			[12051, 12051],
			"mapped",
			[21241]
		],
		[
			[12052, 12052],
			"mapped",
			[21269]
		],
		[
			[12053, 12053],
			"mapped",
			[21274]
		],
		[
			[12054, 12054],
			"mapped",
			[21304]
		],
		[
			[12055, 12055],
			"mapped",
			[21313]
		],
		[
			[12056, 12056],
			"mapped",
			[21340]
		],
		[
			[12057, 12057],
			"mapped",
			[21353]
		],
		[
			[12058, 12058],
			"mapped",
			[21378]
		],
		[
			[12059, 12059],
			"mapped",
			[21430]
		],
		[
			[12060, 12060],
			"mapped",
			[21448]
		],
		[
			[12061, 12061],
			"mapped",
			[21475]
		],
		[
			[12062, 12062],
			"mapped",
			[22231]
		],
		[
			[12063, 12063],
			"mapped",
			[22303]
		],
		[
			[12064, 12064],
			"mapped",
			[22763]
		],
		[
			[12065, 12065],
			"mapped",
			[22786]
		],
		[
			[12066, 12066],
			"mapped",
			[22794]
		],
		[
			[12067, 12067],
			"mapped",
			[22805]
		],
		[
			[12068, 12068],
			"mapped",
			[22823]
		],
		[
			[12069, 12069],
			"mapped",
			[22899]
		],
		[
			[12070, 12070],
			"mapped",
			[23376]
		],
		[
			[12071, 12071],
			"mapped",
			[23424]
		],
		[
			[12072, 12072],
			"mapped",
			[23544]
		],
		[
			[12073, 12073],
			"mapped",
			[23567]
		],
		[
			[12074, 12074],
			"mapped",
			[23586]
		],
		[
			[12075, 12075],
			"mapped",
			[23608]
		],
		[
			[12076, 12076],
			"mapped",
			[23662]
		],
		[
			[12077, 12077],
			"mapped",
			[23665]
		],
		[
			[12078, 12078],
			"mapped",
			[24027]
		],
		[
			[12079, 12079],
			"mapped",
			[24037]
		],
		[
			[12080, 12080],
			"mapped",
			[24049]
		],
		[
			[12081, 12081],
			"mapped",
			[24062]
		],
		[
			[12082, 12082],
			"mapped",
			[24178]
		],
		[
			[12083, 12083],
			"mapped",
			[24186]
		],
		[
			[12084, 12084],
			"mapped",
			[24191]
		],
		[
			[12085, 12085],
			"mapped",
			[24308]
		],
		[
			[12086, 12086],
			"mapped",
			[24318]
		],
		[
			[12087, 12087],
			"mapped",
			[24331]
		],
		[
			[12088, 12088],
			"mapped",
			[24339]
		],
		[
			[12089, 12089],
			"mapped",
			[24400]
		],
		[
			[12090, 12090],
			"mapped",
			[24417]
		],
		[
			[12091, 12091],
			"mapped",
			[24435]
		],
		[
			[12092, 12092],
			"mapped",
			[24515]
		],
		[
			[12093, 12093],
			"mapped",
			[25096]
		],
		[
			[12094, 12094],
			"mapped",
			[25142]
		],
		[
			[12095, 12095],
			"mapped",
			[25163]
		],
		[
			[12096, 12096],
			"mapped",
			[25903]
		],
		[
			[12097, 12097],
			"mapped",
			[25908]
		],
		[
			[12098, 12098],
			"mapped",
			[25991]
		],
		[
			[12099, 12099],
			"mapped",
			[26007]
		],
		[
			[12100, 12100],
			"mapped",
			[26020]
		],
		[
			[12101, 12101],
			"mapped",
			[26041]
		],
		[
			[12102, 12102],
			"mapped",
			[26080]
		],
		[
			[12103, 12103],
			"mapped",
			[26085]
		],
		[
			[12104, 12104],
			"mapped",
			[26352]
		],
		[
			[12105, 12105],
			"mapped",
			[26376]
		],
		[
			[12106, 12106],
			"mapped",
			[26408]
		],
		[
			[12107, 12107],
			"mapped",
			[27424]
		],
		[
			[12108, 12108],
			"mapped",
			[27490]
		],
		[
			[12109, 12109],
			"mapped",
			[27513]
		],
		[
			[12110, 12110],
			"mapped",
			[27571]
		],
		[
			[12111, 12111],
			"mapped",
			[27595]
		],
		[
			[12112, 12112],
			"mapped",
			[27604]
		],
		[
			[12113, 12113],
			"mapped",
			[27611]
		],
		[
			[12114, 12114],
			"mapped",
			[27663]
		],
		[
			[12115, 12115],
			"mapped",
			[27668]
		],
		[
			[12116, 12116],
			"mapped",
			[27700]
		],
		[
			[12117, 12117],
			"mapped",
			[28779]
		],
		[
			[12118, 12118],
			"mapped",
			[29226]
		],
		[
			[12119, 12119],
			"mapped",
			[29238]
		],
		[
			[12120, 12120],
			"mapped",
			[29243]
		],
		[
			[12121, 12121],
			"mapped",
			[29247]
		],
		[
			[12122, 12122],
			"mapped",
			[29255]
		],
		[
			[12123, 12123],
			"mapped",
			[29273]
		],
		[
			[12124, 12124],
			"mapped",
			[29275]
		],
		[
			[12125, 12125],
			"mapped",
			[29356]
		],
		[
			[12126, 12126],
			"mapped",
			[29572]
		],
		[
			[12127, 12127],
			"mapped",
			[29577]
		],
		[
			[12128, 12128],
			"mapped",
			[29916]
		],
		[
			[12129, 12129],
			"mapped",
			[29926]
		],
		[
			[12130, 12130],
			"mapped",
			[29976]
		],
		[
			[12131, 12131],
			"mapped",
			[29983]
		],
		[
			[12132, 12132],
			"mapped",
			[29992]
		],
		[
			[12133, 12133],
			"mapped",
			[3e4]
		],
		[
			[12134, 12134],
			"mapped",
			[30091]
		],
		[
			[12135, 12135],
			"mapped",
			[30098]
		],
		[
			[12136, 12136],
			"mapped",
			[30326]
		],
		[
			[12137, 12137],
			"mapped",
			[30333]
		],
		[
			[12138, 12138],
			"mapped",
			[30382]
		],
		[
			[12139, 12139],
			"mapped",
			[30399]
		],
		[
			[12140, 12140],
			"mapped",
			[30446]
		],
		[
			[12141, 12141],
			"mapped",
			[30683]
		],
		[
			[12142, 12142],
			"mapped",
			[30690]
		],
		[
			[12143, 12143],
			"mapped",
			[30707]
		],
		[
			[12144, 12144],
			"mapped",
			[31034]
		],
		[
			[12145, 12145],
			"mapped",
			[31160]
		],
		[
			[12146, 12146],
			"mapped",
			[31166]
		],
		[
			[12147, 12147],
			"mapped",
			[31348]
		],
		[
			[12148, 12148],
			"mapped",
			[31435]
		],
		[
			[12149, 12149],
			"mapped",
			[31481]
		],
		[
			[12150, 12150],
			"mapped",
			[31859]
		],
		[
			[12151, 12151],
			"mapped",
			[31992]
		],
		[
			[12152, 12152],
			"mapped",
			[32566]
		],
		[
			[12153, 12153],
			"mapped",
			[32593]
		],
		[
			[12154, 12154],
			"mapped",
			[32650]
		],
		[
			[12155, 12155],
			"mapped",
			[32701]
		],
		[
			[12156, 12156],
			"mapped",
			[32769]
		],
		[
			[12157, 12157],
			"mapped",
			[32780]
		],
		[
			[12158, 12158],
			"mapped",
			[32786]
		],
		[
			[12159, 12159],
			"mapped",
			[32819]
		],
		[
			[12160, 12160],
			"mapped",
			[32895]
		],
		[
			[12161, 12161],
			"mapped",
			[32905]
		],
		[
			[12162, 12162],
			"mapped",
			[33251]
		],
		[
			[12163, 12163],
			"mapped",
			[33258]
		],
		[
			[12164, 12164],
			"mapped",
			[33267]
		],
		[
			[12165, 12165],
			"mapped",
			[33276]
		],
		[
			[12166, 12166],
			"mapped",
			[33292]
		],
		[
			[12167, 12167],
			"mapped",
			[33307]
		],
		[
			[12168, 12168],
			"mapped",
			[33311]
		],
		[
			[12169, 12169],
			"mapped",
			[33390]
		],
		[
			[12170, 12170],
			"mapped",
			[33394]
		],
		[
			[12171, 12171],
			"mapped",
			[33400]
		],
		[
			[12172, 12172],
			"mapped",
			[34381]
		],
		[
			[12173, 12173],
			"mapped",
			[34411]
		],
		[
			[12174, 12174],
			"mapped",
			[34880]
		],
		[
			[12175, 12175],
			"mapped",
			[34892]
		],
		[
			[12176, 12176],
			"mapped",
			[34915]
		],
		[
			[12177, 12177],
			"mapped",
			[35198]
		],
		[
			[12178, 12178],
			"mapped",
			[35211]
		],
		[
			[12179, 12179],
			"mapped",
			[35282]
		],
		[
			[12180, 12180],
			"mapped",
			[35328]
		],
		[
			[12181, 12181],
			"mapped",
			[35895]
		],
		[
			[12182, 12182],
			"mapped",
			[35910]
		],
		[
			[12183, 12183],
			"mapped",
			[35925]
		],
		[
			[12184, 12184],
			"mapped",
			[35960]
		],
		[
			[12185, 12185],
			"mapped",
			[35997]
		],
		[
			[12186, 12186],
			"mapped",
			[36196]
		],
		[
			[12187, 12187],
			"mapped",
			[36208]
		],
		[
			[12188, 12188],
			"mapped",
			[36275]
		],
		[
			[12189, 12189],
			"mapped",
			[36523]
		],
		[
			[12190, 12190],
			"mapped",
			[36554]
		],
		[
			[12191, 12191],
			"mapped",
			[36763]
		],
		[
			[12192, 12192],
			"mapped",
			[36784]
		],
		[
			[12193, 12193],
			"mapped",
			[36789]
		],
		[
			[12194, 12194],
			"mapped",
			[37009]
		],
		[
			[12195, 12195],
			"mapped",
			[37193]
		],
		[
			[12196, 12196],
			"mapped",
			[37318]
		],
		[
			[12197, 12197],
			"mapped",
			[37324]
		],
		[
			[12198, 12198],
			"mapped",
			[37329]
		],
		[
			[12199, 12199],
			"mapped",
			[38263]
		],
		[
			[12200, 12200],
			"mapped",
			[38272]
		],
		[
			[12201, 12201],
			"mapped",
			[38428]
		],
		[
			[12202, 12202],
			"mapped",
			[38582]
		],
		[
			[12203, 12203],
			"mapped",
			[38585]
		],
		[
			[12204, 12204],
			"mapped",
			[38632]
		],
		[
			[12205, 12205],
			"mapped",
			[38737]
		],
		[
			[12206, 12206],
			"mapped",
			[38750]
		],
		[
			[12207, 12207],
			"mapped",
			[38754]
		],
		[
			[12208, 12208],
			"mapped",
			[38761]
		],
		[
			[12209, 12209],
			"mapped",
			[38859]
		],
		[
			[12210, 12210],
			"mapped",
			[38893]
		],
		[
			[12211, 12211],
			"mapped",
			[38899]
		],
		[
			[12212, 12212],
			"mapped",
			[38913]
		],
		[
			[12213, 12213],
			"mapped",
			[39080]
		],
		[
			[12214, 12214],
			"mapped",
			[39131]
		],
		[
			[12215, 12215],
			"mapped",
			[39135]
		],
		[
			[12216, 12216],
			"mapped",
			[39318]
		],
		[
			[12217, 12217],
			"mapped",
			[39321]
		],
		[
			[12218, 12218],
			"mapped",
			[39340]
		],
		[
			[12219, 12219],
			"mapped",
			[39592]
		],
		[
			[12220, 12220],
			"mapped",
			[39640]
		],
		[
			[12221, 12221],
			"mapped",
			[39647]
		],
		[
			[12222, 12222],
			"mapped",
			[39717]
		],
		[
			[12223, 12223],
			"mapped",
			[39727]
		],
		[
			[12224, 12224],
			"mapped",
			[39730]
		],
		[
			[12225, 12225],
			"mapped",
			[39740]
		],
		[
			[12226, 12226],
			"mapped",
			[39770]
		],
		[
			[12227, 12227],
			"mapped",
			[40165]
		],
		[
			[12228, 12228],
			"mapped",
			[40565]
		],
		[
			[12229, 12229],
			"mapped",
			[40575]
		],
		[
			[12230, 12230],
			"mapped",
			[40613]
		],
		[
			[12231, 12231],
			"mapped",
			[40635]
		],
		[
			[12232, 12232],
			"mapped",
			[40643]
		],
		[
			[12233, 12233],
			"mapped",
			[40653]
		],
		[
			[12234, 12234],
			"mapped",
			[40657]
		],
		[
			[12235, 12235],
			"mapped",
			[40697]
		],
		[
			[12236, 12236],
			"mapped",
			[40701]
		],
		[
			[12237, 12237],
			"mapped",
			[40718]
		],
		[
			[12238, 12238],
			"mapped",
			[40723]
		],
		[
			[12239, 12239],
			"mapped",
			[40736]
		],
		[
			[12240, 12240],
			"mapped",
			[40763]
		],
		[
			[12241, 12241],
			"mapped",
			[40778]
		],
		[
			[12242, 12242],
			"mapped",
			[40786]
		],
		[
			[12243, 12243],
			"mapped",
			[40845]
		],
		[
			[12244, 12244],
			"mapped",
			[40860]
		],
		[
			[12245, 12245],
			"mapped",
			[40864]
		],
		[[12246, 12271], "disallowed"],
		[[12272, 12283], "disallowed"],
		[[12284, 12287], "disallowed"],
		[
			[12288, 12288],
			"disallowed_STD3_mapped",
			[32]
		],
		[
			[12289, 12289],
			"valid",
			[],
			"NV8"
		],
		[
			[12290, 12290],
			"mapped",
			[46]
		],
		[
			[12291, 12292],
			"valid",
			[],
			"NV8"
		],
		[[12293, 12295], "valid"],
		[
			[12296, 12329],
			"valid",
			[],
			"NV8"
		],
		[[12330, 12333], "valid"],
		[
			[12334, 12341],
			"valid",
			[],
			"NV8"
		],
		[
			[12342, 12342],
			"mapped",
			[12306]
		],
		[
			[12343, 12343],
			"valid",
			[],
			"NV8"
		],
		[
			[12344, 12344],
			"mapped",
			[21313]
		],
		[
			[12345, 12345],
			"mapped",
			[21316]
		],
		[
			[12346, 12346],
			"mapped",
			[21317]
		],
		[
			[12347, 12347],
			"valid",
			[],
			"NV8"
		],
		[[12348, 12348], "valid"],
		[
			[12349, 12349],
			"valid",
			[],
			"NV8"
		],
		[
			[12350, 12350],
			"valid",
			[],
			"NV8"
		],
		[
			[12351, 12351],
			"valid",
			[],
			"NV8"
		],
		[[12352, 12352], "disallowed"],
		[[12353, 12436], "valid"],
		[[12437, 12438], "valid"],
		[[12439, 12440], "disallowed"],
		[[12441, 12442], "valid"],
		[
			[12443, 12443],
			"disallowed_STD3_mapped",
			[32, 12441]
		],
		[
			[12444, 12444],
			"disallowed_STD3_mapped",
			[32, 12442]
		],
		[[12445, 12446], "valid"],
		[
			[12447, 12447],
			"mapped",
			[12424, 12426]
		],
		[
			[12448, 12448],
			"valid",
			[],
			"NV8"
		],
		[[12449, 12542], "valid"],
		[
			[12543, 12543],
			"mapped",
			[12467, 12488]
		],
		[[12544, 12548], "disallowed"],
		[[12549, 12588], "valid"],
		[[12589, 12589], "valid"],
		[[12590, 12592], "disallowed"],
		[
			[12593, 12593],
			"mapped",
			[4352]
		],
		[
			[12594, 12594],
			"mapped",
			[4353]
		],
		[
			[12595, 12595],
			"mapped",
			[4522]
		],
		[
			[12596, 12596],
			"mapped",
			[4354]
		],
		[
			[12597, 12597],
			"mapped",
			[4524]
		],
		[
			[12598, 12598],
			"mapped",
			[4525]
		],
		[
			[12599, 12599],
			"mapped",
			[4355]
		],
		[
			[12600, 12600],
			"mapped",
			[4356]
		],
		[
			[12601, 12601],
			"mapped",
			[4357]
		],
		[
			[12602, 12602],
			"mapped",
			[4528]
		],
		[
			[12603, 12603],
			"mapped",
			[4529]
		],
		[
			[12604, 12604],
			"mapped",
			[4530]
		],
		[
			[12605, 12605],
			"mapped",
			[4531]
		],
		[
			[12606, 12606],
			"mapped",
			[4532]
		],
		[
			[12607, 12607],
			"mapped",
			[4533]
		],
		[
			[12608, 12608],
			"mapped",
			[4378]
		],
		[
			[12609, 12609],
			"mapped",
			[4358]
		],
		[
			[12610, 12610],
			"mapped",
			[4359]
		],
		[
			[12611, 12611],
			"mapped",
			[4360]
		],
		[
			[12612, 12612],
			"mapped",
			[4385]
		],
		[
			[12613, 12613],
			"mapped",
			[4361]
		],
		[
			[12614, 12614],
			"mapped",
			[4362]
		],
		[
			[12615, 12615],
			"mapped",
			[4363]
		],
		[
			[12616, 12616],
			"mapped",
			[4364]
		],
		[
			[12617, 12617],
			"mapped",
			[4365]
		],
		[
			[12618, 12618],
			"mapped",
			[4366]
		],
		[
			[12619, 12619],
			"mapped",
			[4367]
		],
		[
			[12620, 12620],
			"mapped",
			[4368]
		],
		[
			[12621, 12621],
			"mapped",
			[4369]
		],
		[
			[12622, 12622],
			"mapped",
			[4370]
		],
		[
			[12623, 12623],
			"mapped",
			[4449]
		],
		[
			[12624, 12624],
			"mapped",
			[4450]
		],
		[
			[12625, 12625],
			"mapped",
			[4451]
		],
		[
			[12626, 12626],
			"mapped",
			[4452]
		],
		[
			[12627, 12627],
			"mapped",
			[4453]
		],
		[
			[12628, 12628],
			"mapped",
			[4454]
		],
		[
			[12629, 12629],
			"mapped",
			[4455]
		],
		[
			[12630, 12630],
			"mapped",
			[4456]
		],
		[
			[12631, 12631],
			"mapped",
			[4457]
		],
		[
			[12632, 12632],
			"mapped",
			[4458]
		],
		[
			[12633, 12633],
			"mapped",
			[4459]
		],
		[
			[12634, 12634],
			"mapped",
			[4460]
		],
		[
			[12635, 12635],
			"mapped",
			[4461]
		],
		[
			[12636, 12636],
			"mapped",
			[4462]
		],
		[
			[12637, 12637],
			"mapped",
			[4463]
		],
		[
			[12638, 12638],
			"mapped",
			[4464]
		],
		[
			[12639, 12639],
			"mapped",
			[4465]
		],
		[
			[12640, 12640],
			"mapped",
			[4466]
		],
		[
			[12641, 12641],
			"mapped",
			[4467]
		],
		[
			[12642, 12642],
			"mapped",
			[4468]
		],
		[
			[12643, 12643],
			"mapped",
			[4469]
		],
		[[12644, 12644], "disallowed"],
		[
			[12645, 12645],
			"mapped",
			[4372]
		],
		[
			[12646, 12646],
			"mapped",
			[4373]
		],
		[
			[12647, 12647],
			"mapped",
			[4551]
		],
		[
			[12648, 12648],
			"mapped",
			[4552]
		],
		[
			[12649, 12649],
			"mapped",
			[4556]
		],
		[
			[12650, 12650],
			"mapped",
			[4558]
		],
		[
			[12651, 12651],
			"mapped",
			[4563]
		],
		[
			[12652, 12652],
			"mapped",
			[4567]
		],
		[
			[12653, 12653],
			"mapped",
			[4569]
		],
		[
			[12654, 12654],
			"mapped",
			[4380]
		],
		[
			[12655, 12655],
			"mapped",
			[4573]
		],
		[
			[12656, 12656],
			"mapped",
			[4575]
		],
		[
			[12657, 12657],
			"mapped",
			[4381]
		],
		[
			[12658, 12658],
			"mapped",
			[4382]
		],
		[
			[12659, 12659],
			"mapped",
			[4384]
		],
		[
			[12660, 12660],
			"mapped",
			[4386]
		],
		[
			[12661, 12661],
			"mapped",
			[4387]
		],
		[
			[12662, 12662],
			"mapped",
			[4391]
		],
		[
			[12663, 12663],
			"mapped",
			[4393]
		],
		[
			[12664, 12664],
			"mapped",
			[4395]
		],
		[
			[12665, 12665],
			"mapped",
			[4396]
		],
		[
			[12666, 12666],
			"mapped",
			[4397]
		],
		[
			[12667, 12667],
			"mapped",
			[4398]
		],
		[
			[12668, 12668],
			"mapped",
			[4399]
		],
		[
			[12669, 12669],
			"mapped",
			[4402]
		],
		[
			[12670, 12670],
			"mapped",
			[4406]
		],
		[
			[12671, 12671],
			"mapped",
			[4416]
		],
		[
			[12672, 12672],
			"mapped",
			[4423]
		],
		[
			[12673, 12673],
			"mapped",
			[4428]
		],
		[
			[12674, 12674],
			"mapped",
			[4593]
		],
		[
			[12675, 12675],
			"mapped",
			[4594]
		],
		[
			[12676, 12676],
			"mapped",
			[4439]
		],
		[
			[12677, 12677],
			"mapped",
			[4440]
		],
		[
			[12678, 12678],
			"mapped",
			[4441]
		],
		[
			[12679, 12679],
			"mapped",
			[4484]
		],
		[
			[12680, 12680],
			"mapped",
			[4485]
		],
		[
			[12681, 12681],
			"mapped",
			[4488]
		],
		[
			[12682, 12682],
			"mapped",
			[4497]
		],
		[
			[12683, 12683],
			"mapped",
			[4498]
		],
		[
			[12684, 12684],
			"mapped",
			[4500]
		],
		[
			[12685, 12685],
			"mapped",
			[4510]
		],
		[
			[12686, 12686],
			"mapped",
			[4513]
		],
		[[12687, 12687], "disallowed"],
		[
			[12688, 12689],
			"valid",
			[],
			"NV8"
		],
		[
			[12690, 12690],
			"mapped",
			[19968]
		],
		[
			[12691, 12691],
			"mapped",
			[20108]
		],
		[
			[12692, 12692],
			"mapped",
			[19977]
		],
		[
			[12693, 12693],
			"mapped",
			[22235]
		],
		[
			[12694, 12694],
			"mapped",
			[19978]
		],
		[
			[12695, 12695],
			"mapped",
			[20013]
		],
		[
			[12696, 12696],
			"mapped",
			[19979]
		],
		[
			[12697, 12697],
			"mapped",
			[30002]
		],
		[
			[12698, 12698],
			"mapped",
			[20057]
		],
		[
			[12699, 12699],
			"mapped",
			[19993]
		],
		[
			[12700, 12700],
			"mapped",
			[19969]
		],
		[
			[12701, 12701],
			"mapped",
			[22825]
		],
		[
			[12702, 12702],
			"mapped",
			[22320]
		],
		[
			[12703, 12703],
			"mapped",
			[20154]
		],
		[[12704, 12727], "valid"],
		[[12728, 12730], "valid"],
		[[12731, 12735], "disallowed"],
		[
			[12736, 12751],
			"valid",
			[],
			"NV8"
		],
		[
			[12752, 12771],
			"valid",
			[],
			"NV8"
		],
		[[12772, 12783], "disallowed"],
		[[12784, 12799], "valid"],
		[
			[12800, 12800],
			"disallowed_STD3_mapped",
			[
				40,
				4352,
				41
			]
		],
		[
			[12801, 12801],
			"disallowed_STD3_mapped",
			[
				40,
				4354,
				41
			]
		],
		[
			[12802, 12802],
			"disallowed_STD3_mapped",
			[
				40,
				4355,
				41
			]
		],
		[
			[12803, 12803],
			"disallowed_STD3_mapped",
			[
				40,
				4357,
				41
			]
		],
		[
			[12804, 12804],
			"disallowed_STD3_mapped",
			[
				40,
				4358,
				41
			]
		],
		[
			[12805, 12805],
			"disallowed_STD3_mapped",
			[
				40,
				4359,
				41
			]
		],
		[
			[12806, 12806],
			"disallowed_STD3_mapped",
			[
				40,
				4361,
				41
			]
		],
		[
			[12807, 12807],
			"disallowed_STD3_mapped",
			[
				40,
				4363,
				41
			]
		],
		[
			[12808, 12808],
			"disallowed_STD3_mapped",
			[
				40,
				4364,
				41
			]
		],
		[
			[12809, 12809],
			"disallowed_STD3_mapped",
			[
				40,
				4366,
				41
			]
		],
		[
			[12810, 12810],
			"disallowed_STD3_mapped",
			[
				40,
				4367,
				41
			]
		],
		[
			[12811, 12811],
			"disallowed_STD3_mapped",
			[
				40,
				4368,
				41
			]
		],
		[
			[12812, 12812],
			"disallowed_STD3_mapped",
			[
				40,
				4369,
				41
			]
		],
		[
			[12813, 12813],
			"disallowed_STD3_mapped",
			[
				40,
				4370,
				41
			]
		],
		[
			[12814, 12814],
			"disallowed_STD3_mapped",
			[
				40,
				44032,
				41
			]
		],
		[
			[12815, 12815],
			"disallowed_STD3_mapped",
			[
				40,
				45208,
				41
			]
		],
		[
			[12816, 12816],
			"disallowed_STD3_mapped",
			[
				40,
				45796,
				41
			]
		],
		[
			[12817, 12817],
			"disallowed_STD3_mapped",
			[
				40,
				46972,
				41
			]
		],
		[
			[12818, 12818],
			"disallowed_STD3_mapped",
			[
				40,
				47560,
				41
			]
		],
		[
			[12819, 12819],
			"disallowed_STD3_mapped",
			[
				40,
				48148,
				41
			]
		],
		[
			[12820, 12820],
			"disallowed_STD3_mapped",
			[
				40,
				49324,
				41
			]
		],
		[
			[12821, 12821],
			"disallowed_STD3_mapped",
			[
				40,
				50500,
				41
			]
		],
		[
			[12822, 12822],
			"disallowed_STD3_mapped",
			[
				40,
				51088,
				41
			]
		],
		[
			[12823, 12823],
			"disallowed_STD3_mapped",
			[
				40,
				52264,
				41
			]
		],
		[
			[12824, 12824],
			"disallowed_STD3_mapped",
			[
				40,
				52852,
				41
			]
		],
		[
			[12825, 12825],
			"disallowed_STD3_mapped",
			[
				40,
				53440,
				41
			]
		],
		[
			[12826, 12826],
			"disallowed_STD3_mapped",
			[
				40,
				54028,
				41
			]
		],
		[
			[12827, 12827],
			"disallowed_STD3_mapped",
			[
				40,
				54616,
				41
			]
		],
		[
			[12828, 12828],
			"disallowed_STD3_mapped",
			[
				40,
				51452,
				41
			]
		],
		[
			[12829, 12829],
			"disallowed_STD3_mapped",
			[
				40,
				50724,
				51204,
				41
			]
		],
		[
			[12830, 12830],
			"disallowed_STD3_mapped",
			[
				40,
				50724,
				54980,
				41
			]
		],
		[[12831, 12831], "disallowed"],
		[
			[12832, 12832],
			"disallowed_STD3_mapped",
			[
				40,
				19968,
				41
			]
		],
		[
			[12833, 12833],
			"disallowed_STD3_mapped",
			[
				40,
				20108,
				41
			]
		],
		[
			[12834, 12834],
			"disallowed_STD3_mapped",
			[
				40,
				19977,
				41
			]
		],
		[
			[12835, 12835],
			"disallowed_STD3_mapped",
			[
				40,
				22235,
				41
			]
		],
		[
			[12836, 12836],
			"disallowed_STD3_mapped",
			[
				40,
				20116,
				41
			]
		],
		[
			[12837, 12837],
			"disallowed_STD3_mapped",
			[
				40,
				20845,
				41
			]
		],
		[
			[12838, 12838],
			"disallowed_STD3_mapped",
			[
				40,
				19971,
				41
			]
		],
		[
			[12839, 12839],
			"disallowed_STD3_mapped",
			[
				40,
				20843,
				41
			]
		],
		[
			[12840, 12840],
			"disallowed_STD3_mapped",
			[
				40,
				20061,
				41
			]
		],
		[
			[12841, 12841],
			"disallowed_STD3_mapped",
			[
				40,
				21313,
				41
			]
		],
		[
			[12842, 12842],
			"disallowed_STD3_mapped",
			[
				40,
				26376,
				41
			]
		],
		[
			[12843, 12843],
			"disallowed_STD3_mapped",
			[
				40,
				28779,
				41
			]
		],
		[
			[12844, 12844],
			"disallowed_STD3_mapped",
			[
				40,
				27700,
				41
			]
		],
		[
			[12845, 12845],
			"disallowed_STD3_mapped",
			[
				40,
				26408,
				41
			]
		],
		[
			[12846, 12846],
			"disallowed_STD3_mapped",
			[
				40,
				37329,
				41
			]
		],
		[
			[12847, 12847],
			"disallowed_STD3_mapped",
			[
				40,
				22303,
				41
			]
		],
		[
			[12848, 12848],
			"disallowed_STD3_mapped",
			[
				40,
				26085,
				41
			]
		],
		[
			[12849, 12849],
			"disallowed_STD3_mapped",
			[
				40,
				26666,
				41
			]
		],
		[
			[12850, 12850],
			"disallowed_STD3_mapped",
			[
				40,
				26377,
				41
			]
		],
		[
			[12851, 12851],
			"disallowed_STD3_mapped",
			[
				40,
				31038,
				41
			]
		],
		[
			[12852, 12852],
			"disallowed_STD3_mapped",
			[
				40,
				21517,
				41
			]
		],
		[
			[12853, 12853],
			"disallowed_STD3_mapped",
			[
				40,
				29305,
				41
			]
		],
		[
			[12854, 12854],
			"disallowed_STD3_mapped",
			[
				40,
				36001,
				41
			]
		],
		[
			[12855, 12855],
			"disallowed_STD3_mapped",
			[
				40,
				31069,
				41
			]
		],
		[
			[12856, 12856],
			"disallowed_STD3_mapped",
			[
				40,
				21172,
				41
			]
		],
		[
			[12857, 12857],
			"disallowed_STD3_mapped",
			[
				40,
				20195,
				41
			]
		],
		[
			[12858, 12858],
			"disallowed_STD3_mapped",
			[
				40,
				21628,
				41
			]
		],
		[
			[12859, 12859],
			"disallowed_STD3_mapped",
			[
				40,
				23398,
				41
			]
		],
		[
			[12860, 12860],
			"disallowed_STD3_mapped",
			[
				40,
				30435,
				41
			]
		],
		[
			[12861, 12861],
			"disallowed_STD3_mapped",
			[
				40,
				20225,
				41
			]
		],
		[
			[12862, 12862],
			"disallowed_STD3_mapped",
			[
				40,
				36039,
				41
			]
		],
		[
			[12863, 12863],
			"disallowed_STD3_mapped",
			[
				40,
				21332,
				41
			]
		],
		[
			[12864, 12864],
			"disallowed_STD3_mapped",
			[
				40,
				31085,
				41
			]
		],
		[
			[12865, 12865],
			"disallowed_STD3_mapped",
			[
				40,
				20241,
				41
			]
		],
		[
			[12866, 12866],
			"disallowed_STD3_mapped",
			[
				40,
				33258,
				41
			]
		],
		[
			[12867, 12867],
			"disallowed_STD3_mapped",
			[
				40,
				33267,
				41
			]
		],
		[
			[12868, 12868],
			"mapped",
			[21839]
		],
		[
			[12869, 12869],
			"mapped",
			[24188]
		],
		[
			[12870, 12870],
			"mapped",
			[25991]
		],
		[
			[12871, 12871],
			"mapped",
			[31631]
		],
		[
			[12872, 12879],
			"valid",
			[],
			"NV8"
		],
		[
			[12880, 12880],
			"mapped",
			[
				112,
				116,
				101
			]
		],
		[
			[12881, 12881],
			"mapped",
			[50, 49]
		],
		[
			[12882, 12882],
			"mapped",
			[50, 50]
		],
		[
			[12883, 12883],
			"mapped",
			[50, 51]
		],
		[
			[12884, 12884],
			"mapped",
			[50, 52]
		],
		[
			[12885, 12885],
			"mapped",
			[50, 53]
		],
		[
			[12886, 12886],
			"mapped",
			[50, 54]
		],
		[
			[12887, 12887],
			"mapped",
			[50, 55]
		],
		[
			[12888, 12888],
			"mapped",
			[50, 56]
		],
		[
			[12889, 12889],
			"mapped",
			[50, 57]
		],
		[
			[12890, 12890],
			"mapped",
			[51, 48]
		],
		[
			[12891, 12891],
			"mapped",
			[51, 49]
		],
		[
			[12892, 12892],
			"mapped",
			[51, 50]
		],
		[
			[12893, 12893],
			"mapped",
			[51, 51]
		],
		[
			[12894, 12894],
			"mapped",
			[51, 52]
		],
		[
			[12895, 12895],
			"mapped",
			[51, 53]
		],
		[
			[12896, 12896],
			"mapped",
			[4352]
		],
		[
			[12897, 12897],
			"mapped",
			[4354]
		],
		[
			[12898, 12898],
			"mapped",
			[4355]
		],
		[
			[12899, 12899],
			"mapped",
			[4357]
		],
		[
			[12900, 12900],
			"mapped",
			[4358]
		],
		[
			[12901, 12901],
			"mapped",
			[4359]
		],
		[
			[12902, 12902],
			"mapped",
			[4361]
		],
		[
			[12903, 12903],
			"mapped",
			[4363]
		],
		[
			[12904, 12904],
			"mapped",
			[4364]
		],
		[
			[12905, 12905],
			"mapped",
			[4366]
		],
		[
			[12906, 12906],
			"mapped",
			[4367]
		],
		[
			[12907, 12907],
			"mapped",
			[4368]
		],
		[
			[12908, 12908],
			"mapped",
			[4369]
		],
		[
			[12909, 12909],
			"mapped",
			[4370]
		],
		[
			[12910, 12910],
			"mapped",
			[44032]
		],
		[
			[12911, 12911],
			"mapped",
			[45208]
		],
		[
			[12912, 12912],
			"mapped",
			[45796]
		],
		[
			[12913, 12913],
			"mapped",
			[46972]
		],
		[
			[12914, 12914],
			"mapped",
			[47560]
		],
		[
			[12915, 12915],
			"mapped",
			[48148]
		],
		[
			[12916, 12916],
			"mapped",
			[49324]
		],
		[
			[12917, 12917],
			"mapped",
			[50500]
		],
		[
			[12918, 12918],
			"mapped",
			[51088]
		],
		[
			[12919, 12919],
			"mapped",
			[52264]
		],
		[
			[12920, 12920],
			"mapped",
			[52852]
		],
		[
			[12921, 12921],
			"mapped",
			[53440]
		],
		[
			[12922, 12922],
			"mapped",
			[54028]
		],
		[
			[12923, 12923],
			"mapped",
			[54616]
		],
		[
			[12924, 12924],
			"mapped",
			[52280, 44256]
		],
		[
			[12925, 12925],
			"mapped",
			[51452, 51032]
		],
		[
			[12926, 12926],
			"mapped",
			[50864]
		],
		[
			[12927, 12927],
			"valid",
			[],
			"NV8"
		],
		[
			[12928, 12928],
			"mapped",
			[19968]
		],
		[
			[12929, 12929],
			"mapped",
			[20108]
		],
		[
			[12930, 12930],
			"mapped",
			[19977]
		],
		[
			[12931, 12931],
			"mapped",
			[22235]
		],
		[
			[12932, 12932],
			"mapped",
			[20116]
		],
		[
			[12933, 12933],
			"mapped",
			[20845]
		],
		[
			[12934, 12934],
			"mapped",
			[19971]
		],
		[
			[12935, 12935],
			"mapped",
			[20843]
		],
		[
			[12936, 12936],
			"mapped",
			[20061]
		],
		[
			[12937, 12937],
			"mapped",
			[21313]
		],
		[
			[12938, 12938],
			"mapped",
			[26376]
		],
		[
			[12939, 12939],
			"mapped",
			[28779]
		],
		[
			[12940, 12940],
			"mapped",
			[27700]
		],
		[
			[12941, 12941],
			"mapped",
			[26408]
		],
		[
			[12942, 12942],
			"mapped",
			[37329]
		],
		[
			[12943, 12943],
			"mapped",
			[22303]
		],
		[
			[12944, 12944],
			"mapped",
			[26085]
		],
		[
			[12945, 12945],
			"mapped",
			[26666]
		],
		[
			[12946, 12946],
			"mapped",
			[26377]
		],
		[
			[12947, 12947],
			"mapped",
			[31038]
		],
		[
			[12948, 12948],
			"mapped",
			[21517]
		],
		[
			[12949, 12949],
			"mapped",
			[29305]
		],
		[
			[12950, 12950],
			"mapped",
			[36001]
		],
		[
			[12951, 12951],
			"mapped",
			[31069]
		],
		[
			[12952, 12952],
			"mapped",
			[21172]
		],
		[
			[12953, 12953],
			"mapped",
			[31192]
		],
		[
			[12954, 12954],
			"mapped",
			[30007]
		],
		[
			[12955, 12955],
			"mapped",
			[22899]
		],
		[
			[12956, 12956],
			"mapped",
			[36969]
		],
		[
			[12957, 12957],
			"mapped",
			[20778]
		],
		[
			[12958, 12958],
			"mapped",
			[21360]
		],
		[
			[12959, 12959],
			"mapped",
			[27880]
		],
		[
			[12960, 12960],
			"mapped",
			[38917]
		],
		[
			[12961, 12961],
			"mapped",
			[20241]
		],
		[
			[12962, 12962],
			"mapped",
			[20889]
		],
		[
			[12963, 12963],
			"mapped",
			[27491]
		],
		[
			[12964, 12964],
			"mapped",
			[19978]
		],
		[
			[12965, 12965],
			"mapped",
			[20013]
		],
		[
			[12966, 12966],
			"mapped",
			[19979]
		],
		[
			[12967, 12967],
			"mapped",
			[24038]
		],
		[
			[12968, 12968],
			"mapped",
			[21491]
		],
		[
			[12969, 12969],
			"mapped",
			[21307]
		],
		[
			[12970, 12970],
			"mapped",
			[23447]
		],
		[
			[12971, 12971],
			"mapped",
			[23398]
		],
		[
			[12972, 12972],
			"mapped",
			[30435]
		],
		[
			[12973, 12973],
			"mapped",
			[20225]
		],
		[
			[12974, 12974],
			"mapped",
			[36039]
		],
		[
			[12975, 12975],
			"mapped",
			[21332]
		],
		[
			[12976, 12976],
			"mapped",
			[22812]
		],
		[
			[12977, 12977],
			"mapped",
			[51, 54]
		],
		[
			[12978, 12978],
			"mapped",
			[51, 55]
		],
		[
			[12979, 12979],
			"mapped",
			[51, 56]
		],
		[
			[12980, 12980],
			"mapped",
			[51, 57]
		],
		[
			[12981, 12981],
			"mapped",
			[52, 48]
		],
		[
			[12982, 12982],
			"mapped",
			[52, 49]
		],
		[
			[12983, 12983],
			"mapped",
			[52, 50]
		],
		[
			[12984, 12984],
			"mapped",
			[52, 51]
		],
		[
			[12985, 12985],
			"mapped",
			[52, 52]
		],
		[
			[12986, 12986],
			"mapped",
			[52, 53]
		],
		[
			[12987, 12987],
			"mapped",
			[52, 54]
		],
		[
			[12988, 12988],
			"mapped",
			[52, 55]
		],
		[
			[12989, 12989],
			"mapped",
			[52, 56]
		],
		[
			[12990, 12990],
			"mapped",
			[52, 57]
		],
		[
			[12991, 12991],
			"mapped",
			[53, 48]
		],
		[
			[12992, 12992],
			"mapped",
			[49, 26376]
		],
		[
			[12993, 12993],
			"mapped",
			[50, 26376]
		],
		[
			[12994, 12994],
			"mapped",
			[51, 26376]
		],
		[
			[12995, 12995],
			"mapped",
			[52, 26376]
		],
		[
			[12996, 12996],
			"mapped",
			[53, 26376]
		],
		[
			[12997, 12997],
			"mapped",
			[54, 26376]
		],
		[
			[12998, 12998],
			"mapped",
			[55, 26376]
		],
		[
			[12999, 12999],
			"mapped",
			[56, 26376]
		],
		[
			[13e3, 13e3],
			"mapped",
			[57, 26376]
		],
		[
			[13001, 13001],
			"mapped",
			[
				49,
				48,
				26376
			]
		],
		[
			[13002, 13002],
			"mapped",
			[
				49,
				49,
				26376
			]
		],
		[
			[13003, 13003],
			"mapped",
			[
				49,
				50,
				26376
			]
		],
		[
			[13004, 13004],
			"mapped",
			[104, 103]
		],
		[
			[13005, 13005],
			"mapped",
			[
				101,
				114,
				103
			]
		],
		[
			[13006, 13006],
			"mapped",
			[101, 118]
		],
		[
			[13007, 13007],
			"mapped",
			[
				108,
				116,
				100
			]
		],
		[
			[13008, 13008],
			"mapped",
			[12450]
		],
		[
			[13009, 13009],
			"mapped",
			[12452]
		],
		[
			[13010, 13010],
			"mapped",
			[12454]
		],
		[
			[13011, 13011],
			"mapped",
			[12456]
		],
		[
			[13012, 13012],
			"mapped",
			[12458]
		],
		[
			[13013, 13013],
			"mapped",
			[12459]
		],
		[
			[13014, 13014],
			"mapped",
			[12461]
		],
		[
			[13015, 13015],
			"mapped",
			[12463]
		],
		[
			[13016, 13016],
			"mapped",
			[12465]
		],
		[
			[13017, 13017],
			"mapped",
			[12467]
		],
		[
			[13018, 13018],
			"mapped",
			[12469]
		],
		[
			[13019, 13019],
			"mapped",
			[12471]
		],
		[
			[13020, 13020],
			"mapped",
			[12473]
		],
		[
			[13021, 13021],
			"mapped",
			[12475]
		],
		[
			[13022, 13022],
			"mapped",
			[12477]
		],
		[
			[13023, 13023],
			"mapped",
			[12479]
		],
		[
			[13024, 13024],
			"mapped",
			[12481]
		],
		[
			[13025, 13025],
			"mapped",
			[12484]
		],
		[
			[13026, 13026],
			"mapped",
			[12486]
		],
		[
			[13027, 13027],
			"mapped",
			[12488]
		],
		[
			[13028, 13028],
			"mapped",
			[12490]
		],
		[
			[13029, 13029],
			"mapped",
			[12491]
		],
		[
			[13030, 13030],
			"mapped",
			[12492]
		],
		[
			[13031, 13031],
			"mapped",
			[12493]
		],
		[
			[13032, 13032],
			"mapped",
			[12494]
		],
		[
			[13033, 13033],
			"mapped",
			[12495]
		],
		[
			[13034, 13034],
			"mapped",
			[12498]
		],
		[
			[13035, 13035],
			"mapped",
			[12501]
		],
		[
			[13036, 13036],
			"mapped",
			[12504]
		],
		[
			[13037, 13037],
			"mapped",
			[12507]
		],
		[
			[13038, 13038],
			"mapped",
			[12510]
		],
		[
			[13039, 13039],
			"mapped",
			[12511]
		],
		[
			[13040, 13040],
			"mapped",
			[12512]
		],
		[
			[13041, 13041],
			"mapped",
			[12513]
		],
		[
			[13042, 13042],
			"mapped",
			[12514]
		],
		[
			[13043, 13043],
			"mapped",
			[12516]
		],
		[
			[13044, 13044],
			"mapped",
			[12518]
		],
		[
			[13045, 13045],
			"mapped",
			[12520]
		],
		[
			[13046, 13046],
			"mapped",
			[12521]
		],
		[
			[13047, 13047],
			"mapped",
			[12522]
		],
		[
			[13048, 13048],
			"mapped",
			[12523]
		],
		[
			[13049, 13049],
			"mapped",
			[12524]
		],
		[
			[13050, 13050],
			"mapped",
			[12525]
		],
		[
			[13051, 13051],
			"mapped",
			[12527]
		],
		[
			[13052, 13052],
			"mapped",
			[12528]
		],
		[
			[13053, 13053],
			"mapped",
			[12529]
		],
		[
			[13054, 13054],
			"mapped",
			[12530]
		],
		[[13055, 13055], "disallowed"],
		[
			[13056, 13056],
			"mapped",
			[
				12450,
				12497,
				12540,
				12488
			]
		],
		[
			[13057, 13057],
			"mapped",
			[
				12450,
				12523,
				12501,
				12449
			]
		],
		[
			[13058, 13058],
			"mapped",
			[
				12450,
				12531,
				12506,
				12450
			]
		],
		[
			[13059, 13059],
			"mapped",
			[
				12450,
				12540,
				12523
			]
		],
		[
			[13060, 13060],
			"mapped",
			[
				12452,
				12491,
				12531,
				12464
			]
		],
		[
			[13061, 13061],
			"mapped",
			[
				12452,
				12531,
				12481
			]
		],
		[
			[13062, 13062],
			"mapped",
			[
				12454,
				12457,
				12531
			]
		],
		[
			[13063, 13063],
			"mapped",
			[
				12456,
				12473,
				12463,
				12540,
				12489
			]
		],
		[
			[13064, 13064],
			"mapped",
			[
				12456,
				12540,
				12459,
				12540
			]
		],
		[
			[13065, 13065],
			"mapped",
			[
				12458,
				12531,
				12473
			]
		],
		[
			[13066, 13066],
			"mapped",
			[
				12458,
				12540,
				12512
			]
		],
		[
			[13067, 13067],
			"mapped",
			[
				12459,
				12452,
				12522
			]
		],
		[
			[13068, 13068],
			"mapped",
			[
				12459,
				12521,
				12483,
				12488
			]
		],
		[
			[13069, 13069],
			"mapped",
			[
				12459,
				12525,
				12522,
				12540
			]
		],
		[
			[13070, 13070],
			"mapped",
			[
				12460,
				12525,
				12531
			]
		],
		[
			[13071, 13071],
			"mapped",
			[
				12460,
				12531,
				12510
			]
		],
		[
			[13072, 13072],
			"mapped",
			[12462, 12460]
		],
		[
			[13073, 13073],
			"mapped",
			[
				12462,
				12491,
				12540
			]
		],
		[
			[13074, 13074],
			"mapped",
			[
				12461,
				12517,
				12522,
				12540
			]
		],
		[
			[13075, 13075],
			"mapped",
			[
				12462,
				12523,
				12480,
				12540
			]
		],
		[
			[13076, 13076],
			"mapped",
			[12461, 12525]
		],
		[
			[13077, 13077],
			"mapped",
			[
				12461,
				12525,
				12464,
				12521,
				12512
			]
		],
		[
			[13078, 13078],
			"mapped",
			[
				12461,
				12525,
				12513,
				12540,
				12488,
				12523
			]
		],
		[
			[13079, 13079],
			"mapped",
			[
				12461,
				12525,
				12527,
				12483,
				12488
			]
		],
		[
			[13080, 13080],
			"mapped",
			[
				12464,
				12521,
				12512
			]
		],
		[
			[13081, 13081],
			"mapped",
			[
				12464,
				12521,
				12512,
				12488,
				12531
			]
		],
		[
			[13082, 13082],
			"mapped",
			[
				12463,
				12523,
				12476,
				12452,
				12525
			]
		],
		[
			[13083, 13083],
			"mapped",
			[
				12463,
				12525,
				12540,
				12493
			]
		],
		[
			[13084, 13084],
			"mapped",
			[
				12465,
				12540,
				12473
			]
		],
		[
			[13085, 13085],
			"mapped",
			[
				12467,
				12523,
				12490
			]
		],
		[
			[13086, 13086],
			"mapped",
			[
				12467,
				12540,
				12509
			]
		],
		[
			[13087, 13087],
			"mapped",
			[
				12469,
				12452,
				12463,
				12523
			]
		],
		[
			[13088, 13088],
			"mapped",
			[
				12469,
				12531,
				12481,
				12540,
				12512
			]
		],
		[
			[13089, 13089],
			"mapped",
			[
				12471,
				12522,
				12531,
				12464
			]
		],
		[
			[13090, 13090],
			"mapped",
			[
				12475,
				12531,
				12481
			]
		],
		[
			[13091, 13091],
			"mapped",
			[
				12475,
				12531,
				12488
			]
		],
		[
			[13092, 13092],
			"mapped",
			[
				12480,
				12540,
				12473
			]
		],
		[
			[13093, 13093],
			"mapped",
			[12487, 12471]
		],
		[
			[13094, 13094],
			"mapped",
			[12489, 12523]
		],
		[
			[13095, 13095],
			"mapped",
			[12488, 12531]
		],
		[
			[13096, 13096],
			"mapped",
			[12490, 12494]
		],
		[
			[13097, 13097],
			"mapped",
			[
				12494,
				12483,
				12488
			]
		],
		[
			[13098, 13098],
			"mapped",
			[
				12495,
				12452,
				12484
			]
		],
		[
			[13099, 13099],
			"mapped",
			[
				12497,
				12540,
				12475,
				12531,
				12488
			]
		],
		[
			[13100, 13100],
			"mapped",
			[
				12497,
				12540,
				12484
			]
		],
		[
			[13101, 13101],
			"mapped",
			[
				12496,
				12540,
				12524,
				12523
			]
		],
		[
			[13102, 13102],
			"mapped",
			[
				12500,
				12450,
				12473,
				12488,
				12523
			]
		],
		[
			[13103, 13103],
			"mapped",
			[
				12500,
				12463,
				12523
			]
		],
		[
			[13104, 13104],
			"mapped",
			[12500, 12467]
		],
		[
			[13105, 13105],
			"mapped",
			[12499, 12523]
		],
		[
			[13106, 13106],
			"mapped",
			[
				12501,
				12449,
				12521,
				12483,
				12489
			]
		],
		[
			[13107, 13107],
			"mapped",
			[
				12501,
				12451,
				12540,
				12488
			]
		],
		[
			[13108, 13108],
			"mapped",
			[
				12502,
				12483,
				12471,
				12455,
				12523
			]
		],
		[
			[13109, 13109],
			"mapped",
			[
				12501,
				12521,
				12531
			]
		],
		[
			[13110, 13110],
			"mapped",
			[
				12504,
				12463,
				12479,
				12540,
				12523
			]
		],
		[
			[13111, 13111],
			"mapped",
			[12506, 12477]
		],
		[
			[13112, 13112],
			"mapped",
			[
				12506,
				12491,
				12498
			]
		],
		[
			[13113, 13113],
			"mapped",
			[
				12504,
				12523,
				12484
			]
		],
		[
			[13114, 13114],
			"mapped",
			[
				12506,
				12531,
				12473
			]
		],
		[
			[13115, 13115],
			"mapped",
			[
				12506,
				12540,
				12472
			]
		],
		[
			[13116, 13116],
			"mapped",
			[
				12505,
				12540,
				12479
			]
		],
		[
			[13117, 13117],
			"mapped",
			[
				12509,
				12452,
				12531,
				12488
			]
		],
		[
			[13118, 13118],
			"mapped",
			[
				12508,
				12523,
				12488
			]
		],
		[
			[13119, 13119],
			"mapped",
			[12507, 12531]
		],
		[
			[13120, 13120],
			"mapped",
			[
				12509,
				12531,
				12489
			]
		],
		[
			[13121, 13121],
			"mapped",
			[
				12507,
				12540,
				12523
			]
		],
		[
			[13122, 13122],
			"mapped",
			[
				12507,
				12540,
				12531
			]
		],
		[
			[13123, 13123],
			"mapped",
			[
				12510,
				12452,
				12463,
				12525
			]
		],
		[
			[13124, 13124],
			"mapped",
			[
				12510,
				12452,
				12523
			]
		],
		[
			[13125, 13125],
			"mapped",
			[
				12510,
				12483,
				12495
			]
		],
		[
			[13126, 13126],
			"mapped",
			[
				12510,
				12523,
				12463
			]
		],
		[
			[13127, 13127],
			"mapped",
			[
				12510,
				12531,
				12471,
				12519,
				12531
			]
		],
		[
			[13128, 13128],
			"mapped",
			[
				12511,
				12463,
				12525,
				12531
			]
		],
		[
			[13129, 13129],
			"mapped",
			[12511, 12522]
		],
		[
			[13130, 13130],
			"mapped",
			[
				12511,
				12522,
				12496,
				12540,
				12523
			]
		],
		[
			[13131, 13131],
			"mapped",
			[12513, 12460]
		],
		[
			[13132, 13132],
			"mapped",
			[
				12513,
				12460,
				12488,
				12531
			]
		],
		[
			[13133, 13133],
			"mapped",
			[
				12513,
				12540,
				12488,
				12523
			]
		],
		[
			[13134, 13134],
			"mapped",
			[
				12516,
				12540,
				12489
			]
		],
		[
			[13135, 13135],
			"mapped",
			[
				12516,
				12540,
				12523
			]
		],
		[
			[13136, 13136],
			"mapped",
			[
				12518,
				12450,
				12531
			]
		],
		[
			[13137, 13137],
			"mapped",
			[
				12522,
				12483,
				12488,
				12523
			]
		],
		[
			[13138, 13138],
			"mapped",
			[12522, 12521]
		],
		[
			[13139, 13139],
			"mapped",
			[
				12523,
				12500,
				12540
			]
		],
		[
			[13140, 13140],
			"mapped",
			[
				12523,
				12540,
				12502,
				12523
			]
		],
		[
			[13141, 13141],
			"mapped",
			[12524, 12512]
		],
		[
			[13142, 13142],
			"mapped",
			[
				12524,
				12531,
				12488,
				12466,
				12531
			]
		],
		[
			[13143, 13143],
			"mapped",
			[
				12527,
				12483,
				12488
			]
		],
		[
			[13144, 13144],
			"mapped",
			[48, 28857]
		],
		[
			[13145, 13145],
			"mapped",
			[49, 28857]
		],
		[
			[13146, 13146],
			"mapped",
			[50, 28857]
		],
		[
			[13147, 13147],
			"mapped",
			[51, 28857]
		],
		[
			[13148, 13148],
			"mapped",
			[52, 28857]
		],
		[
			[13149, 13149],
			"mapped",
			[53, 28857]
		],
		[
			[13150, 13150],
			"mapped",
			[54, 28857]
		],
		[
			[13151, 13151],
			"mapped",
			[55, 28857]
		],
		[
			[13152, 13152],
			"mapped",
			[56, 28857]
		],
		[
			[13153, 13153],
			"mapped",
			[57, 28857]
		],
		[
			[13154, 13154],
			"mapped",
			[
				49,
				48,
				28857
			]
		],
		[
			[13155, 13155],
			"mapped",
			[
				49,
				49,
				28857
			]
		],
		[
			[13156, 13156],
			"mapped",
			[
				49,
				50,
				28857
			]
		],
		[
			[13157, 13157],
			"mapped",
			[
				49,
				51,
				28857
			]
		],
		[
			[13158, 13158],
			"mapped",
			[
				49,
				52,
				28857
			]
		],
		[
			[13159, 13159],
			"mapped",
			[
				49,
				53,
				28857
			]
		],
		[
			[13160, 13160],
			"mapped",
			[
				49,
				54,
				28857
			]
		],
		[
			[13161, 13161],
			"mapped",
			[
				49,
				55,
				28857
			]
		],
		[
			[13162, 13162],
			"mapped",
			[
				49,
				56,
				28857
			]
		],
		[
			[13163, 13163],
			"mapped",
			[
				49,
				57,
				28857
			]
		],
		[
			[13164, 13164],
			"mapped",
			[
				50,
				48,
				28857
			]
		],
		[
			[13165, 13165],
			"mapped",
			[
				50,
				49,
				28857
			]
		],
		[
			[13166, 13166],
			"mapped",
			[
				50,
				50,
				28857
			]
		],
		[
			[13167, 13167],
			"mapped",
			[
				50,
				51,
				28857
			]
		],
		[
			[13168, 13168],
			"mapped",
			[
				50,
				52,
				28857
			]
		],
		[
			[13169, 13169],
			"mapped",
			[
				104,
				112,
				97
			]
		],
		[
			[13170, 13170],
			"mapped",
			[100, 97]
		],
		[
			[13171, 13171],
			"mapped",
			[97, 117]
		],
		[
			[13172, 13172],
			"mapped",
			[
				98,
				97,
				114
			]
		],
		[
			[13173, 13173],
			"mapped",
			[111, 118]
		],
		[
			[13174, 13174],
			"mapped",
			[112, 99]
		],
		[
			[13175, 13175],
			"mapped",
			[100, 109]
		],
		[
			[13176, 13176],
			"mapped",
			[
				100,
				109,
				50
			]
		],
		[
			[13177, 13177],
			"mapped",
			[
				100,
				109,
				51
			]
		],
		[
			[13178, 13178],
			"mapped",
			[105, 117]
		],
		[
			[13179, 13179],
			"mapped",
			[24179, 25104]
		],
		[
			[13180, 13180],
			"mapped",
			[26157, 21644]
		],
		[
			[13181, 13181],
			"mapped",
			[22823, 27491]
		],
		[
			[13182, 13182],
			"mapped",
			[26126, 27835]
		],
		[
			[13183, 13183],
			"mapped",
			[
				26666,
				24335,
				20250,
				31038
			]
		],
		[
			[13184, 13184],
			"mapped",
			[112, 97]
		],
		[
			[13185, 13185],
			"mapped",
			[110, 97]
		],
		[
			[13186, 13186],
			"mapped",
			[956, 97]
		],
		[
			[13187, 13187],
			"mapped",
			[109, 97]
		],
		[
			[13188, 13188],
			"mapped",
			[107, 97]
		],
		[
			[13189, 13189],
			"mapped",
			[107, 98]
		],
		[
			[13190, 13190],
			"mapped",
			[109, 98]
		],
		[
			[13191, 13191],
			"mapped",
			[103, 98]
		],
		[
			[13192, 13192],
			"mapped",
			[
				99,
				97,
				108
			]
		],
		[
			[13193, 13193],
			"mapped",
			[
				107,
				99,
				97,
				108
			]
		],
		[
			[13194, 13194],
			"mapped",
			[112, 102]
		],
		[
			[13195, 13195],
			"mapped",
			[110, 102]
		],
		[
			[13196, 13196],
			"mapped",
			[956, 102]
		],
		[
			[13197, 13197],
			"mapped",
			[956, 103]
		],
		[
			[13198, 13198],
			"mapped",
			[109, 103]
		],
		[
			[13199, 13199],
			"mapped",
			[107, 103]
		],
		[
			[13200, 13200],
			"mapped",
			[104, 122]
		],
		[
			[13201, 13201],
			"mapped",
			[
				107,
				104,
				122
			]
		],
		[
			[13202, 13202],
			"mapped",
			[
				109,
				104,
				122
			]
		],
		[
			[13203, 13203],
			"mapped",
			[
				103,
				104,
				122
			]
		],
		[
			[13204, 13204],
			"mapped",
			[
				116,
				104,
				122
			]
		],
		[
			[13205, 13205],
			"mapped",
			[956, 108]
		],
		[
			[13206, 13206],
			"mapped",
			[109, 108]
		],
		[
			[13207, 13207],
			"mapped",
			[100, 108]
		],
		[
			[13208, 13208],
			"mapped",
			[107, 108]
		],
		[
			[13209, 13209],
			"mapped",
			[102, 109]
		],
		[
			[13210, 13210],
			"mapped",
			[110, 109]
		],
		[
			[13211, 13211],
			"mapped",
			[956, 109]
		],
		[
			[13212, 13212],
			"mapped",
			[109, 109]
		],
		[
			[13213, 13213],
			"mapped",
			[99, 109]
		],
		[
			[13214, 13214],
			"mapped",
			[107, 109]
		],
		[
			[13215, 13215],
			"mapped",
			[
				109,
				109,
				50
			]
		],
		[
			[13216, 13216],
			"mapped",
			[
				99,
				109,
				50
			]
		],
		[
			[13217, 13217],
			"mapped",
			[109, 50]
		],
		[
			[13218, 13218],
			"mapped",
			[
				107,
				109,
				50
			]
		],
		[
			[13219, 13219],
			"mapped",
			[
				109,
				109,
				51
			]
		],
		[
			[13220, 13220],
			"mapped",
			[
				99,
				109,
				51
			]
		],
		[
			[13221, 13221],
			"mapped",
			[109, 51]
		],
		[
			[13222, 13222],
			"mapped",
			[
				107,
				109,
				51
			]
		],
		[
			[13223, 13223],
			"mapped",
			[
				109,
				8725,
				115
			]
		],
		[
			[13224, 13224],
			"mapped",
			[
				109,
				8725,
				115,
				50
			]
		],
		[
			[13225, 13225],
			"mapped",
			[112, 97]
		],
		[
			[13226, 13226],
			"mapped",
			[
				107,
				112,
				97
			]
		],
		[
			[13227, 13227],
			"mapped",
			[
				109,
				112,
				97
			]
		],
		[
			[13228, 13228],
			"mapped",
			[
				103,
				112,
				97
			]
		],
		[
			[13229, 13229],
			"mapped",
			[
				114,
				97,
				100
			]
		],
		[
			[13230, 13230],
			"mapped",
			[
				114,
				97,
				100,
				8725,
				115
			]
		],
		[
			[13231, 13231],
			"mapped",
			[
				114,
				97,
				100,
				8725,
				115,
				50
			]
		],
		[
			[13232, 13232],
			"mapped",
			[112, 115]
		],
		[
			[13233, 13233],
			"mapped",
			[110, 115]
		],
		[
			[13234, 13234],
			"mapped",
			[956, 115]
		],
		[
			[13235, 13235],
			"mapped",
			[109, 115]
		],
		[
			[13236, 13236],
			"mapped",
			[112, 118]
		],
		[
			[13237, 13237],
			"mapped",
			[110, 118]
		],
		[
			[13238, 13238],
			"mapped",
			[956, 118]
		],
		[
			[13239, 13239],
			"mapped",
			[109, 118]
		],
		[
			[13240, 13240],
			"mapped",
			[107, 118]
		],
		[
			[13241, 13241],
			"mapped",
			[109, 118]
		],
		[
			[13242, 13242],
			"mapped",
			[112, 119]
		],
		[
			[13243, 13243],
			"mapped",
			[110, 119]
		],
		[
			[13244, 13244],
			"mapped",
			[956, 119]
		],
		[
			[13245, 13245],
			"mapped",
			[109, 119]
		],
		[
			[13246, 13246],
			"mapped",
			[107, 119]
		],
		[
			[13247, 13247],
			"mapped",
			[109, 119]
		],
		[
			[13248, 13248],
			"mapped",
			[107, 969]
		],
		[
			[13249, 13249],
			"mapped",
			[109, 969]
		],
		[[13250, 13250], "disallowed"],
		[
			[13251, 13251],
			"mapped",
			[98, 113]
		],
		[
			[13252, 13252],
			"mapped",
			[99, 99]
		],
		[
			[13253, 13253],
			"mapped",
			[99, 100]
		],
		[
			[13254, 13254],
			"mapped",
			[
				99,
				8725,
				107,
				103
			]
		],
		[[13255, 13255], "disallowed"],
		[
			[13256, 13256],
			"mapped",
			[100, 98]
		],
		[
			[13257, 13257],
			"mapped",
			[103, 121]
		],
		[
			[13258, 13258],
			"mapped",
			[104, 97]
		],
		[
			[13259, 13259],
			"mapped",
			[104, 112]
		],
		[
			[13260, 13260],
			"mapped",
			[105, 110]
		],
		[
			[13261, 13261],
			"mapped",
			[107, 107]
		],
		[
			[13262, 13262],
			"mapped",
			[107, 109]
		],
		[
			[13263, 13263],
			"mapped",
			[107, 116]
		],
		[
			[13264, 13264],
			"mapped",
			[108, 109]
		],
		[
			[13265, 13265],
			"mapped",
			[108, 110]
		],
		[
			[13266, 13266],
			"mapped",
			[
				108,
				111,
				103
			]
		],
		[
			[13267, 13267],
			"mapped",
			[108, 120]
		],
		[
			[13268, 13268],
			"mapped",
			[109, 98]
		],
		[
			[13269, 13269],
			"mapped",
			[
				109,
				105,
				108
			]
		],
		[
			[13270, 13270],
			"mapped",
			[
				109,
				111,
				108
			]
		],
		[
			[13271, 13271],
			"mapped",
			[112, 104]
		],
		[[13272, 13272], "disallowed"],
		[
			[13273, 13273],
			"mapped",
			[
				112,
				112,
				109
			]
		],
		[
			[13274, 13274],
			"mapped",
			[112, 114]
		],
		[
			[13275, 13275],
			"mapped",
			[115, 114]
		],
		[
			[13276, 13276],
			"mapped",
			[115, 118]
		],
		[
			[13277, 13277],
			"mapped",
			[119, 98]
		],
		[
			[13278, 13278],
			"mapped",
			[
				118,
				8725,
				109
			]
		],
		[
			[13279, 13279],
			"mapped",
			[
				97,
				8725,
				109
			]
		],
		[
			[13280, 13280],
			"mapped",
			[49, 26085]
		],
		[
			[13281, 13281],
			"mapped",
			[50, 26085]
		],
		[
			[13282, 13282],
			"mapped",
			[51, 26085]
		],
		[
			[13283, 13283],
			"mapped",
			[52, 26085]
		],
		[
			[13284, 13284],
			"mapped",
			[53, 26085]
		],
		[
			[13285, 13285],
			"mapped",
			[54, 26085]
		],
		[
			[13286, 13286],
			"mapped",
			[55, 26085]
		],
		[
			[13287, 13287],
			"mapped",
			[56, 26085]
		],
		[
			[13288, 13288],
			"mapped",
			[57, 26085]
		],
		[
			[13289, 13289],
			"mapped",
			[
				49,
				48,
				26085
			]
		],
		[
			[13290, 13290],
			"mapped",
			[
				49,
				49,
				26085
			]
		],
		[
			[13291, 13291],
			"mapped",
			[
				49,
				50,
				26085
			]
		],
		[
			[13292, 13292],
			"mapped",
			[
				49,
				51,
				26085
			]
		],
		[
			[13293, 13293],
			"mapped",
			[
				49,
				52,
				26085
			]
		],
		[
			[13294, 13294],
			"mapped",
			[
				49,
				53,
				26085
			]
		],
		[
			[13295, 13295],
			"mapped",
			[
				49,
				54,
				26085
			]
		],
		[
			[13296, 13296],
			"mapped",
			[
				49,
				55,
				26085
			]
		],
		[
			[13297, 13297],
			"mapped",
			[
				49,
				56,
				26085
			]
		],
		[
			[13298, 13298],
			"mapped",
			[
				49,
				57,
				26085
			]
		],
		[
			[13299, 13299],
			"mapped",
			[
				50,
				48,
				26085
			]
		],
		[
			[13300, 13300],
			"mapped",
			[
				50,
				49,
				26085
			]
		],
		[
			[13301, 13301],
			"mapped",
			[
				50,
				50,
				26085
			]
		],
		[
			[13302, 13302],
			"mapped",
			[
				50,
				51,
				26085
			]
		],
		[
			[13303, 13303],
			"mapped",
			[
				50,
				52,
				26085
			]
		],
		[
			[13304, 13304],
			"mapped",
			[
				50,
				53,
				26085
			]
		],
		[
			[13305, 13305],
			"mapped",
			[
				50,
				54,
				26085
			]
		],
		[
			[13306, 13306],
			"mapped",
			[
				50,
				55,
				26085
			]
		],
		[
			[13307, 13307],
			"mapped",
			[
				50,
				56,
				26085
			]
		],
		[
			[13308, 13308],
			"mapped",
			[
				50,
				57,
				26085
			]
		],
		[
			[13309, 13309],
			"mapped",
			[
				51,
				48,
				26085
			]
		],
		[
			[13310, 13310],
			"mapped",
			[
				51,
				49,
				26085
			]
		],
		[
			[13311, 13311],
			"mapped",
			[
				103,
				97,
				108
			]
		],
		[[13312, 19893], "valid"],
		[[19894, 19903], "disallowed"],
		[
			[19904, 19967],
			"valid",
			[],
			"NV8"
		],
		[[19968, 40869], "valid"],
		[[40870, 40891], "valid"],
		[[40892, 40899], "valid"],
		[[40900, 40907], "valid"],
		[[40908, 40908], "valid"],
		[[40909, 40917], "valid"],
		[[40918, 40959], "disallowed"],
		[[40960, 42124], "valid"],
		[[42125, 42127], "disallowed"],
		[
			[42128, 42145],
			"valid",
			[],
			"NV8"
		],
		[
			[42146, 42147],
			"valid",
			[],
			"NV8"
		],
		[
			[42148, 42163],
			"valid",
			[],
			"NV8"
		],
		[
			[42164, 42164],
			"valid",
			[],
			"NV8"
		],
		[
			[42165, 42176],
			"valid",
			[],
			"NV8"
		],
		[
			[42177, 42177],
			"valid",
			[],
			"NV8"
		],
		[
			[42178, 42180],
			"valid",
			[],
			"NV8"
		],
		[
			[42181, 42181],
			"valid",
			[],
			"NV8"
		],
		[
			[42182, 42182],
			"valid",
			[],
			"NV8"
		],
		[[42183, 42191], "disallowed"],
		[[42192, 42237], "valid"],
		[
			[42238, 42239],
			"valid",
			[],
			"NV8"
		],
		[[42240, 42508], "valid"],
		[
			[42509, 42511],
			"valid",
			[],
			"NV8"
		],
		[[42512, 42539], "valid"],
		[[42540, 42559], "disallowed"],
		[
			[42560, 42560],
			"mapped",
			[42561]
		],
		[[42561, 42561], "valid"],
		[
			[42562, 42562],
			"mapped",
			[42563]
		],
		[[42563, 42563], "valid"],
		[
			[42564, 42564],
			"mapped",
			[42565]
		],
		[[42565, 42565], "valid"],
		[
			[42566, 42566],
			"mapped",
			[42567]
		],
		[[42567, 42567], "valid"],
		[
			[42568, 42568],
			"mapped",
			[42569]
		],
		[[42569, 42569], "valid"],
		[
			[42570, 42570],
			"mapped",
			[42571]
		],
		[[42571, 42571], "valid"],
		[
			[42572, 42572],
			"mapped",
			[42573]
		],
		[[42573, 42573], "valid"],
		[
			[42574, 42574],
			"mapped",
			[42575]
		],
		[[42575, 42575], "valid"],
		[
			[42576, 42576],
			"mapped",
			[42577]
		],
		[[42577, 42577], "valid"],
		[
			[42578, 42578],
			"mapped",
			[42579]
		],
		[[42579, 42579], "valid"],
		[
			[42580, 42580],
			"mapped",
			[42581]
		],
		[[42581, 42581], "valid"],
		[
			[42582, 42582],
			"mapped",
			[42583]
		],
		[[42583, 42583], "valid"],
		[
			[42584, 42584],
			"mapped",
			[42585]
		],
		[[42585, 42585], "valid"],
		[
			[42586, 42586],
			"mapped",
			[42587]
		],
		[[42587, 42587], "valid"],
		[
			[42588, 42588],
			"mapped",
			[42589]
		],
		[[42589, 42589], "valid"],
		[
			[42590, 42590],
			"mapped",
			[42591]
		],
		[[42591, 42591], "valid"],
		[
			[42592, 42592],
			"mapped",
			[42593]
		],
		[[42593, 42593], "valid"],
		[
			[42594, 42594],
			"mapped",
			[42595]
		],
		[[42595, 42595], "valid"],
		[
			[42596, 42596],
			"mapped",
			[42597]
		],
		[[42597, 42597], "valid"],
		[
			[42598, 42598],
			"mapped",
			[42599]
		],
		[[42599, 42599], "valid"],
		[
			[42600, 42600],
			"mapped",
			[42601]
		],
		[[42601, 42601], "valid"],
		[
			[42602, 42602],
			"mapped",
			[42603]
		],
		[[42603, 42603], "valid"],
		[
			[42604, 42604],
			"mapped",
			[42605]
		],
		[[42605, 42607], "valid"],
		[
			[42608, 42611],
			"valid",
			[],
			"NV8"
		],
		[[42612, 42619], "valid"],
		[[42620, 42621], "valid"],
		[
			[42622, 42622],
			"valid",
			[],
			"NV8"
		],
		[[42623, 42623], "valid"],
		[
			[42624, 42624],
			"mapped",
			[42625]
		],
		[[42625, 42625], "valid"],
		[
			[42626, 42626],
			"mapped",
			[42627]
		],
		[[42627, 42627], "valid"],
		[
			[42628, 42628],
			"mapped",
			[42629]
		],
		[[42629, 42629], "valid"],
		[
			[42630, 42630],
			"mapped",
			[42631]
		],
		[[42631, 42631], "valid"],
		[
			[42632, 42632],
			"mapped",
			[42633]
		],
		[[42633, 42633], "valid"],
		[
			[42634, 42634],
			"mapped",
			[42635]
		],
		[[42635, 42635], "valid"],
		[
			[42636, 42636],
			"mapped",
			[42637]
		],
		[[42637, 42637], "valid"],
		[
			[42638, 42638],
			"mapped",
			[42639]
		],
		[[42639, 42639], "valid"],
		[
			[42640, 42640],
			"mapped",
			[42641]
		],
		[[42641, 42641], "valid"],
		[
			[42642, 42642],
			"mapped",
			[42643]
		],
		[[42643, 42643], "valid"],
		[
			[42644, 42644],
			"mapped",
			[42645]
		],
		[[42645, 42645], "valid"],
		[
			[42646, 42646],
			"mapped",
			[42647]
		],
		[[42647, 42647], "valid"],
		[
			[42648, 42648],
			"mapped",
			[42649]
		],
		[[42649, 42649], "valid"],
		[
			[42650, 42650],
			"mapped",
			[42651]
		],
		[[42651, 42651], "valid"],
		[
			[42652, 42652],
			"mapped",
			[1098]
		],
		[
			[42653, 42653],
			"mapped",
			[1100]
		],
		[[42654, 42654], "valid"],
		[[42655, 42655], "valid"],
		[[42656, 42725], "valid"],
		[
			[42726, 42735],
			"valid",
			[],
			"NV8"
		],
		[[42736, 42737], "valid"],
		[
			[42738, 42743],
			"valid",
			[],
			"NV8"
		],
		[[42744, 42751], "disallowed"],
		[
			[42752, 42774],
			"valid",
			[],
			"NV8"
		],
		[[42775, 42778], "valid"],
		[[42779, 42783], "valid"],
		[
			[42784, 42785],
			"valid",
			[],
			"NV8"
		],
		[
			[42786, 42786],
			"mapped",
			[42787]
		],
		[[42787, 42787], "valid"],
		[
			[42788, 42788],
			"mapped",
			[42789]
		],
		[[42789, 42789], "valid"],
		[
			[42790, 42790],
			"mapped",
			[42791]
		],
		[[42791, 42791], "valid"],
		[
			[42792, 42792],
			"mapped",
			[42793]
		],
		[[42793, 42793], "valid"],
		[
			[42794, 42794],
			"mapped",
			[42795]
		],
		[[42795, 42795], "valid"],
		[
			[42796, 42796],
			"mapped",
			[42797]
		],
		[[42797, 42797], "valid"],
		[
			[42798, 42798],
			"mapped",
			[42799]
		],
		[[42799, 42801], "valid"],
		[
			[42802, 42802],
			"mapped",
			[42803]
		],
		[[42803, 42803], "valid"],
		[
			[42804, 42804],
			"mapped",
			[42805]
		],
		[[42805, 42805], "valid"],
		[
			[42806, 42806],
			"mapped",
			[42807]
		],
		[[42807, 42807], "valid"],
		[
			[42808, 42808],
			"mapped",
			[42809]
		],
		[[42809, 42809], "valid"],
		[
			[42810, 42810],
			"mapped",
			[42811]
		],
		[[42811, 42811], "valid"],
		[
			[42812, 42812],
			"mapped",
			[42813]
		],
		[[42813, 42813], "valid"],
		[
			[42814, 42814],
			"mapped",
			[42815]
		],
		[[42815, 42815], "valid"],
		[
			[42816, 42816],
			"mapped",
			[42817]
		],
		[[42817, 42817], "valid"],
		[
			[42818, 42818],
			"mapped",
			[42819]
		],
		[[42819, 42819], "valid"],
		[
			[42820, 42820],
			"mapped",
			[42821]
		],
		[[42821, 42821], "valid"],
		[
			[42822, 42822],
			"mapped",
			[42823]
		],
		[[42823, 42823], "valid"],
		[
			[42824, 42824],
			"mapped",
			[42825]
		],
		[[42825, 42825], "valid"],
		[
			[42826, 42826],
			"mapped",
			[42827]
		],
		[[42827, 42827], "valid"],
		[
			[42828, 42828],
			"mapped",
			[42829]
		],
		[[42829, 42829], "valid"],
		[
			[42830, 42830],
			"mapped",
			[42831]
		],
		[[42831, 42831], "valid"],
		[
			[42832, 42832],
			"mapped",
			[42833]
		],
		[[42833, 42833], "valid"],
		[
			[42834, 42834],
			"mapped",
			[42835]
		],
		[[42835, 42835], "valid"],
		[
			[42836, 42836],
			"mapped",
			[42837]
		],
		[[42837, 42837], "valid"],
		[
			[42838, 42838],
			"mapped",
			[42839]
		],
		[[42839, 42839], "valid"],
		[
			[42840, 42840],
			"mapped",
			[42841]
		],
		[[42841, 42841], "valid"],
		[
			[42842, 42842],
			"mapped",
			[42843]
		],
		[[42843, 42843], "valid"],
		[
			[42844, 42844],
			"mapped",
			[42845]
		],
		[[42845, 42845], "valid"],
		[
			[42846, 42846],
			"mapped",
			[42847]
		],
		[[42847, 42847], "valid"],
		[
			[42848, 42848],
			"mapped",
			[42849]
		],
		[[42849, 42849], "valid"],
		[
			[42850, 42850],
			"mapped",
			[42851]
		],
		[[42851, 42851], "valid"],
		[
			[42852, 42852],
			"mapped",
			[42853]
		],
		[[42853, 42853], "valid"],
		[
			[42854, 42854],
			"mapped",
			[42855]
		],
		[[42855, 42855], "valid"],
		[
			[42856, 42856],
			"mapped",
			[42857]
		],
		[[42857, 42857], "valid"],
		[
			[42858, 42858],
			"mapped",
			[42859]
		],
		[[42859, 42859], "valid"],
		[
			[42860, 42860],
			"mapped",
			[42861]
		],
		[[42861, 42861], "valid"],
		[
			[42862, 42862],
			"mapped",
			[42863]
		],
		[[42863, 42863], "valid"],
		[
			[42864, 42864],
			"mapped",
			[42863]
		],
		[[42865, 42872], "valid"],
		[
			[42873, 42873],
			"mapped",
			[42874]
		],
		[[42874, 42874], "valid"],
		[
			[42875, 42875],
			"mapped",
			[42876]
		],
		[[42876, 42876], "valid"],
		[
			[42877, 42877],
			"mapped",
			[7545]
		],
		[
			[42878, 42878],
			"mapped",
			[42879]
		],
		[[42879, 42879], "valid"],
		[
			[42880, 42880],
			"mapped",
			[42881]
		],
		[[42881, 42881], "valid"],
		[
			[42882, 42882],
			"mapped",
			[42883]
		],
		[[42883, 42883], "valid"],
		[
			[42884, 42884],
			"mapped",
			[42885]
		],
		[[42885, 42885], "valid"],
		[
			[42886, 42886],
			"mapped",
			[42887]
		],
		[[42887, 42888], "valid"],
		[
			[42889, 42890],
			"valid",
			[],
			"NV8"
		],
		[
			[42891, 42891],
			"mapped",
			[42892]
		],
		[[42892, 42892], "valid"],
		[
			[42893, 42893],
			"mapped",
			[613]
		],
		[[42894, 42894], "valid"],
		[[42895, 42895], "valid"],
		[
			[42896, 42896],
			"mapped",
			[42897]
		],
		[[42897, 42897], "valid"],
		[
			[42898, 42898],
			"mapped",
			[42899]
		],
		[[42899, 42899], "valid"],
		[[42900, 42901], "valid"],
		[
			[42902, 42902],
			"mapped",
			[42903]
		],
		[[42903, 42903], "valid"],
		[
			[42904, 42904],
			"mapped",
			[42905]
		],
		[[42905, 42905], "valid"],
		[
			[42906, 42906],
			"mapped",
			[42907]
		],
		[[42907, 42907], "valid"],
		[
			[42908, 42908],
			"mapped",
			[42909]
		],
		[[42909, 42909], "valid"],
		[
			[42910, 42910],
			"mapped",
			[42911]
		],
		[[42911, 42911], "valid"],
		[
			[42912, 42912],
			"mapped",
			[42913]
		],
		[[42913, 42913], "valid"],
		[
			[42914, 42914],
			"mapped",
			[42915]
		],
		[[42915, 42915], "valid"],
		[
			[42916, 42916],
			"mapped",
			[42917]
		],
		[[42917, 42917], "valid"],
		[
			[42918, 42918],
			"mapped",
			[42919]
		],
		[[42919, 42919], "valid"],
		[
			[42920, 42920],
			"mapped",
			[42921]
		],
		[[42921, 42921], "valid"],
		[
			[42922, 42922],
			"mapped",
			[614]
		],
		[
			[42923, 42923],
			"mapped",
			[604]
		],
		[
			[42924, 42924],
			"mapped",
			[609]
		],
		[
			[42925, 42925],
			"mapped",
			[620]
		],
		[[42926, 42927], "disallowed"],
		[
			[42928, 42928],
			"mapped",
			[670]
		],
		[
			[42929, 42929],
			"mapped",
			[647]
		],
		[
			[42930, 42930],
			"mapped",
			[669]
		],
		[
			[42931, 42931],
			"mapped",
			[43859]
		],
		[
			[42932, 42932],
			"mapped",
			[42933]
		],
		[[42933, 42933], "valid"],
		[
			[42934, 42934],
			"mapped",
			[42935]
		],
		[[42935, 42935], "valid"],
		[[42936, 42998], "disallowed"],
		[[42999, 42999], "valid"],
		[
			[43e3, 43e3],
			"mapped",
			[295]
		],
		[
			[43001, 43001],
			"mapped",
			[339]
		],
		[[43002, 43002], "valid"],
		[[43003, 43007], "valid"],
		[[43008, 43047], "valid"],
		[
			[43048, 43051],
			"valid",
			[],
			"NV8"
		],
		[[43052, 43055], "disallowed"],
		[
			[43056, 43065],
			"valid",
			[],
			"NV8"
		],
		[[43066, 43071], "disallowed"],
		[[43072, 43123], "valid"],
		[
			[43124, 43127],
			"valid",
			[],
			"NV8"
		],
		[[43128, 43135], "disallowed"],
		[[43136, 43204], "valid"],
		[[43205, 43213], "disallowed"],
		[
			[43214, 43215],
			"valid",
			[],
			"NV8"
		],
		[[43216, 43225], "valid"],
		[[43226, 43231], "disallowed"],
		[[43232, 43255], "valid"],
		[
			[43256, 43258],
			"valid",
			[],
			"NV8"
		],
		[[43259, 43259], "valid"],
		[
			[43260, 43260],
			"valid",
			[],
			"NV8"
		],
		[[43261, 43261], "valid"],
		[[43262, 43263], "disallowed"],
		[[43264, 43309], "valid"],
		[
			[43310, 43311],
			"valid",
			[],
			"NV8"
		],
		[[43312, 43347], "valid"],
		[[43348, 43358], "disallowed"],
		[
			[43359, 43359],
			"valid",
			[],
			"NV8"
		],
		[
			[43360, 43388],
			"valid",
			[],
			"NV8"
		],
		[[43389, 43391], "disallowed"],
		[[43392, 43456], "valid"],
		[
			[43457, 43469],
			"valid",
			[],
			"NV8"
		],
		[[43470, 43470], "disallowed"],
		[[43471, 43481], "valid"],
		[[43482, 43485], "disallowed"],
		[
			[43486, 43487],
			"valid",
			[],
			"NV8"
		],
		[[43488, 43518], "valid"],
		[[43519, 43519], "disallowed"],
		[[43520, 43574], "valid"],
		[[43575, 43583], "disallowed"],
		[[43584, 43597], "valid"],
		[[43598, 43599], "disallowed"],
		[[43600, 43609], "valid"],
		[[43610, 43611], "disallowed"],
		[
			[43612, 43615],
			"valid",
			[],
			"NV8"
		],
		[[43616, 43638], "valid"],
		[
			[43639, 43641],
			"valid",
			[],
			"NV8"
		],
		[[43642, 43643], "valid"],
		[[43644, 43647], "valid"],
		[[43648, 43714], "valid"],
		[[43715, 43738], "disallowed"],
		[[43739, 43741], "valid"],
		[
			[43742, 43743],
			"valid",
			[],
			"NV8"
		],
		[[43744, 43759], "valid"],
		[
			[43760, 43761],
			"valid",
			[],
			"NV8"
		],
		[[43762, 43766], "valid"],
		[[43767, 43776], "disallowed"],
		[[43777, 43782], "valid"],
		[[43783, 43784], "disallowed"],
		[[43785, 43790], "valid"],
		[[43791, 43792], "disallowed"],
		[[43793, 43798], "valid"],
		[[43799, 43807], "disallowed"],
		[[43808, 43814], "valid"],
		[[43815, 43815], "disallowed"],
		[[43816, 43822], "valid"],
		[[43823, 43823], "disallowed"],
		[[43824, 43866], "valid"],
		[
			[43867, 43867],
			"valid",
			[],
			"NV8"
		],
		[
			[43868, 43868],
			"mapped",
			[42791]
		],
		[
			[43869, 43869],
			"mapped",
			[43831]
		],
		[
			[43870, 43870],
			"mapped",
			[619]
		],
		[
			[43871, 43871],
			"mapped",
			[43858]
		],
		[[43872, 43875], "valid"],
		[[43876, 43877], "valid"],
		[[43878, 43887], "disallowed"],
		[
			[43888, 43888],
			"mapped",
			[5024]
		],
		[
			[43889, 43889],
			"mapped",
			[5025]
		],
		[
			[43890, 43890],
			"mapped",
			[5026]
		],
		[
			[43891, 43891],
			"mapped",
			[5027]
		],
		[
			[43892, 43892],
			"mapped",
			[5028]
		],
		[
			[43893, 43893],
			"mapped",
			[5029]
		],
		[
			[43894, 43894],
			"mapped",
			[5030]
		],
		[
			[43895, 43895],
			"mapped",
			[5031]
		],
		[
			[43896, 43896],
			"mapped",
			[5032]
		],
		[
			[43897, 43897],
			"mapped",
			[5033]
		],
		[
			[43898, 43898],
			"mapped",
			[5034]
		],
		[
			[43899, 43899],
			"mapped",
			[5035]
		],
		[
			[43900, 43900],
			"mapped",
			[5036]
		],
		[
			[43901, 43901],
			"mapped",
			[5037]
		],
		[
			[43902, 43902],
			"mapped",
			[5038]
		],
		[
			[43903, 43903],
			"mapped",
			[5039]
		],
		[
			[43904, 43904],
			"mapped",
			[5040]
		],
		[
			[43905, 43905],
			"mapped",
			[5041]
		],
		[
			[43906, 43906],
			"mapped",
			[5042]
		],
		[
			[43907, 43907],
			"mapped",
			[5043]
		],
		[
			[43908, 43908],
			"mapped",
			[5044]
		],
		[
			[43909, 43909],
			"mapped",
			[5045]
		],
		[
			[43910, 43910],
			"mapped",
			[5046]
		],
		[
			[43911, 43911],
			"mapped",
			[5047]
		],
		[
			[43912, 43912],
			"mapped",
			[5048]
		],
		[
			[43913, 43913],
			"mapped",
			[5049]
		],
		[
			[43914, 43914],
			"mapped",
			[5050]
		],
		[
			[43915, 43915],
			"mapped",
			[5051]
		],
		[
			[43916, 43916],
			"mapped",
			[5052]
		],
		[
			[43917, 43917],
			"mapped",
			[5053]
		],
		[
			[43918, 43918],
			"mapped",
			[5054]
		],
		[
			[43919, 43919],
			"mapped",
			[5055]
		],
		[
			[43920, 43920],
			"mapped",
			[5056]
		],
		[
			[43921, 43921],
			"mapped",
			[5057]
		],
		[
			[43922, 43922],
			"mapped",
			[5058]
		],
		[
			[43923, 43923],
			"mapped",
			[5059]
		],
		[
			[43924, 43924],
			"mapped",
			[5060]
		],
		[
			[43925, 43925],
			"mapped",
			[5061]
		],
		[
			[43926, 43926],
			"mapped",
			[5062]
		],
		[
			[43927, 43927],
			"mapped",
			[5063]
		],
		[
			[43928, 43928],
			"mapped",
			[5064]
		],
		[
			[43929, 43929],
			"mapped",
			[5065]
		],
		[
			[43930, 43930],
			"mapped",
			[5066]
		],
		[
			[43931, 43931],
			"mapped",
			[5067]
		],
		[
			[43932, 43932],
			"mapped",
			[5068]
		],
		[
			[43933, 43933],
			"mapped",
			[5069]
		],
		[
			[43934, 43934],
			"mapped",
			[5070]
		],
		[
			[43935, 43935],
			"mapped",
			[5071]
		],
		[
			[43936, 43936],
			"mapped",
			[5072]
		],
		[
			[43937, 43937],
			"mapped",
			[5073]
		],
		[
			[43938, 43938],
			"mapped",
			[5074]
		],
		[
			[43939, 43939],
			"mapped",
			[5075]
		],
		[
			[43940, 43940],
			"mapped",
			[5076]
		],
		[
			[43941, 43941],
			"mapped",
			[5077]
		],
		[
			[43942, 43942],
			"mapped",
			[5078]
		],
		[
			[43943, 43943],
			"mapped",
			[5079]
		],
		[
			[43944, 43944],
			"mapped",
			[5080]
		],
		[
			[43945, 43945],
			"mapped",
			[5081]
		],
		[
			[43946, 43946],
			"mapped",
			[5082]
		],
		[
			[43947, 43947],
			"mapped",
			[5083]
		],
		[
			[43948, 43948],
			"mapped",
			[5084]
		],
		[
			[43949, 43949],
			"mapped",
			[5085]
		],
		[
			[43950, 43950],
			"mapped",
			[5086]
		],
		[
			[43951, 43951],
			"mapped",
			[5087]
		],
		[
			[43952, 43952],
			"mapped",
			[5088]
		],
		[
			[43953, 43953],
			"mapped",
			[5089]
		],
		[
			[43954, 43954],
			"mapped",
			[5090]
		],
		[
			[43955, 43955],
			"mapped",
			[5091]
		],
		[
			[43956, 43956],
			"mapped",
			[5092]
		],
		[
			[43957, 43957],
			"mapped",
			[5093]
		],
		[
			[43958, 43958],
			"mapped",
			[5094]
		],
		[
			[43959, 43959],
			"mapped",
			[5095]
		],
		[
			[43960, 43960],
			"mapped",
			[5096]
		],
		[
			[43961, 43961],
			"mapped",
			[5097]
		],
		[
			[43962, 43962],
			"mapped",
			[5098]
		],
		[
			[43963, 43963],
			"mapped",
			[5099]
		],
		[
			[43964, 43964],
			"mapped",
			[5100]
		],
		[
			[43965, 43965],
			"mapped",
			[5101]
		],
		[
			[43966, 43966],
			"mapped",
			[5102]
		],
		[
			[43967, 43967],
			"mapped",
			[5103]
		],
		[[43968, 44010], "valid"],
		[
			[44011, 44011],
			"valid",
			[],
			"NV8"
		],
		[[44012, 44013], "valid"],
		[[44014, 44015], "disallowed"],
		[[44016, 44025], "valid"],
		[[44026, 44031], "disallowed"],
		[[44032, 55203], "valid"],
		[[55204, 55215], "disallowed"],
		[
			[55216, 55238],
			"valid",
			[],
			"NV8"
		],
		[[55239, 55242], "disallowed"],
		[
			[55243, 55291],
			"valid",
			[],
			"NV8"
		],
		[[55292, 55295], "disallowed"],
		[[55296, 57343], "disallowed"],
		[[57344, 63743], "disallowed"],
		[
			[63744, 63744],
			"mapped",
			[35912]
		],
		[
			[63745, 63745],
			"mapped",
			[26356]
		],
		[
			[63746, 63746],
			"mapped",
			[36554]
		],
		[
			[63747, 63747],
			"mapped",
			[36040]
		],
		[
			[63748, 63748],
			"mapped",
			[28369]
		],
		[
			[63749, 63749],
			"mapped",
			[20018]
		],
		[
			[63750, 63750],
			"mapped",
			[21477]
		],
		[
			[63751, 63752],
			"mapped",
			[40860]
		],
		[
			[63753, 63753],
			"mapped",
			[22865]
		],
		[
			[63754, 63754],
			"mapped",
			[37329]
		],
		[
			[63755, 63755],
			"mapped",
			[21895]
		],
		[
			[63756, 63756],
			"mapped",
			[22856]
		],
		[
			[63757, 63757],
			"mapped",
			[25078]
		],
		[
			[63758, 63758],
			"mapped",
			[30313]
		],
		[
			[63759, 63759],
			"mapped",
			[32645]
		],
		[
			[63760, 63760],
			"mapped",
			[34367]
		],
		[
			[63761, 63761],
			"mapped",
			[34746]
		],
		[
			[63762, 63762],
			"mapped",
			[35064]
		],
		[
			[63763, 63763],
			"mapped",
			[37007]
		],
		[
			[63764, 63764],
			"mapped",
			[27138]
		],
		[
			[63765, 63765],
			"mapped",
			[27931]
		],
		[
			[63766, 63766],
			"mapped",
			[28889]
		],
		[
			[63767, 63767],
			"mapped",
			[29662]
		],
		[
			[63768, 63768],
			"mapped",
			[33853]
		],
		[
			[63769, 63769],
			"mapped",
			[37226]
		],
		[
			[63770, 63770],
			"mapped",
			[39409]
		],
		[
			[63771, 63771],
			"mapped",
			[20098]
		],
		[
			[63772, 63772],
			"mapped",
			[21365]
		],
		[
			[63773, 63773],
			"mapped",
			[27396]
		],
		[
			[63774, 63774],
			"mapped",
			[29211]
		],
		[
			[63775, 63775],
			"mapped",
			[34349]
		],
		[
			[63776, 63776],
			"mapped",
			[40478]
		],
		[
			[63777, 63777],
			"mapped",
			[23888]
		],
		[
			[63778, 63778],
			"mapped",
			[28651]
		],
		[
			[63779, 63779],
			"mapped",
			[34253]
		],
		[
			[63780, 63780],
			"mapped",
			[35172]
		],
		[
			[63781, 63781],
			"mapped",
			[25289]
		],
		[
			[63782, 63782],
			"mapped",
			[33240]
		],
		[
			[63783, 63783],
			"mapped",
			[34847]
		],
		[
			[63784, 63784],
			"mapped",
			[24266]
		],
		[
			[63785, 63785],
			"mapped",
			[26391]
		],
		[
			[63786, 63786],
			"mapped",
			[28010]
		],
		[
			[63787, 63787],
			"mapped",
			[29436]
		],
		[
			[63788, 63788],
			"mapped",
			[37070]
		],
		[
			[63789, 63789],
			"mapped",
			[20358]
		],
		[
			[63790, 63790],
			"mapped",
			[20919]
		],
		[
			[63791, 63791],
			"mapped",
			[21214]
		],
		[
			[63792, 63792],
			"mapped",
			[25796]
		],
		[
			[63793, 63793],
			"mapped",
			[27347]
		],
		[
			[63794, 63794],
			"mapped",
			[29200]
		],
		[
			[63795, 63795],
			"mapped",
			[30439]
		],
		[
			[63796, 63796],
			"mapped",
			[32769]
		],
		[
			[63797, 63797],
			"mapped",
			[34310]
		],
		[
			[63798, 63798],
			"mapped",
			[34396]
		],
		[
			[63799, 63799],
			"mapped",
			[36335]
		],
		[
			[63800, 63800],
			"mapped",
			[38706]
		],
		[
			[63801, 63801],
			"mapped",
			[39791]
		],
		[
			[63802, 63802],
			"mapped",
			[40442]
		],
		[
			[63803, 63803],
			"mapped",
			[30860]
		],
		[
			[63804, 63804],
			"mapped",
			[31103]
		],
		[
			[63805, 63805],
			"mapped",
			[32160]
		],
		[
			[63806, 63806],
			"mapped",
			[33737]
		],
		[
			[63807, 63807],
			"mapped",
			[37636]
		],
		[
			[63808, 63808],
			"mapped",
			[40575]
		],
		[
			[63809, 63809],
			"mapped",
			[35542]
		],
		[
			[63810, 63810],
			"mapped",
			[22751]
		],
		[
			[63811, 63811],
			"mapped",
			[24324]
		],
		[
			[63812, 63812],
			"mapped",
			[31840]
		],
		[
			[63813, 63813],
			"mapped",
			[32894]
		],
		[
			[63814, 63814],
			"mapped",
			[29282]
		],
		[
			[63815, 63815],
			"mapped",
			[30922]
		],
		[
			[63816, 63816],
			"mapped",
			[36034]
		],
		[
			[63817, 63817],
			"mapped",
			[38647]
		],
		[
			[63818, 63818],
			"mapped",
			[22744]
		],
		[
			[63819, 63819],
			"mapped",
			[23650]
		],
		[
			[63820, 63820],
			"mapped",
			[27155]
		],
		[
			[63821, 63821],
			"mapped",
			[28122]
		],
		[
			[63822, 63822],
			"mapped",
			[28431]
		],
		[
			[63823, 63823],
			"mapped",
			[32047]
		],
		[
			[63824, 63824],
			"mapped",
			[32311]
		],
		[
			[63825, 63825],
			"mapped",
			[38475]
		],
		[
			[63826, 63826],
			"mapped",
			[21202]
		],
		[
			[63827, 63827],
			"mapped",
			[32907]
		],
		[
			[63828, 63828],
			"mapped",
			[20956]
		],
		[
			[63829, 63829],
			"mapped",
			[20940]
		],
		[
			[63830, 63830],
			"mapped",
			[31260]
		],
		[
			[63831, 63831],
			"mapped",
			[32190]
		],
		[
			[63832, 63832],
			"mapped",
			[33777]
		],
		[
			[63833, 63833],
			"mapped",
			[38517]
		],
		[
			[63834, 63834],
			"mapped",
			[35712]
		],
		[
			[63835, 63835],
			"mapped",
			[25295]
		],
		[
			[63836, 63836],
			"mapped",
			[27138]
		],
		[
			[63837, 63837],
			"mapped",
			[35582]
		],
		[
			[63838, 63838],
			"mapped",
			[20025]
		],
		[
			[63839, 63839],
			"mapped",
			[23527]
		],
		[
			[63840, 63840],
			"mapped",
			[24594]
		],
		[
			[63841, 63841],
			"mapped",
			[29575]
		],
		[
			[63842, 63842],
			"mapped",
			[30064]
		],
		[
			[63843, 63843],
			"mapped",
			[21271]
		],
		[
			[63844, 63844],
			"mapped",
			[30971]
		],
		[
			[63845, 63845],
			"mapped",
			[20415]
		],
		[
			[63846, 63846],
			"mapped",
			[24489]
		],
		[
			[63847, 63847],
			"mapped",
			[19981]
		],
		[
			[63848, 63848],
			"mapped",
			[27852]
		],
		[
			[63849, 63849],
			"mapped",
			[25976]
		],
		[
			[63850, 63850],
			"mapped",
			[32034]
		],
		[
			[63851, 63851],
			"mapped",
			[21443]
		],
		[
			[63852, 63852],
			"mapped",
			[22622]
		],
		[
			[63853, 63853],
			"mapped",
			[30465]
		],
		[
			[63854, 63854],
			"mapped",
			[33865]
		],
		[
			[63855, 63855],
			"mapped",
			[35498]
		],
		[
			[63856, 63856],
			"mapped",
			[27578]
		],
		[
			[63857, 63857],
			"mapped",
			[36784]
		],
		[
			[63858, 63858],
			"mapped",
			[27784]
		],
		[
			[63859, 63859],
			"mapped",
			[25342]
		],
		[
			[63860, 63860],
			"mapped",
			[33509]
		],
		[
			[63861, 63861],
			"mapped",
			[25504]
		],
		[
			[63862, 63862],
			"mapped",
			[30053]
		],
		[
			[63863, 63863],
			"mapped",
			[20142]
		],
		[
			[63864, 63864],
			"mapped",
			[20841]
		],
		[
			[63865, 63865],
			"mapped",
			[20937]
		],
		[
			[63866, 63866],
			"mapped",
			[26753]
		],
		[
			[63867, 63867],
			"mapped",
			[31975]
		],
		[
			[63868, 63868],
			"mapped",
			[33391]
		],
		[
			[63869, 63869],
			"mapped",
			[35538]
		],
		[
			[63870, 63870],
			"mapped",
			[37327]
		],
		[
			[63871, 63871],
			"mapped",
			[21237]
		],
		[
			[63872, 63872],
			"mapped",
			[21570]
		],
		[
			[63873, 63873],
			"mapped",
			[22899]
		],
		[
			[63874, 63874],
			"mapped",
			[24300]
		],
		[
			[63875, 63875],
			"mapped",
			[26053]
		],
		[
			[63876, 63876],
			"mapped",
			[28670]
		],
		[
			[63877, 63877],
			"mapped",
			[31018]
		],
		[
			[63878, 63878],
			"mapped",
			[38317]
		],
		[
			[63879, 63879],
			"mapped",
			[39530]
		],
		[
			[63880, 63880],
			"mapped",
			[40599]
		],
		[
			[63881, 63881],
			"mapped",
			[40654]
		],
		[
			[63882, 63882],
			"mapped",
			[21147]
		],
		[
			[63883, 63883],
			"mapped",
			[26310]
		],
		[
			[63884, 63884],
			"mapped",
			[27511]
		],
		[
			[63885, 63885],
			"mapped",
			[36706]
		],
		[
			[63886, 63886],
			"mapped",
			[24180]
		],
		[
			[63887, 63887],
			"mapped",
			[24976]
		],
		[
			[63888, 63888],
			"mapped",
			[25088]
		],
		[
			[63889, 63889],
			"mapped",
			[25754]
		],
		[
			[63890, 63890],
			"mapped",
			[28451]
		],
		[
			[63891, 63891],
			"mapped",
			[29001]
		],
		[
			[63892, 63892],
			"mapped",
			[29833]
		],
		[
			[63893, 63893],
			"mapped",
			[31178]
		],
		[
			[63894, 63894],
			"mapped",
			[32244]
		],
		[
			[63895, 63895],
			"mapped",
			[32879]
		],
		[
			[63896, 63896],
			"mapped",
			[36646]
		],
		[
			[63897, 63897],
			"mapped",
			[34030]
		],
		[
			[63898, 63898],
			"mapped",
			[36899]
		],
		[
			[63899, 63899],
			"mapped",
			[37706]
		],
		[
			[63900, 63900],
			"mapped",
			[21015]
		],
		[
			[63901, 63901],
			"mapped",
			[21155]
		],
		[
			[63902, 63902],
			"mapped",
			[21693]
		],
		[
			[63903, 63903],
			"mapped",
			[28872]
		],
		[
			[63904, 63904],
			"mapped",
			[35010]
		],
		[
			[63905, 63905],
			"mapped",
			[35498]
		],
		[
			[63906, 63906],
			"mapped",
			[24265]
		],
		[
			[63907, 63907],
			"mapped",
			[24565]
		],
		[
			[63908, 63908],
			"mapped",
			[25467]
		],
		[
			[63909, 63909],
			"mapped",
			[27566]
		],
		[
			[63910, 63910],
			"mapped",
			[31806]
		],
		[
			[63911, 63911],
			"mapped",
			[29557]
		],
		[
			[63912, 63912],
			"mapped",
			[20196]
		],
		[
			[63913, 63913],
			"mapped",
			[22265]
		],
		[
			[63914, 63914],
			"mapped",
			[23527]
		],
		[
			[63915, 63915],
			"mapped",
			[23994]
		],
		[
			[63916, 63916],
			"mapped",
			[24604]
		],
		[
			[63917, 63917],
			"mapped",
			[29618]
		],
		[
			[63918, 63918],
			"mapped",
			[29801]
		],
		[
			[63919, 63919],
			"mapped",
			[32666]
		],
		[
			[63920, 63920],
			"mapped",
			[32838]
		],
		[
			[63921, 63921],
			"mapped",
			[37428]
		],
		[
			[63922, 63922],
			"mapped",
			[38646]
		],
		[
			[63923, 63923],
			"mapped",
			[38728]
		],
		[
			[63924, 63924],
			"mapped",
			[38936]
		],
		[
			[63925, 63925],
			"mapped",
			[20363]
		],
		[
			[63926, 63926],
			"mapped",
			[31150]
		],
		[
			[63927, 63927],
			"mapped",
			[37300]
		],
		[
			[63928, 63928],
			"mapped",
			[38584]
		],
		[
			[63929, 63929],
			"mapped",
			[24801]
		],
		[
			[63930, 63930],
			"mapped",
			[20102]
		],
		[
			[63931, 63931],
			"mapped",
			[20698]
		],
		[
			[63932, 63932],
			"mapped",
			[23534]
		],
		[
			[63933, 63933],
			"mapped",
			[23615]
		],
		[
			[63934, 63934],
			"mapped",
			[26009]
		],
		[
			[63935, 63935],
			"mapped",
			[27138]
		],
		[
			[63936, 63936],
			"mapped",
			[29134]
		],
		[
			[63937, 63937],
			"mapped",
			[30274]
		],
		[
			[63938, 63938],
			"mapped",
			[34044]
		],
		[
			[63939, 63939],
			"mapped",
			[36988]
		],
		[
			[63940, 63940],
			"mapped",
			[40845]
		],
		[
			[63941, 63941],
			"mapped",
			[26248]
		],
		[
			[63942, 63942],
			"mapped",
			[38446]
		],
		[
			[63943, 63943],
			"mapped",
			[21129]
		],
		[
			[63944, 63944],
			"mapped",
			[26491]
		],
		[
			[63945, 63945],
			"mapped",
			[26611]
		],
		[
			[63946, 63946],
			"mapped",
			[27969]
		],
		[
			[63947, 63947],
			"mapped",
			[28316]
		],
		[
			[63948, 63948],
			"mapped",
			[29705]
		],
		[
			[63949, 63949],
			"mapped",
			[30041]
		],
		[
			[63950, 63950],
			"mapped",
			[30827]
		],
		[
			[63951, 63951],
			"mapped",
			[32016]
		],
		[
			[63952, 63952],
			"mapped",
			[39006]
		],
		[
			[63953, 63953],
			"mapped",
			[20845]
		],
		[
			[63954, 63954],
			"mapped",
			[25134]
		],
		[
			[63955, 63955],
			"mapped",
			[38520]
		],
		[
			[63956, 63956],
			"mapped",
			[20523]
		],
		[
			[63957, 63957],
			"mapped",
			[23833]
		],
		[
			[63958, 63958],
			"mapped",
			[28138]
		],
		[
			[63959, 63959],
			"mapped",
			[36650]
		],
		[
			[63960, 63960],
			"mapped",
			[24459]
		],
		[
			[63961, 63961],
			"mapped",
			[24900]
		],
		[
			[63962, 63962],
			"mapped",
			[26647]
		],
		[
			[63963, 63963],
			"mapped",
			[29575]
		],
		[
			[63964, 63964],
			"mapped",
			[38534]
		],
		[
			[63965, 63965],
			"mapped",
			[21033]
		],
		[
			[63966, 63966],
			"mapped",
			[21519]
		],
		[
			[63967, 63967],
			"mapped",
			[23653]
		],
		[
			[63968, 63968],
			"mapped",
			[26131]
		],
		[
			[63969, 63969],
			"mapped",
			[26446]
		],
		[
			[63970, 63970],
			"mapped",
			[26792]
		],
		[
			[63971, 63971],
			"mapped",
			[27877]
		],
		[
			[63972, 63972],
			"mapped",
			[29702]
		],
		[
			[63973, 63973],
			"mapped",
			[30178]
		],
		[
			[63974, 63974],
			"mapped",
			[32633]
		],
		[
			[63975, 63975],
			"mapped",
			[35023]
		],
		[
			[63976, 63976],
			"mapped",
			[35041]
		],
		[
			[63977, 63977],
			"mapped",
			[37324]
		],
		[
			[63978, 63978],
			"mapped",
			[38626]
		],
		[
			[63979, 63979],
			"mapped",
			[21311]
		],
		[
			[63980, 63980],
			"mapped",
			[28346]
		],
		[
			[63981, 63981],
			"mapped",
			[21533]
		],
		[
			[63982, 63982],
			"mapped",
			[29136]
		],
		[
			[63983, 63983],
			"mapped",
			[29848]
		],
		[
			[63984, 63984],
			"mapped",
			[34298]
		],
		[
			[63985, 63985],
			"mapped",
			[38563]
		],
		[
			[63986, 63986],
			"mapped",
			[40023]
		],
		[
			[63987, 63987],
			"mapped",
			[40607]
		],
		[
			[63988, 63988],
			"mapped",
			[26519]
		],
		[
			[63989, 63989],
			"mapped",
			[28107]
		],
		[
			[63990, 63990],
			"mapped",
			[33256]
		],
		[
			[63991, 63991],
			"mapped",
			[31435]
		],
		[
			[63992, 63992],
			"mapped",
			[31520]
		],
		[
			[63993, 63993],
			"mapped",
			[31890]
		],
		[
			[63994, 63994],
			"mapped",
			[29376]
		],
		[
			[63995, 63995],
			"mapped",
			[28825]
		],
		[
			[63996, 63996],
			"mapped",
			[35672]
		],
		[
			[63997, 63997],
			"mapped",
			[20160]
		],
		[
			[63998, 63998],
			"mapped",
			[33590]
		],
		[
			[63999, 63999],
			"mapped",
			[21050]
		],
		[
			[64e3, 64e3],
			"mapped",
			[20999]
		],
		[
			[64001, 64001],
			"mapped",
			[24230]
		],
		[
			[64002, 64002],
			"mapped",
			[25299]
		],
		[
			[64003, 64003],
			"mapped",
			[31958]
		],
		[
			[64004, 64004],
			"mapped",
			[23429]
		],
		[
			[64005, 64005],
			"mapped",
			[27934]
		],
		[
			[64006, 64006],
			"mapped",
			[26292]
		],
		[
			[64007, 64007],
			"mapped",
			[36667]
		],
		[
			[64008, 64008],
			"mapped",
			[34892]
		],
		[
			[64009, 64009],
			"mapped",
			[38477]
		],
		[
			[64010, 64010],
			"mapped",
			[35211]
		],
		[
			[64011, 64011],
			"mapped",
			[24275]
		],
		[
			[64012, 64012],
			"mapped",
			[20800]
		],
		[
			[64013, 64013],
			"mapped",
			[21952]
		],
		[[64014, 64015], "valid"],
		[
			[64016, 64016],
			"mapped",
			[22618]
		],
		[[64017, 64017], "valid"],
		[
			[64018, 64018],
			"mapped",
			[26228]
		],
		[[64019, 64020], "valid"],
		[
			[64021, 64021],
			"mapped",
			[20958]
		],
		[
			[64022, 64022],
			"mapped",
			[29482]
		],
		[
			[64023, 64023],
			"mapped",
			[30410]
		],
		[
			[64024, 64024],
			"mapped",
			[31036]
		],
		[
			[64025, 64025],
			"mapped",
			[31070]
		],
		[
			[64026, 64026],
			"mapped",
			[31077]
		],
		[
			[64027, 64027],
			"mapped",
			[31119]
		],
		[
			[64028, 64028],
			"mapped",
			[38742]
		],
		[
			[64029, 64029],
			"mapped",
			[31934]
		],
		[
			[64030, 64030],
			"mapped",
			[32701]
		],
		[[64031, 64031], "valid"],
		[
			[64032, 64032],
			"mapped",
			[34322]
		],
		[[64033, 64033], "valid"],
		[
			[64034, 64034],
			"mapped",
			[35576]
		],
		[[64035, 64036], "valid"],
		[
			[64037, 64037],
			"mapped",
			[36920]
		],
		[
			[64038, 64038],
			"mapped",
			[37117]
		],
		[[64039, 64041], "valid"],
		[
			[64042, 64042],
			"mapped",
			[39151]
		],
		[
			[64043, 64043],
			"mapped",
			[39164]
		],
		[
			[64044, 64044],
			"mapped",
			[39208]
		],
		[
			[64045, 64045],
			"mapped",
			[40372]
		],
		[
			[64046, 64046],
			"mapped",
			[37086]
		],
		[
			[64047, 64047],
			"mapped",
			[38583]
		],
		[
			[64048, 64048],
			"mapped",
			[20398]
		],
		[
			[64049, 64049],
			"mapped",
			[20711]
		],
		[
			[64050, 64050],
			"mapped",
			[20813]
		],
		[
			[64051, 64051],
			"mapped",
			[21193]
		],
		[
			[64052, 64052],
			"mapped",
			[21220]
		],
		[
			[64053, 64053],
			"mapped",
			[21329]
		],
		[
			[64054, 64054],
			"mapped",
			[21917]
		],
		[
			[64055, 64055],
			"mapped",
			[22022]
		],
		[
			[64056, 64056],
			"mapped",
			[22120]
		],
		[
			[64057, 64057],
			"mapped",
			[22592]
		],
		[
			[64058, 64058],
			"mapped",
			[22696]
		],
		[
			[64059, 64059],
			"mapped",
			[23652]
		],
		[
			[64060, 64060],
			"mapped",
			[23662]
		],
		[
			[64061, 64061],
			"mapped",
			[24724]
		],
		[
			[64062, 64062],
			"mapped",
			[24936]
		],
		[
			[64063, 64063],
			"mapped",
			[24974]
		],
		[
			[64064, 64064],
			"mapped",
			[25074]
		],
		[
			[64065, 64065],
			"mapped",
			[25935]
		],
		[
			[64066, 64066],
			"mapped",
			[26082]
		],
		[
			[64067, 64067],
			"mapped",
			[26257]
		],
		[
			[64068, 64068],
			"mapped",
			[26757]
		],
		[
			[64069, 64069],
			"mapped",
			[28023]
		],
		[
			[64070, 64070],
			"mapped",
			[28186]
		],
		[
			[64071, 64071],
			"mapped",
			[28450]
		],
		[
			[64072, 64072],
			"mapped",
			[29038]
		],
		[
			[64073, 64073],
			"mapped",
			[29227]
		],
		[
			[64074, 64074],
			"mapped",
			[29730]
		],
		[
			[64075, 64075],
			"mapped",
			[30865]
		],
		[
			[64076, 64076],
			"mapped",
			[31038]
		],
		[
			[64077, 64077],
			"mapped",
			[31049]
		],
		[
			[64078, 64078],
			"mapped",
			[31048]
		],
		[
			[64079, 64079],
			"mapped",
			[31056]
		],
		[
			[64080, 64080],
			"mapped",
			[31062]
		],
		[
			[64081, 64081],
			"mapped",
			[31069]
		],
		[
			[64082, 64082],
			"mapped",
			[31117]
		],
		[
			[64083, 64083],
			"mapped",
			[31118]
		],
		[
			[64084, 64084],
			"mapped",
			[31296]
		],
		[
			[64085, 64085],
			"mapped",
			[31361]
		],
		[
			[64086, 64086],
			"mapped",
			[31680]
		],
		[
			[64087, 64087],
			"mapped",
			[32244]
		],
		[
			[64088, 64088],
			"mapped",
			[32265]
		],
		[
			[64089, 64089],
			"mapped",
			[32321]
		],
		[
			[64090, 64090],
			"mapped",
			[32626]
		],
		[
			[64091, 64091],
			"mapped",
			[32773]
		],
		[
			[64092, 64092],
			"mapped",
			[33261]
		],
		[
			[64093, 64094],
			"mapped",
			[33401]
		],
		[
			[64095, 64095],
			"mapped",
			[33879]
		],
		[
			[64096, 64096],
			"mapped",
			[35088]
		],
		[
			[64097, 64097],
			"mapped",
			[35222]
		],
		[
			[64098, 64098],
			"mapped",
			[35585]
		],
		[
			[64099, 64099],
			"mapped",
			[35641]
		],
		[
			[64100, 64100],
			"mapped",
			[36051]
		],
		[
			[64101, 64101],
			"mapped",
			[36104]
		],
		[
			[64102, 64102],
			"mapped",
			[36790]
		],
		[
			[64103, 64103],
			"mapped",
			[36920]
		],
		[
			[64104, 64104],
			"mapped",
			[38627]
		],
		[
			[64105, 64105],
			"mapped",
			[38911]
		],
		[
			[64106, 64106],
			"mapped",
			[38971]
		],
		[
			[64107, 64107],
			"mapped",
			[24693]
		],
		[
			[64108, 64108],
			"mapped",
			[148206]
		],
		[
			[64109, 64109],
			"mapped",
			[33304]
		],
		[[64110, 64111], "disallowed"],
		[
			[64112, 64112],
			"mapped",
			[20006]
		],
		[
			[64113, 64113],
			"mapped",
			[20917]
		],
		[
			[64114, 64114],
			"mapped",
			[20840]
		],
		[
			[64115, 64115],
			"mapped",
			[20352]
		],
		[
			[64116, 64116],
			"mapped",
			[20805]
		],
		[
			[64117, 64117],
			"mapped",
			[20864]
		],
		[
			[64118, 64118],
			"mapped",
			[21191]
		],
		[
			[64119, 64119],
			"mapped",
			[21242]
		],
		[
			[64120, 64120],
			"mapped",
			[21917]
		],
		[
			[64121, 64121],
			"mapped",
			[21845]
		],
		[
			[64122, 64122],
			"mapped",
			[21913]
		],
		[
			[64123, 64123],
			"mapped",
			[21986]
		],
		[
			[64124, 64124],
			"mapped",
			[22618]
		],
		[
			[64125, 64125],
			"mapped",
			[22707]
		],
		[
			[64126, 64126],
			"mapped",
			[22852]
		],
		[
			[64127, 64127],
			"mapped",
			[22868]
		],
		[
			[64128, 64128],
			"mapped",
			[23138]
		],
		[
			[64129, 64129],
			"mapped",
			[23336]
		],
		[
			[64130, 64130],
			"mapped",
			[24274]
		],
		[
			[64131, 64131],
			"mapped",
			[24281]
		],
		[
			[64132, 64132],
			"mapped",
			[24425]
		],
		[
			[64133, 64133],
			"mapped",
			[24493]
		],
		[
			[64134, 64134],
			"mapped",
			[24792]
		],
		[
			[64135, 64135],
			"mapped",
			[24910]
		],
		[
			[64136, 64136],
			"mapped",
			[24840]
		],
		[
			[64137, 64137],
			"mapped",
			[24974]
		],
		[
			[64138, 64138],
			"mapped",
			[24928]
		],
		[
			[64139, 64139],
			"mapped",
			[25074]
		],
		[
			[64140, 64140],
			"mapped",
			[25140]
		],
		[
			[64141, 64141],
			"mapped",
			[25540]
		],
		[
			[64142, 64142],
			"mapped",
			[25628]
		],
		[
			[64143, 64143],
			"mapped",
			[25682]
		],
		[
			[64144, 64144],
			"mapped",
			[25942]
		],
		[
			[64145, 64145],
			"mapped",
			[26228]
		],
		[
			[64146, 64146],
			"mapped",
			[26391]
		],
		[
			[64147, 64147],
			"mapped",
			[26395]
		],
		[
			[64148, 64148],
			"mapped",
			[26454]
		],
		[
			[64149, 64149],
			"mapped",
			[27513]
		],
		[
			[64150, 64150],
			"mapped",
			[27578]
		],
		[
			[64151, 64151],
			"mapped",
			[27969]
		],
		[
			[64152, 64152],
			"mapped",
			[28379]
		],
		[
			[64153, 64153],
			"mapped",
			[28363]
		],
		[
			[64154, 64154],
			"mapped",
			[28450]
		],
		[
			[64155, 64155],
			"mapped",
			[28702]
		],
		[
			[64156, 64156],
			"mapped",
			[29038]
		],
		[
			[64157, 64157],
			"mapped",
			[30631]
		],
		[
			[64158, 64158],
			"mapped",
			[29237]
		],
		[
			[64159, 64159],
			"mapped",
			[29359]
		],
		[
			[64160, 64160],
			"mapped",
			[29482]
		],
		[
			[64161, 64161],
			"mapped",
			[29809]
		],
		[
			[64162, 64162],
			"mapped",
			[29958]
		],
		[
			[64163, 64163],
			"mapped",
			[30011]
		],
		[
			[64164, 64164],
			"mapped",
			[30237]
		],
		[
			[64165, 64165],
			"mapped",
			[30239]
		],
		[
			[64166, 64166],
			"mapped",
			[30410]
		],
		[
			[64167, 64167],
			"mapped",
			[30427]
		],
		[
			[64168, 64168],
			"mapped",
			[30452]
		],
		[
			[64169, 64169],
			"mapped",
			[30538]
		],
		[
			[64170, 64170],
			"mapped",
			[30528]
		],
		[
			[64171, 64171],
			"mapped",
			[30924]
		],
		[
			[64172, 64172],
			"mapped",
			[31409]
		],
		[
			[64173, 64173],
			"mapped",
			[31680]
		],
		[
			[64174, 64174],
			"mapped",
			[31867]
		],
		[
			[64175, 64175],
			"mapped",
			[32091]
		],
		[
			[64176, 64176],
			"mapped",
			[32244]
		],
		[
			[64177, 64177],
			"mapped",
			[32574]
		],
		[
			[64178, 64178],
			"mapped",
			[32773]
		],
		[
			[64179, 64179],
			"mapped",
			[33618]
		],
		[
			[64180, 64180],
			"mapped",
			[33775]
		],
		[
			[64181, 64181],
			"mapped",
			[34681]
		],
		[
			[64182, 64182],
			"mapped",
			[35137]
		],
		[
			[64183, 64183],
			"mapped",
			[35206]
		],
		[
			[64184, 64184],
			"mapped",
			[35222]
		],
		[
			[64185, 64185],
			"mapped",
			[35519]
		],
		[
			[64186, 64186],
			"mapped",
			[35576]
		],
		[
			[64187, 64187],
			"mapped",
			[35531]
		],
		[
			[64188, 64188],
			"mapped",
			[35585]
		],
		[
			[64189, 64189],
			"mapped",
			[35582]
		],
		[
			[64190, 64190],
			"mapped",
			[35565]
		],
		[
			[64191, 64191],
			"mapped",
			[35641]
		],
		[
			[64192, 64192],
			"mapped",
			[35722]
		],
		[
			[64193, 64193],
			"mapped",
			[36104]
		],
		[
			[64194, 64194],
			"mapped",
			[36664]
		],
		[
			[64195, 64195],
			"mapped",
			[36978]
		],
		[
			[64196, 64196],
			"mapped",
			[37273]
		],
		[
			[64197, 64197],
			"mapped",
			[37494]
		],
		[
			[64198, 64198],
			"mapped",
			[38524]
		],
		[
			[64199, 64199],
			"mapped",
			[38627]
		],
		[
			[64200, 64200],
			"mapped",
			[38742]
		],
		[
			[64201, 64201],
			"mapped",
			[38875]
		],
		[
			[64202, 64202],
			"mapped",
			[38911]
		],
		[
			[64203, 64203],
			"mapped",
			[38923]
		],
		[
			[64204, 64204],
			"mapped",
			[38971]
		],
		[
			[64205, 64205],
			"mapped",
			[39698]
		],
		[
			[64206, 64206],
			"mapped",
			[40860]
		],
		[
			[64207, 64207],
			"mapped",
			[141386]
		],
		[
			[64208, 64208],
			"mapped",
			[141380]
		],
		[
			[64209, 64209],
			"mapped",
			[144341]
		],
		[
			[64210, 64210],
			"mapped",
			[15261]
		],
		[
			[64211, 64211],
			"mapped",
			[16408]
		],
		[
			[64212, 64212],
			"mapped",
			[16441]
		],
		[
			[64213, 64213],
			"mapped",
			[152137]
		],
		[
			[64214, 64214],
			"mapped",
			[154832]
		],
		[
			[64215, 64215],
			"mapped",
			[163539]
		],
		[
			[64216, 64216],
			"mapped",
			[40771]
		],
		[
			[64217, 64217],
			"mapped",
			[40846]
		],
		[[64218, 64255], "disallowed"],
		[
			[64256, 64256],
			"mapped",
			[102, 102]
		],
		[
			[64257, 64257],
			"mapped",
			[102, 105]
		],
		[
			[64258, 64258],
			"mapped",
			[102, 108]
		],
		[
			[64259, 64259],
			"mapped",
			[
				102,
				102,
				105
			]
		],
		[
			[64260, 64260],
			"mapped",
			[
				102,
				102,
				108
			]
		],
		[
			[64261, 64262],
			"mapped",
			[115, 116]
		],
		[[64263, 64274], "disallowed"],
		[
			[64275, 64275],
			"mapped",
			[1396, 1398]
		],
		[
			[64276, 64276],
			"mapped",
			[1396, 1381]
		],
		[
			[64277, 64277],
			"mapped",
			[1396, 1387]
		],
		[
			[64278, 64278],
			"mapped",
			[1406, 1398]
		],
		[
			[64279, 64279],
			"mapped",
			[1396, 1389]
		],
		[[64280, 64284], "disallowed"],
		[
			[64285, 64285],
			"mapped",
			[1497, 1460]
		],
		[[64286, 64286], "valid"],
		[
			[64287, 64287],
			"mapped",
			[1522, 1463]
		],
		[
			[64288, 64288],
			"mapped",
			[1506]
		],
		[
			[64289, 64289],
			"mapped",
			[1488]
		],
		[
			[64290, 64290],
			"mapped",
			[1491]
		],
		[
			[64291, 64291],
			"mapped",
			[1492]
		],
		[
			[64292, 64292],
			"mapped",
			[1499]
		],
		[
			[64293, 64293],
			"mapped",
			[1500]
		],
		[
			[64294, 64294],
			"mapped",
			[1501]
		],
		[
			[64295, 64295],
			"mapped",
			[1512]
		],
		[
			[64296, 64296],
			"mapped",
			[1514]
		],
		[
			[64297, 64297],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[64298, 64298],
			"mapped",
			[1513, 1473]
		],
		[
			[64299, 64299],
			"mapped",
			[1513, 1474]
		],
		[
			[64300, 64300],
			"mapped",
			[
				1513,
				1468,
				1473
			]
		],
		[
			[64301, 64301],
			"mapped",
			[
				1513,
				1468,
				1474
			]
		],
		[
			[64302, 64302],
			"mapped",
			[1488, 1463]
		],
		[
			[64303, 64303],
			"mapped",
			[1488, 1464]
		],
		[
			[64304, 64304],
			"mapped",
			[1488, 1468]
		],
		[
			[64305, 64305],
			"mapped",
			[1489, 1468]
		],
		[
			[64306, 64306],
			"mapped",
			[1490, 1468]
		],
		[
			[64307, 64307],
			"mapped",
			[1491, 1468]
		],
		[
			[64308, 64308],
			"mapped",
			[1492, 1468]
		],
		[
			[64309, 64309],
			"mapped",
			[1493, 1468]
		],
		[
			[64310, 64310],
			"mapped",
			[1494, 1468]
		],
		[[64311, 64311], "disallowed"],
		[
			[64312, 64312],
			"mapped",
			[1496, 1468]
		],
		[
			[64313, 64313],
			"mapped",
			[1497, 1468]
		],
		[
			[64314, 64314],
			"mapped",
			[1498, 1468]
		],
		[
			[64315, 64315],
			"mapped",
			[1499, 1468]
		],
		[
			[64316, 64316],
			"mapped",
			[1500, 1468]
		],
		[[64317, 64317], "disallowed"],
		[
			[64318, 64318],
			"mapped",
			[1502, 1468]
		],
		[[64319, 64319], "disallowed"],
		[
			[64320, 64320],
			"mapped",
			[1504, 1468]
		],
		[
			[64321, 64321],
			"mapped",
			[1505, 1468]
		],
		[[64322, 64322], "disallowed"],
		[
			[64323, 64323],
			"mapped",
			[1507, 1468]
		],
		[
			[64324, 64324],
			"mapped",
			[1508, 1468]
		],
		[[64325, 64325], "disallowed"],
		[
			[64326, 64326],
			"mapped",
			[1510, 1468]
		],
		[
			[64327, 64327],
			"mapped",
			[1511, 1468]
		],
		[
			[64328, 64328],
			"mapped",
			[1512, 1468]
		],
		[
			[64329, 64329],
			"mapped",
			[1513, 1468]
		],
		[
			[64330, 64330],
			"mapped",
			[1514, 1468]
		],
		[
			[64331, 64331],
			"mapped",
			[1493, 1465]
		],
		[
			[64332, 64332],
			"mapped",
			[1489, 1471]
		],
		[
			[64333, 64333],
			"mapped",
			[1499, 1471]
		],
		[
			[64334, 64334],
			"mapped",
			[1508, 1471]
		],
		[
			[64335, 64335],
			"mapped",
			[1488, 1500]
		],
		[
			[64336, 64337],
			"mapped",
			[1649]
		],
		[
			[64338, 64341],
			"mapped",
			[1659]
		],
		[
			[64342, 64345],
			"mapped",
			[1662]
		],
		[
			[64346, 64349],
			"mapped",
			[1664]
		],
		[
			[64350, 64353],
			"mapped",
			[1658]
		],
		[
			[64354, 64357],
			"mapped",
			[1663]
		],
		[
			[64358, 64361],
			"mapped",
			[1657]
		],
		[
			[64362, 64365],
			"mapped",
			[1700]
		],
		[
			[64366, 64369],
			"mapped",
			[1702]
		],
		[
			[64370, 64373],
			"mapped",
			[1668]
		],
		[
			[64374, 64377],
			"mapped",
			[1667]
		],
		[
			[64378, 64381],
			"mapped",
			[1670]
		],
		[
			[64382, 64385],
			"mapped",
			[1671]
		],
		[
			[64386, 64387],
			"mapped",
			[1677]
		],
		[
			[64388, 64389],
			"mapped",
			[1676]
		],
		[
			[64390, 64391],
			"mapped",
			[1678]
		],
		[
			[64392, 64393],
			"mapped",
			[1672]
		],
		[
			[64394, 64395],
			"mapped",
			[1688]
		],
		[
			[64396, 64397],
			"mapped",
			[1681]
		],
		[
			[64398, 64401],
			"mapped",
			[1705]
		],
		[
			[64402, 64405],
			"mapped",
			[1711]
		],
		[
			[64406, 64409],
			"mapped",
			[1715]
		],
		[
			[64410, 64413],
			"mapped",
			[1713]
		],
		[
			[64414, 64415],
			"mapped",
			[1722]
		],
		[
			[64416, 64419],
			"mapped",
			[1723]
		],
		[
			[64420, 64421],
			"mapped",
			[1728]
		],
		[
			[64422, 64425],
			"mapped",
			[1729]
		],
		[
			[64426, 64429],
			"mapped",
			[1726]
		],
		[
			[64430, 64431],
			"mapped",
			[1746]
		],
		[
			[64432, 64433],
			"mapped",
			[1747]
		],
		[
			[64434, 64449],
			"valid",
			[],
			"NV8"
		],
		[[64450, 64466], "disallowed"],
		[
			[64467, 64470],
			"mapped",
			[1709]
		],
		[
			[64471, 64472],
			"mapped",
			[1735]
		],
		[
			[64473, 64474],
			"mapped",
			[1734]
		],
		[
			[64475, 64476],
			"mapped",
			[1736]
		],
		[
			[64477, 64477],
			"mapped",
			[1735, 1652]
		],
		[
			[64478, 64479],
			"mapped",
			[1739]
		],
		[
			[64480, 64481],
			"mapped",
			[1733]
		],
		[
			[64482, 64483],
			"mapped",
			[1737]
		],
		[
			[64484, 64487],
			"mapped",
			[1744]
		],
		[
			[64488, 64489],
			"mapped",
			[1609]
		],
		[
			[64490, 64491],
			"mapped",
			[1574, 1575]
		],
		[
			[64492, 64493],
			"mapped",
			[1574, 1749]
		],
		[
			[64494, 64495],
			"mapped",
			[1574, 1608]
		],
		[
			[64496, 64497],
			"mapped",
			[1574, 1735]
		],
		[
			[64498, 64499],
			"mapped",
			[1574, 1734]
		],
		[
			[64500, 64501],
			"mapped",
			[1574, 1736]
		],
		[
			[64502, 64504],
			"mapped",
			[1574, 1744]
		],
		[
			[64505, 64507],
			"mapped",
			[1574, 1609]
		],
		[
			[64508, 64511],
			"mapped",
			[1740]
		],
		[
			[64512, 64512],
			"mapped",
			[1574, 1580]
		],
		[
			[64513, 64513],
			"mapped",
			[1574, 1581]
		],
		[
			[64514, 64514],
			"mapped",
			[1574, 1605]
		],
		[
			[64515, 64515],
			"mapped",
			[1574, 1609]
		],
		[
			[64516, 64516],
			"mapped",
			[1574, 1610]
		],
		[
			[64517, 64517],
			"mapped",
			[1576, 1580]
		],
		[
			[64518, 64518],
			"mapped",
			[1576, 1581]
		],
		[
			[64519, 64519],
			"mapped",
			[1576, 1582]
		],
		[
			[64520, 64520],
			"mapped",
			[1576, 1605]
		],
		[
			[64521, 64521],
			"mapped",
			[1576, 1609]
		],
		[
			[64522, 64522],
			"mapped",
			[1576, 1610]
		],
		[
			[64523, 64523],
			"mapped",
			[1578, 1580]
		],
		[
			[64524, 64524],
			"mapped",
			[1578, 1581]
		],
		[
			[64525, 64525],
			"mapped",
			[1578, 1582]
		],
		[
			[64526, 64526],
			"mapped",
			[1578, 1605]
		],
		[
			[64527, 64527],
			"mapped",
			[1578, 1609]
		],
		[
			[64528, 64528],
			"mapped",
			[1578, 1610]
		],
		[
			[64529, 64529],
			"mapped",
			[1579, 1580]
		],
		[
			[64530, 64530],
			"mapped",
			[1579, 1605]
		],
		[
			[64531, 64531],
			"mapped",
			[1579, 1609]
		],
		[
			[64532, 64532],
			"mapped",
			[1579, 1610]
		],
		[
			[64533, 64533],
			"mapped",
			[1580, 1581]
		],
		[
			[64534, 64534],
			"mapped",
			[1580, 1605]
		],
		[
			[64535, 64535],
			"mapped",
			[1581, 1580]
		],
		[
			[64536, 64536],
			"mapped",
			[1581, 1605]
		],
		[
			[64537, 64537],
			"mapped",
			[1582, 1580]
		],
		[
			[64538, 64538],
			"mapped",
			[1582, 1581]
		],
		[
			[64539, 64539],
			"mapped",
			[1582, 1605]
		],
		[
			[64540, 64540],
			"mapped",
			[1587, 1580]
		],
		[
			[64541, 64541],
			"mapped",
			[1587, 1581]
		],
		[
			[64542, 64542],
			"mapped",
			[1587, 1582]
		],
		[
			[64543, 64543],
			"mapped",
			[1587, 1605]
		],
		[
			[64544, 64544],
			"mapped",
			[1589, 1581]
		],
		[
			[64545, 64545],
			"mapped",
			[1589, 1605]
		],
		[
			[64546, 64546],
			"mapped",
			[1590, 1580]
		],
		[
			[64547, 64547],
			"mapped",
			[1590, 1581]
		],
		[
			[64548, 64548],
			"mapped",
			[1590, 1582]
		],
		[
			[64549, 64549],
			"mapped",
			[1590, 1605]
		],
		[
			[64550, 64550],
			"mapped",
			[1591, 1581]
		],
		[
			[64551, 64551],
			"mapped",
			[1591, 1605]
		],
		[
			[64552, 64552],
			"mapped",
			[1592, 1605]
		],
		[
			[64553, 64553],
			"mapped",
			[1593, 1580]
		],
		[
			[64554, 64554],
			"mapped",
			[1593, 1605]
		],
		[
			[64555, 64555],
			"mapped",
			[1594, 1580]
		],
		[
			[64556, 64556],
			"mapped",
			[1594, 1605]
		],
		[
			[64557, 64557],
			"mapped",
			[1601, 1580]
		],
		[
			[64558, 64558],
			"mapped",
			[1601, 1581]
		],
		[
			[64559, 64559],
			"mapped",
			[1601, 1582]
		],
		[
			[64560, 64560],
			"mapped",
			[1601, 1605]
		],
		[
			[64561, 64561],
			"mapped",
			[1601, 1609]
		],
		[
			[64562, 64562],
			"mapped",
			[1601, 1610]
		],
		[
			[64563, 64563],
			"mapped",
			[1602, 1581]
		],
		[
			[64564, 64564],
			"mapped",
			[1602, 1605]
		],
		[
			[64565, 64565],
			"mapped",
			[1602, 1609]
		],
		[
			[64566, 64566],
			"mapped",
			[1602, 1610]
		],
		[
			[64567, 64567],
			"mapped",
			[1603, 1575]
		],
		[
			[64568, 64568],
			"mapped",
			[1603, 1580]
		],
		[
			[64569, 64569],
			"mapped",
			[1603, 1581]
		],
		[
			[64570, 64570],
			"mapped",
			[1603, 1582]
		],
		[
			[64571, 64571],
			"mapped",
			[1603, 1604]
		],
		[
			[64572, 64572],
			"mapped",
			[1603, 1605]
		],
		[
			[64573, 64573],
			"mapped",
			[1603, 1609]
		],
		[
			[64574, 64574],
			"mapped",
			[1603, 1610]
		],
		[
			[64575, 64575],
			"mapped",
			[1604, 1580]
		],
		[
			[64576, 64576],
			"mapped",
			[1604, 1581]
		],
		[
			[64577, 64577],
			"mapped",
			[1604, 1582]
		],
		[
			[64578, 64578],
			"mapped",
			[1604, 1605]
		],
		[
			[64579, 64579],
			"mapped",
			[1604, 1609]
		],
		[
			[64580, 64580],
			"mapped",
			[1604, 1610]
		],
		[
			[64581, 64581],
			"mapped",
			[1605, 1580]
		],
		[
			[64582, 64582],
			"mapped",
			[1605, 1581]
		],
		[
			[64583, 64583],
			"mapped",
			[1605, 1582]
		],
		[
			[64584, 64584],
			"mapped",
			[1605, 1605]
		],
		[
			[64585, 64585],
			"mapped",
			[1605, 1609]
		],
		[
			[64586, 64586],
			"mapped",
			[1605, 1610]
		],
		[
			[64587, 64587],
			"mapped",
			[1606, 1580]
		],
		[
			[64588, 64588],
			"mapped",
			[1606, 1581]
		],
		[
			[64589, 64589],
			"mapped",
			[1606, 1582]
		],
		[
			[64590, 64590],
			"mapped",
			[1606, 1605]
		],
		[
			[64591, 64591],
			"mapped",
			[1606, 1609]
		],
		[
			[64592, 64592],
			"mapped",
			[1606, 1610]
		],
		[
			[64593, 64593],
			"mapped",
			[1607, 1580]
		],
		[
			[64594, 64594],
			"mapped",
			[1607, 1605]
		],
		[
			[64595, 64595],
			"mapped",
			[1607, 1609]
		],
		[
			[64596, 64596],
			"mapped",
			[1607, 1610]
		],
		[
			[64597, 64597],
			"mapped",
			[1610, 1580]
		],
		[
			[64598, 64598],
			"mapped",
			[1610, 1581]
		],
		[
			[64599, 64599],
			"mapped",
			[1610, 1582]
		],
		[
			[64600, 64600],
			"mapped",
			[1610, 1605]
		],
		[
			[64601, 64601],
			"mapped",
			[1610, 1609]
		],
		[
			[64602, 64602],
			"mapped",
			[1610, 1610]
		],
		[
			[64603, 64603],
			"mapped",
			[1584, 1648]
		],
		[
			[64604, 64604],
			"mapped",
			[1585, 1648]
		],
		[
			[64605, 64605],
			"mapped",
			[1609, 1648]
		],
		[
			[64606, 64606],
			"disallowed_STD3_mapped",
			[
				32,
				1612,
				1617
			]
		],
		[
			[64607, 64607],
			"disallowed_STD3_mapped",
			[
				32,
				1613,
				1617
			]
		],
		[
			[64608, 64608],
			"disallowed_STD3_mapped",
			[
				32,
				1614,
				1617
			]
		],
		[
			[64609, 64609],
			"disallowed_STD3_mapped",
			[
				32,
				1615,
				1617
			]
		],
		[
			[64610, 64610],
			"disallowed_STD3_mapped",
			[
				32,
				1616,
				1617
			]
		],
		[
			[64611, 64611],
			"disallowed_STD3_mapped",
			[
				32,
				1617,
				1648
			]
		],
		[
			[64612, 64612],
			"mapped",
			[1574, 1585]
		],
		[
			[64613, 64613],
			"mapped",
			[1574, 1586]
		],
		[
			[64614, 64614],
			"mapped",
			[1574, 1605]
		],
		[
			[64615, 64615],
			"mapped",
			[1574, 1606]
		],
		[
			[64616, 64616],
			"mapped",
			[1574, 1609]
		],
		[
			[64617, 64617],
			"mapped",
			[1574, 1610]
		],
		[
			[64618, 64618],
			"mapped",
			[1576, 1585]
		],
		[
			[64619, 64619],
			"mapped",
			[1576, 1586]
		],
		[
			[64620, 64620],
			"mapped",
			[1576, 1605]
		],
		[
			[64621, 64621],
			"mapped",
			[1576, 1606]
		],
		[
			[64622, 64622],
			"mapped",
			[1576, 1609]
		],
		[
			[64623, 64623],
			"mapped",
			[1576, 1610]
		],
		[
			[64624, 64624],
			"mapped",
			[1578, 1585]
		],
		[
			[64625, 64625],
			"mapped",
			[1578, 1586]
		],
		[
			[64626, 64626],
			"mapped",
			[1578, 1605]
		],
		[
			[64627, 64627],
			"mapped",
			[1578, 1606]
		],
		[
			[64628, 64628],
			"mapped",
			[1578, 1609]
		],
		[
			[64629, 64629],
			"mapped",
			[1578, 1610]
		],
		[
			[64630, 64630],
			"mapped",
			[1579, 1585]
		],
		[
			[64631, 64631],
			"mapped",
			[1579, 1586]
		],
		[
			[64632, 64632],
			"mapped",
			[1579, 1605]
		],
		[
			[64633, 64633],
			"mapped",
			[1579, 1606]
		],
		[
			[64634, 64634],
			"mapped",
			[1579, 1609]
		],
		[
			[64635, 64635],
			"mapped",
			[1579, 1610]
		],
		[
			[64636, 64636],
			"mapped",
			[1601, 1609]
		],
		[
			[64637, 64637],
			"mapped",
			[1601, 1610]
		],
		[
			[64638, 64638],
			"mapped",
			[1602, 1609]
		],
		[
			[64639, 64639],
			"mapped",
			[1602, 1610]
		],
		[
			[64640, 64640],
			"mapped",
			[1603, 1575]
		],
		[
			[64641, 64641],
			"mapped",
			[1603, 1604]
		],
		[
			[64642, 64642],
			"mapped",
			[1603, 1605]
		],
		[
			[64643, 64643],
			"mapped",
			[1603, 1609]
		],
		[
			[64644, 64644],
			"mapped",
			[1603, 1610]
		],
		[
			[64645, 64645],
			"mapped",
			[1604, 1605]
		],
		[
			[64646, 64646],
			"mapped",
			[1604, 1609]
		],
		[
			[64647, 64647],
			"mapped",
			[1604, 1610]
		],
		[
			[64648, 64648],
			"mapped",
			[1605, 1575]
		],
		[
			[64649, 64649],
			"mapped",
			[1605, 1605]
		],
		[
			[64650, 64650],
			"mapped",
			[1606, 1585]
		],
		[
			[64651, 64651],
			"mapped",
			[1606, 1586]
		],
		[
			[64652, 64652],
			"mapped",
			[1606, 1605]
		],
		[
			[64653, 64653],
			"mapped",
			[1606, 1606]
		],
		[
			[64654, 64654],
			"mapped",
			[1606, 1609]
		],
		[
			[64655, 64655],
			"mapped",
			[1606, 1610]
		],
		[
			[64656, 64656],
			"mapped",
			[1609, 1648]
		],
		[
			[64657, 64657],
			"mapped",
			[1610, 1585]
		],
		[
			[64658, 64658],
			"mapped",
			[1610, 1586]
		],
		[
			[64659, 64659],
			"mapped",
			[1610, 1605]
		],
		[
			[64660, 64660],
			"mapped",
			[1610, 1606]
		],
		[
			[64661, 64661],
			"mapped",
			[1610, 1609]
		],
		[
			[64662, 64662],
			"mapped",
			[1610, 1610]
		],
		[
			[64663, 64663],
			"mapped",
			[1574, 1580]
		],
		[
			[64664, 64664],
			"mapped",
			[1574, 1581]
		],
		[
			[64665, 64665],
			"mapped",
			[1574, 1582]
		],
		[
			[64666, 64666],
			"mapped",
			[1574, 1605]
		],
		[
			[64667, 64667],
			"mapped",
			[1574, 1607]
		],
		[
			[64668, 64668],
			"mapped",
			[1576, 1580]
		],
		[
			[64669, 64669],
			"mapped",
			[1576, 1581]
		],
		[
			[64670, 64670],
			"mapped",
			[1576, 1582]
		],
		[
			[64671, 64671],
			"mapped",
			[1576, 1605]
		],
		[
			[64672, 64672],
			"mapped",
			[1576, 1607]
		],
		[
			[64673, 64673],
			"mapped",
			[1578, 1580]
		],
		[
			[64674, 64674],
			"mapped",
			[1578, 1581]
		],
		[
			[64675, 64675],
			"mapped",
			[1578, 1582]
		],
		[
			[64676, 64676],
			"mapped",
			[1578, 1605]
		],
		[
			[64677, 64677],
			"mapped",
			[1578, 1607]
		],
		[
			[64678, 64678],
			"mapped",
			[1579, 1605]
		],
		[
			[64679, 64679],
			"mapped",
			[1580, 1581]
		],
		[
			[64680, 64680],
			"mapped",
			[1580, 1605]
		],
		[
			[64681, 64681],
			"mapped",
			[1581, 1580]
		],
		[
			[64682, 64682],
			"mapped",
			[1581, 1605]
		],
		[
			[64683, 64683],
			"mapped",
			[1582, 1580]
		],
		[
			[64684, 64684],
			"mapped",
			[1582, 1605]
		],
		[
			[64685, 64685],
			"mapped",
			[1587, 1580]
		],
		[
			[64686, 64686],
			"mapped",
			[1587, 1581]
		],
		[
			[64687, 64687],
			"mapped",
			[1587, 1582]
		],
		[
			[64688, 64688],
			"mapped",
			[1587, 1605]
		],
		[
			[64689, 64689],
			"mapped",
			[1589, 1581]
		],
		[
			[64690, 64690],
			"mapped",
			[1589, 1582]
		],
		[
			[64691, 64691],
			"mapped",
			[1589, 1605]
		],
		[
			[64692, 64692],
			"mapped",
			[1590, 1580]
		],
		[
			[64693, 64693],
			"mapped",
			[1590, 1581]
		],
		[
			[64694, 64694],
			"mapped",
			[1590, 1582]
		],
		[
			[64695, 64695],
			"mapped",
			[1590, 1605]
		],
		[
			[64696, 64696],
			"mapped",
			[1591, 1581]
		],
		[
			[64697, 64697],
			"mapped",
			[1592, 1605]
		],
		[
			[64698, 64698],
			"mapped",
			[1593, 1580]
		],
		[
			[64699, 64699],
			"mapped",
			[1593, 1605]
		],
		[
			[64700, 64700],
			"mapped",
			[1594, 1580]
		],
		[
			[64701, 64701],
			"mapped",
			[1594, 1605]
		],
		[
			[64702, 64702],
			"mapped",
			[1601, 1580]
		],
		[
			[64703, 64703],
			"mapped",
			[1601, 1581]
		],
		[
			[64704, 64704],
			"mapped",
			[1601, 1582]
		],
		[
			[64705, 64705],
			"mapped",
			[1601, 1605]
		],
		[
			[64706, 64706],
			"mapped",
			[1602, 1581]
		],
		[
			[64707, 64707],
			"mapped",
			[1602, 1605]
		],
		[
			[64708, 64708],
			"mapped",
			[1603, 1580]
		],
		[
			[64709, 64709],
			"mapped",
			[1603, 1581]
		],
		[
			[64710, 64710],
			"mapped",
			[1603, 1582]
		],
		[
			[64711, 64711],
			"mapped",
			[1603, 1604]
		],
		[
			[64712, 64712],
			"mapped",
			[1603, 1605]
		],
		[
			[64713, 64713],
			"mapped",
			[1604, 1580]
		],
		[
			[64714, 64714],
			"mapped",
			[1604, 1581]
		],
		[
			[64715, 64715],
			"mapped",
			[1604, 1582]
		],
		[
			[64716, 64716],
			"mapped",
			[1604, 1605]
		],
		[
			[64717, 64717],
			"mapped",
			[1604, 1607]
		],
		[
			[64718, 64718],
			"mapped",
			[1605, 1580]
		],
		[
			[64719, 64719],
			"mapped",
			[1605, 1581]
		],
		[
			[64720, 64720],
			"mapped",
			[1605, 1582]
		],
		[
			[64721, 64721],
			"mapped",
			[1605, 1605]
		],
		[
			[64722, 64722],
			"mapped",
			[1606, 1580]
		],
		[
			[64723, 64723],
			"mapped",
			[1606, 1581]
		],
		[
			[64724, 64724],
			"mapped",
			[1606, 1582]
		],
		[
			[64725, 64725],
			"mapped",
			[1606, 1605]
		],
		[
			[64726, 64726],
			"mapped",
			[1606, 1607]
		],
		[
			[64727, 64727],
			"mapped",
			[1607, 1580]
		],
		[
			[64728, 64728],
			"mapped",
			[1607, 1605]
		],
		[
			[64729, 64729],
			"mapped",
			[1607, 1648]
		],
		[
			[64730, 64730],
			"mapped",
			[1610, 1580]
		],
		[
			[64731, 64731],
			"mapped",
			[1610, 1581]
		],
		[
			[64732, 64732],
			"mapped",
			[1610, 1582]
		],
		[
			[64733, 64733],
			"mapped",
			[1610, 1605]
		],
		[
			[64734, 64734],
			"mapped",
			[1610, 1607]
		],
		[
			[64735, 64735],
			"mapped",
			[1574, 1605]
		],
		[
			[64736, 64736],
			"mapped",
			[1574, 1607]
		],
		[
			[64737, 64737],
			"mapped",
			[1576, 1605]
		],
		[
			[64738, 64738],
			"mapped",
			[1576, 1607]
		],
		[
			[64739, 64739],
			"mapped",
			[1578, 1605]
		],
		[
			[64740, 64740],
			"mapped",
			[1578, 1607]
		],
		[
			[64741, 64741],
			"mapped",
			[1579, 1605]
		],
		[
			[64742, 64742],
			"mapped",
			[1579, 1607]
		],
		[
			[64743, 64743],
			"mapped",
			[1587, 1605]
		],
		[
			[64744, 64744],
			"mapped",
			[1587, 1607]
		],
		[
			[64745, 64745],
			"mapped",
			[1588, 1605]
		],
		[
			[64746, 64746],
			"mapped",
			[1588, 1607]
		],
		[
			[64747, 64747],
			"mapped",
			[1603, 1604]
		],
		[
			[64748, 64748],
			"mapped",
			[1603, 1605]
		],
		[
			[64749, 64749],
			"mapped",
			[1604, 1605]
		],
		[
			[64750, 64750],
			"mapped",
			[1606, 1605]
		],
		[
			[64751, 64751],
			"mapped",
			[1606, 1607]
		],
		[
			[64752, 64752],
			"mapped",
			[1610, 1605]
		],
		[
			[64753, 64753],
			"mapped",
			[1610, 1607]
		],
		[
			[64754, 64754],
			"mapped",
			[
				1600,
				1614,
				1617
			]
		],
		[
			[64755, 64755],
			"mapped",
			[
				1600,
				1615,
				1617
			]
		],
		[
			[64756, 64756],
			"mapped",
			[
				1600,
				1616,
				1617
			]
		],
		[
			[64757, 64757],
			"mapped",
			[1591, 1609]
		],
		[
			[64758, 64758],
			"mapped",
			[1591, 1610]
		],
		[
			[64759, 64759],
			"mapped",
			[1593, 1609]
		],
		[
			[64760, 64760],
			"mapped",
			[1593, 1610]
		],
		[
			[64761, 64761],
			"mapped",
			[1594, 1609]
		],
		[
			[64762, 64762],
			"mapped",
			[1594, 1610]
		],
		[
			[64763, 64763],
			"mapped",
			[1587, 1609]
		],
		[
			[64764, 64764],
			"mapped",
			[1587, 1610]
		],
		[
			[64765, 64765],
			"mapped",
			[1588, 1609]
		],
		[
			[64766, 64766],
			"mapped",
			[1588, 1610]
		],
		[
			[64767, 64767],
			"mapped",
			[1581, 1609]
		],
		[
			[64768, 64768],
			"mapped",
			[1581, 1610]
		],
		[
			[64769, 64769],
			"mapped",
			[1580, 1609]
		],
		[
			[64770, 64770],
			"mapped",
			[1580, 1610]
		],
		[
			[64771, 64771],
			"mapped",
			[1582, 1609]
		],
		[
			[64772, 64772],
			"mapped",
			[1582, 1610]
		],
		[
			[64773, 64773],
			"mapped",
			[1589, 1609]
		],
		[
			[64774, 64774],
			"mapped",
			[1589, 1610]
		],
		[
			[64775, 64775],
			"mapped",
			[1590, 1609]
		],
		[
			[64776, 64776],
			"mapped",
			[1590, 1610]
		],
		[
			[64777, 64777],
			"mapped",
			[1588, 1580]
		],
		[
			[64778, 64778],
			"mapped",
			[1588, 1581]
		],
		[
			[64779, 64779],
			"mapped",
			[1588, 1582]
		],
		[
			[64780, 64780],
			"mapped",
			[1588, 1605]
		],
		[
			[64781, 64781],
			"mapped",
			[1588, 1585]
		],
		[
			[64782, 64782],
			"mapped",
			[1587, 1585]
		],
		[
			[64783, 64783],
			"mapped",
			[1589, 1585]
		],
		[
			[64784, 64784],
			"mapped",
			[1590, 1585]
		],
		[
			[64785, 64785],
			"mapped",
			[1591, 1609]
		],
		[
			[64786, 64786],
			"mapped",
			[1591, 1610]
		],
		[
			[64787, 64787],
			"mapped",
			[1593, 1609]
		],
		[
			[64788, 64788],
			"mapped",
			[1593, 1610]
		],
		[
			[64789, 64789],
			"mapped",
			[1594, 1609]
		],
		[
			[64790, 64790],
			"mapped",
			[1594, 1610]
		],
		[
			[64791, 64791],
			"mapped",
			[1587, 1609]
		],
		[
			[64792, 64792],
			"mapped",
			[1587, 1610]
		],
		[
			[64793, 64793],
			"mapped",
			[1588, 1609]
		],
		[
			[64794, 64794],
			"mapped",
			[1588, 1610]
		],
		[
			[64795, 64795],
			"mapped",
			[1581, 1609]
		],
		[
			[64796, 64796],
			"mapped",
			[1581, 1610]
		],
		[
			[64797, 64797],
			"mapped",
			[1580, 1609]
		],
		[
			[64798, 64798],
			"mapped",
			[1580, 1610]
		],
		[
			[64799, 64799],
			"mapped",
			[1582, 1609]
		],
		[
			[64800, 64800],
			"mapped",
			[1582, 1610]
		],
		[
			[64801, 64801],
			"mapped",
			[1589, 1609]
		],
		[
			[64802, 64802],
			"mapped",
			[1589, 1610]
		],
		[
			[64803, 64803],
			"mapped",
			[1590, 1609]
		],
		[
			[64804, 64804],
			"mapped",
			[1590, 1610]
		],
		[
			[64805, 64805],
			"mapped",
			[1588, 1580]
		],
		[
			[64806, 64806],
			"mapped",
			[1588, 1581]
		],
		[
			[64807, 64807],
			"mapped",
			[1588, 1582]
		],
		[
			[64808, 64808],
			"mapped",
			[1588, 1605]
		],
		[
			[64809, 64809],
			"mapped",
			[1588, 1585]
		],
		[
			[64810, 64810],
			"mapped",
			[1587, 1585]
		],
		[
			[64811, 64811],
			"mapped",
			[1589, 1585]
		],
		[
			[64812, 64812],
			"mapped",
			[1590, 1585]
		],
		[
			[64813, 64813],
			"mapped",
			[1588, 1580]
		],
		[
			[64814, 64814],
			"mapped",
			[1588, 1581]
		],
		[
			[64815, 64815],
			"mapped",
			[1588, 1582]
		],
		[
			[64816, 64816],
			"mapped",
			[1588, 1605]
		],
		[
			[64817, 64817],
			"mapped",
			[1587, 1607]
		],
		[
			[64818, 64818],
			"mapped",
			[1588, 1607]
		],
		[
			[64819, 64819],
			"mapped",
			[1591, 1605]
		],
		[
			[64820, 64820],
			"mapped",
			[1587, 1580]
		],
		[
			[64821, 64821],
			"mapped",
			[1587, 1581]
		],
		[
			[64822, 64822],
			"mapped",
			[1587, 1582]
		],
		[
			[64823, 64823],
			"mapped",
			[1588, 1580]
		],
		[
			[64824, 64824],
			"mapped",
			[1588, 1581]
		],
		[
			[64825, 64825],
			"mapped",
			[1588, 1582]
		],
		[
			[64826, 64826],
			"mapped",
			[1591, 1605]
		],
		[
			[64827, 64827],
			"mapped",
			[1592, 1605]
		],
		[
			[64828, 64829],
			"mapped",
			[1575, 1611]
		],
		[
			[64830, 64831],
			"valid",
			[],
			"NV8"
		],
		[[64832, 64847], "disallowed"],
		[
			[64848, 64848],
			"mapped",
			[
				1578,
				1580,
				1605
			]
		],
		[
			[64849, 64850],
			"mapped",
			[
				1578,
				1581,
				1580
			]
		],
		[
			[64851, 64851],
			"mapped",
			[
				1578,
				1581,
				1605
			]
		],
		[
			[64852, 64852],
			"mapped",
			[
				1578,
				1582,
				1605
			]
		],
		[
			[64853, 64853],
			"mapped",
			[
				1578,
				1605,
				1580
			]
		],
		[
			[64854, 64854],
			"mapped",
			[
				1578,
				1605,
				1581
			]
		],
		[
			[64855, 64855],
			"mapped",
			[
				1578,
				1605,
				1582
			]
		],
		[
			[64856, 64857],
			"mapped",
			[
				1580,
				1605,
				1581
			]
		],
		[
			[64858, 64858],
			"mapped",
			[
				1581,
				1605,
				1610
			]
		],
		[
			[64859, 64859],
			"mapped",
			[
				1581,
				1605,
				1609
			]
		],
		[
			[64860, 64860],
			"mapped",
			[
				1587,
				1581,
				1580
			]
		],
		[
			[64861, 64861],
			"mapped",
			[
				1587,
				1580,
				1581
			]
		],
		[
			[64862, 64862],
			"mapped",
			[
				1587,
				1580,
				1609
			]
		],
		[
			[64863, 64864],
			"mapped",
			[
				1587,
				1605,
				1581
			]
		],
		[
			[64865, 64865],
			"mapped",
			[
				1587,
				1605,
				1580
			]
		],
		[
			[64866, 64867],
			"mapped",
			[
				1587,
				1605,
				1605
			]
		],
		[
			[64868, 64869],
			"mapped",
			[
				1589,
				1581,
				1581
			]
		],
		[
			[64870, 64870],
			"mapped",
			[
				1589,
				1605,
				1605
			]
		],
		[
			[64871, 64872],
			"mapped",
			[
				1588,
				1581,
				1605
			]
		],
		[
			[64873, 64873],
			"mapped",
			[
				1588,
				1580,
				1610
			]
		],
		[
			[64874, 64875],
			"mapped",
			[
				1588,
				1605,
				1582
			]
		],
		[
			[64876, 64877],
			"mapped",
			[
				1588,
				1605,
				1605
			]
		],
		[
			[64878, 64878],
			"mapped",
			[
				1590,
				1581,
				1609
			]
		],
		[
			[64879, 64880],
			"mapped",
			[
				1590,
				1582,
				1605
			]
		],
		[
			[64881, 64882],
			"mapped",
			[
				1591,
				1605,
				1581
			]
		],
		[
			[64883, 64883],
			"mapped",
			[
				1591,
				1605,
				1605
			]
		],
		[
			[64884, 64884],
			"mapped",
			[
				1591,
				1605,
				1610
			]
		],
		[
			[64885, 64885],
			"mapped",
			[
				1593,
				1580,
				1605
			]
		],
		[
			[64886, 64887],
			"mapped",
			[
				1593,
				1605,
				1605
			]
		],
		[
			[64888, 64888],
			"mapped",
			[
				1593,
				1605,
				1609
			]
		],
		[
			[64889, 64889],
			"mapped",
			[
				1594,
				1605,
				1605
			]
		],
		[
			[64890, 64890],
			"mapped",
			[
				1594,
				1605,
				1610
			]
		],
		[
			[64891, 64891],
			"mapped",
			[
				1594,
				1605,
				1609
			]
		],
		[
			[64892, 64893],
			"mapped",
			[
				1601,
				1582,
				1605
			]
		],
		[
			[64894, 64894],
			"mapped",
			[
				1602,
				1605,
				1581
			]
		],
		[
			[64895, 64895],
			"mapped",
			[
				1602,
				1605,
				1605
			]
		],
		[
			[64896, 64896],
			"mapped",
			[
				1604,
				1581,
				1605
			]
		],
		[
			[64897, 64897],
			"mapped",
			[
				1604,
				1581,
				1610
			]
		],
		[
			[64898, 64898],
			"mapped",
			[
				1604,
				1581,
				1609
			]
		],
		[
			[64899, 64900],
			"mapped",
			[
				1604,
				1580,
				1580
			]
		],
		[
			[64901, 64902],
			"mapped",
			[
				1604,
				1582,
				1605
			]
		],
		[
			[64903, 64904],
			"mapped",
			[
				1604,
				1605,
				1581
			]
		],
		[
			[64905, 64905],
			"mapped",
			[
				1605,
				1581,
				1580
			]
		],
		[
			[64906, 64906],
			"mapped",
			[
				1605,
				1581,
				1605
			]
		],
		[
			[64907, 64907],
			"mapped",
			[
				1605,
				1581,
				1610
			]
		],
		[
			[64908, 64908],
			"mapped",
			[
				1605,
				1580,
				1581
			]
		],
		[
			[64909, 64909],
			"mapped",
			[
				1605,
				1580,
				1605
			]
		],
		[
			[64910, 64910],
			"mapped",
			[
				1605,
				1582,
				1580
			]
		],
		[
			[64911, 64911],
			"mapped",
			[
				1605,
				1582,
				1605
			]
		],
		[[64912, 64913], "disallowed"],
		[
			[64914, 64914],
			"mapped",
			[
				1605,
				1580,
				1582
			]
		],
		[
			[64915, 64915],
			"mapped",
			[
				1607,
				1605,
				1580
			]
		],
		[
			[64916, 64916],
			"mapped",
			[
				1607,
				1605,
				1605
			]
		],
		[
			[64917, 64917],
			"mapped",
			[
				1606,
				1581,
				1605
			]
		],
		[
			[64918, 64918],
			"mapped",
			[
				1606,
				1581,
				1609
			]
		],
		[
			[64919, 64920],
			"mapped",
			[
				1606,
				1580,
				1605
			]
		],
		[
			[64921, 64921],
			"mapped",
			[
				1606,
				1580,
				1609
			]
		],
		[
			[64922, 64922],
			"mapped",
			[
				1606,
				1605,
				1610
			]
		],
		[
			[64923, 64923],
			"mapped",
			[
				1606,
				1605,
				1609
			]
		],
		[
			[64924, 64925],
			"mapped",
			[
				1610,
				1605,
				1605
			]
		],
		[
			[64926, 64926],
			"mapped",
			[
				1576,
				1582,
				1610
			]
		],
		[
			[64927, 64927],
			"mapped",
			[
				1578,
				1580,
				1610
			]
		],
		[
			[64928, 64928],
			"mapped",
			[
				1578,
				1580,
				1609
			]
		],
		[
			[64929, 64929],
			"mapped",
			[
				1578,
				1582,
				1610
			]
		],
		[
			[64930, 64930],
			"mapped",
			[
				1578,
				1582,
				1609
			]
		],
		[
			[64931, 64931],
			"mapped",
			[
				1578,
				1605,
				1610
			]
		],
		[
			[64932, 64932],
			"mapped",
			[
				1578,
				1605,
				1609
			]
		],
		[
			[64933, 64933],
			"mapped",
			[
				1580,
				1605,
				1610
			]
		],
		[
			[64934, 64934],
			"mapped",
			[
				1580,
				1581,
				1609
			]
		],
		[
			[64935, 64935],
			"mapped",
			[
				1580,
				1605,
				1609
			]
		],
		[
			[64936, 64936],
			"mapped",
			[
				1587,
				1582,
				1609
			]
		],
		[
			[64937, 64937],
			"mapped",
			[
				1589,
				1581,
				1610
			]
		],
		[
			[64938, 64938],
			"mapped",
			[
				1588,
				1581,
				1610
			]
		],
		[
			[64939, 64939],
			"mapped",
			[
				1590,
				1581,
				1610
			]
		],
		[
			[64940, 64940],
			"mapped",
			[
				1604,
				1580,
				1610
			]
		],
		[
			[64941, 64941],
			"mapped",
			[
				1604,
				1605,
				1610
			]
		],
		[
			[64942, 64942],
			"mapped",
			[
				1610,
				1581,
				1610
			]
		],
		[
			[64943, 64943],
			"mapped",
			[
				1610,
				1580,
				1610
			]
		],
		[
			[64944, 64944],
			"mapped",
			[
				1610,
				1605,
				1610
			]
		],
		[
			[64945, 64945],
			"mapped",
			[
				1605,
				1605,
				1610
			]
		],
		[
			[64946, 64946],
			"mapped",
			[
				1602,
				1605,
				1610
			]
		],
		[
			[64947, 64947],
			"mapped",
			[
				1606,
				1581,
				1610
			]
		],
		[
			[64948, 64948],
			"mapped",
			[
				1602,
				1605,
				1581
			]
		],
		[
			[64949, 64949],
			"mapped",
			[
				1604,
				1581,
				1605
			]
		],
		[
			[64950, 64950],
			"mapped",
			[
				1593,
				1605,
				1610
			]
		],
		[
			[64951, 64951],
			"mapped",
			[
				1603,
				1605,
				1610
			]
		],
		[
			[64952, 64952],
			"mapped",
			[
				1606,
				1580,
				1581
			]
		],
		[
			[64953, 64953],
			"mapped",
			[
				1605,
				1582,
				1610
			]
		],
		[
			[64954, 64954],
			"mapped",
			[
				1604,
				1580,
				1605
			]
		],
		[
			[64955, 64955],
			"mapped",
			[
				1603,
				1605,
				1605
			]
		],
		[
			[64956, 64956],
			"mapped",
			[
				1604,
				1580,
				1605
			]
		],
		[
			[64957, 64957],
			"mapped",
			[
				1606,
				1580,
				1581
			]
		],
		[
			[64958, 64958],
			"mapped",
			[
				1580,
				1581,
				1610
			]
		],
		[
			[64959, 64959],
			"mapped",
			[
				1581,
				1580,
				1610
			]
		],
		[
			[64960, 64960],
			"mapped",
			[
				1605,
				1580,
				1610
			]
		],
		[
			[64961, 64961],
			"mapped",
			[
				1601,
				1605,
				1610
			]
		],
		[
			[64962, 64962],
			"mapped",
			[
				1576,
				1581,
				1610
			]
		],
		[
			[64963, 64963],
			"mapped",
			[
				1603,
				1605,
				1605
			]
		],
		[
			[64964, 64964],
			"mapped",
			[
				1593,
				1580,
				1605
			]
		],
		[
			[64965, 64965],
			"mapped",
			[
				1589,
				1605,
				1605
			]
		],
		[
			[64966, 64966],
			"mapped",
			[
				1587,
				1582,
				1610
			]
		],
		[
			[64967, 64967],
			"mapped",
			[
				1606,
				1580,
				1610
			]
		],
		[[64968, 64975], "disallowed"],
		[[64976, 65007], "disallowed"],
		[
			[65008, 65008],
			"mapped",
			[
				1589,
				1604,
				1746
			]
		],
		[
			[65009, 65009],
			"mapped",
			[
				1602,
				1604,
				1746
			]
		],
		[
			[65010, 65010],
			"mapped",
			[
				1575,
				1604,
				1604,
				1607
			]
		],
		[
			[65011, 65011],
			"mapped",
			[
				1575,
				1603,
				1576,
				1585
			]
		],
		[
			[65012, 65012],
			"mapped",
			[
				1605,
				1581,
				1605,
				1583
			]
		],
		[
			[65013, 65013],
			"mapped",
			[
				1589,
				1604,
				1593,
				1605
			]
		],
		[
			[65014, 65014],
			"mapped",
			[
				1585,
				1587,
				1608,
				1604
			]
		],
		[
			[65015, 65015],
			"mapped",
			[
				1593,
				1604,
				1610,
				1607
			]
		],
		[
			[65016, 65016],
			"mapped",
			[
				1608,
				1587,
				1604,
				1605
			]
		],
		[
			[65017, 65017],
			"mapped",
			[
				1589,
				1604,
				1609
			]
		],
		[
			[65018, 65018],
			"disallowed_STD3_mapped",
			[
				1589,
				1604,
				1609,
				32,
				1575,
				1604,
				1604,
				1607,
				32,
				1593,
				1604,
				1610,
				1607,
				32,
				1608,
				1587,
				1604,
				1605
			]
		],
		[
			[65019, 65019],
			"disallowed_STD3_mapped",
			[
				1580,
				1604,
				32,
				1580,
				1604,
				1575,
				1604,
				1607
			]
		],
		[
			[65020, 65020],
			"mapped",
			[
				1585,
				1740,
				1575,
				1604
			]
		],
		[
			[65021, 65021],
			"valid",
			[],
			"NV8"
		],
		[[65022, 65023], "disallowed"],
		[[65024, 65039], "ignored"],
		[
			[65040, 65040],
			"disallowed_STD3_mapped",
			[44]
		],
		[
			[65041, 65041],
			"mapped",
			[12289]
		],
		[[65042, 65042], "disallowed"],
		[
			[65043, 65043],
			"disallowed_STD3_mapped",
			[58]
		],
		[
			[65044, 65044],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[65045, 65045],
			"disallowed_STD3_mapped",
			[33]
		],
		[
			[65046, 65046],
			"disallowed_STD3_mapped",
			[63]
		],
		[
			[65047, 65047],
			"mapped",
			[12310]
		],
		[
			[65048, 65048],
			"mapped",
			[12311]
		],
		[[65049, 65049], "disallowed"],
		[[65050, 65055], "disallowed"],
		[[65056, 65059], "valid"],
		[[65060, 65062], "valid"],
		[[65063, 65069], "valid"],
		[[65070, 65071], "valid"],
		[[65072, 65072], "disallowed"],
		[
			[65073, 65073],
			"mapped",
			[8212]
		],
		[
			[65074, 65074],
			"mapped",
			[8211]
		],
		[
			[65075, 65076],
			"disallowed_STD3_mapped",
			[95]
		],
		[
			[65077, 65077],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[65078, 65078],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[65079, 65079],
			"disallowed_STD3_mapped",
			[123]
		],
		[
			[65080, 65080],
			"disallowed_STD3_mapped",
			[125]
		],
		[
			[65081, 65081],
			"mapped",
			[12308]
		],
		[
			[65082, 65082],
			"mapped",
			[12309]
		],
		[
			[65083, 65083],
			"mapped",
			[12304]
		],
		[
			[65084, 65084],
			"mapped",
			[12305]
		],
		[
			[65085, 65085],
			"mapped",
			[12298]
		],
		[
			[65086, 65086],
			"mapped",
			[12299]
		],
		[
			[65087, 65087],
			"mapped",
			[12296]
		],
		[
			[65088, 65088],
			"mapped",
			[12297]
		],
		[
			[65089, 65089],
			"mapped",
			[12300]
		],
		[
			[65090, 65090],
			"mapped",
			[12301]
		],
		[
			[65091, 65091],
			"mapped",
			[12302]
		],
		[
			[65092, 65092],
			"mapped",
			[12303]
		],
		[
			[65093, 65094],
			"valid",
			[],
			"NV8"
		],
		[
			[65095, 65095],
			"disallowed_STD3_mapped",
			[91]
		],
		[
			[65096, 65096],
			"disallowed_STD3_mapped",
			[93]
		],
		[
			[65097, 65100],
			"disallowed_STD3_mapped",
			[32, 773]
		],
		[
			[65101, 65103],
			"disallowed_STD3_mapped",
			[95]
		],
		[
			[65104, 65104],
			"disallowed_STD3_mapped",
			[44]
		],
		[
			[65105, 65105],
			"mapped",
			[12289]
		],
		[[65106, 65106], "disallowed"],
		[[65107, 65107], "disallowed"],
		[
			[65108, 65108],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[65109, 65109],
			"disallowed_STD3_mapped",
			[58]
		],
		[
			[65110, 65110],
			"disallowed_STD3_mapped",
			[63]
		],
		[
			[65111, 65111],
			"disallowed_STD3_mapped",
			[33]
		],
		[
			[65112, 65112],
			"mapped",
			[8212]
		],
		[
			[65113, 65113],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[65114, 65114],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[65115, 65115],
			"disallowed_STD3_mapped",
			[123]
		],
		[
			[65116, 65116],
			"disallowed_STD3_mapped",
			[125]
		],
		[
			[65117, 65117],
			"mapped",
			[12308]
		],
		[
			[65118, 65118],
			"mapped",
			[12309]
		],
		[
			[65119, 65119],
			"disallowed_STD3_mapped",
			[35]
		],
		[
			[65120, 65120],
			"disallowed_STD3_mapped",
			[38]
		],
		[
			[65121, 65121],
			"disallowed_STD3_mapped",
			[42]
		],
		[
			[65122, 65122],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[65123, 65123],
			"mapped",
			[45]
		],
		[
			[65124, 65124],
			"disallowed_STD3_mapped",
			[60]
		],
		[
			[65125, 65125],
			"disallowed_STD3_mapped",
			[62]
		],
		[
			[65126, 65126],
			"disallowed_STD3_mapped",
			[61]
		],
		[[65127, 65127], "disallowed"],
		[
			[65128, 65128],
			"disallowed_STD3_mapped",
			[92]
		],
		[
			[65129, 65129],
			"disallowed_STD3_mapped",
			[36]
		],
		[
			[65130, 65130],
			"disallowed_STD3_mapped",
			[37]
		],
		[
			[65131, 65131],
			"disallowed_STD3_mapped",
			[64]
		],
		[[65132, 65135], "disallowed"],
		[
			[65136, 65136],
			"disallowed_STD3_mapped",
			[32, 1611]
		],
		[
			[65137, 65137],
			"mapped",
			[1600, 1611]
		],
		[
			[65138, 65138],
			"disallowed_STD3_mapped",
			[32, 1612]
		],
		[[65139, 65139], "valid"],
		[
			[65140, 65140],
			"disallowed_STD3_mapped",
			[32, 1613]
		],
		[[65141, 65141], "disallowed"],
		[
			[65142, 65142],
			"disallowed_STD3_mapped",
			[32, 1614]
		],
		[
			[65143, 65143],
			"mapped",
			[1600, 1614]
		],
		[
			[65144, 65144],
			"disallowed_STD3_mapped",
			[32, 1615]
		],
		[
			[65145, 65145],
			"mapped",
			[1600, 1615]
		],
		[
			[65146, 65146],
			"disallowed_STD3_mapped",
			[32, 1616]
		],
		[
			[65147, 65147],
			"mapped",
			[1600, 1616]
		],
		[
			[65148, 65148],
			"disallowed_STD3_mapped",
			[32, 1617]
		],
		[
			[65149, 65149],
			"mapped",
			[1600, 1617]
		],
		[
			[65150, 65150],
			"disallowed_STD3_mapped",
			[32, 1618]
		],
		[
			[65151, 65151],
			"mapped",
			[1600, 1618]
		],
		[
			[65152, 65152],
			"mapped",
			[1569]
		],
		[
			[65153, 65154],
			"mapped",
			[1570]
		],
		[
			[65155, 65156],
			"mapped",
			[1571]
		],
		[
			[65157, 65158],
			"mapped",
			[1572]
		],
		[
			[65159, 65160],
			"mapped",
			[1573]
		],
		[
			[65161, 65164],
			"mapped",
			[1574]
		],
		[
			[65165, 65166],
			"mapped",
			[1575]
		],
		[
			[65167, 65170],
			"mapped",
			[1576]
		],
		[
			[65171, 65172],
			"mapped",
			[1577]
		],
		[
			[65173, 65176],
			"mapped",
			[1578]
		],
		[
			[65177, 65180],
			"mapped",
			[1579]
		],
		[
			[65181, 65184],
			"mapped",
			[1580]
		],
		[
			[65185, 65188],
			"mapped",
			[1581]
		],
		[
			[65189, 65192],
			"mapped",
			[1582]
		],
		[
			[65193, 65194],
			"mapped",
			[1583]
		],
		[
			[65195, 65196],
			"mapped",
			[1584]
		],
		[
			[65197, 65198],
			"mapped",
			[1585]
		],
		[
			[65199, 65200],
			"mapped",
			[1586]
		],
		[
			[65201, 65204],
			"mapped",
			[1587]
		],
		[
			[65205, 65208],
			"mapped",
			[1588]
		],
		[
			[65209, 65212],
			"mapped",
			[1589]
		],
		[
			[65213, 65216],
			"mapped",
			[1590]
		],
		[
			[65217, 65220],
			"mapped",
			[1591]
		],
		[
			[65221, 65224],
			"mapped",
			[1592]
		],
		[
			[65225, 65228],
			"mapped",
			[1593]
		],
		[
			[65229, 65232],
			"mapped",
			[1594]
		],
		[
			[65233, 65236],
			"mapped",
			[1601]
		],
		[
			[65237, 65240],
			"mapped",
			[1602]
		],
		[
			[65241, 65244],
			"mapped",
			[1603]
		],
		[
			[65245, 65248],
			"mapped",
			[1604]
		],
		[
			[65249, 65252],
			"mapped",
			[1605]
		],
		[
			[65253, 65256],
			"mapped",
			[1606]
		],
		[
			[65257, 65260],
			"mapped",
			[1607]
		],
		[
			[65261, 65262],
			"mapped",
			[1608]
		],
		[
			[65263, 65264],
			"mapped",
			[1609]
		],
		[
			[65265, 65268],
			"mapped",
			[1610]
		],
		[
			[65269, 65270],
			"mapped",
			[1604, 1570]
		],
		[
			[65271, 65272],
			"mapped",
			[1604, 1571]
		],
		[
			[65273, 65274],
			"mapped",
			[1604, 1573]
		],
		[
			[65275, 65276],
			"mapped",
			[1604, 1575]
		],
		[[65277, 65278], "disallowed"],
		[[65279, 65279], "ignored"],
		[[65280, 65280], "disallowed"],
		[
			[65281, 65281],
			"disallowed_STD3_mapped",
			[33]
		],
		[
			[65282, 65282],
			"disallowed_STD3_mapped",
			[34]
		],
		[
			[65283, 65283],
			"disallowed_STD3_mapped",
			[35]
		],
		[
			[65284, 65284],
			"disallowed_STD3_mapped",
			[36]
		],
		[
			[65285, 65285],
			"disallowed_STD3_mapped",
			[37]
		],
		[
			[65286, 65286],
			"disallowed_STD3_mapped",
			[38]
		],
		[
			[65287, 65287],
			"disallowed_STD3_mapped",
			[39]
		],
		[
			[65288, 65288],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[65289, 65289],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[65290, 65290],
			"disallowed_STD3_mapped",
			[42]
		],
		[
			[65291, 65291],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[65292, 65292],
			"disallowed_STD3_mapped",
			[44]
		],
		[
			[65293, 65293],
			"mapped",
			[45]
		],
		[
			[65294, 65294],
			"mapped",
			[46]
		],
		[
			[65295, 65295],
			"disallowed_STD3_mapped",
			[47]
		],
		[
			[65296, 65296],
			"mapped",
			[48]
		],
		[
			[65297, 65297],
			"mapped",
			[49]
		],
		[
			[65298, 65298],
			"mapped",
			[50]
		],
		[
			[65299, 65299],
			"mapped",
			[51]
		],
		[
			[65300, 65300],
			"mapped",
			[52]
		],
		[
			[65301, 65301],
			"mapped",
			[53]
		],
		[
			[65302, 65302],
			"mapped",
			[54]
		],
		[
			[65303, 65303],
			"mapped",
			[55]
		],
		[
			[65304, 65304],
			"mapped",
			[56]
		],
		[
			[65305, 65305],
			"mapped",
			[57]
		],
		[
			[65306, 65306],
			"disallowed_STD3_mapped",
			[58]
		],
		[
			[65307, 65307],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[65308, 65308],
			"disallowed_STD3_mapped",
			[60]
		],
		[
			[65309, 65309],
			"disallowed_STD3_mapped",
			[61]
		],
		[
			[65310, 65310],
			"disallowed_STD3_mapped",
			[62]
		],
		[
			[65311, 65311],
			"disallowed_STD3_mapped",
			[63]
		],
		[
			[65312, 65312],
			"disallowed_STD3_mapped",
			[64]
		],
		[
			[65313, 65313],
			"mapped",
			[97]
		],
		[
			[65314, 65314],
			"mapped",
			[98]
		],
		[
			[65315, 65315],
			"mapped",
			[99]
		],
		[
			[65316, 65316],
			"mapped",
			[100]
		],
		[
			[65317, 65317],
			"mapped",
			[101]
		],
		[
			[65318, 65318],
			"mapped",
			[102]
		],
		[
			[65319, 65319],
			"mapped",
			[103]
		],
		[
			[65320, 65320],
			"mapped",
			[104]
		],
		[
			[65321, 65321],
			"mapped",
			[105]
		],
		[
			[65322, 65322],
			"mapped",
			[106]
		],
		[
			[65323, 65323],
			"mapped",
			[107]
		],
		[
			[65324, 65324],
			"mapped",
			[108]
		],
		[
			[65325, 65325],
			"mapped",
			[109]
		],
		[
			[65326, 65326],
			"mapped",
			[110]
		],
		[
			[65327, 65327],
			"mapped",
			[111]
		],
		[
			[65328, 65328],
			"mapped",
			[112]
		],
		[
			[65329, 65329],
			"mapped",
			[113]
		],
		[
			[65330, 65330],
			"mapped",
			[114]
		],
		[
			[65331, 65331],
			"mapped",
			[115]
		],
		[
			[65332, 65332],
			"mapped",
			[116]
		],
		[
			[65333, 65333],
			"mapped",
			[117]
		],
		[
			[65334, 65334],
			"mapped",
			[118]
		],
		[
			[65335, 65335],
			"mapped",
			[119]
		],
		[
			[65336, 65336],
			"mapped",
			[120]
		],
		[
			[65337, 65337],
			"mapped",
			[121]
		],
		[
			[65338, 65338],
			"mapped",
			[122]
		],
		[
			[65339, 65339],
			"disallowed_STD3_mapped",
			[91]
		],
		[
			[65340, 65340],
			"disallowed_STD3_mapped",
			[92]
		],
		[
			[65341, 65341],
			"disallowed_STD3_mapped",
			[93]
		],
		[
			[65342, 65342],
			"disallowed_STD3_mapped",
			[94]
		],
		[
			[65343, 65343],
			"disallowed_STD3_mapped",
			[95]
		],
		[
			[65344, 65344],
			"disallowed_STD3_mapped",
			[96]
		],
		[
			[65345, 65345],
			"mapped",
			[97]
		],
		[
			[65346, 65346],
			"mapped",
			[98]
		],
		[
			[65347, 65347],
			"mapped",
			[99]
		],
		[
			[65348, 65348],
			"mapped",
			[100]
		],
		[
			[65349, 65349],
			"mapped",
			[101]
		],
		[
			[65350, 65350],
			"mapped",
			[102]
		],
		[
			[65351, 65351],
			"mapped",
			[103]
		],
		[
			[65352, 65352],
			"mapped",
			[104]
		],
		[
			[65353, 65353],
			"mapped",
			[105]
		],
		[
			[65354, 65354],
			"mapped",
			[106]
		],
		[
			[65355, 65355],
			"mapped",
			[107]
		],
		[
			[65356, 65356],
			"mapped",
			[108]
		],
		[
			[65357, 65357],
			"mapped",
			[109]
		],
		[
			[65358, 65358],
			"mapped",
			[110]
		],
		[
			[65359, 65359],
			"mapped",
			[111]
		],
		[
			[65360, 65360],
			"mapped",
			[112]
		],
		[
			[65361, 65361],
			"mapped",
			[113]
		],
		[
			[65362, 65362],
			"mapped",
			[114]
		],
		[
			[65363, 65363],
			"mapped",
			[115]
		],
		[
			[65364, 65364],
			"mapped",
			[116]
		],
		[
			[65365, 65365],
			"mapped",
			[117]
		],
		[
			[65366, 65366],
			"mapped",
			[118]
		],
		[
			[65367, 65367],
			"mapped",
			[119]
		],
		[
			[65368, 65368],
			"mapped",
			[120]
		],
		[
			[65369, 65369],
			"mapped",
			[121]
		],
		[
			[65370, 65370],
			"mapped",
			[122]
		],
		[
			[65371, 65371],
			"disallowed_STD3_mapped",
			[123]
		],
		[
			[65372, 65372],
			"disallowed_STD3_mapped",
			[124]
		],
		[
			[65373, 65373],
			"disallowed_STD3_mapped",
			[125]
		],
		[
			[65374, 65374],
			"disallowed_STD3_mapped",
			[126]
		],
		[
			[65375, 65375],
			"mapped",
			[10629]
		],
		[
			[65376, 65376],
			"mapped",
			[10630]
		],
		[
			[65377, 65377],
			"mapped",
			[46]
		],
		[
			[65378, 65378],
			"mapped",
			[12300]
		],
		[
			[65379, 65379],
			"mapped",
			[12301]
		],
		[
			[65380, 65380],
			"mapped",
			[12289]
		],
		[
			[65381, 65381],
			"mapped",
			[12539]
		],
		[
			[65382, 65382],
			"mapped",
			[12530]
		],
		[
			[65383, 65383],
			"mapped",
			[12449]
		],
		[
			[65384, 65384],
			"mapped",
			[12451]
		],
		[
			[65385, 65385],
			"mapped",
			[12453]
		],
		[
			[65386, 65386],
			"mapped",
			[12455]
		],
		[
			[65387, 65387],
			"mapped",
			[12457]
		],
		[
			[65388, 65388],
			"mapped",
			[12515]
		],
		[
			[65389, 65389],
			"mapped",
			[12517]
		],
		[
			[65390, 65390],
			"mapped",
			[12519]
		],
		[
			[65391, 65391],
			"mapped",
			[12483]
		],
		[
			[65392, 65392],
			"mapped",
			[12540]
		],
		[
			[65393, 65393],
			"mapped",
			[12450]
		],
		[
			[65394, 65394],
			"mapped",
			[12452]
		],
		[
			[65395, 65395],
			"mapped",
			[12454]
		],
		[
			[65396, 65396],
			"mapped",
			[12456]
		],
		[
			[65397, 65397],
			"mapped",
			[12458]
		],
		[
			[65398, 65398],
			"mapped",
			[12459]
		],
		[
			[65399, 65399],
			"mapped",
			[12461]
		],
		[
			[65400, 65400],
			"mapped",
			[12463]
		],
		[
			[65401, 65401],
			"mapped",
			[12465]
		],
		[
			[65402, 65402],
			"mapped",
			[12467]
		],
		[
			[65403, 65403],
			"mapped",
			[12469]
		],
		[
			[65404, 65404],
			"mapped",
			[12471]
		],
		[
			[65405, 65405],
			"mapped",
			[12473]
		],
		[
			[65406, 65406],
			"mapped",
			[12475]
		],
		[
			[65407, 65407],
			"mapped",
			[12477]
		],
		[
			[65408, 65408],
			"mapped",
			[12479]
		],
		[
			[65409, 65409],
			"mapped",
			[12481]
		],
		[
			[65410, 65410],
			"mapped",
			[12484]
		],
		[
			[65411, 65411],
			"mapped",
			[12486]
		],
		[
			[65412, 65412],
			"mapped",
			[12488]
		],
		[
			[65413, 65413],
			"mapped",
			[12490]
		],
		[
			[65414, 65414],
			"mapped",
			[12491]
		],
		[
			[65415, 65415],
			"mapped",
			[12492]
		],
		[
			[65416, 65416],
			"mapped",
			[12493]
		],
		[
			[65417, 65417],
			"mapped",
			[12494]
		],
		[
			[65418, 65418],
			"mapped",
			[12495]
		],
		[
			[65419, 65419],
			"mapped",
			[12498]
		],
		[
			[65420, 65420],
			"mapped",
			[12501]
		],
		[
			[65421, 65421],
			"mapped",
			[12504]
		],
		[
			[65422, 65422],
			"mapped",
			[12507]
		],
		[
			[65423, 65423],
			"mapped",
			[12510]
		],
		[
			[65424, 65424],
			"mapped",
			[12511]
		],
		[
			[65425, 65425],
			"mapped",
			[12512]
		],
		[
			[65426, 65426],
			"mapped",
			[12513]
		],
		[
			[65427, 65427],
			"mapped",
			[12514]
		],
		[
			[65428, 65428],
			"mapped",
			[12516]
		],
		[
			[65429, 65429],
			"mapped",
			[12518]
		],
		[
			[65430, 65430],
			"mapped",
			[12520]
		],
		[
			[65431, 65431],
			"mapped",
			[12521]
		],
		[
			[65432, 65432],
			"mapped",
			[12522]
		],
		[
			[65433, 65433],
			"mapped",
			[12523]
		],
		[
			[65434, 65434],
			"mapped",
			[12524]
		],
		[
			[65435, 65435],
			"mapped",
			[12525]
		],
		[
			[65436, 65436],
			"mapped",
			[12527]
		],
		[
			[65437, 65437],
			"mapped",
			[12531]
		],
		[
			[65438, 65438],
			"mapped",
			[12441]
		],
		[
			[65439, 65439],
			"mapped",
			[12442]
		],
		[[65440, 65440], "disallowed"],
		[
			[65441, 65441],
			"mapped",
			[4352]
		],
		[
			[65442, 65442],
			"mapped",
			[4353]
		],
		[
			[65443, 65443],
			"mapped",
			[4522]
		],
		[
			[65444, 65444],
			"mapped",
			[4354]
		],
		[
			[65445, 65445],
			"mapped",
			[4524]
		],
		[
			[65446, 65446],
			"mapped",
			[4525]
		],
		[
			[65447, 65447],
			"mapped",
			[4355]
		],
		[
			[65448, 65448],
			"mapped",
			[4356]
		],
		[
			[65449, 65449],
			"mapped",
			[4357]
		],
		[
			[65450, 65450],
			"mapped",
			[4528]
		],
		[
			[65451, 65451],
			"mapped",
			[4529]
		],
		[
			[65452, 65452],
			"mapped",
			[4530]
		],
		[
			[65453, 65453],
			"mapped",
			[4531]
		],
		[
			[65454, 65454],
			"mapped",
			[4532]
		],
		[
			[65455, 65455],
			"mapped",
			[4533]
		],
		[
			[65456, 65456],
			"mapped",
			[4378]
		],
		[
			[65457, 65457],
			"mapped",
			[4358]
		],
		[
			[65458, 65458],
			"mapped",
			[4359]
		],
		[
			[65459, 65459],
			"mapped",
			[4360]
		],
		[
			[65460, 65460],
			"mapped",
			[4385]
		],
		[
			[65461, 65461],
			"mapped",
			[4361]
		],
		[
			[65462, 65462],
			"mapped",
			[4362]
		],
		[
			[65463, 65463],
			"mapped",
			[4363]
		],
		[
			[65464, 65464],
			"mapped",
			[4364]
		],
		[
			[65465, 65465],
			"mapped",
			[4365]
		],
		[
			[65466, 65466],
			"mapped",
			[4366]
		],
		[
			[65467, 65467],
			"mapped",
			[4367]
		],
		[
			[65468, 65468],
			"mapped",
			[4368]
		],
		[
			[65469, 65469],
			"mapped",
			[4369]
		],
		[
			[65470, 65470],
			"mapped",
			[4370]
		],
		[[65471, 65473], "disallowed"],
		[
			[65474, 65474],
			"mapped",
			[4449]
		],
		[
			[65475, 65475],
			"mapped",
			[4450]
		],
		[
			[65476, 65476],
			"mapped",
			[4451]
		],
		[
			[65477, 65477],
			"mapped",
			[4452]
		],
		[
			[65478, 65478],
			"mapped",
			[4453]
		],
		[
			[65479, 65479],
			"mapped",
			[4454]
		],
		[[65480, 65481], "disallowed"],
		[
			[65482, 65482],
			"mapped",
			[4455]
		],
		[
			[65483, 65483],
			"mapped",
			[4456]
		],
		[
			[65484, 65484],
			"mapped",
			[4457]
		],
		[
			[65485, 65485],
			"mapped",
			[4458]
		],
		[
			[65486, 65486],
			"mapped",
			[4459]
		],
		[
			[65487, 65487],
			"mapped",
			[4460]
		],
		[[65488, 65489], "disallowed"],
		[
			[65490, 65490],
			"mapped",
			[4461]
		],
		[
			[65491, 65491],
			"mapped",
			[4462]
		],
		[
			[65492, 65492],
			"mapped",
			[4463]
		],
		[
			[65493, 65493],
			"mapped",
			[4464]
		],
		[
			[65494, 65494],
			"mapped",
			[4465]
		],
		[
			[65495, 65495],
			"mapped",
			[4466]
		],
		[[65496, 65497], "disallowed"],
		[
			[65498, 65498],
			"mapped",
			[4467]
		],
		[
			[65499, 65499],
			"mapped",
			[4468]
		],
		[
			[65500, 65500],
			"mapped",
			[4469]
		],
		[[65501, 65503], "disallowed"],
		[
			[65504, 65504],
			"mapped",
			[162]
		],
		[
			[65505, 65505],
			"mapped",
			[163]
		],
		[
			[65506, 65506],
			"mapped",
			[172]
		],
		[
			[65507, 65507],
			"disallowed_STD3_mapped",
			[32, 772]
		],
		[
			[65508, 65508],
			"mapped",
			[166]
		],
		[
			[65509, 65509],
			"mapped",
			[165]
		],
		[
			[65510, 65510],
			"mapped",
			[8361]
		],
		[[65511, 65511], "disallowed"],
		[
			[65512, 65512],
			"mapped",
			[9474]
		],
		[
			[65513, 65513],
			"mapped",
			[8592]
		],
		[
			[65514, 65514],
			"mapped",
			[8593]
		],
		[
			[65515, 65515],
			"mapped",
			[8594]
		],
		[
			[65516, 65516],
			"mapped",
			[8595]
		],
		[
			[65517, 65517],
			"mapped",
			[9632]
		],
		[
			[65518, 65518],
			"mapped",
			[9675]
		],
		[[65519, 65528], "disallowed"],
		[[65529, 65531], "disallowed"],
		[[65532, 65532], "disallowed"],
		[[65533, 65533], "disallowed"],
		[[65534, 65535], "disallowed"],
		[[65536, 65547], "valid"],
		[[65548, 65548], "disallowed"],
		[[65549, 65574], "valid"],
		[[65575, 65575], "disallowed"],
		[[65576, 65594], "valid"],
		[[65595, 65595], "disallowed"],
		[[65596, 65597], "valid"],
		[[65598, 65598], "disallowed"],
		[[65599, 65613], "valid"],
		[[65614, 65615], "disallowed"],
		[[65616, 65629], "valid"],
		[[65630, 65663], "disallowed"],
		[[65664, 65786], "valid"],
		[[65787, 65791], "disallowed"],
		[
			[65792, 65794],
			"valid",
			[],
			"NV8"
		],
		[[65795, 65798], "disallowed"],
		[
			[65799, 65843],
			"valid",
			[],
			"NV8"
		],
		[[65844, 65846], "disallowed"],
		[
			[65847, 65855],
			"valid",
			[],
			"NV8"
		],
		[
			[65856, 65930],
			"valid",
			[],
			"NV8"
		],
		[
			[65931, 65932],
			"valid",
			[],
			"NV8"
		],
		[[65933, 65935], "disallowed"],
		[
			[65936, 65947],
			"valid",
			[],
			"NV8"
		],
		[[65948, 65951], "disallowed"],
		[
			[65952, 65952],
			"valid",
			[],
			"NV8"
		],
		[[65953, 65999], "disallowed"],
		[
			[66e3, 66044],
			"valid",
			[],
			"NV8"
		],
		[[66045, 66045], "valid"],
		[[66046, 66175], "disallowed"],
		[[66176, 66204], "valid"],
		[[66205, 66207], "disallowed"],
		[[66208, 66256], "valid"],
		[[66257, 66271], "disallowed"],
		[[66272, 66272], "valid"],
		[
			[66273, 66299],
			"valid",
			[],
			"NV8"
		],
		[[66300, 66303], "disallowed"],
		[[66304, 66334], "valid"],
		[[66335, 66335], "valid"],
		[
			[66336, 66339],
			"valid",
			[],
			"NV8"
		],
		[[66340, 66351], "disallowed"],
		[[66352, 66368], "valid"],
		[
			[66369, 66369],
			"valid",
			[],
			"NV8"
		],
		[[66370, 66377], "valid"],
		[
			[66378, 66378],
			"valid",
			[],
			"NV8"
		],
		[[66379, 66383], "disallowed"],
		[[66384, 66426], "valid"],
		[[66427, 66431], "disallowed"],
		[[66432, 66461], "valid"],
		[[66462, 66462], "disallowed"],
		[
			[66463, 66463],
			"valid",
			[],
			"NV8"
		],
		[[66464, 66499], "valid"],
		[[66500, 66503], "disallowed"],
		[[66504, 66511], "valid"],
		[
			[66512, 66517],
			"valid",
			[],
			"NV8"
		],
		[[66518, 66559], "disallowed"],
		[
			[66560, 66560],
			"mapped",
			[66600]
		],
		[
			[66561, 66561],
			"mapped",
			[66601]
		],
		[
			[66562, 66562],
			"mapped",
			[66602]
		],
		[
			[66563, 66563],
			"mapped",
			[66603]
		],
		[
			[66564, 66564],
			"mapped",
			[66604]
		],
		[
			[66565, 66565],
			"mapped",
			[66605]
		],
		[
			[66566, 66566],
			"mapped",
			[66606]
		],
		[
			[66567, 66567],
			"mapped",
			[66607]
		],
		[
			[66568, 66568],
			"mapped",
			[66608]
		],
		[
			[66569, 66569],
			"mapped",
			[66609]
		],
		[
			[66570, 66570],
			"mapped",
			[66610]
		],
		[
			[66571, 66571],
			"mapped",
			[66611]
		],
		[
			[66572, 66572],
			"mapped",
			[66612]
		],
		[
			[66573, 66573],
			"mapped",
			[66613]
		],
		[
			[66574, 66574],
			"mapped",
			[66614]
		],
		[
			[66575, 66575],
			"mapped",
			[66615]
		],
		[
			[66576, 66576],
			"mapped",
			[66616]
		],
		[
			[66577, 66577],
			"mapped",
			[66617]
		],
		[
			[66578, 66578],
			"mapped",
			[66618]
		],
		[
			[66579, 66579],
			"mapped",
			[66619]
		],
		[
			[66580, 66580],
			"mapped",
			[66620]
		],
		[
			[66581, 66581],
			"mapped",
			[66621]
		],
		[
			[66582, 66582],
			"mapped",
			[66622]
		],
		[
			[66583, 66583],
			"mapped",
			[66623]
		],
		[
			[66584, 66584],
			"mapped",
			[66624]
		],
		[
			[66585, 66585],
			"mapped",
			[66625]
		],
		[
			[66586, 66586],
			"mapped",
			[66626]
		],
		[
			[66587, 66587],
			"mapped",
			[66627]
		],
		[
			[66588, 66588],
			"mapped",
			[66628]
		],
		[
			[66589, 66589],
			"mapped",
			[66629]
		],
		[
			[66590, 66590],
			"mapped",
			[66630]
		],
		[
			[66591, 66591],
			"mapped",
			[66631]
		],
		[
			[66592, 66592],
			"mapped",
			[66632]
		],
		[
			[66593, 66593],
			"mapped",
			[66633]
		],
		[
			[66594, 66594],
			"mapped",
			[66634]
		],
		[
			[66595, 66595],
			"mapped",
			[66635]
		],
		[
			[66596, 66596],
			"mapped",
			[66636]
		],
		[
			[66597, 66597],
			"mapped",
			[66637]
		],
		[
			[66598, 66598],
			"mapped",
			[66638]
		],
		[
			[66599, 66599],
			"mapped",
			[66639]
		],
		[[66600, 66637], "valid"],
		[[66638, 66717], "valid"],
		[[66718, 66719], "disallowed"],
		[[66720, 66729], "valid"],
		[[66730, 66815], "disallowed"],
		[[66816, 66855], "valid"],
		[[66856, 66863], "disallowed"],
		[[66864, 66915], "valid"],
		[[66916, 66926], "disallowed"],
		[
			[66927, 66927],
			"valid",
			[],
			"NV8"
		],
		[[66928, 67071], "disallowed"],
		[[67072, 67382], "valid"],
		[[67383, 67391], "disallowed"],
		[[67392, 67413], "valid"],
		[[67414, 67423], "disallowed"],
		[[67424, 67431], "valid"],
		[[67432, 67583], "disallowed"],
		[[67584, 67589], "valid"],
		[[67590, 67591], "disallowed"],
		[[67592, 67592], "valid"],
		[[67593, 67593], "disallowed"],
		[[67594, 67637], "valid"],
		[[67638, 67638], "disallowed"],
		[[67639, 67640], "valid"],
		[[67641, 67643], "disallowed"],
		[[67644, 67644], "valid"],
		[[67645, 67646], "disallowed"],
		[[67647, 67647], "valid"],
		[[67648, 67669], "valid"],
		[[67670, 67670], "disallowed"],
		[
			[67671, 67679],
			"valid",
			[],
			"NV8"
		],
		[[67680, 67702], "valid"],
		[
			[67703, 67711],
			"valid",
			[],
			"NV8"
		],
		[[67712, 67742], "valid"],
		[[67743, 67750], "disallowed"],
		[
			[67751, 67759],
			"valid",
			[],
			"NV8"
		],
		[[67760, 67807], "disallowed"],
		[[67808, 67826], "valid"],
		[[67827, 67827], "disallowed"],
		[[67828, 67829], "valid"],
		[[67830, 67834], "disallowed"],
		[
			[67835, 67839],
			"valid",
			[],
			"NV8"
		],
		[[67840, 67861], "valid"],
		[
			[67862, 67865],
			"valid",
			[],
			"NV8"
		],
		[
			[67866, 67867],
			"valid",
			[],
			"NV8"
		],
		[[67868, 67870], "disallowed"],
		[
			[67871, 67871],
			"valid",
			[],
			"NV8"
		],
		[[67872, 67897], "valid"],
		[[67898, 67902], "disallowed"],
		[
			[67903, 67903],
			"valid",
			[],
			"NV8"
		],
		[[67904, 67967], "disallowed"],
		[[67968, 68023], "valid"],
		[[68024, 68027], "disallowed"],
		[
			[68028, 68029],
			"valid",
			[],
			"NV8"
		],
		[[68030, 68031], "valid"],
		[
			[68032, 68047],
			"valid",
			[],
			"NV8"
		],
		[[68048, 68049], "disallowed"],
		[
			[68050, 68095],
			"valid",
			[],
			"NV8"
		],
		[[68096, 68099], "valid"],
		[[68100, 68100], "disallowed"],
		[[68101, 68102], "valid"],
		[[68103, 68107], "disallowed"],
		[[68108, 68115], "valid"],
		[[68116, 68116], "disallowed"],
		[[68117, 68119], "valid"],
		[[68120, 68120], "disallowed"],
		[[68121, 68147], "valid"],
		[[68148, 68151], "disallowed"],
		[[68152, 68154], "valid"],
		[[68155, 68158], "disallowed"],
		[[68159, 68159], "valid"],
		[
			[68160, 68167],
			"valid",
			[],
			"NV8"
		],
		[[68168, 68175], "disallowed"],
		[
			[68176, 68184],
			"valid",
			[],
			"NV8"
		],
		[[68185, 68191], "disallowed"],
		[[68192, 68220], "valid"],
		[
			[68221, 68223],
			"valid",
			[],
			"NV8"
		],
		[[68224, 68252], "valid"],
		[
			[68253, 68255],
			"valid",
			[],
			"NV8"
		],
		[[68256, 68287], "disallowed"],
		[[68288, 68295], "valid"],
		[
			[68296, 68296],
			"valid",
			[],
			"NV8"
		],
		[[68297, 68326], "valid"],
		[[68327, 68330], "disallowed"],
		[
			[68331, 68342],
			"valid",
			[],
			"NV8"
		],
		[[68343, 68351], "disallowed"],
		[[68352, 68405], "valid"],
		[[68406, 68408], "disallowed"],
		[
			[68409, 68415],
			"valid",
			[],
			"NV8"
		],
		[[68416, 68437], "valid"],
		[[68438, 68439], "disallowed"],
		[
			[68440, 68447],
			"valid",
			[],
			"NV8"
		],
		[[68448, 68466], "valid"],
		[[68467, 68471], "disallowed"],
		[
			[68472, 68479],
			"valid",
			[],
			"NV8"
		],
		[[68480, 68497], "valid"],
		[[68498, 68504], "disallowed"],
		[
			[68505, 68508],
			"valid",
			[],
			"NV8"
		],
		[[68509, 68520], "disallowed"],
		[
			[68521, 68527],
			"valid",
			[],
			"NV8"
		],
		[[68528, 68607], "disallowed"],
		[[68608, 68680], "valid"],
		[[68681, 68735], "disallowed"],
		[
			[68736, 68736],
			"mapped",
			[68800]
		],
		[
			[68737, 68737],
			"mapped",
			[68801]
		],
		[
			[68738, 68738],
			"mapped",
			[68802]
		],
		[
			[68739, 68739],
			"mapped",
			[68803]
		],
		[
			[68740, 68740],
			"mapped",
			[68804]
		],
		[
			[68741, 68741],
			"mapped",
			[68805]
		],
		[
			[68742, 68742],
			"mapped",
			[68806]
		],
		[
			[68743, 68743],
			"mapped",
			[68807]
		],
		[
			[68744, 68744],
			"mapped",
			[68808]
		],
		[
			[68745, 68745],
			"mapped",
			[68809]
		],
		[
			[68746, 68746],
			"mapped",
			[68810]
		],
		[
			[68747, 68747],
			"mapped",
			[68811]
		],
		[
			[68748, 68748],
			"mapped",
			[68812]
		],
		[
			[68749, 68749],
			"mapped",
			[68813]
		],
		[
			[68750, 68750],
			"mapped",
			[68814]
		],
		[
			[68751, 68751],
			"mapped",
			[68815]
		],
		[
			[68752, 68752],
			"mapped",
			[68816]
		],
		[
			[68753, 68753],
			"mapped",
			[68817]
		],
		[
			[68754, 68754],
			"mapped",
			[68818]
		],
		[
			[68755, 68755],
			"mapped",
			[68819]
		],
		[
			[68756, 68756],
			"mapped",
			[68820]
		],
		[
			[68757, 68757],
			"mapped",
			[68821]
		],
		[
			[68758, 68758],
			"mapped",
			[68822]
		],
		[
			[68759, 68759],
			"mapped",
			[68823]
		],
		[
			[68760, 68760],
			"mapped",
			[68824]
		],
		[
			[68761, 68761],
			"mapped",
			[68825]
		],
		[
			[68762, 68762],
			"mapped",
			[68826]
		],
		[
			[68763, 68763],
			"mapped",
			[68827]
		],
		[
			[68764, 68764],
			"mapped",
			[68828]
		],
		[
			[68765, 68765],
			"mapped",
			[68829]
		],
		[
			[68766, 68766],
			"mapped",
			[68830]
		],
		[
			[68767, 68767],
			"mapped",
			[68831]
		],
		[
			[68768, 68768],
			"mapped",
			[68832]
		],
		[
			[68769, 68769],
			"mapped",
			[68833]
		],
		[
			[68770, 68770],
			"mapped",
			[68834]
		],
		[
			[68771, 68771],
			"mapped",
			[68835]
		],
		[
			[68772, 68772],
			"mapped",
			[68836]
		],
		[
			[68773, 68773],
			"mapped",
			[68837]
		],
		[
			[68774, 68774],
			"mapped",
			[68838]
		],
		[
			[68775, 68775],
			"mapped",
			[68839]
		],
		[
			[68776, 68776],
			"mapped",
			[68840]
		],
		[
			[68777, 68777],
			"mapped",
			[68841]
		],
		[
			[68778, 68778],
			"mapped",
			[68842]
		],
		[
			[68779, 68779],
			"mapped",
			[68843]
		],
		[
			[68780, 68780],
			"mapped",
			[68844]
		],
		[
			[68781, 68781],
			"mapped",
			[68845]
		],
		[
			[68782, 68782],
			"mapped",
			[68846]
		],
		[
			[68783, 68783],
			"mapped",
			[68847]
		],
		[
			[68784, 68784],
			"mapped",
			[68848]
		],
		[
			[68785, 68785],
			"mapped",
			[68849]
		],
		[
			[68786, 68786],
			"mapped",
			[68850]
		],
		[[68787, 68799], "disallowed"],
		[[68800, 68850], "valid"],
		[[68851, 68857], "disallowed"],
		[
			[68858, 68863],
			"valid",
			[],
			"NV8"
		],
		[[68864, 69215], "disallowed"],
		[
			[69216, 69246],
			"valid",
			[],
			"NV8"
		],
		[[69247, 69631], "disallowed"],
		[[69632, 69702], "valid"],
		[
			[69703, 69709],
			"valid",
			[],
			"NV8"
		],
		[[69710, 69713], "disallowed"],
		[
			[69714, 69733],
			"valid",
			[],
			"NV8"
		],
		[[69734, 69743], "valid"],
		[[69744, 69758], "disallowed"],
		[[69759, 69759], "valid"],
		[[69760, 69818], "valid"],
		[
			[69819, 69820],
			"valid",
			[],
			"NV8"
		],
		[[69821, 69821], "disallowed"],
		[
			[69822, 69825],
			"valid",
			[],
			"NV8"
		],
		[[69826, 69839], "disallowed"],
		[[69840, 69864], "valid"],
		[[69865, 69871], "disallowed"],
		[[69872, 69881], "valid"],
		[[69882, 69887], "disallowed"],
		[[69888, 69940], "valid"],
		[[69941, 69941], "disallowed"],
		[[69942, 69951], "valid"],
		[
			[69952, 69955],
			"valid",
			[],
			"NV8"
		],
		[[69956, 69967], "disallowed"],
		[[69968, 70003], "valid"],
		[
			[70004, 70005],
			"valid",
			[],
			"NV8"
		],
		[[70006, 70006], "valid"],
		[[70007, 70015], "disallowed"],
		[[70016, 70084], "valid"],
		[
			[70085, 70088],
			"valid",
			[],
			"NV8"
		],
		[
			[70089, 70089],
			"valid",
			[],
			"NV8"
		],
		[[70090, 70092], "valid"],
		[
			[70093, 70093],
			"valid",
			[],
			"NV8"
		],
		[[70094, 70095], "disallowed"],
		[[70096, 70105], "valid"],
		[[70106, 70106], "valid"],
		[
			[70107, 70107],
			"valid",
			[],
			"NV8"
		],
		[[70108, 70108], "valid"],
		[
			[70109, 70111],
			"valid",
			[],
			"NV8"
		],
		[[70112, 70112], "disallowed"],
		[
			[70113, 70132],
			"valid",
			[],
			"NV8"
		],
		[[70133, 70143], "disallowed"],
		[[70144, 70161], "valid"],
		[[70162, 70162], "disallowed"],
		[[70163, 70199], "valid"],
		[
			[70200, 70205],
			"valid",
			[],
			"NV8"
		],
		[[70206, 70271], "disallowed"],
		[[70272, 70278], "valid"],
		[[70279, 70279], "disallowed"],
		[[70280, 70280], "valid"],
		[[70281, 70281], "disallowed"],
		[[70282, 70285], "valid"],
		[[70286, 70286], "disallowed"],
		[[70287, 70301], "valid"],
		[[70302, 70302], "disallowed"],
		[[70303, 70312], "valid"],
		[
			[70313, 70313],
			"valid",
			[],
			"NV8"
		],
		[[70314, 70319], "disallowed"],
		[[70320, 70378], "valid"],
		[[70379, 70383], "disallowed"],
		[[70384, 70393], "valid"],
		[[70394, 70399], "disallowed"],
		[[70400, 70400], "valid"],
		[[70401, 70403], "valid"],
		[[70404, 70404], "disallowed"],
		[[70405, 70412], "valid"],
		[[70413, 70414], "disallowed"],
		[[70415, 70416], "valid"],
		[[70417, 70418], "disallowed"],
		[[70419, 70440], "valid"],
		[[70441, 70441], "disallowed"],
		[[70442, 70448], "valid"],
		[[70449, 70449], "disallowed"],
		[[70450, 70451], "valid"],
		[[70452, 70452], "disallowed"],
		[[70453, 70457], "valid"],
		[[70458, 70459], "disallowed"],
		[[70460, 70468], "valid"],
		[[70469, 70470], "disallowed"],
		[[70471, 70472], "valid"],
		[[70473, 70474], "disallowed"],
		[[70475, 70477], "valid"],
		[[70478, 70479], "disallowed"],
		[[70480, 70480], "valid"],
		[[70481, 70486], "disallowed"],
		[[70487, 70487], "valid"],
		[[70488, 70492], "disallowed"],
		[[70493, 70499], "valid"],
		[[70500, 70501], "disallowed"],
		[[70502, 70508], "valid"],
		[[70509, 70511], "disallowed"],
		[[70512, 70516], "valid"],
		[[70517, 70783], "disallowed"],
		[[70784, 70853], "valid"],
		[
			[70854, 70854],
			"valid",
			[],
			"NV8"
		],
		[[70855, 70855], "valid"],
		[[70856, 70863], "disallowed"],
		[[70864, 70873], "valid"],
		[[70874, 71039], "disallowed"],
		[[71040, 71093], "valid"],
		[[71094, 71095], "disallowed"],
		[[71096, 71104], "valid"],
		[
			[71105, 71113],
			"valid",
			[],
			"NV8"
		],
		[
			[71114, 71127],
			"valid",
			[],
			"NV8"
		],
		[[71128, 71133], "valid"],
		[[71134, 71167], "disallowed"],
		[[71168, 71232], "valid"],
		[
			[71233, 71235],
			"valid",
			[],
			"NV8"
		],
		[[71236, 71236], "valid"],
		[[71237, 71247], "disallowed"],
		[[71248, 71257], "valid"],
		[[71258, 71295], "disallowed"],
		[[71296, 71351], "valid"],
		[[71352, 71359], "disallowed"],
		[[71360, 71369], "valid"],
		[[71370, 71423], "disallowed"],
		[[71424, 71449], "valid"],
		[[71450, 71452], "disallowed"],
		[[71453, 71467], "valid"],
		[[71468, 71471], "disallowed"],
		[[71472, 71481], "valid"],
		[
			[71482, 71487],
			"valid",
			[],
			"NV8"
		],
		[[71488, 71839], "disallowed"],
		[
			[71840, 71840],
			"mapped",
			[71872]
		],
		[
			[71841, 71841],
			"mapped",
			[71873]
		],
		[
			[71842, 71842],
			"mapped",
			[71874]
		],
		[
			[71843, 71843],
			"mapped",
			[71875]
		],
		[
			[71844, 71844],
			"mapped",
			[71876]
		],
		[
			[71845, 71845],
			"mapped",
			[71877]
		],
		[
			[71846, 71846],
			"mapped",
			[71878]
		],
		[
			[71847, 71847],
			"mapped",
			[71879]
		],
		[
			[71848, 71848],
			"mapped",
			[71880]
		],
		[
			[71849, 71849],
			"mapped",
			[71881]
		],
		[
			[71850, 71850],
			"mapped",
			[71882]
		],
		[
			[71851, 71851],
			"mapped",
			[71883]
		],
		[
			[71852, 71852],
			"mapped",
			[71884]
		],
		[
			[71853, 71853],
			"mapped",
			[71885]
		],
		[
			[71854, 71854],
			"mapped",
			[71886]
		],
		[
			[71855, 71855],
			"mapped",
			[71887]
		],
		[
			[71856, 71856],
			"mapped",
			[71888]
		],
		[
			[71857, 71857],
			"mapped",
			[71889]
		],
		[
			[71858, 71858],
			"mapped",
			[71890]
		],
		[
			[71859, 71859],
			"mapped",
			[71891]
		],
		[
			[71860, 71860],
			"mapped",
			[71892]
		],
		[
			[71861, 71861],
			"mapped",
			[71893]
		],
		[
			[71862, 71862],
			"mapped",
			[71894]
		],
		[
			[71863, 71863],
			"mapped",
			[71895]
		],
		[
			[71864, 71864],
			"mapped",
			[71896]
		],
		[
			[71865, 71865],
			"mapped",
			[71897]
		],
		[
			[71866, 71866],
			"mapped",
			[71898]
		],
		[
			[71867, 71867],
			"mapped",
			[71899]
		],
		[
			[71868, 71868],
			"mapped",
			[71900]
		],
		[
			[71869, 71869],
			"mapped",
			[71901]
		],
		[
			[71870, 71870],
			"mapped",
			[71902]
		],
		[
			[71871, 71871],
			"mapped",
			[71903]
		],
		[[71872, 71913], "valid"],
		[
			[71914, 71922],
			"valid",
			[],
			"NV8"
		],
		[[71923, 71934], "disallowed"],
		[[71935, 71935], "valid"],
		[[71936, 72383], "disallowed"],
		[[72384, 72440], "valid"],
		[[72441, 73727], "disallowed"],
		[[73728, 74606], "valid"],
		[[74607, 74648], "valid"],
		[[74649, 74649], "valid"],
		[[74650, 74751], "disallowed"],
		[
			[74752, 74850],
			"valid",
			[],
			"NV8"
		],
		[
			[74851, 74862],
			"valid",
			[],
			"NV8"
		],
		[[74863, 74863], "disallowed"],
		[
			[74864, 74867],
			"valid",
			[],
			"NV8"
		],
		[
			[74868, 74868],
			"valid",
			[],
			"NV8"
		],
		[[74869, 74879], "disallowed"],
		[[74880, 75075], "valid"],
		[[75076, 77823], "disallowed"],
		[[77824, 78894], "valid"],
		[[78895, 82943], "disallowed"],
		[[82944, 83526], "valid"],
		[[83527, 92159], "disallowed"],
		[[92160, 92728], "valid"],
		[[92729, 92735], "disallowed"],
		[[92736, 92766], "valid"],
		[[92767, 92767], "disallowed"],
		[[92768, 92777], "valid"],
		[[92778, 92781], "disallowed"],
		[
			[92782, 92783],
			"valid",
			[],
			"NV8"
		],
		[[92784, 92879], "disallowed"],
		[[92880, 92909], "valid"],
		[[92910, 92911], "disallowed"],
		[[92912, 92916], "valid"],
		[
			[92917, 92917],
			"valid",
			[],
			"NV8"
		],
		[[92918, 92927], "disallowed"],
		[[92928, 92982], "valid"],
		[
			[92983, 92991],
			"valid",
			[],
			"NV8"
		],
		[[92992, 92995], "valid"],
		[
			[92996, 92997],
			"valid",
			[],
			"NV8"
		],
		[[92998, 93007], "disallowed"],
		[[93008, 93017], "valid"],
		[[93018, 93018], "disallowed"],
		[
			[93019, 93025],
			"valid",
			[],
			"NV8"
		],
		[[93026, 93026], "disallowed"],
		[[93027, 93047], "valid"],
		[[93048, 93052], "disallowed"],
		[[93053, 93071], "valid"],
		[[93072, 93951], "disallowed"],
		[[93952, 94020], "valid"],
		[[94021, 94031], "disallowed"],
		[[94032, 94078], "valid"],
		[[94079, 94094], "disallowed"],
		[[94095, 94111], "valid"],
		[[94112, 110591], "disallowed"],
		[[110592, 110593], "valid"],
		[[110594, 113663], "disallowed"],
		[[113664, 113770], "valid"],
		[[113771, 113775], "disallowed"],
		[[113776, 113788], "valid"],
		[[113789, 113791], "disallowed"],
		[[113792, 113800], "valid"],
		[[113801, 113807], "disallowed"],
		[[113808, 113817], "valid"],
		[[113818, 113819], "disallowed"],
		[
			[113820, 113820],
			"valid",
			[],
			"NV8"
		],
		[[113821, 113822], "valid"],
		[
			[113823, 113823],
			"valid",
			[],
			"NV8"
		],
		[[113824, 113827], "ignored"],
		[[113828, 118783], "disallowed"],
		[
			[118784, 119029],
			"valid",
			[],
			"NV8"
		],
		[[119030, 119039], "disallowed"],
		[
			[119040, 119078],
			"valid",
			[],
			"NV8"
		],
		[[119079, 119080], "disallowed"],
		[
			[119081, 119081],
			"valid",
			[],
			"NV8"
		],
		[
			[119082, 119133],
			"valid",
			[],
			"NV8"
		],
		[
			[119134, 119134],
			"mapped",
			[119127, 119141]
		],
		[
			[119135, 119135],
			"mapped",
			[119128, 119141]
		],
		[
			[119136, 119136],
			"mapped",
			[
				119128,
				119141,
				119150
			]
		],
		[
			[119137, 119137],
			"mapped",
			[
				119128,
				119141,
				119151
			]
		],
		[
			[119138, 119138],
			"mapped",
			[
				119128,
				119141,
				119152
			]
		],
		[
			[119139, 119139],
			"mapped",
			[
				119128,
				119141,
				119153
			]
		],
		[
			[119140, 119140],
			"mapped",
			[
				119128,
				119141,
				119154
			]
		],
		[
			[119141, 119154],
			"valid",
			[],
			"NV8"
		],
		[[119155, 119162], "disallowed"],
		[
			[119163, 119226],
			"valid",
			[],
			"NV8"
		],
		[
			[119227, 119227],
			"mapped",
			[119225, 119141]
		],
		[
			[119228, 119228],
			"mapped",
			[119226, 119141]
		],
		[
			[119229, 119229],
			"mapped",
			[
				119225,
				119141,
				119150
			]
		],
		[
			[119230, 119230],
			"mapped",
			[
				119226,
				119141,
				119150
			]
		],
		[
			[119231, 119231],
			"mapped",
			[
				119225,
				119141,
				119151
			]
		],
		[
			[119232, 119232],
			"mapped",
			[
				119226,
				119141,
				119151
			]
		],
		[
			[119233, 119261],
			"valid",
			[],
			"NV8"
		],
		[
			[119262, 119272],
			"valid",
			[],
			"NV8"
		],
		[[119273, 119295], "disallowed"],
		[
			[119296, 119365],
			"valid",
			[],
			"NV8"
		],
		[[119366, 119551], "disallowed"],
		[
			[119552, 119638],
			"valid",
			[],
			"NV8"
		],
		[[119639, 119647], "disallowed"],
		[
			[119648, 119665],
			"valid",
			[],
			"NV8"
		],
		[[119666, 119807], "disallowed"],
		[
			[119808, 119808],
			"mapped",
			[97]
		],
		[
			[119809, 119809],
			"mapped",
			[98]
		],
		[
			[119810, 119810],
			"mapped",
			[99]
		],
		[
			[119811, 119811],
			"mapped",
			[100]
		],
		[
			[119812, 119812],
			"mapped",
			[101]
		],
		[
			[119813, 119813],
			"mapped",
			[102]
		],
		[
			[119814, 119814],
			"mapped",
			[103]
		],
		[
			[119815, 119815],
			"mapped",
			[104]
		],
		[
			[119816, 119816],
			"mapped",
			[105]
		],
		[
			[119817, 119817],
			"mapped",
			[106]
		],
		[
			[119818, 119818],
			"mapped",
			[107]
		],
		[
			[119819, 119819],
			"mapped",
			[108]
		],
		[
			[119820, 119820],
			"mapped",
			[109]
		],
		[
			[119821, 119821],
			"mapped",
			[110]
		],
		[
			[119822, 119822],
			"mapped",
			[111]
		],
		[
			[119823, 119823],
			"mapped",
			[112]
		],
		[
			[119824, 119824],
			"mapped",
			[113]
		],
		[
			[119825, 119825],
			"mapped",
			[114]
		],
		[
			[119826, 119826],
			"mapped",
			[115]
		],
		[
			[119827, 119827],
			"mapped",
			[116]
		],
		[
			[119828, 119828],
			"mapped",
			[117]
		],
		[
			[119829, 119829],
			"mapped",
			[118]
		],
		[
			[119830, 119830],
			"mapped",
			[119]
		],
		[
			[119831, 119831],
			"mapped",
			[120]
		],
		[
			[119832, 119832],
			"mapped",
			[121]
		],
		[
			[119833, 119833],
			"mapped",
			[122]
		],
		[
			[119834, 119834],
			"mapped",
			[97]
		],
		[
			[119835, 119835],
			"mapped",
			[98]
		],
		[
			[119836, 119836],
			"mapped",
			[99]
		],
		[
			[119837, 119837],
			"mapped",
			[100]
		],
		[
			[119838, 119838],
			"mapped",
			[101]
		],
		[
			[119839, 119839],
			"mapped",
			[102]
		],
		[
			[119840, 119840],
			"mapped",
			[103]
		],
		[
			[119841, 119841],
			"mapped",
			[104]
		],
		[
			[119842, 119842],
			"mapped",
			[105]
		],
		[
			[119843, 119843],
			"mapped",
			[106]
		],
		[
			[119844, 119844],
			"mapped",
			[107]
		],
		[
			[119845, 119845],
			"mapped",
			[108]
		],
		[
			[119846, 119846],
			"mapped",
			[109]
		],
		[
			[119847, 119847],
			"mapped",
			[110]
		],
		[
			[119848, 119848],
			"mapped",
			[111]
		],
		[
			[119849, 119849],
			"mapped",
			[112]
		],
		[
			[119850, 119850],
			"mapped",
			[113]
		],
		[
			[119851, 119851],
			"mapped",
			[114]
		],
		[
			[119852, 119852],
			"mapped",
			[115]
		],
		[
			[119853, 119853],
			"mapped",
			[116]
		],
		[
			[119854, 119854],
			"mapped",
			[117]
		],
		[
			[119855, 119855],
			"mapped",
			[118]
		],
		[
			[119856, 119856],
			"mapped",
			[119]
		],
		[
			[119857, 119857],
			"mapped",
			[120]
		],
		[
			[119858, 119858],
			"mapped",
			[121]
		],
		[
			[119859, 119859],
			"mapped",
			[122]
		],
		[
			[119860, 119860],
			"mapped",
			[97]
		],
		[
			[119861, 119861],
			"mapped",
			[98]
		],
		[
			[119862, 119862],
			"mapped",
			[99]
		],
		[
			[119863, 119863],
			"mapped",
			[100]
		],
		[
			[119864, 119864],
			"mapped",
			[101]
		],
		[
			[119865, 119865],
			"mapped",
			[102]
		],
		[
			[119866, 119866],
			"mapped",
			[103]
		],
		[
			[119867, 119867],
			"mapped",
			[104]
		],
		[
			[119868, 119868],
			"mapped",
			[105]
		],
		[
			[119869, 119869],
			"mapped",
			[106]
		],
		[
			[119870, 119870],
			"mapped",
			[107]
		],
		[
			[119871, 119871],
			"mapped",
			[108]
		],
		[
			[119872, 119872],
			"mapped",
			[109]
		],
		[
			[119873, 119873],
			"mapped",
			[110]
		],
		[
			[119874, 119874],
			"mapped",
			[111]
		],
		[
			[119875, 119875],
			"mapped",
			[112]
		],
		[
			[119876, 119876],
			"mapped",
			[113]
		],
		[
			[119877, 119877],
			"mapped",
			[114]
		],
		[
			[119878, 119878],
			"mapped",
			[115]
		],
		[
			[119879, 119879],
			"mapped",
			[116]
		],
		[
			[119880, 119880],
			"mapped",
			[117]
		],
		[
			[119881, 119881],
			"mapped",
			[118]
		],
		[
			[119882, 119882],
			"mapped",
			[119]
		],
		[
			[119883, 119883],
			"mapped",
			[120]
		],
		[
			[119884, 119884],
			"mapped",
			[121]
		],
		[
			[119885, 119885],
			"mapped",
			[122]
		],
		[
			[119886, 119886],
			"mapped",
			[97]
		],
		[
			[119887, 119887],
			"mapped",
			[98]
		],
		[
			[119888, 119888],
			"mapped",
			[99]
		],
		[
			[119889, 119889],
			"mapped",
			[100]
		],
		[
			[119890, 119890],
			"mapped",
			[101]
		],
		[
			[119891, 119891],
			"mapped",
			[102]
		],
		[
			[119892, 119892],
			"mapped",
			[103]
		],
		[[119893, 119893], "disallowed"],
		[
			[119894, 119894],
			"mapped",
			[105]
		],
		[
			[119895, 119895],
			"mapped",
			[106]
		],
		[
			[119896, 119896],
			"mapped",
			[107]
		],
		[
			[119897, 119897],
			"mapped",
			[108]
		],
		[
			[119898, 119898],
			"mapped",
			[109]
		],
		[
			[119899, 119899],
			"mapped",
			[110]
		],
		[
			[119900, 119900],
			"mapped",
			[111]
		],
		[
			[119901, 119901],
			"mapped",
			[112]
		],
		[
			[119902, 119902],
			"mapped",
			[113]
		],
		[
			[119903, 119903],
			"mapped",
			[114]
		],
		[
			[119904, 119904],
			"mapped",
			[115]
		],
		[
			[119905, 119905],
			"mapped",
			[116]
		],
		[
			[119906, 119906],
			"mapped",
			[117]
		],
		[
			[119907, 119907],
			"mapped",
			[118]
		],
		[
			[119908, 119908],
			"mapped",
			[119]
		],
		[
			[119909, 119909],
			"mapped",
			[120]
		],
		[
			[119910, 119910],
			"mapped",
			[121]
		],
		[
			[119911, 119911],
			"mapped",
			[122]
		],
		[
			[119912, 119912],
			"mapped",
			[97]
		],
		[
			[119913, 119913],
			"mapped",
			[98]
		],
		[
			[119914, 119914],
			"mapped",
			[99]
		],
		[
			[119915, 119915],
			"mapped",
			[100]
		],
		[
			[119916, 119916],
			"mapped",
			[101]
		],
		[
			[119917, 119917],
			"mapped",
			[102]
		],
		[
			[119918, 119918],
			"mapped",
			[103]
		],
		[
			[119919, 119919],
			"mapped",
			[104]
		],
		[
			[119920, 119920],
			"mapped",
			[105]
		],
		[
			[119921, 119921],
			"mapped",
			[106]
		],
		[
			[119922, 119922],
			"mapped",
			[107]
		],
		[
			[119923, 119923],
			"mapped",
			[108]
		],
		[
			[119924, 119924],
			"mapped",
			[109]
		],
		[
			[119925, 119925],
			"mapped",
			[110]
		],
		[
			[119926, 119926],
			"mapped",
			[111]
		],
		[
			[119927, 119927],
			"mapped",
			[112]
		],
		[
			[119928, 119928],
			"mapped",
			[113]
		],
		[
			[119929, 119929],
			"mapped",
			[114]
		],
		[
			[119930, 119930],
			"mapped",
			[115]
		],
		[
			[119931, 119931],
			"mapped",
			[116]
		],
		[
			[119932, 119932],
			"mapped",
			[117]
		],
		[
			[119933, 119933],
			"mapped",
			[118]
		],
		[
			[119934, 119934],
			"mapped",
			[119]
		],
		[
			[119935, 119935],
			"mapped",
			[120]
		],
		[
			[119936, 119936],
			"mapped",
			[121]
		],
		[
			[119937, 119937],
			"mapped",
			[122]
		],
		[
			[119938, 119938],
			"mapped",
			[97]
		],
		[
			[119939, 119939],
			"mapped",
			[98]
		],
		[
			[119940, 119940],
			"mapped",
			[99]
		],
		[
			[119941, 119941],
			"mapped",
			[100]
		],
		[
			[119942, 119942],
			"mapped",
			[101]
		],
		[
			[119943, 119943],
			"mapped",
			[102]
		],
		[
			[119944, 119944],
			"mapped",
			[103]
		],
		[
			[119945, 119945],
			"mapped",
			[104]
		],
		[
			[119946, 119946],
			"mapped",
			[105]
		],
		[
			[119947, 119947],
			"mapped",
			[106]
		],
		[
			[119948, 119948],
			"mapped",
			[107]
		],
		[
			[119949, 119949],
			"mapped",
			[108]
		],
		[
			[119950, 119950],
			"mapped",
			[109]
		],
		[
			[119951, 119951],
			"mapped",
			[110]
		],
		[
			[119952, 119952],
			"mapped",
			[111]
		],
		[
			[119953, 119953],
			"mapped",
			[112]
		],
		[
			[119954, 119954],
			"mapped",
			[113]
		],
		[
			[119955, 119955],
			"mapped",
			[114]
		],
		[
			[119956, 119956],
			"mapped",
			[115]
		],
		[
			[119957, 119957],
			"mapped",
			[116]
		],
		[
			[119958, 119958],
			"mapped",
			[117]
		],
		[
			[119959, 119959],
			"mapped",
			[118]
		],
		[
			[119960, 119960],
			"mapped",
			[119]
		],
		[
			[119961, 119961],
			"mapped",
			[120]
		],
		[
			[119962, 119962],
			"mapped",
			[121]
		],
		[
			[119963, 119963],
			"mapped",
			[122]
		],
		[
			[119964, 119964],
			"mapped",
			[97]
		],
		[[119965, 119965], "disallowed"],
		[
			[119966, 119966],
			"mapped",
			[99]
		],
		[
			[119967, 119967],
			"mapped",
			[100]
		],
		[[119968, 119969], "disallowed"],
		[
			[119970, 119970],
			"mapped",
			[103]
		],
		[[119971, 119972], "disallowed"],
		[
			[119973, 119973],
			"mapped",
			[106]
		],
		[
			[119974, 119974],
			"mapped",
			[107]
		],
		[[119975, 119976], "disallowed"],
		[
			[119977, 119977],
			"mapped",
			[110]
		],
		[
			[119978, 119978],
			"mapped",
			[111]
		],
		[
			[119979, 119979],
			"mapped",
			[112]
		],
		[
			[119980, 119980],
			"mapped",
			[113]
		],
		[[119981, 119981], "disallowed"],
		[
			[119982, 119982],
			"mapped",
			[115]
		],
		[
			[119983, 119983],
			"mapped",
			[116]
		],
		[
			[119984, 119984],
			"mapped",
			[117]
		],
		[
			[119985, 119985],
			"mapped",
			[118]
		],
		[
			[119986, 119986],
			"mapped",
			[119]
		],
		[
			[119987, 119987],
			"mapped",
			[120]
		],
		[
			[119988, 119988],
			"mapped",
			[121]
		],
		[
			[119989, 119989],
			"mapped",
			[122]
		],
		[
			[119990, 119990],
			"mapped",
			[97]
		],
		[
			[119991, 119991],
			"mapped",
			[98]
		],
		[
			[119992, 119992],
			"mapped",
			[99]
		],
		[
			[119993, 119993],
			"mapped",
			[100]
		],
		[[119994, 119994], "disallowed"],
		[
			[119995, 119995],
			"mapped",
			[102]
		],
		[[119996, 119996], "disallowed"],
		[
			[119997, 119997],
			"mapped",
			[104]
		],
		[
			[119998, 119998],
			"mapped",
			[105]
		],
		[
			[119999, 119999],
			"mapped",
			[106]
		],
		[
			[12e4, 12e4],
			"mapped",
			[107]
		],
		[
			[120001, 120001],
			"mapped",
			[108]
		],
		[
			[120002, 120002],
			"mapped",
			[109]
		],
		[
			[120003, 120003],
			"mapped",
			[110]
		],
		[[120004, 120004], "disallowed"],
		[
			[120005, 120005],
			"mapped",
			[112]
		],
		[
			[120006, 120006],
			"mapped",
			[113]
		],
		[
			[120007, 120007],
			"mapped",
			[114]
		],
		[
			[120008, 120008],
			"mapped",
			[115]
		],
		[
			[120009, 120009],
			"mapped",
			[116]
		],
		[
			[120010, 120010],
			"mapped",
			[117]
		],
		[
			[120011, 120011],
			"mapped",
			[118]
		],
		[
			[120012, 120012],
			"mapped",
			[119]
		],
		[
			[120013, 120013],
			"mapped",
			[120]
		],
		[
			[120014, 120014],
			"mapped",
			[121]
		],
		[
			[120015, 120015],
			"mapped",
			[122]
		],
		[
			[120016, 120016],
			"mapped",
			[97]
		],
		[
			[120017, 120017],
			"mapped",
			[98]
		],
		[
			[120018, 120018],
			"mapped",
			[99]
		],
		[
			[120019, 120019],
			"mapped",
			[100]
		],
		[
			[120020, 120020],
			"mapped",
			[101]
		],
		[
			[120021, 120021],
			"mapped",
			[102]
		],
		[
			[120022, 120022],
			"mapped",
			[103]
		],
		[
			[120023, 120023],
			"mapped",
			[104]
		],
		[
			[120024, 120024],
			"mapped",
			[105]
		],
		[
			[120025, 120025],
			"mapped",
			[106]
		],
		[
			[120026, 120026],
			"mapped",
			[107]
		],
		[
			[120027, 120027],
			"mapped",
			[108]
		],
		[
			[120028, 120028],
			"mapped",
			[109]
		],
		[
			[120029, 120029],
			"mapped",
			[110]
		],
		[
			[120030, 120030],
			"mapped",
			[111]
		],
		[
			[120031, 120031],
			"mapped",
			[112]
		],
		[
			[120032, 120032],
			"mapped",
			[113]
		],
		[
			[120033, 120033],
			"mapped",
			[114]
		],
		[
			[120034, 120034],
			"mapped",
			[115]
		],
		[
			[120035, 120035],
			"mapped",
			[116]
		],
		[
			[120036, 120036],
			"mapped",
			[117]
		],
		[
			[120037, 120037],
			"mapped",
			[118]
		],
		[
			[120038, 120038],
			"mapped",
			[119]
		],
		[
			[120039, 120039],
			"mapped",
			[120]
		],
		[
			[120040, 120040],
			"mapped",
			[121]
		],
		[
			[120041, 120041],
			"mapped",
			[122]
		],
		[
			[120042, 120042],
			"mapped",
			[97]
		],
		[
			[120043, 120043],
			"mapped",
			[98]
		],
		[
			[120044, 120044],
			"mapped",
			[99]
		],
		[
			[120045, 120045],
			"mapped",
			[100]
		],
		[
			[120046, 120046],
			"mapped",
			[101]
		],
		[
			[120047, 120047],
			"mapped",
			[102]
		],
		[
			[120048, 120048],
			"mapped",
			[103]
		],
		[
			[120049, 120049],
			"mapped",
			[104]
		],
		[
			[120050, 120050],
			"mapped",
			[105]
		],
		[
			[120051, 120051],
			"mapped",
			[106]
		],
		[
			[120052, 120052],
			"mapped",
			[107]
		],
		[
			[120053, 120053],
			"mapped",
			[108]
		],
		[
			[120054, 120054],
			"mapped",
			[109]
		],
		[
			[120055, 120055],
			"mapped",
			[110]
		],
		[
			[120056, 120056],
			"mapped",
			[111]
		],
		[
			[120057, 120057],
			"mapped",
			[112]
		],
		[
			[120058, 120058],
			"mapped",
			[113]
		],
		[
			[120059, 120059],
			"mapped",
			[114]
		],
		[
			[120060, 120060],
			"mapped",
			[115]
		],
		[
			[120061, 120061],
			"mapped",
			[116]
		],
		[
			[120062, 120062],
			"mapped",
			[117]
		],
		[
			[120063, 120063],
			"mapped",
			[118]
		],
		[
			[120064, 120064],
			"mapped",
			[119]
		],
		[
			[120065, 120065],
			"mapped",
			[120]
		],
		[
			[120066, 120066],
			"mapped",
			[121]
		],
		[
			[120067, 120067],
			"mapped",
			[122]
		],
		[
			[120068, 120068],
			"mapped",
			[97]
		],
		[
			[120069, 120069],
			"mapped",
			[98]
		],
		[[120070, 120070], "disallowed"],
		[
			[120071, 120071],
			"mapped",
			[100]
		],
		[
			[120072, 120072],
			"mapped",
			[101]
		],
		[
			[120073, 120073],
			"mapped",
			[102]
		],
		[
			[120074, 120074],
			"mapped",
			[103]
		],
		[[120075, 120076], "disallowed"],
		[
			[120077, 120077],
			"mapped",
			[106]
		],
		[
			[120078, 120078],
			"mapped",
			[107]
		],
		[
			[120079, 120079],
			"mapped",
			[108]
		],
		[
			[120080, 120080],
			"mapped",
			[109]
		],
		[
			[120081, 120081],
			"mapped",
			[110]
		],
		[
			[120082, 120082],
			"mapped",
			[111]
		],
		[
			[120083, 120083],
			"mapped",
			[112]
		],
		[
			[120084, 120084],
			"mapped",
			[113]
		],
		[[120085, 120085], "disallowed"],
		[
			[120086, 120086],
			"mapped",
			[115]
		],
		[
			[120087, 120087],
			"mapped",
			[116]
		],
		[
			[120088, 120088],
			"mapped",
			[117]
		],
		[
			[120089, 120089],
			"mapped",
			[118]
		],
		[
			[120090, 120090],
			"mapped",
			[119]
		],
		[
			[120091, 120091],
			"mapped",
			[120]
		],
		[
			[120092, 120092],
			"mapped",
			[121]
		],
		[[120093, 120093], "disallowed"],
		[
			[120094, 120094],
			"mapped",
			[97]
		],
		[
			[120095, 120095],
			"mapped",
			[98]
		],
		[
			[120096, 120096],
			"mapped",
			[99]
		],
		[
			[120097, 120097],
			"mapped",
			[100]
		],
		[
			[120098, 120098],
			"mapped",
			[101]
		],
		[
			[120099, 120099],
			"mapped",
			[102]
		],
		[
			[120100, 120100],
			"mapped",
			[103]
		],
		[
			[120101, 120101],
			"mapped",
			[104]
		],
		[
			[120102, 120102],
			"mapped",
			[105]
		],
		[
			[120103, 120103],
			"mapped",
			[106]
		],
		[
			[120104, 120104],
			"mapped",
			[107]
		],
		[
			[120105, 120105],
			"mapped",
			[108]
		],
		[
			[120106, 120106],
			"mapped",
			[109]
		],
		[
			[120107, 120107],
			"mapped",
			[110]
		],
		[
			[120108, 120108],
			"mapped",
			[111]
		],
		[
			[120109, 120109],
			"mapped",
			[112]
		],
		[
			[120110, 120110],
			"mapped",
			[113]
		],
		[
			[120111, 120111],
			"mapped",
			[114]
		],
		[
			[120112, 120112],
			"mapped",
			[115]
		],
		[
			[120113, 120113],
			"mapped",
			[116]
		],
		[
			[120114, 120114],
			"mapped",
			[117]
		],
		[
			[120115, 120115],
			"mapped",
			[118]
		],
		[
			[120116, 120116],
			"mapped",
			[119]
		],
		[
			[120117, 120117],
			"mapped",
			[120]
		],
		[
			[120118, 120118],
			"mapped",
			[121]
		],
		[
			[120119, 120119],
			"mapped",
			[122]
		],
		[
			[120120, 120120],
			"mapped",
			[97]
		],
		[
			[120121, 120121],
			"mapped",
			[98]
		],
		[[120122, 120122], "disallowed"],
		[
			[120123, 120123],
			"mapped",
			[100]
		],
		[
			[120124, 120124],
			"mapped",
			[101]
		],
		[
			[120125, 120125],
			"mapped",
			[102]
		],
		[
			[120126, 120126],
			"mapped",
			[103]
		],
		[[120127, 120127], "disallowed"],
		[
			[120128, 120128],
			"mapped",
			[105]
		],
		[
			[120129, 120129],
			"mapped",
			[106]
		],
		[
			[120130, 120130],
			"mapped",
			[107]
		],
		[
			[120131, 120131],
			"mapped",
			[108]
		],
		[
			[120132, 120132],
			"mapped",
			[109]
		],
		[[120133, 120133], "disallowed"],
		[
			[120134, 120134],
			"mapped",
			[111]
		],
		[[120135, 120137], "disallowed"],
		[
			[120138, 120138],
			"mapped",
			[115]
		],
		[
			[120139, 120139],
			"mapped",
			[116]
		],
		[
			[120140, 120140],
			"mapped",
			[117]
		],
		[
			[120141, 120141],
			"mapped",
			[118]
		],
		[
			[120142, 120142],
			"mapped",
			[119]
		],
		[
			[120143, 120143],
			"mapped",
			[120]
		],
		[
			[120144, 120144],
			"mapped",
			[121]
		],
		[[120145, 120145], "disallowed"],
		[
			[120146, 120146],
			"mapped",
			[97]
		],
		[
			[120147, 120147],
			"mapped",
			[98]
		],
		[
			[120148, 120148],
			"mapped",
			[99]
		],
		[
			[120149, 120149],
			"mapped",
			[100]
		],
		[
			[120150, 120150],
			"mapped",
			[101]
		],
		[
			[120151, 120151],
			"mapped",
			[102]
		],
		[
			[120152, 120152],
			"mapped",
			[103]
		],
		[
			[120153, 120153],
			"mapped",
			[104]
		],
		[
			[120154, 120154],
			"mapped",
			[105]
		],
		[
			[120155, 120155],
			"mapped",
			[106]
		],
		[
			[120156, 120156],
			"mapped",
			[107]
		],
		[
			[120157, 120157],
			"mapped",
			[108]
		],
		[
			[120158, 120158],
			"mapped",
			[109]
		],
		[
			[120159, 120159],
			"mapped",
			[110]
		],
		[
			[120160, 120160],
			"mapped",
			[111]
		],
		[
			[120161, 120161],
			"mapped",
			[112]
		],
		[
			[120162, 120162],
			"mapped",
			[113]
		],
		[
			[120163, 120163],
			"mapped",
			[114]
		],
		[
			[120164, 120164],
			"mapped",
			[115]
		],
		[
			[120165, 120165],
			"mapped",
			[116]
		],
		[
			[120166, 120166],
			"mapped",
			[117]
		],
		[
			[120167, 120167],
			"mapped",
			[118]
		],
		[
			[120168, 120168],
			"mapped",
			[119]
		],
		[
			[120169, 120169],
			"mapped",
			[120]
		],
		[
			[120170, 120170],
			"mapped",
			[121]
		],
		[
			[120171, 120171],
			"mapped",
			[122]
		],
		[
			[120172, 120172],
			"mapped",
			[97]
		],
		[
			[120173, 120173],
			"mapped",
			[98]
		],
		[
			[120174, 120174],
			"mapped",
			[99]
		],
		[
			[120175, 120175],
			"mapped",
			[100]
		],
		[
			[120176, 120176],
			"mapped",
			[101]
		],
		[
			[120177, 120177],
			"mapped",
			[102]
		],
		[
			[120178, 120178],
			"mapped",
			[103]
		],
		[
			[120179, 120179],
			"mapped",
			[104]
		],
		[
			[120180, 120180],
			"mapped",
			[105]
		],
		[
			[120181, 120181],
			"mapped",
			[106]
		],
		[
			[120182, 120182],
			"mapped",
			[107]
		],
		[
			[120183, 120183],
			"mapped",
			[108]
		],
		[
			[120184, 120184],
			"mapped",
			[109]
		],
		[
			[120185, 120185],
			"mapped",
			[110]
		],
		[
			[120186, 120186],
			"mapped",
			[111]
		],
		[
			[120187, 120187],
			"mapped",
			[112]
		],
		[
			[120188, 120188],
			"mapped",
			[113]
		],
		[
			[120189, 120189],
			"mapped",
			[114]
		],
		[
			[120190, 120190],
			"mapped",
			[115]
		],
		[
			[120191, 120191],
			"mapped",
			[116]
		],
		[
			[120192, 120192],
			"mapped",
			[117]
		],
		[
			[120193, 120193],
			"mapped",
			[118]
		],
		[
			[120194, 120194],
			"mapped",
			[119]
		],
		[
			[120195, 120195],
			"mapped",
			[120]
		],
		[
			[120196, 120196],
			"mapped",
			[121]
		],
		[
			[120197, 120197],
			"mapped",
			[122]
		],
		[
			[120198, 120198],
			"mapped",
			[97]
		],
		[
			[120199, 120199],
			"mapped",
			[98]
		],
		[
			[120200, 120200],
			"mapped",
			[99]
		],
		[
			[120201, 120201],
			"mapped",
			[100]
		],
		[
			[120202, 120202],
			"mapped",
			[101]
		],
		[
			[120203, 120203],
			"mapped",
			[102]
		],
		[
			[120204, 120204],
			"mapped",
			[103]
		],
		[
			[120205, 120205],
			"mapped",
			[104]
		],
		[
			[120206, 120206],
			"mapped",
			[105]
		],
		[
			[120207, 120207],
			"mapped",
			[106]
		],
		[
			[120208, 120208],
			"mapped",
			[107]
		],
		[
			[120209, 120209],
			"mapped",
			[108]
		],
		[
			[120210, 120210],
			"mapped",
			[109]
		],
		[
			[120211, 120211],
			"mapped",
			[110]
		],
		[
			[120212, 120212],
			"mapped",
			[111]
		],
		[
			[120213, 120213],
			"mapped",
			[112]
		],
		[
			[120214, 120214],
			"mapped",
			[113]
		],
		[
			[120215, 120215],
			"mapped",
			[114]
		],
		[
			[120216, 120216],
			"mapped",
			[115]
		],
		[
			[120217, 120217],
			"mapped",
			[116]
		],
		[
			[120218, 120218],
			"mapped",
			[117]
		],
		[
			[120219, 120219],
			"mapped",
			[118]
		],
		[
			[120220, 120220],
			"mapped",
			[119]
		],
		[
			[120221, 120221],
			"mapped",
			[120]
		],
		[
			[120222, 120222],
			"mapped",
			[121]
		],
		[
			[120223, 120223],
			"mapped",
			[122]
		],
		[
			[120224, 120224],
			"mapped",
			[97]
		],
		[
			[120225, 120225],
			"mapped",
			[98]
		],
		[
			[120226, 120226],
			"mapped",
			[99]
		],
		[
			[120227, 120227],
			"mapped",
			[100]
		],
		[
			[120228, 120228],
			"mapped",
			[101]
		],
		[
			[120229, 120229],
			"mapped",
			[102]
		],
		[
			[120230, 120230],
			"mapped",
			[103]
		],
		[
			[120231, 120231],
			"mapped",
			[104]
		],
		[
			[120232, 120232],
			"mapped",
			[105]
		],
		[
			[120233, 120233],
			"mapped",
			[106]
		],
		[
			[120234, 120234],
			"mapped",
			[107]
		],
		[
			[120235, 120235],
			"mapped",
			[108]
		],
		[
			[120236, 120236],
			"mapped",
			[109]
		],
		[
			[120237, 120237],
			"mapped",
			[110]
		],
		[
			[120238, 120238],
			"mapped",
			[111]
		],
		[
			[120239, 120239],
			"mapped",
			[112]
		],
		[
			[120240, 120240],
			"mapped",
			[113]
		],
		[
			[120241, 120241],
			"mapped",
			[114]
		],
		[
			[120242, 120242],
			"mapped",
			[115]
		],
		[
			[120243, 120243],
			"mapped",
			[116]
		],
		[
			[120244, 120244],
			"mapped",
			[117]
		],
		[
			[120245, 120245],
			"mapped",
			[118]
		],
		[
			[120246, 120246],
			"mapped",
			[119]
		],
		[
			[120247, 120247],
			"mapped",
			[120]
		],
		[
			[120248, 120248],
			"mapped",
			[121]
		],
		[
			[120249, 120249],
			"mapped",
			[122]
		],
		[
			[120250, 120250],
			"mapped",
			[97]
		],
		[
			[120251, 120251],
			"mapped",
			[98]
		],
		[
			[120252, 120252],
			"mapped",
			[99]
		],
		[
			[120253, 120253],
			"mapped",
			[100]
		],
		[
			[120254, 120254],
			"mapped",
			[101]
		],
		[
			[120255, 120255],
			"mapped",
			[102]
		],
		[
			[120256, 120256],
			"mapped",
			[103]
		],
		[
			[120257, 120257],
			"mapped",
			[104]
		],
		[
			[120258, 120258],
			"mapped",
			[105]
		],
		[
			[120259, 120259],
			"mapped",
			[106]
		],
		[
			[120260, 120260],
			"mapped",
			[107]
		],
		[
			[120261, 120261],
			"mapped",
			[108]
		],
		[
			[120262, 120262],
			"mapped",
			[109]
		],
		[
			[120263, 120263],
			"mapped",
			[110]
		],
		[
			[120264, 120264],
			"mapped",
			[111]
		],
		[
			[120265, 120265],
			"mapped",
			[112]
		],
		[
			[120266, 120266],
			"mapped",
			[113]
		],
		[
			[120267, 120267],
			"mapped",
			[114]
		],
		[
			[120268, 120268],
			"mapped",
			[115]
		],
		[
			[120269, 120269],
			"mapped",
			[116]
		],
		[
			[120270, 120270],
			"mapped",
			[117]
		],
		[
			[120271, 120271],
			"mapped",
			[118]
		],
		[
			[120272, 120272],
			"mapped",
			[119]
		],
		[
			[120273, 120273],
			"mapped",
			[120]
		],
		[
			[120274, 120274],
			"mapped",
			[121]
		],
		[
			[120275, 120275],
			"mapped",
			[122]
		],
		[
			[120276, 120276],
			"mapped",
			[97]
		],
		[
			[120277, 120277],
			"mapped",
			[98]
		],
		[
			[120278, 120278],
			"mapped",
			[99]
		],
		[
			[120279, 120279],
			"mapped",
			[100]
		],
		[
			[120280, 120280],
			"mapped",
			[101]
		],
		[
			[120281, 120281],
			"mapped",
			[102]
		],
		[
			[120282, 120282],
			"mapped",
			[103]
		],
		[
			[120283, 120283],
			"mapped",
			[104]
		],
		[
			[120284, 120284],
			"mapped",
			[105]
		],
		[
			[120285, 120285],
			"mapped",
			[106]
		],
		[
			[120286, 120286],
			"mapped",
			[107]
		],
		[
			[120287, 120287],
			"mapped",
			[108]
		],
		[
			[120288, 120288],
			"mapped",
			[109]
		],
		[
			[120289, 120289],
			"mapped",
			[110]
		],
		[
			[120290, 120290],
			"mapped",
			[111]
		],
		[
			[120291, 120291],
			"mapped",
			[112]
		],
		[
			[120292, 120292],
			"mapped",
			[113]
		],
		[
			[120293, 120293],
			"mapped",
			[114]
		],
		[
			[120294, 120294],
			"mapped",
			[115]
		],
		[
			[120295, 120295],
			"mapped",
			[116]
		],
		[
			[120296, 120296],
			"mapped",
			[117]
		],
		[
			[120297, 120297],
			"mapped",
			[118]
		],
		[
			[120298, 120298],
			"mapped",
			[119]
		],
		[
			[120299, 120299],
			"mapped",
			[120]
		],
		[
			[120300, 120300],
			"mapped",
			[121]
		],
		[
			[120301, 120301],
			"mapped",
			[122]
		],
		[
			[120302, 120302],
			"mapped",
			[97]
		],
		[
			[120303, 120303],
			"mapped",
			[98]
		],
		[
			[120304, 120304],
			"mapped",
			[99]
		],
		[
			[120305, 120305],
			"mapped",
			[100]
		],
		[
			[120306, 120306],
			"mapped",
			[101]
		],
		[
			[120307, 120307],
			"mapped",
			[102]
		],
		[
			[120308, 120308],
			"mapped",
			[103]
		],
		[
			[120309, 120309],
			"mapped",
			[104]
		],
		[
			[120310, 120310],
			"mapped",
			[105]
		],
		[
			[120311, 120311],
			"mapped",
			[106]
		],
		[
			[120312, 120312],
			"mapped",
			[107]
		],
		[
			[120313, 120313],
			"mapped",
			[108]
		],
		[
			[120314, 120314],
			"mapped",
			[109]
		],
		[
			[120315, 120315],
			"mapped",
			[110]
		],
		[
			[120316, 120316],
			"mapped",
			[111]
		],
		[
			[120317, 120317],
			"mapped",
			[112]
		],
		[
			[120318, 120318],
			"mapped",
			[113]
		],
		[
			[120319, 120319],
			"mapped",
			[114]
		],
		[
			[120320, 120320],
			"mapped",
			[115]
		],
		[
			[120321, 120321],
			"mapped",
			[116]
		],
		[
			[120322, 120322],
			"mapped",
			[117]
		],
		[
			[120323, 120323],
			"mapped",
			[118]
		],
		[
			[120324, 120324],
			"mapped",
			[119]
		],
		[
			[120325, 120325],
			"mapped",
			[120]
		],
		[
			[120326, 120326],
			"mapped",
			[121]
		],
		[
			[120327, 120327],
			"mapped",
			[122]
		],
		[
			[120328, 120328],
			"mapped",
			[97]
		],
		[
			[120329, 120329],
			"mapped",
			[98]
		],
		[
			[120330, 120330],
			"mapped",
			[99]
		],
		[
			[120331, 120331],
			"mapped",
			[100]
		],
		[
			[120332, 120332],
			"mapped",
			[101]
		],
		[
			[120333, 120333],
			"mapped",
			[102]
		],
		[
			[120334, 120334],
			"mapped",
			[103]
		],
		[
			[120335, 120335],
			"mapped",
			[104]
		],
		[
			[120336, 120336],
			"mapped",
			[105]
		],
		[
			[120337, 120337],
			"mapped",
			[106]
		],
		[
			[120338, 120338],
			"mapped",
			[107]
		],
		[
			[120339, 120339],
			"mapped",
			[108]
		],
		[
			[120340, 120340],
			"mapped",
			[109]
		],
		[
			[120341, 120341],
			"mapped",
			[110]
		],
		[
			[120342, 120342],
			"mapped",
			[111]
		],
		[
			[120343, 120343],
			"mapped",
			[112]
		],
		[
			[120344, 120344],
			"mapped",
			[113]
		],
		[
			[120345, 120345],
			"mapped",
			[114]
		],
		[
			[120346, 120346],
			"mapped",
			[115]
		],
		[
			[120347, 120347],
			"mapped",
			[116]
		],
		[
			[120348, 120348],
			"mapped",
			[117]
		],
		[
			[120349, 120349],
			"mapped",
			[118]
		],
		[
			[120350, 120350],
			"mapped",
			[119]
		],
		[
			[120351, 120351],
			"mapped",
			[120]
		],
		[
			[120352, 120352],
			"mapped",
			[121]
		],
		[
			[120353, 120353],
			"mapped",
			[122]
		],
		[
			[120354, 120354],
			"mapped",
			[97]
		],
		[
			[120355, 120355],
			"mapped",
			[98]
		],
		[
			[120356, 120356],
			"mapped",
			[99]
		],
		[
			[120357, 120357],
			"mapped",
			[100]
		],
		[
			[120358, 120358],
			"mapped",
			[101]
		],
		[
			[120359, 120359],
			"mapped",
			[102]
		],
		[
			[120360, 120360],
			"mapped",
			[103]
		],
		[
			[120361, 120361],
			"mapped",
			[104]
		],
		[
			[120362, 120362],
			"mapped",
			[105]
		],
		[
			[120363, 120363],
			"mapped",
			[106]
		],
		[
			[120364, 120364],
			"mapped",
			[107]
		],
		[
			[120365, 120365],
			"mapped",
			[108]
		],
		[
			[120366, 120366],
			"mapped",
			[109]
		],
		[
			[120367, 120367],
			"mapped",
			[110]
		],
		[
			[120368, 120368],
			"mapped",
			[111]
		],
		[
			[120369, 120369],
			"mapped",
			[112]
		],
		[
			[120370, 120370],
			"mapped",
			[113]
		],
		[
			[120371, 120371],
			"mapped",
			[114]
		],
		[
			[120372, 120372],
			"mapped",
			[115]
		],
		[
			[120373, 120373],
			"mapped",
			[116]
		],
		[
			[120374, 120374],
			"mapped",
			[117]
		],
		[
			[120375, 120375],
			"mapped",
			[118]
		],
		[
			[120376, 120376],
			"mapped",
			[119]
		],
		[
			[120377, 120377],
			"mapped",
			[120]
		],
		[
			[120378, 120378],
			"mapped",
			[121]
		],
		[
			[120379, 120379],
			"mapped",
			[122]
		],
		[
			[120380, 120380],
			"mapped",
			[97]
		],
		[
			[120381, 120381],
			"mapped",
			[98]
		],
		[
			[120382, 120382],
			"mapped",
			[99]
		],
		[
			[120383, 120383],
			"mapped",
			[100]
		],
		[
			[120384, 120384],
			"mapped",
			[101]
		],
		[
			[120385, 120385],
			"mapped",
			[102]
		],
		[
			[120386, 120386],
			"mapped",
			[103]
		],
		[
			[120387, 120387],
			"mapped",
			[104]
		],
		[
			[120388, 120388],
			"mapped",
			[105]
		],
		[
			[120389, 120389],
			"mapped",
			[106]
		],
		[
			[120390, 120390],
			"mapped",
			[107]
		],
		[
			[120391, 120391],
			"mapped",
			[108]
		],
		[
			[120392, 120392],
			"mapped",
			[109]
		],
		[
			[120393, 120393],
			"mapped",
			[110]
		],
		[
			[120394, 120394],
			"mapped",
			[111]
		],
		[
			[120395, 120395],
			"mapped",
			[112]
		],
		[
			[120396, 120396],
			"mapped",
			[113]
		],
		[
			[120397, 120397],
			"mapped",
			[114]
		],
		[
			[120398, 120398],
			"mapped",
			[115]
		],
		[
			[120399, 120399],
			"mapped",
			[116]
		],
		[
			[120400, 120400],
			"mapped",
			[117]
		],
		[
			[120401, 120401],
			"mapped",
			[118]
		],
		[
			[120402, 120402],
			"mapped",
			[119]
		],
		[
			[120403, 120403],
			"mapped",
			[120]
		],
		[
			[120404, 120404],
			"mapped",
			[121]
		],
		[
			[120405, 120405],
			"mapped",
			[122]
		],
		[
			[120406, 120406],
			"mapped",
			[97]
		],
		[
			[120407, 120407],
			"mapped",
			[98]
		],
		[
			[120408, 120408],
			"mapped",
			[99]
		],
		[
			[120409, 120409],
			"mapped",
			[100]
		],
		[
			[120410, 120410],
			"mapped",
			[101]
		],
		[
			[120411, 120411],
			"mapped",
			[102]
		],
		[
			[120412, 120412],
			"mapped",
			[103]
		],
		[
			[120413, 120413],
			"mapped",
			[104]
		],
		[
			[120414, 120414],
			"mapped",
			[105]
		],
		[
			[120415, 120415],
			"mapped",
			[106]
		],
		[
			[120416, 120416],
			"mapped",
			[107]
		],
		[
			[120417, 120417],
			"mapped",
			[108]
		],
		[
			[120418, 120418],
			"mapped",
			[109]
		],
		[
			[120419, 120419],
			"mapped",
			[110]
		],
		[
			[120420, 120420],
			"mapped",
			[111]
		],
		[
			[120421, 120421],
			"mapped",
			[112]
		],
		[
			[120422, 120422],
			"mapped",
			[113]
		],
		[
			[120423, 120423],
			"mapped",
			[114]
		],
		[
			[120424, 120424],
			"mapped",
			[115]
		],
		[
			[120425, 120425],
			"mapped",
			[116]
		],
		[
			[120426, 120426],
			"mapped",
			[117]
		],
		[
			[120427, 120427],
			"mapped",
			[118]
		],
		[
			[120428, 120428],
			"mapped",
			[119]
		],
		[
			[120429, 120429],
			"mapped",
			[120]
		],
		[
			[120430, 120430],
			"mapped",
			[121]
		],
		[
			[120431, 120431],
			"mapped",
			[122]
		],
		[
			[120432, 120432],
			"mapped",
			[97]
		],
		[
			[120433, 120433],
			"mapped",
			[98]
		],
		[
			[120434, 120434],
			"mapped",
			[99]
		],
		[
			[120435, 120435],
			"mapped",
			[100]
		],
		[
			[120436, 120436],
			"mapped",
			[101]
		],
		[
			[120437, 120437],
			"mapped",
			[102]
		],
		[
			[120438, 120438],
			"mapped",
			[103]
		],
		[
			[120439, 120439],
			"mapped",
			[104]
		],
		[
			[120440, 120440],
			"mapped",
			[105]
		],
		[
			[120441, 120441],
			"mapped",
			[106]
		],
		[
			[120442, 120442],
			"mapped",
			[107]
		],
		[
			[120443, 120443],
			"mapped",
			[108]
		],
		[
			[120444, 120444],
			"mapped",
			[109]
		],
		[
			[120445, 120445],
			"mapped",
			[110]
		],
		[
			[120446, 120446],
			"mapped",
			[111]
		],
		[
			[120447, 120447],
			"mapped",
			[112]
		],
		[
			[120448, 120448],
			"mapped",
			[113]
		],
		[
			[120449, 120449],
			"mapped",
			[114]
		],
		[
			[120450, 120450],
			"mapped",
			[115]
		],
		[
			[120451, 120451],
			"mapped",
			[116]
		],
		[
			[120452, 120452],
			"mapped",
			[117]
		],
		[
			[120453, 120453],
			"mapped",
			[118]
		],
		[
			[120454, 120454],
			"mapped",
			[119]
		],
		[
			[120455, 120455],
			"mapped",
			[120]
		],
		[
			[120456, 120456],
			"mapped",
			[121]
		],
		[
			[120457, 120457],
			"mapped",
			[122]
		],
		[
			[120458, 120458],
			"mapped",
			[97]
		],
		[
			[120459, 120459],
			"mapped",
			[98]
		],
		[
			[120460, 120460],
			"mapped",
			[99]
		],
		[
			[120461, 120461],
			"mapped",
			[100]
		],
		[
			[120462, 120462],
			"mapped",
			[101]
		],
		[
			[120463, 120463],
			"mapped",
			[102]
		],
		[
			[120464, 120464],
			"mapped",
			[103]
		],
		[
			[120465, 120465],
			"mapped",
			[104]
		],
		[
			[120466, 120466],
			"mapped",
			[105]
		],
		[
			[120467, 120467],
			"mapped",
			[106]
		],
		[
			[120468, 120468],
			"mapped",
			[107]
		],
		[
			[120469, 120469],
			"mapped",
			[108]
		],
		[
			[120470, 120470],
			"mapped",
			[109]
		],
		[
			[120471, 120471],
			"mapped",
			[110]
		],
		[
			[120472, 120472],
			"mapped",
			[111]
		],
		[
			[120473, 120473],
			"mapped",
			[112]
		],
		[
			[120474, 120474],
			"mapped",
			[113]
		],
		[
			[120475, 120475],
			"mapped",
			[114]
		],
		[
			[120476, 120476],
			"mapped",
			[115]
		],
		[
			[120477, 120477],
			"mapped",
			[116]
		],
		[
			[120478, 120478],
			"mapped",
			[117]
		],
		[
			[120479, 120479],
			"mapped",
			[118]
		],
		[
			[120480, 120480],
			"mapped",
			[119]
		],
		[
			[120481, 120481],
			"mapped",
			[120]
		],
		[
			[120482, 120482],
			"mapped",
			[121]
		],
		[
			[120483, 120483],
			"mapped",
			[122]
		],
		[
			[120484, 120484],
			"mapped",
			[305]
		],
		[
			[120485, 120485],
			"mapped",
			[567]
		],
		[[120486, 120487], "disallowed"],
		[
			[120488, 120488],
			"mapped",
			[945]
		],
		[
			[120489, 120489],
			"mapped",
			[946]
		],
		[
			[120490, 120490],
			"mapped",
			[947]
		],
		[
			[120491, 120491],
			"mapped",
			[948]
		],
		[
			[120492, 120492],
			"mapped",
			[949]
		],
		[
			[120493, 120493],
			"mapped",
			[950]
		],
		[
			[120494, 120494],
			"mapped",
			[951]
		],
		[
			[120495, 120495],
			"mapped",
			[952]
		],
		[
			[120496, 120496],
			"mapped",
			[953]
		],
		[
			[120497, 120497],
			"mapped",
			[954]
		],
		[
			[120498, 120498],
			"mapped",
			[955]
		],
		[
			[120499, 120499],
			"mapped",
			[956]
		],
		[
			[120500, 120500],
			"mapped",
			[957]
		],
		[
			[120501, 120501],
			"mapped",
			[958]
		],
		[
			[120502, 120502],
			"mapped",
			[959]
		],
		[
			[120503, 120503],
			"mapped",
			[960]
		],
		[
			[120504, 120504],
			"mapped",
			[961]
		],
		[
			[120505, 120505],
			"mapped",
			[952]
		],
		[
			[120506, 120506],
			"mapped",
			[963]
		],
		[
			[120507, 120507],
			"mapped",
			[964]
		],
		[
			[120508, 120508],
			"mapped",
			[965]
		],
		[
			[120509, 120509],
			"mapped",
			[966]
		],
		[
			[120510, 120510],
			"mapped",
			[967]
		],
		[
			[120511, 120511],
			"mapped",
			[968]
		],
		[
			[120512, 120512],
			"mapped",
			[969]
		],
		[
			[120513, 120513],
			"mapped",
			[8711]
		],
		[
			[120514, 120514],
			"mapped",
			[945]
		],
		[
			[120515, 120515],
			"mapped",
			[946]
		],
		[
			[120516, 120516],
			"mapped",
			[947]
		],
		[
			[120517, 120517],
			"mapped",
			[948]
		],
		[
			[120518, 120518],
			"mapped",
			[949]
		],
		[
			[120519, 120519],
			"mapped",
			[950]
		],
		[
			[120520, 120520],
			"mapped",
			[951]
		],
		[
			[120521, 120521],
			"mapped",
			[952]
		],
		[
			[120522, 120522],
			"mapped",
			[953]
		],
		[
			[120523, 120523],
			"mapped",
			[954]
		],
		[
			[120524, 120524],
			"mapped",
			[955]
		],
		[
			[120525, 120525],
			"mapped",
			[956]
		],
		[
			[120526, 120526],
			"mapped",
			[957]
		],
		[
			[120527, 120527],
			"mapped",
			[958]
		],
		[
			[120528, 120528],
			"mapped",
			[959]
		],
		[
			[120529, 120529],
			"mapped",
			[960]
		],
		[
			[120530, 120530],
			"mapped",
			[961]
		],
		[
			[120531, 120532],
			"mapped",
			[963]
		],
		[
			[120533, 120533],
			"mapped",
			[964]
		],
		[
			[120534, 120534],
			"mapped",
			[965]
		],
		[
			[120535, 120535],
			"mapped",
			[966]
		],
		[
			[120536, 120536],
			"mapped",
			[967]
		],
		[
			[120537, 120537],
			"mapped",
			[968]
		],
		[
			[120538, 120538],
			"mapped",
			[969]
		],
		[
			[120539, 120539],
			"mapped",
			[8706]
		],
		[
			[120540, 120540],
			"mapped",
			[949]
		],
		[
			[120541, 120541],
			"mapped",
			[952]
		],
		[
			[120542, 120542],
			"mapped",
			[954]
		],
		[
			[120543, 120543],
			"mapped",
			[966]
		],
		[
			[120544, 120544],
			"mapped",
			[961]
		],
		[
			[120545, 120545],
			"mapped",
			[960]
		],
		[
			[120546, 120546],
			"mapped",
			[945]
		],
		[
			[120547, 120547],
			"mapped",
			[946]
		],
		[
			[120548, 120548],
			"mapped",
			[947]
		],
		[
			[120549, 120549],
			"mapped",
			[948]
		],
		[
			[120550, 120550],
			"mapped",
			[949]
		],
		[
			[120551, 120551],
			"mapped",
			[950]
		],
		[
			[120552, 120552],
			"mapped",
			[951]
		],
		[
			[120553, 120553],
			"mapped",
			[952]
		],
		[
			[120554, 120554],
			"mapped",
			[953]
		],
		[
			[120555, 120555],
			"mapped",
			[954]
		],
		[
			[120556, 120556],
			"mapped",
			[955]
		],
		[
			[120557, 120557],
			"mapped",
			[956]
		],
		[
			[120558, 120558],
			"mapped",
			[957]
		],
		[
			[120559, 120559],
			"mapped",
			[958]
		],
		[
			[120560, 120560],
			"mapped",
			[959]
		],
		[
			[120561, 120561],
			"mapped",
			[960]
		],
		[
			[120562, 120562],
			"mapped",
			[961]
		],
		[
			[120563, 120563],
			"mapped",
			[952]
		],
		[
			[120564, 120564],
			"mapped",
			[963]
		],
		[
			[120565, 120565],
			"mapped",
			[964]
		],
		[
			[120566, 120566],
			"mapped",
			[965]
		],
		[
			[120567, 120567],
			"mapped",
			[966]
		],
		[
			[120568, 120568],
			"mapped",
			[967]
		],
		[
			[120569, 120569],
			"mapped",
			[968]
		],
		[
			[120570, 120570],
			"mapped",
			[969]
		],
		[
			[120571, 120571],
			"mapped",
			[8711]
		],
		[
			[120572, 120572],
			"mapped",
			[945]
		],
		[
			[120573, 120573],
			"mapped",
			[946]
		],
		[
			[120574, 120574],
			"mapped",
			[947]
		],
		[
			[120575, 120575],
			"mapped",
			[948]
		],
		[
			[120576, 120576],
			"mapped",
			[949]
		],
		[
			[120577, 120577],
			"mapped",
			[950]
		],
		[
			[120578, 120578],
			"mapped",
			[951]
		],
		[
			[120579, 120579],
			"mapped",
			[952]
		],
		[
			[120580, 120580],
			"mapped",
			[953]
		],
		[
			[120581, 120581],
			"mapped",
			[954]
		],
		[
			[120582, 120582],
			"mapped",
			[955]
		],
		[
			[120583, 120583],
			"mapped",
			[956]
		],
		[
			[120584, 120584],
			"mapped",
			[957]
		],
		[
			[120585, 120585],
			"mapped",
			[958]
		],
		[
			[120586, 120586],
			"mapped",
			[959]
		],
		[
			[120587, 120587],
			"mapped",
			[960]
		],
		[
			[120588, 120588],
			"mapped",
			[961]
		],
		[
			[120589, 120590],
			"mapped",
			[963]
		],
		[
			[120591, 120591],
			"mapped",
			[964]
		],
		[
			[120592, 120592],
			"mapped",
			[965]
		],
		[
			[120593, 120593],
			"mapped",
			[966]
		],
		[
			[120594, 120594],
			"mapped",
			[967]
		],
		[
			[120595, 120595],
			"mapped",
			[968]
		],
		[
			[120596, 120596],
			"mapped",
			[969]
		],
		[
			[120597, 120597],
			"mapped",
			[8706]
		],
		[
			[120598, 120598],
			"mapped",
			[949]
		],
		[
			[120599, 120599],
			"mapped",
			[952]
		],
		[
			[120600, 120600],
			"mapped",
			[954]
		],
		[
			[120601, 120601],
			"mapped",
			[966]
		],
		[
			[120602, 120602],
			"mapped",
			[961]
		],
		[
			[120603, 120603],
			"mapped",
			[960]
		],
		[
			[120604, 120604],
			"mapped",
			[945]
		],
		[
			[120605, 120605],
			"mapped",
			[946]
		],
		[
			[120606, 120606],
			"mapped",
			[947]
		],
		[
			[120607, 120607],
			"mapped",
			[948]
		],
		[
			[120608, 120608],
			"mapped",
			[949]
		],
		[
			[120609, 120609],
			"mapped",
			[950]
		],
		[
			[120610, 120610],
			"mapped",
			[951]
		],
		[
			[120611, 120611],
			"mapped",
			[952]
		],
		[
			[120612, 120612],
			"mapped",
			[953]
		],
		[
			[120613, 120613],
			"mapped",
			[954]
		],
		[
			[120614, 120614],
			"mapped",
			[955]
		],
		[
			[120615, 120615],
			"mapped",
			[956]
		],
		[
			[120616, 120616],
			"mapped",
			[957]
		],
		[
			[120617, 120617],
			"mapped",
			[958]
		],
		[
			[120618, 120618],
			"mapped",
			[959]
		],
		[
			[120619, 120619],
			"mapped",
			[960]
		],
		[
			[120620, 120620],
			"mapped",
			[961]
		],
		[
			[120621, 120621],
			"mapped",
			[952]
		],
		[
			[120622, 120622],
			"mapped",
			[963]
		],
		[
			[120623, 120623],
			"mapped",
			[964]
		],
		[
			[120624, 120624],
			"mapped",
			[965]
		],
		[
			[120625, 120625],
			"mapped",
			[966]
		],
		[
			[120626, 120626],
			"mapped",
			[967]
		],
		[
			[120627, 120627],
			"mapped",
			[968]
		],
		[
			[120628, 120628],
			"mapped",
			[969]
		],
		[
			[120629, 120629],
			"mapped",
			[8711]
		],
		[
			[120630, 120630],
			"mapped",
			[945]
		],
		[
			[120631, 120631],
			"mapped",
			[946]
		],
		[
			[120632, 120632],
			"mapped",
			[947]
		],
		[
			[120633, 120633],
			"mapped",
			[948]
		],
		[
			[120634, 120634],
			"mapped",
			[949]
		],
		[
			[120635, 120635],
			"mapped",
			[950]
		],
		[
			[120636, 120636],
			"mapped",
			[951]
		],
		[
			[120637, 120637],
			"mapped",
			[952]
		],
		[
			[120638, 120638],
			"mapped",
			[953]
		],
		[
			[120639, 120639],
			"mapped",
			[954]
		],
		[
			[120640, 120640],
			"mapped",
			[955]
		],
		[
			[120641, 120641],
			"mapped",
			[956]
		],
		[
			[120642, 120642],
			"mapped",
			[957]
		],
		[
			[120643, 120643],
			"mapped",
			[958]
		],
		[
			[120644, 120644],
			"mapped",
			[959]
		],
		[
			[120645, 120645],
			"mapped",
			[960]
		],
		[
			[120646, 120646],
			"mapped",
			[961]
		],
		[
			[120647, 120648],
			"mapped",
			[963]
		],
		[
			[120649, 120649],
			"mapped",
			[964]
		],
		[
			[120650, 120650],
			"mapped",
			[965]
		],
		[
			[120651, 120651],
			"mapped",
			[966]
		],
		[
			[120652, 120652],
			"mapped",
			[967]
		],
		[
			[120653, 120653],
			"mapped",
			[968]
		],
		[
			[120654, 120654],
			"mapped",
			[969]
		],
		[
			[120655, 120655],
			"mapped",
			[8706]
		],
		[
			[120656, 120656],
			"mapped",
			[949]
		],
		[
			[120657, 120657],
			"mapped",
			[952]
		],
		[
			[120658, 120658],
			"mapped",
			[954]
		],
		[
			[120659, 120659],
			"mapped",
			[966]
		],
		[
			[120660, 120660],
			"mapped",
			[961]
		],
		[
			[120661, 120661],
			"mapped",
			[960]
		],
		[
			[120662, 120662],
			"mapped",
			[945]
		],
		[
			[120663, 120663],
			"mapped",
			[946]
		],
		[
			[120664, 120664],
			"mapped",
			[947]
		],
		[
			[120665, 120665],
			"mapped",
			[948]
		],
		[
			[120666, 120666],
			"mapped",
			[949]
		],
		[
			[120667, 120667],
			"mapped",
			[950]
		],
		[
			[120668, 120668],
			"mapped",
			[951]
		],
		[
			[120669, 120669],
			"mapped",
			[952]
		],
		[
			[120670, 120670],
			"mapped",
			[953]
		],
		[
			[120671, 120671],
			"mapped",
			[954]
		],
		[
			[120672, 120672],
			"mapped",
			[955]
		],
		[
			[120673, 120673],
			"mapped",
			[956]
		],
		[
			[120674, 120674],
			"mapped",
			[957]
		],
		[
			[120675, 120675],
			"mapped",
			[958]
		],
		[
			[120676, 120676],
			"mapped",
			[959]
		],
		[
			[120677, 120677],
			"mapped",
			[960]
		],
		[
			[120678, 120678],
			"mapped",
			[961]
		],
		[
			[120679, 120679],
			"mapped",
			[952]
		],
		[
			[120680, 120680],
			"mapped",
			[963]
		],
		[
			[120681, 120681],
			"mapped",
			[964]
		],
		[
			[120682, 120682],
			"mapped",
			[965]
		],
		[
			[120683, 120683],
			"mapped",
			[966]
		],
		[
			[120684, 120684],
			"mapped",
			[967]
		],
		[
			[120685, 120685],
			"mapped",
			[968]
		],
		[
			[120686, 120686],
			"mapped",
			[969]
		],
		[
			[120687, 120687],
			"mapped",
			[8711]
		],
		[
			[120688, 120688],
			"mapped",
			[945]
		],
		[
			[120689, 120689],
			"mapped",
			[946]
		],
		[
			[120690, 120690],
			"mapped",
			[947]
		],
		[
			[120691, 120691],
			"mapped",
			[948]
		],
		[
			[120692, 120692],
			"mapped",
			[949]
		],
		[
			[120693, 120693],
			"mapped",
			[950]
		],
		[
			[120694, 120694],
			"mapped",
			[951]
		],
		[
			[120695, 120695],
			"mapped",
			[952]
		],
		[
			[120696, 120696],
			"mapped",
			[953]
		],
		[
			[120697, 120697],
			"mapped",
			[954]
		],
		[
			[120698, 120698],
			"mapped",
			[955]
		],
		[
			[120699, 120699],
			"mapped",
			[956]
		],
		[
			[120700, 120700],
			"mapped",
			[957]
		],
		[
			[120701, 120701],
			"mapped",
			[958]
		],
		[
			[120702, 120702],
			"mapped",
			[959]
		],
		[
			[120703, 120703],
			"mapped",
			[960]
		],
		[
			[120704, 120704],
			"mapped",
			[961]
		],
		[
			[120705, 120706],
			"mapped",
			[963]
		],
		[
			[120707, 120707],
			"mapped",
			[964]
		],
		[
			[120708, 120708],
			"mapped",
			[965]
		],
		[
			[120709, 120709],
			"mapped",
			[966]
		],
		[
			[120710, 120710],
			"mapped",
			[967]
		],
		[
			[120711, 120711],
			"mapped",
			[968]
		],
		[
			[120712, 120712],
			"mapped",
			[969]
		],
		[
			[120713, 120713],
			"mapped",
			[8706]
		],
		[
			[120714, 120714],
			"mapped",
			[949]
		],
		[
			[120715, 120715],
			"mapped",
			[952]
		],
		[
			[120716, 120716],
			"mapped",
			[954]
		],
		[
			[120717, 120717],
			"mapped",
			[966]
		],
		[
			[120718, 120718],
			"mapped",
			[961]
		],
		[
			[120719, 120719],
			"mapped",
			[960]
		],
		[
			[120720, 120720],
			"mapped",
			[945]
		],
		[
			[120721, 120721],
			"mapped",
			[946]
		],
		[
			[120722, 120722],
			"mapped",
			[947]
		],
		[
			[120723, 120723],
			"mapped",
			[948]
		],
		[
			[120724, 120724],
			"mapped",
			[949]
		],
		[
			[120725, 120725],
			"mapped",
			[950]
		],
		[
			[120726, 120726],
			"mapped",
			[951]
		],
		[
			[120727, 120727],
			"mapped",
			[952]
		],
		[
			[120728, 120728],
			"mapped",
			[953]
		],
		[
			[120729, 120729],
			"mapped",
			[954]
		],
		[
			[120730, 120730],
			"mapped",
			[955]
		],
		[
			[120731, 120731],
			"mapped",
			[956]
		],
		[
			[120732, 120732],
			"mapped",
			[957]
		],
		[
			[120733, 120733],
			"mapped",
			[958]
		],
		[
			[120734, 120734],
			"mapped",
			[959]
		],
		[
			[120735, 120735],
			"mapped",
			[960]
		],
		[
			[120736, 120736],
			"mapped",
			[961]
		],
		[
			[120737, 120737],
			"mapped",
			[952]
		],
		[
			[120738, 120738],
			"mapped",
			[963]
		],
		[
			[120739, 120739],
			"mapped",
			[964]
		],
		[
			[120740, 120740],
			"mapped",
			[965]
		],
		[
			[120741, 120741],
			"mapped",
			[966]
		],
		[
			[120742, 120742],
			"mapped",
			[967]
		],
		[
			[120743, 120743],
			"mapped",
			[968]
		],
		[
			[120744, 120744],
			"mapped",
			[969]
		],
		[
			[120745, 120745],
			"mapped",
			[8711]
		],
		[
			[120746, 120746],
			"mapped",
			[945]
		],
		[
			[120747, 120747],
			"mapped",
			[946]
		],
		[
			[120748, 120748],
			"mapped",
			[947]
		],
		[
			[120749, 120749],
			"mapped",
			[948]
		],
		[
			[120750, 120750],
			"mapped",
			[949]
		],
		[
			[120751, 120751],
			"mapped",
			[950]
		],
		[
			[120752, 120752],
			"mapped",
			[951]
		],
		[
			[120753, 120753],
			"mapped",
			[952]
		],
		[
			[120754, 120754],
			"mapped",
			[953]
		],
		[
			[120755, 120755],
			"mapped",
			[954]
		],
		[
			[120756, 120756],
			"mapped",
			[955]
		],
		[
			[120757, 120757],
			"mapped",
			[956]
		],
		[
			[120758, 120758],
			"mapped",
			[957]
		],
		[
			[120759, 120759],
			"mapped",
			[958]
		],
		[
			[120760, 120760],
			"mapped",
			[959]
		],
		[
			[120761, 120761],
			"mapped",
			[960]
		],
		[
			[120762, 120762],
			"mapped",
			[961]
		],
		[
			[120763, 120764],
			"mapped",
			[963]
		],
		[
			[120765, 120765],
			"mapped",
			[964]
		],
		[
			[120766, 120766],
			"mapped",
			[965]
		],
		[
			[120767, 120767],
			"mapped",
			[966]
		],
		[
			[120768, 120768],
			"mapped",
			[967]
		],
		[
			[120769, 120769],
			"mapped",
			[968]
		],
		[
			[120770, 120770],
			"mapped",
			[969]
		],
		[
			[120771, 120771],
			"mapped",
			[8706]
		],
		[
			[120772, 120772],
			"mapped",
			[949]
		],
		[
			[120773, 120773],
			"mapped",
			[952]
		],
		[
			[120774, 120774],
			"mapped",
			[954]
		],
		[
			[120775, 120775],
			"mapped",
			[966]
		],
		[
			[120776, 120776],
			"mapped",
			[961]
		],
		[
			[120777, 120777],
			"mapped",
			[960]
		],
		[
			[120778, 120779],
			"mapped",
			[989]
		],
		[[120780, 120781], "disallowed"],
		[
			[120782, 120782],
			"mapped",
			[48]
		],
		[
			[120783, 120783],
			"mapped",
			[49]
		],
		[
			[120784, 120784],
			"mapped",
			[50]
		],
		[
			[120785, 120785],
			"mapped",
			[51]
		],
		[
			[120786, 120786],
			"mapped",
			[52]
		],
		[
			[120787, 120787],
			"mapped",
			[53]
		],
		[
			[120788, 120788],
			"mapped",
			[54]
		],
		[
			[120789, 120789],
			"mapped",
			[55]
		],
		[
			[120790, 120790],
			"mapped",
			[56]
		],
		[
			[120791, 120791],
			"mapped",
			[57]
		],
		[
			[120792, 120792],
			"mapped",
			[48]
		],
		[
			[120793, 120793],
			"mapped",
			[49]
		],
		[
			[120794, 120794],
			"mapped",
			[50]
		],
		[
			[120795, 120795],
			"mapped",
			[51]
		],
		[
			[120796, 120796],
			"mapped",
			[52]
		],
		[
			[120797, 120797],
			"mapped",
			[53]
		],
		[
			[120798, 120798],
			"mapped",
			[54]
		],
		[
			[120799, 120799],
			"mapped",
			[55]
		],
		[
			[120800, 120800],
			"mapped",
			[56]
		],
		[
			[120801, 120801],
			"mapped",
			[57]
		],
		[
			[120802, 120802],
			"mapped",
			[48]
		],
		[
			[120803, 120803],
			"mapped",
			[49]
		],
		[
			[120804, 120804],
			"mapped",
			[50]
		],
		[
			[120805, 120805],
			"mapped",
			[51]
		],
		[
			[120806, 120806],
			"mapped",
			[52]
		],
		[
			[120807, 120807],
			"mapped",
			[53]
		],
		[
			[120808, 120808],
			"mapped",
			[54]
		],
		[
			[120809, 120809],
			"mapped",
			[55]
		],
		[
			[120810, 120810],
			"mapped",
			[56]
		],
		[
			[120811, 120811],
			"mapped",
			[57]
		],
		[
			[120812, 120812],
			"mapped",
			[48]
		],
		[
			[120813, 120813],
			"mapped",
			[49]
		],
		[
			[120814, 120814],
			"mapped",
			[50]
		],
		[
			[120815, 120815],
			"mapped",
			[51]
		],
		[
			[120816, 120816],
			"mapped",
			[52]
		],
		[
			[120817, 120817],
			"mapped",
			[53]
		],
		[
			[120818, 120818],
			"mapped",
			[54]
		],
		[
			[120819, 120819],
			"mapped",
			[55]
		],
		[
			[120820, 120820],
			"mapped",
			[56]
		],
		[
			[120821, 120821],
			"mapped",
			[57]
		],
		[
			[120822, 120822],
			"mapped",
			[48]
		],
		[
			[120823, 120823],
			"mapped",
			[49]
		],
		[
			[120824, 120824],
			"mapped",
			[50]
		],
		[
			[120825, 120825],
			"mapped",
			[51]
		],
		[
			[120826, 120826],
			"mapped",
			[52]
		],
		[
			[120827, 120827],
			"mapped",
			[53]
		],
		[
			[120828, 120828],
			"mapped",
			[54]
		],
		[
			[120829, 120829],
			"mapped",
			[55]
		],
		[
			[120830, 120830],
			"mapped",
			[56]
		],
		[
			[120831, 120831],
			"mapped",
			[57]
		],
		[
			[120832, 121343],
			"valid",
			[],
			"NV8"
		],
		[[121344, 121398], "valid"],
		[
			[121399, 121402],
			"valid",
			[],
			"NV8"
		],
		[[121403, 121452], "valid"],
		[
			[121453, 121460],
			"valid",
			[],
			"NV8"
		],
		[[121461, 121461], "valid"],
		[
			[121462, 121475],
			"valid",
			[],
			"NV8"
		],
		[[121476, 121476], "valid"],
		[
			[121477, 121483],
			"valid",
			[],
			"NV8"
		],
		[[121484, 121498], "disallowed"],
		[[121499, 121503], "valid"],
		[[121504, 121504], "disallowed"],
		[[121505, 121519], "valid"],
		[[121520, 124927], "disallowed"],
		[[124928, 125124], "valid"],
		[[125125, 125126], "disallowed"],
		[
			[125127, 125135],
			"valid",
			[],
			"NV8"
		],
		[[125136, 125142], "valid"],
		[[125143, 126463], "disallowed"],
		[
			[126464, 126464],
			"mapped",
			[1575]
		],
		[
			[126465, 126465],
			"mapped",
			[1576]
		],
		[
			[126466, 126466],
			"mapped",
			[1580]
		],
		[
			[126467, 126467],
			"mapped",
			[1583]
		],
		[[126468, 126468], "disallowed"],
		[
			[126469, 126469],
			"mapped",
			[1608]
		],
		[
			[126470, 126470],
			"mapped",
			[1586]
		],
		[
			[126471, 126471],
			"mapped",
			[1581]
		],
		[
			[126472, 126472],
			"mapped",
			[1591]
		],
		[
			[126473, 126473],
			"mapped",
			[1610]
		],
		[
			[126474, 126474],
			"mapped",
			[1603]
		],
		[
			[126475, 126475],
			"mapped",
			[1604]
		],
		[
			[126476, 126476],
			"mapped",
			[1605]
		],
		[
			[126477, 126477],
			"mapped",
			[1606]
		],
		[
			[126478, 126478],
			"mapped",
			[1587]
		],
		[
			[126479, 126479],
			"mapped",
			[1593]
		],
		[
			[126480, 126480],
			"mapped",
			[1601]
		],
		[
			[126481, 126481],
			"mapped",
			[1589]
		],
		[
			[126482, 126482],
			"mapped",
			[1602]
		],
		[
			[126483, 126483],
			"mapped",
			[1585]
		],
		[
			[126484, 126484],
			"mapped",
			[1588]
		],
		[
			[126485, 126485],
			"mapped",
			[1578]
		],
		[
			[126486, 126486],
			"mapped",
			[1579]
		],
		[
			[126487, 126487],
			"mapped",
			[1582]
		],
		[
			[126488, 126488],
			"mapped",
			[1584]
		],
		[
			[126489, 126489],
			"mapped",
			[1590]
		],
		[
			[126490, 126490],
			"mapped",
			[1592]
		],
		[
			[126491, 126491],
			"mapped",
			[1594]
		],
		[
			[126492, 126492],
			"mapped",
			[1646]
		],
		[
			[126493, 126493],
			"mapped",
			[1722]
		],
		[
			[126494, 126494],
			"mapped",
			[1697]
		],
		[
			[126495, 126495],
			"mapped",
			[1647]
		],
		[[126496, 126496], "disallowed"],
		[
			[126497, 126497],
			"mapped",
			[1576]
		],
		[
			[126498, 126498],
			"mapped",
			[1580]
		],
		[[126499, 126499], "disallowed"],
		[
			[126500, 126500],
			"mapped",
			[1607]
		],
		[[126501, 126502], "disallowed"],
		[
			[126503, 126503],
			"mapped",
			[1581]
		],
		[[126504, 126504], "disallowed"],
		[
			[126505, 126505],
			"mapped",
			[1610]
		],
		[
			[126506, 126506],
			"mapped",
			[1603]
		],
		[
			[126507, 126507],
			"mapped",
			[1604]
		],
		[
			[126508, 126508],
			"mapped",
			[1605]
		],
		[
			[126509, 126509],
			"mapped",
			[1606]
		],
		[
			[126510, 126510],
			"mapped",
			[1587]
		],
		[
			[126511, 126511],
			"mapped",
			[1593]
		],
		[
			[126512, 126512],
			"mapped",
			[1601]
		],
		[
			[126513, 126513],
			"mapped",
			[1589]
		],
		[
			[126514, 126514],
			"mapped",
			[1602]
		],
		[[126515, 126515], "disallowed"],
		[
			[126516, 126516],
			"mapped",
			[1588]
		],
		[
			[126517, 126517],
			"mapped",
			[1578]
		],
		[
			[126518, 126518],
			"mapped",
			[1579]
		],
		[
			[126519, 126519],
			"mapped",
			[1582]
		],
		[[126520, 126520], "disallowed"],
		[
			[126521, 126521],
			"mapped",
			[1590]
		],
		[[126522, 126522], "disallowed"],
		[
			[126523, 126523],
			"mapped",
			[1594]
		],
		[[126524, 126529], "disallowed"],
		[
			[126530, 126530],
			"mapped",
			[1580]
		],
		[[126531, 126534], "disallowed"],
		[
			[126535, 126535],
			"mapped",
			[1581]
		],
		[[126536, 126536], "disallowed"],
		[
			[126537, 126537],
			"mapped",
			[1610]
		],
		[[126538, 126538], "disallowed"],
		[
			[126539, 126539],
			"mapped",
			[1604]
		],
		[[126540, 126540], "disallowed"],
		[
			[126541, 126541],
			"mapped",
			[1606]
		],
		[
			[126542, 126542],
			"mapped",
			[1587]
		],
		[
			[126543, 126543],
			"mapped",
			[1593]
		],
		[[126544, 126544], "disallowed"],
		[
			[126545, 126545],
			"mapped",
			[1589]
		],
		[
			[126546, 126546],
			"mapped",
			[1602]
		],
		[[126547, 126547], "disallowed"],
		[
			[126548, 126548],
			"mapped",
			[1588]
		],
		[[126549, 126550], "disallowed"],
		[
			[126551, 126551],
			"mapped",
			[1582]
		],
		[[126552, 126552], "disallowed"],
		[
			[126553, 126553],
			"mapped",
			[1590]
		],
		[[126554, 126554], "disallowed"],
		[
			[126555, 126555],
			"mapped",
			[1594]
		],
		[[126556, 126556], "disallowed"],
		[
			[126557, 126557],
			"mapped",
			[1722]
		],
		[[126558, 126558], "disallowed"],
		[
			[126559, 126559],
			"mapped",
			[1647]
		],
		[[126560, 126560], "disallowed"],
		[
			[126561, 126561],
			"mapped",
			[1576]
		],
		[
			[126562, 126562],
			"mapped",
			[1580]
		],
		[[126563, 126563], "disallowed"],
		[
			[126564, 126564],
			"mapped",
			[1607]
		],
		[[126565, 126566], "disallowed"],
		[
			[126567, 126567],
			"mapped",
			[1581]
		],
		[
			[126568, 126568],
			"mapped",
			[1591]
		],
		[
			[126569, 126569],
			"mapped",
			[1610]
		],
		[
			[126570, 126570],
			"mapped",
			[1603]
		],
		[[126571, 126571], "disallowed"],
		[
			[126572, 126572],
			"mapped",
			[1605]
		],
		[
			[126573, 126573],
			"mapped",
			[1606]
		],
		[
			[126574, 126574],
			"mapped",
			[1587]
		],
		[
			[126575, 126575],
			"mapped",
			[1593]
		],
		[
			[126576, 126576],
			"mapped",
			[1601]
		],
		[
			[126577, 126577],
			"mapped",
			[1589]
		],
		[
			[126578, 126578],
			"mapped",
			[1602]
		],
		[[126579, 126579], "disallowed"],
		[
			[126580, 126580],
			"mapped",
			[1588]
		],
		[
			[126581, 126581],
			"mapped",
			[1578]
		],
		[
			[126582, 126582],
			"mapped",
			[1579]
		],
		[
			[126583, 126583],
			"mapped",
			[1582]
		],
		[[126584, 126584], "disallowed"],
		[
			[126585, 126585],
			"mapped",
			[1590]
		],
		[
			[126586, 126586],
			"mapped",
			[1592]
		],
		[
			[126587, 126587],
			"mapped",
			[1594]
		],
		[
			[126588, 126588],
			"mapped",
			[1646]
		],
		[[126589, 126589], "disallowed"],
		[
			[126590, 126590],
			"mapped",
			[1697]
		],
		[[126591, 126591], "disallowed"],
		[
			[126592, 126592],
			"mapped",
			[1575]
		],
		[
			[126593, 126593],
			"mapped",
			[1576]
		],
		[
			[126594, 126594],
			"mapped",
			[1580]
		],
		[
			[126595, 126595],
			"mapped",
			[1583]
		],
		[
			[126596, 126596],
			"mapped",
			[1607]
		],
		[
			[126597, 126597],
			"mapped",
			[1608]
		],
		[
			[126598, 126598],
			"mapped",
			[1586]
		],
		[
			[126599, 126599],
			"mapped",
			[1581]
		],
		[
			[126600, 126600],
			"mapped",
			[1591]
		],
		[
			[126601, 126601],
			"mapped",
			[1610]
		],
		[[126602, 126602], "disallowed"],
		[
			[126603, 126603],
			"mapped",
			[1604]
		],
		[
			[126604, 126604],
			"mapped",
			[1605]
		],
		[
			[126605, 126605],
			"mapped",
			[1606]
		],
		[
			[126606, 126606],
			"mapped",
			[1587]
		],
		[
			[126607, 126607],
			"mapped",
			[1593]
		],
		[
			[126608, 126608],
			"mapped",
			[1601]
		],
		[
			[126609, 126609],
			"mapped",
			[1589]
		],
		[
			[126610, 126610],
			"mapped",
			[1602]
		],
		[
			[126611, 126611],
			"mapped",
			[1585]
		],
		[
			[126612, 126612],
			"mapped",
			[1588]
		],
		[
			[126613, 126613],
			"mapped",
			[1578]
		],
		[
			[126614, 126614],
			"mapped",
			[1579]
		],
		[
			[126615, 126615],
			"mapped",
			[1582]
		],
		[
			[126616, 126616],
			"mapped",
			[1584]
		],
		[
			[126617, 126617],
			"mapped",
			[1590]
		],
		[
			[126618, 126618],
			"mapped",
			[1592]
		],
		[
			[126619, 126619],
			"mapped",
			[1594]
		],
		[[126620, 126624], "disallowed"],
		[
			[126625, 126625],
			"mapped",
			[1576]
		],
		[
			[126626, 126626],
			"mapped",
			[1580]
		],
		[
			[126627, 126627],
			"mapped",
			[1583]
		],
		[[126628, 126628], "disallowed"],
		[
			[126629, 126629],
			"mapped",
			[1608]
		],
		[
			[126630, 126630],
			"mapped",
			[1586]
		],
		[
			[126631, 126631],
			"mapped",
			[1581]
		],
		[
			[126632, 126632],
			"mapped",
			[1591]
		],
		[
			[126633, 126633],
			"mapped",
			[1610]
		],
		[[126634, 126634], "disallowed"],
		[
			[126635, 126635],
			"mapped",
			[1604]
		],
		[
			[126636, 126636],
			"mapped",
			[1605]
		],
		[
			[126637, 126637],
			"mapped",
			[1606]
		],
		[
			[126638, 126638],
			"mapped",
			[1587]
		],
		[
			[126639, 126639],
			"mapped",
			[1593]
		],
		[
			[126640, 126640],
			"mapped",
			[1601]
		],
		[
			[126641, 126641],
			"mapped",
			[1589]
		],
		[
			[126642, 126642],
			"mapped",
			[1602]
		],
		[
			[126643, 126643],
			"mapped",
			[1585]
		],
		[
			[126644, 126644],
			"mapped",
			[1588]
		],
		[
			[126645, 126645],
			"mapped",
			[1578]
		],
		[
			[126646, 126646],
			"mapped",
			[1579]
		],
		[
			[126647, 126647],
			"mapped",
			[1582]
		],
		[
			[126648, 126648],
			"mapped",
			[1584]
		],
		[
			[126649, 126649],
			"mapped",
			[1590]
		],
		[
			[126650, 126650],
			"mapped",
			[1592]
		],
		[
			[126651, 126651],
			"mapped",
			[1594]
		],
		[[126652, 126703], "disallowed"],
		[
			[126704, 126705],
			"valid",
			[],
			"NV8"
		],
		[[126706, 126975], "disallowed"],
		[
			[126976, 127019],
			"valid",
			[],
			"NV8"
		],
		[[127020, 127023], "disallowed"],
		[
			[127024, 127123],
			"valid",
			[],
			"NV8"
		],
		[[127124, 127135], "disallowed"],
		[
			[127136, 127150],
			"valid",
			[],
			"NV8"
		],
		[[127151, 127152], "disallowed"],
		[
			[127153, 127166],
			"valid",
			[],
			"NV8"
		],
		[
			[127167, 127167],
			"valid",
			[],
			"NV8"
		],
		[[127168, 127168], "disallowed"],
		[
			[127169, 127183],
			"valid",
			[],
			"NV8"
		],
		[[127184, 127184], "disallowed"],
		[
			[127185, 127199],
			"valid",
			[],
			"NV8"
		],
		[
			[127200, 127221],
			"valid",
			[],
			"NV8"
		],
		[[127222, 127231], "disallowed"],
		[[127232, 127232], "disallowed"],
		[
			[127233, 127233],
			"disallowed_STD3_mapped",
			[48, 44]
		],
		[
			[127234, 127234],
			"disallowed_STD3_mapped",
			[49, 44]
		],
		[
			[127235, 127235],
			"disallowed_STD3_mapped",
			[50, 44]
		],
		[
			[127236, 127236],
			"disallowed_STD3_mapped",
			[51, 44]
		],
		[
			[127237, 127237],
			"disallowed_STD3_mapped",
			[52, 44]
		],
		[
			[127238, 127238],
			"disallowed_STD3_mapped",
			[53, 44]
		],
		[
			[127239, 127239],
			"disallowed_STD3_mapped",
			[54, 44]
		],
		[
			[127240, 127240],
			"disallowed_STD3_mapped",
			[55, 44]
		],
		[
			[127241, 127241],
			"disallowed_STD3_mapped",
			[56, 44]
		],
		[
			[127242, 127242],
			"disallowed_STD3_mapped",
			[57, 44]
		],
		[
			[127243, 127244],
			"valid",
			[],
			"NV8"
		],
		[[127245, 127247], "disallowed"],
		[
			[127248, 127248],
			"disallowed_STD3_mapped",
			[
				40,
				97,
				41
			]
		],
		[
			[127249, 127249],
			"disallowed_STD3_mapped",
			[
				40,
				98,
				41
			]
		],
		[
			[127250, 127250],
			"disallowed_STD3_mapped",
			[
				40,
				99,
				41
			]
		],
		[
			[127251, 127251],
			"disallowed_STD3_mapped",
			[
				40,
				100,
				41
			]
		],
		[
			[127252, 127252],
			"disallowed_STD3_mapped",
			[
				40,
				101,
				41
			]
		],
		[
			[127253, 127253],
			"disallowed_STD3_mapped",
			[
				40,
				102,
				41
			]
		],
		[
			[127254, 127254],
			"disallowed_STD3_mapped",
			[
				40,
				103,
				41
			]
		],
		[
			[127255, 127255],
			"disallowed_STD3_mapped",
			[
				40,
				104,
				41
			]
		],
		[
			[127256, 127256],
			"disallowed_STD3_mapped",
			[
				40,
				105,
				41
			]
		],
		[
			[127257, 127257],
			"disallowed_STD3_mapped",
			[
				40,
				106,
				41
			]
		],
		[
			[127258, 127258],
			"disallowed_STD3_mapped",
			[
				40,
				107,
				41
			]
		],
		[
			[127259, 127259],
			"disallowed_STD3_mapped",
			[
				40,
				108,
				41
			]
		],
		[
			[127260, 127260],
			"disallowed_STD3_mapped",
			[
				40,
				109,
				41
			]
		],
		[
			[127261, 127261],
			"disallowed_STD3_mapped",
			[
				40,
				110,
				41
			]
		],
		[
			[127262, 127262],
			"disallowed_STD3_mapped",
			[
				40,
				111,
				41
			]
		],
		[
			[127263, 127263],
			"disallowed_STD3_mapped",
			[
				40,
				112,
				41
			]
		],
		[
			[127264, 127264],
			"disallowed_STD3_mapped",
			[
				40,
				113,
				41
			]
		],
		[
			[127265, 127265],
			"disallowed_STD3_mapped",
			[
				40,
				114,
				41
			]
		],
		[
			[127266, 127266],
			"disallowed_STD3_mapped",
			[
				40,
				115,
				41
			]
		],
		[
			[127267, 127267],
			"disallowed_STD3_mapped",
			[
				40,
				116,
				41
			]
		],
		[
			[127268, 127268],
			"disallowed_STD3_mapped",
			[
				40,
				117,
				41
			]
		],
		[
			[127269, 127269],
			"disallowed_STD3_mapped",
			[
				40,
				118,
				41
			]
		],
		[
			[127270, 127270],
			"disallowed_STD3_mapped",
			[
				40,
				119,
				41
			]
		],
		[
			[127271, 127271],
			"disallowed_STD3_mapped",
			[
				40,
				120,
				41
			]
		],
		[
			[127272, 127272],
			"disallowed_STD3_mapped",
			[
				40,
				121,
				41
			]
		],
		[
			[127273, 127273],
			"disallowed_STD3_mapped",
			[
				40,
				122,
				41
			]
		],
		[
			[127274, 127274],
			"mapped",
			[
				12308,
				115,
				12309
			]
		],
		[
			[127275, 127275],
			"mapped",
			[99]
		],
		[
			[127276, 127276],
			"mapped",
			[114]
		],
		[
			[127277, 127277],
			"mapped",
			[99, 100]
		],
		[
			[127278, 127278],
			"mapped",
			[119, 122]
		],
		[[127279, 127279], "disallowed"],
		[
			[127280, 127280],
			"mapped",
			[97]
		],
		[
			[127281, 127281],
			"mapped",
			[98]
		],
		[
			[127282, 127282],
			"mapped",
			[99]
		],
		[
			[127283, 127283],
			"mapped",
			[100]
		],
		[
			[127284, 127284],
			"mapped",
			[101]
		],
		[
			[127285, 127285],
			"mapped",
			[102]
		],
		[
			[127286, 127286],
			"mapped",
			[103]
		],
		[
			[127287, 127287],
			"mapped",
			[104]
		],
		[
			[127288, 127288],
			"mapped",
			[105]
		],
		[
			[127289, 127289],
			"mapped",
			[106]
		],
		[
			[127290, 127290],
			"mapped",
			[107]
		],
		[
			[127291, 127291],
			"mapped",
			[108]
		],
		[
			[127292, 127292],
			"mapped",
			[109]
		],
		[
			[127293, 127293],
			"mapped",
			[110]
		],
		[
			[127294, 127294],
			"mapped",
			[111]
		],
		[
			[127295, 127295],
			"mapped",
			[112]
		],
		[
			[127296, 127296],
			"mapped",
			[113]
		],
		[
			[127297, 127297],
			"mapped",
			[114]
		],
		[
			[127298, 127298],
			"mapped",
			[115]
		],
		[
			[127299, 127299],
			"mapped",
			[116]
		],
		[
			[127300, 127300],
			"mapped",
			[117]
		],
		[
			[127301, 127301],
			"mapped",
			[118]
		],
		[
			[127302, 127302],
			"mapped",
			[119]
		],
		[
			[127303, 127303],
			"mapped",
			[120]
		],
		[
			[127304, 127304],
			"mapped",
			[121]
		],
		[
			[127305, 127305],
			"mapped",
			[122]
		],
		[
			[127306, 127306],
			"mapped",
			[104, 118]
		],
		[
			[127307, 127307],
			"mapped",
			[109, 118]
		],
		[
			[127308, 127308],
			"mapped",
			[115, 100]
		],
		[
			[127309, 127309],
			"mapped",
			[115, 115]
		],
		[
			[127310, 127310],
			"mapped",
			[
				112,
				112,
				118
			]
		],
		[
			[127311, 127311],
			"mapped",
			[119, 99]
		],
		[
			[127312, 127318],
			"valid",
			[],
			"NV8"
		],
		[
			[127319, 127319],
			"valid",
			[],
			"NV8"
		],
		[
			[127320, 127326],
			"valid",
			[],
			"NV8"
		],
		[
			[127327, 127327],
			"valid",
			[],
			"NV8"
		],
		[
			[127328, 127337],
			"valid",
			[],
			"NV8"
		],
		[
			[127338, 127338],
			"mapped",
			[109, 99]
		],
		[
			[127339, 127339],
			"mapped",
			[109, 100]
		],
		[[127340, 127343], "disallowed"],
		[
			[127344, 127352],
			"valid",
			[],
			"NV8"
		],
		[
			[127353, 127353],
			"valid",
			[],
			"NV8"
		],
		[
			[127354, 127354],
			"valid",
			[],
			"NV8"
		],
		[
			[127355, 127356],
			"valid",
			[],
			"NV8"
		],
		[
			[127357, 127358],
			"valid",
			[],
			"NV8"
		],
		[
			[127359, 127359],
			"valid",
			[],
			"NV8"
		],
		[
			[127360, 127369],
			"valid",
			[],
			"NV8"
		],
		[
			[127370, 127373],
			"valid",
			[],
			"NV8"
		],
		[
			[127374, 127375],
			"valid",
			[],
			"NV8"
		],
		[
			[127376, 127376],
			"mapped",
			[100, 106]
		],
		[
			[127377, 127386],
			"valid",
			[],
			"NV8"
		],
		[[127387, 127461], "disallowed"],
		[
			[127462, 127487],
			"valid",
			[],
			"NV8"
		],
		[
			[127488, 127488],
			"mapped",
			[12411, 12363]
		],
		[
			[127489, 127489],
			"mapped",
			[12467, 12467]
		],
		[
			[127490, 127490],
			"mapped",
			[12469]
		],
		[[127491, 127503], "disallowed"],
		[
			[127504, 127504],
			"mapped",
			[25163]
		],
		[
			[127505, 127505],
			"mapped",
			[23383]
		],
		[
			[127506, 127506],
			"mapped",
			[21452]
		],
		[
			[127507, 127507],
			"mapped",
			[12487]
		],
		[
			[127508, 127508],
			"mapped",
			[20108]
		],
		[
			[127509, 127509],
			"mapped",
			[22810]
		],
		[
			[127510, 127510],
			"mapped",
			[35299]
		],
		[
			[127511, 127511],
			"mapped",
			[22825]
		],
		[
			[127512, 127512],
			"mapped",
			[20132]
		],
		[
			[127513, 127513],
			"mapped",
			[26144]
		],
		[
			[127514, 127514],
			"mapped",
			[28961]
		],
		[
			[127515, 127515],
			"mapped",
			[26009]
		],
		[
			[127516, 127516],
			"mapped",
			[21069]
		],
		[
			[127517, 127517],
			"mapped",
			[24460]
		],
		[
			[127518, 127518],
			"mapped",
			[20877]
		],
		[
			[127519, 127519],
			"mapped",
			[26032]
		],
		[
			[127520, 127520],
			"mapped",
			[21021]
		],
		[
			[127521, 127521],
			"mapped",
			[32066]
		],
		[
			[127522, 127522],
			"mapped",
			[29983]
		],
		[
			[127523, 127523],
			"mapped",
			[36009]
		],
		[
			[127524, 127524],
			"mapped",
			[22768]
		],
		[
			[127525, 127525],
			"mapped",
			[21561]
		],
		[
			[127526, 127526],
			"mapped",
			[28436]
		],
		[
			[127527, 127527],
			"mapped",
			[25237]
		],
		[
			[127528, 127528],
			"mapped",
			[25429]
		],
		[
			[127529, 127529],
			"mapped",
			[19968]
		],
		[
			[127530, 127530],
			"mapped",
			[19977]
		],
		[
			[127531, 127531],
			"mapped",
			[36938]
		],
		[
			[127532, 127532],
			"mapped",
			[24038]
		],
		[
			[127533, 127533],
			"mapped",
			[20013]
		],
		[
			[127534, 127534],
			"mapped",
			[21491]
		],
		[
			[127535, 127535],
			"mapped",
			[25351]
		],
		[
			[127536, 127536],
			"mapped",
			[36208]
		],
		[
			[127537, 127537],
			"mapped",
			[25171]
		],
		[
			[127538, 127538],
			"mapped",
			[31105]
		],
		[
			[127539, 127539],
			"mapped",
			[31354]
		],
		[
			[127540, 127540],
			"mapped",
			[21512]
		],
		[
			[127541, 127541],
			"mapped",
			[28288]
		],
		[
			[127542, 127542],
			"mapped",
			[26377]
		],
		[
			[127543, 127543],
			"mapped",
			[26376]
		],
		[
			[127544, 127544],
			"mapped",
			[30003]
		],
		[
			[127545, 127545],
			"mapped",
			[21106]
		],
		[
			[127546, 127546],
			"mapped",
			[21942]
		],
		[[127547, 127551], "disallowed"],
		[
			[127552, 127552],
			"mapped",
			[
				12308,
				26412,
				12309
			]
		],
		[
			[127553, 127553],
			"mapped",
			[
				12308,
				19977,
				12309
			]
		],
		[
			[127554, 127554],
			"mapped",
			[
				12308,
				20108,
				12309
			]
		],
		[
			[127555, 127555],
			"mapped",
			[
				12308,
				23433,
				12309
			]
		],
		[
			[127556, 127556],
			"mapped",
			[
				12308,
				28857,
				12309
			]
		],
		[
			[127557, 127557],
			"mapped",
			[
				12308,
				25171,
				12309
			]
		],
		[
			[127558, 127558],
			"mapped",
			[
				12308,
				30423,
				12309
			]
		],
		[
			[127559, 127559],
			"mapped",
			[
				12308,
				21213,
				12309
			]
		],
		[
			[127560, 127560],
			"mapped",
			[
				12308,
				25943,
				12309
			]
		],
		[[127561, 127567], "disallowed"],
		[
			[127568, 127568],
			"mapped",
			[24471]
		],
		[
			[127569, 127569],
			"mapped",
			[21487]
		],
		[[127570, 127743], "disallowed"],
		[
			[127744, 127776],
			"valid",
			[],
			"NV8"
		],
		[
			[127777, 127788],
			"valid",
			[],
			"NV8"
		],
		[
			[127789, 127791],
			"valid",
			[],
			"NV8"
		],
		[
			[127792, 127797],
			"valid",
			[],
			"NV8"
		],
		[
			[127798, 127798],
			"valid",
			[],
			"NV8"
		],
		[
			[127799, 127868],
			"valid",
			[],
			"NV8"
		],
		[
			[127869, 127869],
			"valid",
			[],
			"NV8"
		],
		[
			[127870, 127871],
			"valid",
			[],
			"NV8"
		],
		[
			[127872, 127891],
			"valid",
			[],
			"NV8"
		],
		[
			[127892, 127903],
			"valid",
			[],
			"NV8"
		],
		[
			[127904, 127940],
			"valid",
			[],
			"NV8"
		],
		[
			[127941, 127941],
			"valid",
			[],
			"NV8"
		],
		[
			[127942, 127946],
			"valid",
			[],
			"NV8"
		],
		[
			[127947, 127950],
			"valid",
			[],
			"NV8"
		],
		[
			[127951, 127955],
			"valid",
			[],
			"NV8"
		],
		[
			[127956, 127967],
			"valid",
			[],
			"NV8"
		],
		[
			[127968, 127984],
			"valid",
			[],
			"NV8"
		],
		[
			[127985, 127991],
			"valid",
			[],
			"NV8"
		],
		[
			[127992, 127999],
			"valid",
			[],
			"NV8"
		],
		[
			[128e3, 128062],
			"valid",
			[],
			"NV8"
		],
		[
			[128063, 128063],
			"valid",
			[],
			"NV8"
		],
		[
			[128064, 128064],
			"valid",
			[],
			"NV8"
		],
		[
			[128065, 128065],
			"valid",
			[],
			"NV8"
		],
		[
			[128066, 128247],
			"valid",
			[],
			"NV8"
		],
		[
			[128248, 128248],
			"valid",
			[],
			"NV8"
		],
		[
			[128249, 128252],
			"valid",
			[],
			"NV8"
		],
		[
			[128253, 128254],
			"valid",
			[],
			"NV8"
		],
		[
			[128255, 128255],
			"valid",
			[],
			"NV8"
		],
		[
			[128256, 128317],
			"valid",
			[],
			"NV8"
		],
		[
			[128318, 128319],
			"valid",
			[],
			"NV8"
		],
		[
			[128320, 128323],
			"valid",
			[],
			"NV8"
		],
		[
			[128324, 128330],
			"valid",
			[],
			"NV8"
		],
		[
			[128331, 128335],
			"valid",
			[],
			"NV8"
		],
		[
			[128336, 128359],
			"valid",
			[],
			"NV8"
		],
		[
			[128360, 128377],
			"valid",
			[],
			"NV8"
		],
		[[128378, 128378], "disallowed"],
		[
			[128379, 128419],
			"valid",
			[],
			"NV8"
		],
		[[128420, 128420], "disallowed"],
		[
			[128421, 128506],
			"valid",
			[],
			"NV8"
		],
		[
			[128507, 128511],
			"valid",
			[],
			"NV8"
		],
		[
			[128512, 128512],
			"valid",
			[],
			"NV8"
		],
		[
			[128513, 128528],
			"valid",
			[],
			"NV8"
		],
		[
			[128529, 128529],
			"valid",
			[],
			"NV8"
		],
		[
			[128530, 128532],
			"valid",
			[],
			"NV8"
		],
		[
			[128533, 128533],
			"valid",
			[],
			"NV8"
		],
		[
			[128534, 128534],
			"valid",
			[],
			"NV8"
		],
		[
			[128535, 128535],
			"valid",
			[],
			"NV8"
		],
		[
			[128536, 128536],
			"valid",
			[],
			"NV8"
		],
		[
			[128537, 128537],
			"valid",
			[],
			"NV8"
		],
		[
			[128538, 128538],
			"valid",
			[],
			"NV8"
		],
		[
			[128539, 128539],
			"valid",
			[],
			"NV8"
		],
		[
			[128540, 128542],
			"valid",
			[],
			"NV8"
		],
		[
			[128543, 128543],
			"valid",
			[],
			"NV8"
		],
		[
			[128544, 128549],
			"valid",
			[],
			"NV8"
		],
		[
			[128550, 128551],
			"valid",
			[],
			"NV8"
		],
		[
			[128552, 128555],
			"valid",
			[],
			"NV8"
		],
		[
			[128556, 128556],
			"valid",
			[],
			"NV8"
		],
		[
			[128557, 128557],
			"valid",
			[],
			"NV8"
		],
		[
			[128558, 128559],
			"valid",
			[],
			"NV8"
		],
		[
			[128560, 128563],
			"valid",
			[],
			"NV8"
		],
		[
			[128564, 128564],
			"valid",
			[],
			"NV8"
		],
		[
			[128565, 128576],
			"valid",
			[],
			"NV8"
		],
		[
			[128577, 128578],
			"valid",
			[],
			"NV8"
		],
		[
			[128579, 128580],
			"valid",
			[],
			"NV8"
		],
		[
			[128581, 128591],
			"valid",
			[],
			"NV8"
		],
		[
			[128592, 128639],
			"valid",
			[],
			"NV8"
		],
		[
			[128640, 128709],
			"valid",
			[],
			"NV8"
		],
		[
			[128710, 128719],
			"valid",
			[],
			"NV8"
		],
		[
			[128720, 128720],
			"valid",
			[],
			"NV8"
		],
		[[128721, 128735], "disallowed"],
		[
			[128736, 128748],
			"valid",
			[],
			"NV8"
		],
		[[128749, 128751], "disallowed"],
		[
			[128752, 128755],
			"valid",
			[],
			"NV8"
		],
		[[128756, 128767], "disallowed"],
		[
			[128768, 128883],
			"valid",
			[],
			"NV8"
		],
		[[128884, 128895], "disallowed"],
		[
			[128896, 128980],
			"valid",
			[],
			"NV8"
		],
		[[128981, 129023], "disallowed"],
		[
			[129024, 129035],
			"valid",
			[],
			"NV8"
		],
		[[129036, 129039], "disallowed"],
		[
			[129040, 129095],
			"valid",
			[],
			"NV8"
		],
		[[129096, 129103], "disallowed"],
		[
			[129104, 129113],
			"valid",
			[],
			"NV8"
		],
		[[129114, 129119], "disallowed"],
		[
			[129120, 129159],
			"valid",
			[],
			"NV8"
		],
		[[129160, 129167], "disallowed"],
		[
			[129168, 129197],
			"valid",
			[],
			"NV8"
		],
		[[129198, 129295], "disallowed"],
		[
			[129296, 129304],
			"valid",
			[],
			"NV8"
		],
		[[129305, 129407], "disallowed"],
		[
			[129408, 129412],
			"valid",
			[],
			"NV8"
		],
		[[129413, 129471], "disallowed"],
		[
			[129472, 129472],
			"valid",
			[],
			"NV8"
		],
		[[129473, 131069], "disallowed"],
		[[131070, 131071], "disallowed"],
		[[131072, 173782], "valid"],
		[[173783, 173823], "disallowed"],
		[[173824, 177972], "valid"],
		[[177973, 177983], "disallowed"],
		[[177984, 178205], "valid"],
		[[178206, 178207], "disallowed"],
		[[178208, 183969], "valid"],
		[[183970, 194559], "disallowed"],
		[
			[194560, 194560],
			"mapped",
			[20029]
		],
		[
			[194561, 194561],
			"mapped",
			[20024]
		],
		[
			[194562, 194562],
			"mapped",
			[20033]
		],
		[
			[194563, 194563],
			"mapped",
			[131362]
		],
		[
			[194564, 194564],
			"mapped",
			[20320]
		],
		[
			[194565, 194565],
			"mapped",
			[20398]
		],
		[
			[194566, 194566],
			"mapped",
			[20411]
		],
		[
			[194567, 194567],
			"mapped",
			[20482]
		],
		[
			[194568, 194568],
			"mapped",
			[20602]
		],
		[
			[194569, 194569],
			"mapped",
			[20633]
		],
		[
			[194570, 194570],
			"mapped",
			[20711]
		],
		[
			[194571, 194571],
			"mapped",
			[20687]
		],
		[
			[194572, 194572],
			"mapped",
			[13470]
		],
		[
			[194573, 194573],
			"mapped",
			[132666]
		],
		[
			[194574, 194574],
			"mapped",
			[20813]
		],
		[
			[194575, 194575],
			"mapped",
			[20820]
		],
		[
			[194576, 194576],
			"mapped",
			[20836]
		],
		[
			[194577, 194577],
			"mapped",
			[20855]
		],
		[
			[194578, 194578],
			"mapped",
			[132380]
		],
		[
			[194579, 194579],
			"mapped",
			[13497]
		],
		[
			[194580, 194580],
			"mapped",
			[20839]
		],
		[
			[194581, 194581],
			"mapped",
			[20877]
		],
		[
			[194582, 194582],
			"mapped",
			[132427]
		],
		[
			[194583, 194583],
			"mapped",
			[20887]
		],
		[
			[194584, 194584],
			"mapped",
			[20900]
		],
		[
			[194585, 194585],
			"mapped",
			[20172]
		],
		[
			[194586, 194586],
			"mapped",
			[20908]
		],
		[
			[194587, 194587],
			"mapped",
			[20917]
		],
		[
			[194588, 194588],
			"mapped",
			[168415]
		],
		[
			[194589, 194589],
			"mapped",
			[20981]
		],
		[
			[194590, 194590],
			"mapped",
			[20995]
		],
		[
			[194591, 194591],
			"mapped",
			[13535]
		],
		[
			[194592, 194592],
			"mapped",
			[21051]
		],
		[
			[194593, 194593],
			"mapped",
			[21062]
		],
		[
			[194594, 194594],
			"mapped",
			[21106]
		],
		[
			[194595, 194595],
			"mapped",
			[21111]
		],
		[
			[194596, 194596],
			"mapped",
			[13589]
		],
		[
			[194597, 194597],
			"mapped",
			[21191]
		],
		[
			[194598, 194598],
			"mapped",
			[21193]
		],
		[
			[194599, 194599],
			"mapped",
			[21220]
		],
		[
			[194600, 194600],
			"mapped",
			[21242]
		],
		[
			[194601, 194601],
			"mapped",
			[21253]
		],
		[
			[194602, 194602],
			"mapped",
			[21254]
		],
		[
			[194603, 194603],
			"mapped",
			[21271]
		],
		[
			[194604, 194604],
			"mapped",
			[21321]
		],
		[
			[194605, 194605],
			"mapped",
			[21329]
		],
		[
			[194606, 194606],
			"mapped",
			[21338]
		],
		[
			[194607, 194607],
			"mapped",
			[21363]
		],
		[
			[194608, 194608],
			"mapped",
			[21373]
		],
		[
			[194609, 194611],
			"mapped",
			[21375]
		],
		[
			[194612, 194612],
			"mapped",
			[133676]
		],
		[
			[194613, 194613],
			"mapped",
			[28784]
		],
		[
			[194614, 194614],
			"mapped",
			[21450]
		],
		[
			[194615, 194615],
			"mapped",
			[21471]
		],
		[
			[194616, 194616],
			"mapped",
			[133987]
		],
		[
			[194617, 194617],
			"mapped",
			[21483]
		],
		[
			[194618, 194618],
			"mapped",
			[21489]
		],
		[
			[194619, 194619],
			"mapped",
			[21510]
		],
		[
			[194620, 194620],
			"mapped",
			[21662]
		],
		[
			[194621, 194621],
			"mapped",
			[21560]
		],
		[
			[194622, 194622],
			"mapped",
			[21576]
		],
		[
			[194623, 194623],
			"mapped",
			[21608]
		],
		[
			[194624, 194624],
			"mapped",
			[21666]
		],
		[
			[194625, 194625],
			"mapped",
			[21750]
		],
		[
			[194626, 194626],
			"mapped",
			[21776]
		],
		[
			[194627, 194627],
			"mapped",
			[21843]
		],
		[
			[194628, 194628],
			"mapped",
			[21859]
		],
		[
			[194629, 194630],
			"mapped",
			[21892]
		],
		[
			[194631, 194631],
			"mapped",
			[21913]
		],
		[
			[194632, 194632],
			"mapped",
			[21931]
		],
		[
			[194633, 194633],
			"mapped",
			[21939]
		],
		[
			[194634, 194634],
			"mapped",
			[21954]
		],
		[
			[194635, 194635],
			"mapped",
			[22294]
		],
		[
			[194636, 194636],
			"mapped",
			[22022]
		],
		[
			[194637, 194637],
			"mapped",
			[22295]
		],
		[
			[194638, 194638],
			"mapped",
			[22097]
		],
		[
			[194639, 194639],
			"mapped",
			[22132]
		],
		[
			[194640, 194640],
			"mapped",
			[20999]
		],
		[
			[194641, 194641],
			"mapped",
			[22766]
		],
		[
			[194642, 194642],
			"mapped",
			[22478]
		],
		[
			[194643, 194643],
			"mapped",
			[22516]
		],
		[
			[194644, 194644],
			"mapped",
			[22541]
		],
		[
			[194645, 194645],
			"mapped",
			[22411]
		],
		[
			[194646, 194646],
			"mapped",
			[22578]
		],
		[
			[194647, 194647],
			"mapped",
			[22577]
		],
		[
			[194648, 194648],
			"mapped",
			[22700]
		],
		[
			[194649, 194649],
			"mapped",
			[136420]
		],
		[
			[194650, 194650],
			"mapped",
			[22770]
		],
		[
			[194651, 194651],
			"mapped",
			[22775]
		],
		[
			[194652, 194652],
			"mapped",
			[22790]
		],
		[
			[194653, 194653],
			"mapped",
			[22810]
		],
		[
			[194654, 194654],
			"mapped",
			[22818]
		],
		[
			[194655, 194655],
			"mapped",
			[22882]
		],
		[
			[194656, 194656],
			"mapped",
			[136872]
		],
		[
			[194657, 194657],
			"mapped",
			[136938]
		],
		[
			[194658, 194658],
			"mapped",
			[23020]
		],
		[
			[194659, 194659],
			"mapped",
			[23067]
		],
		[
			[194660, 194660],
			"mapped",
			[23079]
		],
		[
			[194661, 194661],
			"mapped",
			[23e3]
		],
		[
			[194662, 194662],
			"mapped",
			[23142]
		],
		[
			[194663, 194663],
			"mapped",
			[14062]
		],
		[[194664, 194664], "disallowed"],
		[
			[194665, 194665],
			"mapped",
			[23304]
		],
		[
			[194666, 194667],
			"mapped",
			[23358]
		],
		[
			[194668, 194668],
			"mapped",
			[137672]
		],
		[
			[194669, 194669],
			"mapped",
			[23491]
		],
		[
			[194670, 194670],
			"mapped",
			[23512]
		],
		[
			[194671, 194671],
			"mapped",
			[23527]
		],
		[
			[194672, 194672],
			"mapped",
			[23539]
		],
		[
			[194673, 194673],
			"mapped",
			[138008]
		],
		[
			[194674, 194674],
			"mapped",
			[23551]
		],
		[
			[194675, 194675],
			"mapped",
			[23558]
		],
		[[194676, 194676], "disallowed"],
		[
			[194677, 194677],
			"mapped",
			[23586]
		],
		[
			[194678, 194678],
			"mapped",
			[14209]
		],
		[
			[194679, 194679],
			"mapped",
			[23648]
		],
		[
			[194680, 194680],
			"mapped",
			[23662]
		],
		[
			[194681, 194681],
			"mapped",
			[23744]
		],
		[
			[194682, 194682],
			"mapped",
			[23693]
		],
		[
			[194683, 194683],
			"mapped",
			[138724]
		],
		[
			[194684, 194684],
			"mapped",
			[23875]
		],
		[
			[194685, 194685],
			"mapped",
			[138726]
		],
		[
			[194686, 194686],
			"mapped",
			[23918]
		],
		[
			[194687, 194687],
			"mapped",
			[23915]
		],
		[
			[194688, 194688],
			"mapped",
			[23932]
		],
		[
			[194689, 194689],
			"mapped",
			[24033]
		],
		[
			[194690, 194690],
			"mapped",
			[24034]
		],
		[
			[194691, 194691],
			"mapped",
			[14383]
		],
		[
			[194692, 194692],
			"mapped",
			[24061]
		],
		[
			[194693, 194693],
			"mapped",
			[24104]
		],
		[
			[194694, 194694],
			"mapped",
			[24125]
		],
		[
			[194695, 194695],
			"mapped",
			[24169]
		],
		[
			[194696, 194696],
			"mapped",
			[14434]
		],
		[
			[194697, 194697],
			"mapped",
			[139651]
		],
		[
			[194698, 194698],
			"mapped",
			[14460]
		],
		[
			[194699, 194699],
			"mapped",
			[24240]
		],
		[
			[194700, 194700],
			"mapped",
			[24243]
		],
		[
			[194701, 194701],
			"mapped",
			[24246]
		],
		[
			[194702, 194702],
			"mapped",
			[24266]
		],
		[
			[194703, 194703],
			"mapped",
			[172946]
		],
		[
			[194704, 194704],
			"mapped",
			[24318]
		],
		[
			[194705, 194706],
			"mapped",
			[140081]
		],
		[
			[194707, 194707],
			"mapped",
			[33281]
		],
		[
			[194708, 194709],
			"mapped",
			[24354]
		],
		[
			[194710, 194710],
			"mapped",
			[14535]
		],
		[
			[194711, 194711],
			"mapped",
			[144056]
		],
		[
			[194712, 194712],
			"mapped",
			[156122]
		],
		[
			[194713, 194713],
			"mapped",
			[24418]
		],
		[
			[194714, 194714],
			"mapped",
			[24427]
		],
		[
			[194715, 194715],
			"mapped",
			[14563]
		],
		[
			[194716, 194716],
			"mapped",
			[24474]
		],
		[
			[194717, 194717],
			"mapped",
			[24525]
		],
		[
			[194718, 194718],
			"mapped",
			[24535]
		],
		[
			[194719, 194719],
			"mapped",
			[24569]
		],
		[
			[194720, 194720],
			"mapped",
			[24705]
		],
		[
			[194721, 194721],
			"mapped",
			[14650]
		],
		[
			[194722, 194722],
			"mapped",
			[14620]
		],
		[
			[194723, 194723],
			"mapped",
			[24724]
		],
		[
			[194724, 194724],
			"mapped",
			[141012]
		],
		[
			[194725, 194725],
			"mapped",
			[24775]
		],
		[
			[194726, 194726],
			"mapped",
			[24904]
		],
		[
			[194727, 194727],
			"mapped",
			[24908]
		],
		[
			[194728, 194728],
			"mapped",
			[24910]
		],
		[
			[194729, 194729],
			"mapped",
			[24908]
		],
		[
			[194730, 194730],
			"mapped",
			[24954]
		],
		[
			[194731, 194731],
			"mapped",
			[24974]
		],
		[
			[194732, 194732],
			"mapped",
			[25010]
		],
		[
			[194733, 194733],
			"mapped",
			[24996]
		],
		[
			[194734, 194734],
			"mapped",
			[25007]
		],
		[
			[194735, 194735],
			"mapped",
			[25054]
		],
		[
			[194736, 194736],
			"mapped",
			[25074]
		],
		[
			[194737, 194737],
			"mapped",
			[25078]
		],
		[
			[194738, 194738],
			"mapped",
			[25104]
		],
		[
			[194739, 194739],
			"mapped",
			[25115]
		],
		[
			[194740, 194740],
			"mapped",
			[25181]
		],
		[
			[194741, 194741],
			"mapped",
			[25265]
		],
		[
			[194742, 194742],
			"mapped",
			[25300]
		],
		[
			[194743, 194743],
			"mapped",
			[25424]
		],
		[
			[194744, 194744],
			"mapped",
			[142092]
		],
		[
			[194745, 194745],
			"mapped",
			[25405]
		],
		[
			[194746, 194746],
			"mapped",
			[25340]
		],
		[
			[194747, 194747],
			"mapped",
			[25448]
		],
		[
			[194748, 194748],
			"mapped",
			[25475]
		],
		[
			[194749, 194749],
			"mapped",
			[25572]
		],
		[
			[194750, 194750],
			"mapped",
			[142321]
		],
		[
			[194751, 194751],
			"mapped",
			[25634]
		],
		[
			[194752, 194752],
			"mapped",
			[25541]
		],
		[
			[194753, 194753],
			"mapped",
			[25513]
		],
		[
			[194754, 194754],
			"mapped",
			[14894]
		],
		[
			[194755, 194755],
			"mapped",
			[25705]
		],
		[
			[194756, 194756],
			"mapped",
			[25726]
		],
		[
			[194757, 194757],
			"mapped",
			[25757]
		],
		[
			[194758, 194758],
			"mapped",
			[25719]
		],
		[
			[194759, 194759],
			"mapped",
			[14956]
		],
		[
			[194760, 194760],
			"mapped",
			[25935]
		],
		[
			[194761, 194761],
			"mapped",
			[25964]
		],
		[
			[194762, 194762],
			"mapped",
			[143370]
		],
		[
			[194763, 194763],
			"mapped",
			[26083]
		],
		[
			[194764, 194764],
			"mapped",
			[26360]
		],
		[
			[194765, 194765],
			"mapped",
			[26185]
		],
		[
			[194766, 194766],
			"mapped",
			[15129]
		],
		[
			[194767, 194767],
			"mapped",
			[26257]
		],
		[
			[194768, 194768],
			"mapped",
			[15112]
		],
		[
			[194769, 194769],
			"mapped",
			[15076]
		],
		[
			[194770, 194770],
			"mapped",
			[20882]
		],
		[
			[194771, 194771],
			"mapped",
			[20885]
		],
		[
			[194772, 194772],
			"mapped",
			[26368]
		],
		[
			[194773, 194773],
			"mapped",
			[26268]
		],
		[
			[194774, 194774],
			"mapped",
			[32941]
		],
		[
			[194775, 194775],
			"mapped",
			[17369]
		],
		[
			[194776, 194776],
			"mapped",
			[26391]
		],
		[
			[194777, 194777],
			"mapped",
			[26395]
		],
		[
			[194778, 194778],
			"mapped",
			[26401]
		],
		[
			[194779, 194779],
			"mapped",
			[26462]
		],
		[
			[194780, 194780],
			"mapped",
			[26451]
		],
		[
			[194781, 194781],
			"mapped",
			[144323]
		],
		[
			[194782, 194782],
			"mapped",
			[15177]
		],
		[
			[194783, 194783],
			"mapped",
			[26618]
		],
		[
			[194784, 194784],
			"mapped",
			[26501]
		],
		[
			[194785, 194785],
			"mapped",
			[26706]
		],
		[
			[194786, 194786],
			"mapped",
			[26757]
		],
		[
			[194787, 194787],
			"mapped",
			[144493]
		],
		[
			[194788, 194788],
			"mapped",
			[26766]
		],
		[
			[194789, 194789],
			"mapped",
			[26655]
		],
		[
			[194790, 194790],
			"mapped",
			[26900]
		],
		[
			[194791, 194791],
			"mapped",
			[15261]
		],
		[
			[194792, 194792],
			"mapped",
			[26946]
		],
		[
			[194793, 194793],
			"mapped",
			[27043]
		],
		[
			[194794, 194794],
			"mapped",
			[27114]
		],
		[
			[194795, 194795],
			"mapped",
			[27304]
		],
		[
			[194796, 194796],
			"mapped",
			[145059]
		],
		[
			[194797, 194797],
			"mapped",
			[27355]
		],
		[
			[194798, 194798],
			"mapped",
			[15384]
		],
		[
			[194799, 194799],
			"mapped",
			[27425]
		],
		[
			[194800, 194800],
			"mapped",
			[145575]
		],
		[
			[194801, 194801],
			"mapped",
			[27476]
		],
		[
			[194802, 194802],
			"mapped",
			[15438]
		],
		[
			[194803, 194803],
			"mapped",
			[27506]
		],
		[
			[194804, 194804],
			"mapped",
			[27551]
		],
		[
			[194805, 194805],
			"mapped",
			[27578]
		],
		[
			[194806, 194806],
			"mapped",
			[27579]
		],
		[
			[194807, 194807],
			"mapped",
			[146061]
		],
		[
			[194808, 194808],
			"mapped",
			[138507]
		],
		[
			[194809, 194809],
			"mapped",
			[146170]
		],
		[
			[194810, 194810],
			"mapped",
			[27726]
		],
		[
			[194811, 194811],
			"mapped",
			[146620]
		],
		[
			[194812, 194812],
			"mapped",
			[27839]
		],
		[
			[194813, 194813],
			"mapped",
			[27853]
		],
		[
			[194814, 194814],
			"mapped",
			[27751]
		],
		[
			[194815, 194815],
			"mapped",
			[27926]
		],
		[
			[194816, 194816],
			"mapped",
			[27966]
		],
		[
			[194817, 194817],
			"mapped",
			[28023]
		],
		[
			[194818, 194818],
			"mapped",
			[27969]
		],
		[
			[194819, 194819],
			"mapped",
			[28009]
		],
		[
			[194820, 194820],
			"mapped",
			[28024]
		],
		[
			[194821, 194821],
			"mapped",
			[28037]
		],
		[
			[194822, 194822],
			"mapped",
			[146718]
		],
		[
			[194823, 194823],
			"mapped",
			[27956]
		],
		[
			[194824, 194824],
			"mapped",
			[28207]
		],
		[
			[194825, 194825],
			"mapped",
			[28270]
		],
		[
			[194826, 194826],
			"mapped",
			[15667]
		],
		[
			[194827, 194827],
			"mapped",
			[28363]
		],
		[
			[194828, 194828],
			"mapped",
			[28359]
		],
		[
			[194829, 194829],
			"mapped",
			[147153]
		],
		[
			[194830, 194830],
			"mapped",
			[28153]
		],
		[
			[194831, 194831],
			"mapped",
			[28526]
		],
		[
			[194832, 194832],
			"mapped",
			[147294]
		],
		[
			[194833, 194833],
			"mapped",
			[147342]
		],
		[
			[194834, 194834],
			"mapped",
			[28614]
		],
		[
			[194835, 194835],
			"mapped",
			[28729]
		],
		[
			[194836, 194836],
			"mapped",
			[28702]
		],
		[
			[194837, 194837],
			"mapped",
			[28699]
		],
		[
			[194838, 194838],
			"mapped",
			[15766]
		],
		[
			[194839, 194839],
			"mapped",
			[28746]
		],
		[
			[194840, 194840],
			"mapped",
			[28797]
		],
		[
			[194841, 194841],
			"mapped",
			[28791]
		],
		[
			[194842, 194842],
			"mapped",
			[28845]
		],
		[
			[194843, 194843],
			"mapped",
			[132389]
		],
		[
			[194844, 194844],
			"mapped",
			[28997]
		],
		[
			[194845, 194845],
			"mapped",
			[148067]
		],
		[
			[194846, 194846],
			"mapped",
			[29084]
		],
		[[194847, 194847], "disallowed"],
		[
			[194848, 194848],
			"mapped",
			[29224]
		],
		[
			[194849, 194849],
			"mapped",
			[29237]
		],
		[
			[194850, 194850],
			"mapped",
			[29264]
		],
		[
			[194851, 194851],
			"mapped",
			[149e3]
		],
		[
			[194852, 194852],
			"mapped",
			[29312]
		],
		[
			[194853, 194853],
			"mapped",
			[29333]
		],
		[
			[194854, 194854],
			"mapped",
			[149301]
		],
		[
			[194855, 194855],
			"mapped",
			[149524]
		],
		[
			[194856, 194856],
			"mapped",
			[29562]
		],
		[
			[194857, 194857],
			"mapped",
			[29579]
		],
		[
			[194858, 194858],
			"mapped",
			[16044]
		],
		[
			[194859, 194859],
			"mapped",
			[29605]
		],
		[
			[194860, 194861],
			"mapped",
			[16056]
		],
		[
			[194862, 194862],
			"mapped",
			[29767]
		],
		[
			[194863, 194863],
			"mapped",
			[29788]
		],
		[
			[194864, 194864],
			"mapped",
			[29809]
		],
		[
			[194865, 194865],
			"mapped",
			[29829]
		],
		[
			[194866, 194866],
			"mapped",
			[29898]
		],
		[
			[194867, 194867],
			"mapped",
			[16155]
		],
		[
			[194868, 194868],
			"mapped",
			[29988]
		],
		[
			[194869, 194869],
			"mapped",
			[150582]
		],
		[
			[194870, 194870],
			"mapped",
			[30014]
		],
		[
			[194871, 194871],
			"mapped",
			[150674]
		],
		[
			[194872, 194872],
			"mapped",
			[30064]
		],
		[
			[194873, 194873],
			"mapped",
			[139679]
		],
		[
			[194874, 194874],
			"mapped",
			[30224]
		],
		[
			[194875, 194875],
			"mapped",
			[151457]
		],
		[
			[194876, 194876],
			"mapped",
			[151480]
		],
		[
			[194877, 194877],
			"mapped",
			[151620]
		],
		[
			[194878, 194878],
			"mapped",
			[16380]
		],
		[
			[194879, 194879],
			"mapped",
			[16392]
		],
		[
			[194880, 194880],
			"mapped",
			[30452]
		],
		[
			[194881, 194881],
			"mapped",
			[151795]
		],
		[
			[194882, 194882],
			"mapped",
			[151794]
		],
		[
			[194883, 194883],
			"mapped",
			[151833]
		],
		[
			[194884, 194884],
			"mapped",
			[151859]
		],
		[
			[194885, 194885],
			"mapped",
			[30494]
		],
		[
			[194886, 194887],
			"mapped",
			[30495]
		],
		[
			[194888, 194888],
			"mapped",
			[30538]
		],
		[
			[194889, 194889],
			"mapped",
			[16441]
		],
		[
			[194890, 194890],
			"mapped",
			[30603]
		],
		[
			[194891, 194891],
			"mapped",
			[16454]
		],
		[
			[194892, 194892],
			"mapped",
			[16534]
		],
		[
			[194893, 194893],
			"mapped",
			[152605]
		],
		[
			[194894, 194894],
			"mapped",
			[30798]
		],
		[
			[194895, 194895],
			"mapped",
			[30860]
		],
		[
			[194896, 194896],
			"mapped",
			[30924]
		],
		[
			[194897, 194897],
			"mapped",
			[16611]
		],
		[
			[194898, 194898],
			"mapped",
			[153126]
		],
		[
			[194899, 194899],
			"mapped",
			[31062]
		],
		[
			[194900, 194900],
			"mapped",
			[153242]
		],
		[
			[194901, 194901],
			"mapped",
			[153285]
		],
		[
			[194902, 194902],
			"mapped",
			[31119]
		],
		[
			[194903, 194903],
			"mapped",
			[31211]
		],
		[
			[194904, 194904],
			"mapped",
			[16687]
		],
		[
			[194905, 194905],
			"mapped",
			[31296]
		],
		[
			[194906, 194906],
			"mapped",
			[31306]
		],
		[
			[194907, 194907],
			"mapped",
			[31311]
		],
		[
			[194908, 194908],
			"mapped",
			[153980]
		],
		[
			[194909, 194910],
			"mapped",
			[154279]
		],
		[[194911, 194911], "disallowed"],
		[
			[194912, 194912],
			"mapped",
			[16898]
		],
		[
			[194913, 194913],
			"mapped",
			[154539]
		],
		[
			[194914, 194914],
			"mapped",
			[31686]
		],
		[
			[194915, 194915],
			"mapped",
			[31689]
		],
		[
			[194916, 194916],
			"mapped",
			[16935]
		],
		[
			[194917, 194917],
			"mapped",
			[154752]
		],
		[
			[194918, 194918],
			"mapped",
			[31954]
		],
		[
			[194919, 194919],
			"mapped",
			[17056]
		],
		[
			[194920, 194920],
			"mapped",
			[31976]
		],
		[
			[194921, 194921],
			"mapped",
			[31971]
		],
		[
			[194922, 194922],
			"mapped",
			[32e3]
		],
		[
			[194923, 194923],
			"mapped",
			[155526]
		],
		[
			[194924, 194924],
			"mapped",
			[32099]
		],
		[
			[194925, 194925],
			"mapped",
			[17153]
		],
		[
			[194926, 194926],
			"mapped",
			[32199]
		],
		[
			[194927, 194927],
			"mapped",
			[32258]
		],
		[
			[194928, 194928],
			"mapped",
			[32325]
		],
		[
			[194929, 194929],
			"mapped",
			[17204]
		],
		[
			[194930, 194930],
			"mapped",
			[156200]
		],
		[
			[194931, 194931],
			"mapped",
			[156231]
		],
		[
			[194932, 194932],
			"mapped",
			[17241]
		],
		[
			[194933, 194933],
			"mapped",
			[156377]
		],
		[
			[194934, 194934],
			"mapped",
			[32634]
		],
		[
			[194935, 194935],
			"mapped",
			[156478]
		],
		[
			[194936, 194936],
			"mapped",
			[32661]
		],
		[
			[194937, 194937],
			"mapped",
			[32762]
		],
		[
			[194938, 194938],
			"mapped",
			[32773]
		],
		[
			[194939, 194939],
			"mapped",
			[156890]
		],
		[
			[194940, 194940],
			"mapped",
			[156963]
		],
		[
			[194941, 194941],
			"mapped",
			[32864]
		],
		[
			[194942, 194942],
			"mapped",
			[157096]
		],
		[
			[194943, 194943],
			"mapped",
			[32880]
		],
		[
			[194944, 194944],
			"mapped",
			[144223]
		],
		[
			[194945, 194945],
			"mapped",
			[17365]
		],
		[
			[194946, 194946],
			"mapped",
			[32946]
		],
		[
			[194947, 194947],
			"mapped",
			[33027]
		],
		[
			[194948, 194948],
			"mapped",
			[17419]
		],
		[
			[194949, 194949],
			"mapped",
			[33086]
		],
		[
			[194950, 194950],
			"mapped",
			[23221]
		],
		[
			[194951, 194951],
			"mapped",
			[157607]
		],
		[
			[194952, 194952],
			"mapped",
			[157621]
		],
		[
			[194953, 194953],
			"mapped",
			[144275]
		],
		[
			[194954, 194954],
			"mapped",
			[144284]
		],
		[
			[194955, 194955],
			"mapped",
			[33281]
		],
		[
			[194956, 194956],
			"mapped",
			[33284]
		],
		[
			[194957, 194957],
			"mapped",
			[36766]
		],
		[
			[194958, 194958],
			"mapped",
			[17515]
		],
		[
			[194959, 194959],
			"mapped",
			[33425]
		],
		[
			[194960, 194960],
			"mapped",
			[33419]
		],
		[
			[194961, 194961],
			"mapped",
			[33437]
		],
		[
			[194962, 194962],
			"mapped",
			[21171]
		],
		[
			[194963, 194963],
			"mapped",
			[33457]
		],
		[
			[194964, 194964],
			"mapped",
			[33459]
		],
		[
			[194965, 194965],
			"mapped",
			[33469]
		],
		[
			[194966, 194966],
			"mapped",
			[33510]
		],
		[
			[194967, 194967],
			"mapped",
			[158524]
		],
		[
			[194968, 194968],
			"mapped",
			[33509]
		],
		[
			[194969, 194969],
			"mapped",
			[33565]
		],
		[
			[194970, 194970],
			"mapped",
			[33635]
		],
		[
			[194971, 194971],
			"mapped",
			[33709]
		],
		[
			[194972, 194972],
			"mapped",
			[33571]
		],
		[
			[194973, 194973],
			"mapped",
			[33725]
		],
		[
			[194974, 194974],
			"mapped",
			[33767]
		],
		[
			[194975, 194975],
			"mapped",
			[33879]
		],
		[
			[194976, 194976],
			"mapped",
			[33619]
		],
		[
			[194977, 194977],
			"mapped",
			[33738]
		],
		[
			[194978, 194978],
			"mapped",
			[33740]
		],
		[
			[194979, 194979],
			"mapped",
			[33756]
		],
		[
			[194980, 194980],
			"mapped",
			[158774]
		],
		[
			[194981, 194981],
			"mapped",
			[159083]
		],
		[
			[194982, 194982],
			"mapped",
			[158933]
		],
		[
			[194983, 194983],
			"mapped",
			[17707]
		],
		[
			[194984, 194984],
			"mapped",
			[34033]
		],
		[
			[194985, 194985],
			"mapped",
			[34035]
		],
		[
			[194986, 194986],
			"mapped",
			[34070]
		],
		[
			[194987, 194987],
			"mapped",
			[160714]
		],
		[
			[194988, 194988],
			"mapped",
			[34148]
		],
		[
			[194989, 194989],
			"mapped",
			[159532]
		],
		[
			[194990, 194990],
			"mapped",
			[17757]
		],
		[
			[194991, 194991],
			"mapped",
			[17761]
		],
		[
			[194992, 194992],
			"mapped",
			[159665]
		],
		[
			[194993, 194993],
			"mapped",
			[159954]
		],
		[
			[194994, 194994],
			"mapped",
			[17771]
		],
		[
			[194995, 194995],
			"mapped",
			[34384]
		],
		[
			[194996, 194996],
			"mapped",
			[34396]
		],
		[
			[194997, 194997],
			"mapped",
			[34407]
		],
		[
			[194998, 194998],
			"mapped",
			[34409]
		],
		[
			[194999, 194999],
			"mapped",
			[34473]
		],
		[
			[195e3, 195e3],
			"mapped",
			[34440]
		],
		[
			[195001, 195001],
			"mapped",
			[34574]
		],
		[
			[195002, 195002],
			"mapped",
			[34530]
		],
		[
			[195003, 195003],
			"mapped",
			[34681]
		],
		[
			[195004, 195004],
			"mapped",
			[34600]
		],
		[
			[195005, 195005],
			"mapped",
			[34667]
		],
		[
			[195006, 195006],
			"mapped",
			[34694]
		],
		[[195007, 195007], "disallowed"],
		[
			[195008, 195008],
			"mapped",
			[34785]
		],
		[
			[195009, 195009],
			"mapped",
			[34817]
		],
		[
			[195010, 195010],
			"mapped",
			[17913]
		],
		[
			[195011, 195011],
			"mapped",
			[34912]
		],
		[
			[195012, 195012],
			"mapped",
			[34915]
		],
		[
			[195013, 195013],
			"mapped",
			[161383]
		],
		[
			[195014, 195014],
			"mapped",
			[35031]
		],
		[
			[195015, 195015],
			"mapped",
			[35038]
		],
		[
			[195016, 195016],
			"mapped",
			[17973]
		],
		[
			[195017, 195017],
			"mapped",
			[35066]
		],
		[
			[195018, 195018],
			"mapped",
			[13499]
		],
		[
			[195019, 195019],
			"mapped",
			[161966]
		],
		[
			[195020, 195020],
			"mapped",
			[162150]
		],
		[
			[195021, 195021],
			"mapped",
			[18110]
		],
		[
			[195022, 195022],
			"mapped",
			[18119]
		],
		[
			[195023, 195023],
			"mapped",
			[35488]
		],
		[
			[195024, 195024],
			"mapped",
			[35565]
		],
		[
			[195025, 195025],
			"mapped",
			[35722]
		],
		[
			[195026, 195026],
			"mapped",
			[35925]
		],
		[
			[195027, 195027],
			"mapped",
			[162984]
		],
		[
			[195028, 195028],
			"mapped",
			[36011]
		],
		[
			[195029, 195029],
			"mapped",
			[36033]
		],
		[
			[195030, 195030],
			"mapped",
			[36123]
		],
		[
			[195031, 195031],
			"mapped",
			[36215]
		],
		[
			[195032, 195032],
			"mapped",
			[163631]
		],
		[
			[195033, 195033],
			"mapped",
			[133124]
		],
		[
			[195034, 195034],
			"mapped",
			[36299]
		],
		[
			[195035, 195035],
			"mapped",
			[36284]
		],
		[
			[195036, 195036],
			"mapped",
			[36336]
		],
		[
			[195037, 195037],
			"mapped",
			[133342]
		],
		[
			[195038, 195038],
			"mapped",
			[36564]
		],
		[
			[195039, 195039],
			"mapped",
			[36664]
		],
		[
			[195040, 195040],
			"mapped",
			[165330]
		],
		[
			[195041, 195041],
			"mapped",
			[165357]
		],
		[
			[195042, 195042],
			"mapped",
			[37012]
		],
		[
			[195043, 195043],
			"mapped",
			[37105]
		],
		[
			[195044, 195044],
			"mapped",
			[37137]
		],
		[
			[195045, 195045],
			"mapped",
			[165678]
		],
		[
			[195046, 195046],
			"mapped",
			[37147]
		],
		[
			[195047, 195047],
			"mapped",
			[37432]
		],
		[
			[195048, 195048],
			"mapped",
			[37591]
		],
		[
			[195049, 195049],
			"mapped",
			[37592]
		],
		[
			[195050, 195050],
			"mapped",
			[37500]
		],
		[
			[195051, 195051],
			"mapped",
			[37881]
		],
		[
			[195052, 195052],
			"mapped",
			[37909]
		],
		[
			[195053, 195053],
			"mapped",
			[166906]
		],
		[
			[195054, 195054],
			"mapped",
			[38283]
		],
		[
			[195055, 195055],
			"mapped",
			[18837]
		],
		[
			[195056, 195056],
			"mapped",
			[38327]
		],
		[
			[195057, 195057],
			"mapped",
			[167287]
		],
		[
			[195058, 195058],
			"mapped",
			[18918]
		],
		[
			[195059, 195059],
			"mapped",
			[38595]
		],
		[
			[195060, 195060],
			"mapped",
			[23986]
		],
		[
			[195061, 195061],
			"mapped",
			[38691]
		],
		[
			[195062, 195062],
			"mapped",
			[168261]
		],
		[
			[195063, 195063],
			"mapped",
			[168474]
		],
		[
			[195064, 195064],
			"mapped",
			[19054]
		],
		[
			[195065, 195065],
			"mapped",
			[19062]
		],
		[
			[195066, 195066],
			"mapped",
			[38880]
		],
		[
			[195067, 195067],
			"mapped",
			[168970]
		],
		[
			[195068, 195068],
			"mapped",
			[19122]
		],
		[
			[195069, 195069],
			"mapped",
			[169110]
		],
		[
			[195070, 195071],
			"mapped",
			[38923]
		],
		[
			[195072, 195072],
			"mapped",
			[38953]
		],
		[
			[195073, 195073],
			"mapped",
			[169398]
		],
		[
			[195074, 195074],
			"mapped",
			[39138]
		],
		[
			[195075, 195075],
			"mapped",
			[19251]
		],
		[
			[195076, 195076],
			"mapped",
			[39209]
		],
		[
			[195077, 195077],
			"mapped",
			[39335]
		],
		[
			[195078, 195078],
			"mapped",
			[39362]
		],
		[
			[195079, 195079],
			"mapped",
			[39422]
		],
		[
			[195080, 195080],
			"mapped",
			[19406]
		],
		[
			[195081, 195081],
			"mapped",
			[170800]
		],
		[
			[195082, 195082],
			"mapped",
			[39698]
		],
		[
			[195083, 195083],
			"mapped",
			[4e4]
		],
		[
			[195084, 195084],
			"mapped",
			[40189]
		],
		[
			[195085, 195085],
			"mapped",
			[19662]
		],
		[
			[195086, 195086],
			"mapped",
			[19693]
		],
		[
			[195087, 195087],
			"mapped",
			[40295]
		],
		[
			[195088, 195088],
			"mapped",
			[172238]
		],
		[
			[195089, 195089],
			"mapped",
			[19704]
		],
		[
			[195090, 195090],
			"mapped",
			[172293]
		],
		[
			[195091, 195091],
			"mapped",
			[172558]
		],
		[
			[195092, 195092],
			"mapped",
			[172689]
		],
		[
			[195093, 195093],
			"mapped",
			[40635]
		],
		[
			[195094, 195094],
			"mapped",
			[19798]
		],
		[
			[195095, 195095],
			"mapped",
			[40697]
		],
		[
			[195096, 195096],
			"mapped",
			[40702]
		],
		[
			[195097, 195097],
			"mapped",
			[40709]
		],
		[
			[195098, 195098],
			"mapped",
			[40719]
		],
		[
			[195099, 195099],
			"mapped",
			[40726]
		],
		[
			[195100, 195100],
			"mapped",
			[40763]
		],
		[
			[195101, 195101],
			"mapped",
			[173568]
		],
		[[195102, 196605], "disallowed"],
		[[196606, 196607], "disallowed"],
		[[196608, 262141], "disallowed"],
		[[262142, 262143], "disallowed"],
		[[262144, 327677], "disallowed"],
		[[327678, 327679], "disallowed"],
		[[327680, 393213], "disallowed"],
		[[393214, 393215], "disallowed"],
		[[393216, 458749], "disallowed"],
		[[458750, 458751], "disallowed"],
		[[458752, 524285], "disallowed"],
		[[524286, 524287], "disallowed"],
		[[524288, 589821], "disallowed"],
		[[589822, 589823], "disallowed"],
		[[589824, 655357], "disallowed"],
		[[655358, 655359], "disallowed"],
		[[655360, 720893], "disallowed"],
		[[720894, 720895], "disallowed"],
		[[720896, 786429], "disallowed"],
		[[786430, 786431], "disallowed"],
		[[786432, 851965], "disallowed"],
		[[851966, 851967], "disallowed"],
		[[851968, 917501], "disallowed"],
		[[917502, 917503], "disallowed"],
		[[917504, 917504], "disallowed"],
		[[917505, 917505], "disallowed"],
		[[917506, 917535], "disallowed"],
		[[917536, 917631], "disallowed"],
		[[917632, 917759], "disallowed"],
		[[917760, 917999], "ignored"],
		[[918e3, 983037], "disallowed"],
		[[983038, 983039], "disallowed"],
		[[983040, 1048573], "disallowed"],
		[[1048574, 1048575], "disallowed"],
		[[1048576, 1114109], "disallowed"],
		[[1114110, 1114111], "disallowed"]
	];
} });

//#endregion
//#region node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js
var require_tr46 = __commonJS({ "node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js"(exports, module) {
	var punycode$1 = __require("punycode");
	var mappingTable = require_mappingTable();
	var PROCESSING_OPTIONS = {
		TRANSITIONAL: 0,
		NONTRANSITIONAL: 1
	};
	function normalize(str$1) {
		return str$1.split("\0").map(function(s$1) {
			return s$1.normalize("NFC");
		}).join("\0");
	}
	function findStatus(val) {
		var start = 0;
		var end = mappingTable.length - 1;
		while (start <= end) {
			var mid = Math.floor((start + end) / 2);
			var target = mappingTable[mid];
			if (target[0][0] <= val && target[0][1] >= val) return target;
			else if (target[0][0] > val) end = mid - 1;
			else start = mid + 1;
		}
		return null;
	}
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	function countSymbols$1(string) {
		return string.replace(regexAstralSymbols, "_").length;
	}
	function mapChars(domain_name, useSTD3, processing_option) {
		var hasError = false;
		var processed = "";
		var len = countSymbols$1(domain_name);
		for (var i$1 = 0; i$1 < len; ++i$1) {
			var codePoint = domain_name.codePointAt(i$1);
			var status = findStatus(codePoint);
			switch (status[1]) {
				case "disallowed":
					hasError = true;
					processed += String.fromCodePoint(codePoint);
					break;
				case "ignored": break;
				case "mapped":
					processed += String.fromCodePoint.apply(String, status[2]);
					break;
				case "deviation":
					if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) processed += String.fromCodePoint.apply(String, status[2]);
					else processed += String.fromCodePoint(codePoint);
					break;
				case "valid":
					processed += String.fromCodePoint(codePoint);
					break;
				case "disallowed_STD3_mapped":
					if (useSTD3) {
						hasError = true;
						processed += String.fromCodePoint(codePoint);
					} else processed += String.fromCodePoint.apply(String, status[2]);
					break;
				case "disallowed_STD3_valid":
					if (useSTD3) hasError = true;
					processed += String.fromCodePoint(codePoint);
					break;
			}
		}
		return {
			string: processed,
			error: hasError
		};
	}
	var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
	function validateLabel(label, processing_option) {
		if (label.substr(0, 4) === "xn--") {
			label = punycode$1.toUnicode(label);
			processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
		}
		var error$1 = false;
		if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) error$1 = true;
		var len = countSymbols$1(label);
		for (var i$1 = 0; i$1 < len; ++i$1) {
			var status = findStatus(label.codePointAt(i$1));
			if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
				error$1 = true;
				break;
			}
		}
		return {
			label,
			error: error$1
		};
	}
	function processing(domain_name, useSTD3, processing_option) {
		var result = mapChars(domain_name, useSTD3, processing_option);
		result.string = normalize(result.string);
		var labels = result.string.split(".");
		for (var i$1 = 0; i$1 < labels.length; ++i$1) try {
			var validation = validateLabel(labels[i$1]);
			labels[i$1] = validation.label;
			result.error = result.error || validation.error;
		} catch (e) {
			result.error = true;
		}
		return {
			string: labels.join("."),
			error: result.error
		};
	}
	module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
		var result = processing(domain_name, useSTD3, processing_option);
		var labels = result.string.split(".");
		labels = labels.map(function(l) {
			try {
				return punycode$1.toASCII(l);
			} catch (e) {
				result.error = true;
				return l;
			}
		});
		if (verifyDnsLength) {
			var total = labels.slice(0, labels.length - 1).join(".").length;
			if (total.length > 253 || total.length === 0) result.error = true;
			for (var i$1 = 0; i$1 < labels.length; ++i$1) if (labels.length > 63 || labels.length === 0) {
				result.error = true;
				break;
			}
		}
		if (result.error) return null;
		return labels.join(".");
	};
	module.exports.toUnicode = function(domain_name, useSTD3) {
		var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
		return {
			domain: result.string,
			error: result.error
		};
	};
	module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
} });

//#endregion
//#region node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({ "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
	const punycode = __require("punycode");
	const tr46 = require_tr46();
	const specialSchemes = {
		ftp: 21,
		file: null,
		gopher: 70,
		http: 80,
		https: 443,
		ws: 80,
		wss: 443
	};
	const failure = Symbol("failure");
	function countSymbols(str$1) {
		return punycode.ucs2.decode(str$1).length;
	}
	function at(input, idx) {
		const c$1 = input[idx];
		return isNaN(c$1) ? void 0 : String.fromCodePoint(c$1);
	}
	function isASCIIDigit(c$1) {
		return c$1 >= 48 && c$1 <= 57;
	}
	function isASCIIAlpha(c$1) {
		return c$1 >= 65 && c$1 <= 90 || c$1 >= 97 && c$1 <= 122;
	}
	function isASCIIAlphanumeric(c$1) {
		return isASCIIAlpha(c$1) || isASCIIDigit(c$1);
	}
	function isASCIIHex(c$1) {
		return isASCIIDigit(c$1) || c$1 >= 65 && c$1 <= 70 || c$1 >= 97 && c$1 <= 102;
	}
	function isSingleDot(buffer) {
		return buffer === "." || buffer.toLowerCase() === "%2e";
	}
	function isDoubleDot(buffer) {
		buffer = buffer.toLowerCase();
		return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
	}
	function isWindowsDriveLetterCodePoints(cp1, cp2) {
		return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
	}
	function isWindowsDriveLetterString(string) {
		return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
	}
	function isNormalizedWindowsDriveLetterString(string) {
		return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
	}
	function containsForbiddenHostCodePoint(string) {
		return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
	}
	function containsForbiddenHostCodePointExcludingPercent(string) {
		return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
	}
	function isSpecialScheme(scheme) {
		return specialSchemes[scheme] !== void 0;
	}
	function isSpecial(url) {
		return isSpecialScheme(url.scheme);
	}
	function defaultPort(scheme) {
		return specialSchemes[scheme];
	}
	function percentEncode(c$1) {
		let hex = c$1.toString(16).toUpperCase();
		if (hex.length === 1) hex = "0" + hex;
		return "%" + hex;
	}
	function utf8PercentEncode(c$1) {
		const buf = new Buffer(c$1);
		let str$1 = "";
		for (let i$1 = 0; i$1 < buf.length; ++i$1) str$1 += percentEncode(buf[i$1]);
		return str$1;
	}
	function utf8PercentDecode(str$1) {
		const input = new Buffer(str$1);
		const output = [];
		for (let i$1 = 0; i$1 < input.length; ++i$1) if (input[i$1] !== 37) output.push(input[i$1]);
		else if (input[i$1] === 37 && isASCIIHex(input[i$1 + 1]) && isASCIIHex(input[i$1 + 2])) {
			output.push(parseInt(input.slice(i$1 + 1, i$1 + 3).toString(), 16));
			i$1 += 2;
		} else output.push(input[i$1]);
		return new Buffer(output).toString();
	}
	function isC0ControlPercentEncode(c$1) {
		return c$1 <= 31 || c$1 > 126;
	}
	const extraPathPercentEncodeSet = new Set([
		32,
		34,
		35,
		60,
		62,
		63,
		96,
		123,
		125
	]);
	function isPathPercentEncode(c$1) {
		return isC0ControlPercentEncode(c$1) || extraPathPercentEncodeSet.has(c$1);
	}
	const extraUserinfoPercentEncodeSet = new Set([
		47,
		58,
		59,
		61,
		64,
		91,
		92,
		93,
		94,
		124
	]);
	function isUserinfoPercentEncode(c$1) {
		return isPathPercentEncode(c$1) || extraUserinfoPercentEncodeSet.has(c$1);
	}
	function percentEncodeChar(c$1, encodeSetPredicate) {
		const cStr = String.fromCodePoint(c$1);
		if (encodeSetPredicate(c$1)) return utf8PercentEncode(cStr);
		return cStr;
	}
	function parseIPv4Number(input) {
		let R = 10;
		if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
			input = input.substring(2);
			R = 16;
		} else if (input.length >= 2 && input.charAt(0) === "0") {
			input = input.substring(1);
			R = 8;
		}
		if (input === "") return 0;
		const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
		if (regex.test(input)) return failure;
		return parseInt(input, R);
	}
	function parseIPv4(input) {
		const parts = input.split(".");
		if (parts[parts.length - 1] === "") {
			if (parts.length > 1) parts.pop();
		}
		if (parts.length > 4) return input;
		const numbers = [];
		for (const part of parts) {
			if (part === "") return input;
			const n$1 = parseIPv4Number(part);
			if (n$1 === failure) return input;
			numbers.push(n$1);
		}
		for (let i$1 = 0; i$1 < numbers.length - 1; ++i$1) if (numbers[i$1] > 255) return failure;
		if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
		let ipv4 = numbers.pop();
		let counter = 0;
		for (const n$1 of numbers) {
			ipv4 += n$1 * Math.pow(256, 3 - counter);
			++counter;
		}
		return ipv4;
	}
	function serializeIPv4(address) {
		let output = "";
		let n$1 = address;
		for (let i$1 = 1; i$1 <= 4; ++i$1) {
			output = String(n$1 % 256) + output;
			if (i$1 !== 4) output = "." + output;
			n$1 = Math.floor(n$1 / 256);
		}
		return output;
	}
	function parseIPv6(input) {
		const address = [
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0
		];
		let pieceIndex = 0;
		let compress = null;
		let pointer = 0;
		input = punycode.ucs2.decode(input);
		if (input[pointer] === 58) {
			if (input[pointer + 1] !== 58) return failure;
			pointer += 2;
			++pieceIndex;
			compress = pieceIndex;
		}
		while (pointer < input.length) {
			if (pieceIndex === 8) return failure;
			if (input[pointer] === 58) {
				if (compress !== null) return failure;
				++pointer;
				++pieceIndex;
				compress = pieceIndex;
				continue;
			}
			let value = 0;
			let length = 0;
			while (length < 4 && isASCIIHex(input[pointer])) {
				value = value * 16 + parseInt(at(input, pointer), 16);
				++pointer;
				++length;
			}
			if (input[pointer] === 46) {
				if (length === 0) return failure;
				pointer -= length;
				if (pieceIndex > 6) return failure;
				let numbersSeen = 0;
				while (input[pointer] !== void 0) {
					let ipv4Piece = null;
					if (numbersSeen > 0) if (input[pointer] === 46 && numbersSeen < 4) ++pointer;
					else return failure;
					if (!isASCIIDigit(input[pointer])) return failure;
					while (isASCIIDigit(input[pointer])) {
						const number = parseInt(at(input, pointer));
						if (ipv4Piece === null) ipv4Piece = number;
						else if (ipv4Piece === 0) return failure;
						else ipv4Piece = ipv4Piece * 10 + number;
						if (ipv4Piece > 255) return failure;
						++pointer;
					}
					address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
					++numbersSeen;
					if (numbersSeen === 2 || numbersSeen === 4) ++pieceIndex;
				}
				if (numbersSeen !== 4) return failure;
				break;
			} else if (input[pointer] === 58) {
				++pointer;
				if (input[pointer] === void 0) return failure;
			} else if (input[pointer] !== void 0) return failure;
			address[pieceIndex] = value;
			++pieceIndex;
		}
		if (compress !== null) {
			let swaps = pieceIndex - compress;
			pieceIndex = 7;
			while (pieceIndex !== 0 && swaps > 0) {
				const temp = address[compress + swaps - 1];
				address[compress + swaps - 1] = address[pieceIndex];
				address[pieceIndex] = temp;
				--pieceIndex;
				--swaps;
			}
		} else if (compress === null && pieceIndex !== 8) return failure;
		return address;
	}
	function serializeIPv6(address) {
		let output = "";
		const seqResult = findLongestZeroSequence(address);
		const compress = seqResult.idx;
		let ignore0 = false;
		for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
			if (ignore0 && address[pieceIndex] === 0) continue;
			else if (ignore0) ignore0 = false;
			if (compress === pieceIndex) {
				const separator = pieceIndex === 0 ? "::" : ":";
				output += separator;
				ignore0 = true;
				continue;
			}
			output += address[pieceIndex].toString(16);
			if (pieceIndex !== 7) output += ":";
		}
		return output;
	}
	function parseHost(input, isSpecialArg) {
		if (input[0] === "[") {
			if (input[input.length - 1] !== "]") return failure;
			return parseIPv6(input.substring(1, input.length - 1));
		}
		if (!isSpecialArg) return parseOpaqueHost(input);
		const domain = utf8PercentDecode(input);
		const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
		if (asciiDomain === null) return failure;
		if (containsForbiddenHostCodePoint(asciiDomain)) return failure;
		const ipv4Host = parseIPv4(asciiDomain);
		if (typeof ipv4Host === "number" || ipv4Host === failure) return ipv4Host;
		return asciiDomain;
	}
	function parseOpaqueHost(input) {
		if (containsForbiddenHostCodePointExcludingPercent(input)) return failure;
		let output = "";
		const decoded = punycode.ucs2.decode(input);
		for (let i$1 = 0; i$1 < decoded.length; ++i$1) output += percentEncodeChar(decoded[i$1], isC0ControlPercentEncode);
		return output;
	}
	function findLongestZeroSequence(arr) {
		let maxIdx = null;
		let maxLen = 1;
		let currStart = null;
		let currLen = 0;
		for (let i$1 = 0; i$1 < arr.length; ++i$1) if (arr[i$1] !== 0) {
			if (currLen > maxLen) {
				maxIdx = currStart;
				maxLen = currLen;
			}
			currStart = null;
			currLen = 0;
		} else {
			if (currStart === null) currStart = i$1;
			++currLen;
		}
		if (currLen > maxLen) {
			maxIdx = currStart;
			maxLen = currLen;
		}
		return {
			idx: maxIdx,
			len: maxLen
		};
	}
	function serializeHost(host) {
		if (typeof host === "number") return serializeIPv4(host);
		if (host instanceof Array) return "[" + serializeIPv6(host) + "]";
		return host;
	}
	function trimControlChars(url) {
		return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
	}
	function trimTabAndNewline(url) {
		return url.replace(/\u0009|\u000A|\u000D/g, "");
	}
	function shortenPath(url) {
		const path$9 = url.path;
		if (path$9.length === 0) return;
		if (url.scheme === "file" && path$9.length === 1 && isNormalizedWindowsDriveLetter(path$9[0])) return;
		path$9.pop();
	}
	function includesCredentials(url) {
		return url.username !== "" || url.password !== "";
	}
	function cannotHaveAUsernamePasswordPort(url) {
		return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
	}
	function isNormalizedWindowsDriveLetter(string) {
		return /^[A-Za-z]:$/.test(string);
	}
	function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
		this.pointer = 0;
		this.input = input;
		this.base = base || null;
		this.encodingOverride = encodingOverride || "utf-8";
		this.stateOverride = stateOverride;
		this.url = url;
		this.failure = false;
		this.parseError = false;
		if (!this.url) {
			this.url = {
				scheme: "",
				username: "",
				password: "",
				host: null,
				port: null,
				path: [],
				query: null,
				fragment: null,
				cannotBeABaseURL: false
			};
			const res$1 = trimControlChars(this.input);
			if (res$1 !== this.input) this.parseError = true;
			this.input = res$1;
		}
		const res = trimTabAndNewline(this.input);
		if (res !== this.input) this.parseError = true;
		this.input = res;
		this.state = stateOverride || "scheme start";
		this.buffer = "";
		this.atFlag = false;
		this.arrFlag = false;
		this.passwordTokenSeenFlag = false;
		this.input = punycode.ucs2.decode(this.input);
		for (; this.pointer <= this.input.length; ++this.pointer) {
			const c$1 = this.input[this.pointer];
			const cStr = isNaN(c$1) ? void 0 : String.fromCodePoint(c$1);
			const ret = this["parse " + this.state](c$1, cStr);
			if (!ret) break;
			else if (ret === failure) {
				this.failure = true;
				break;
			}
		}
	}
	URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c$1, cStr) {
		if (isASCIIAlpha(c$1)) {
			this.buffer += cStr.toLowerCase();
			this.state = "scheme";
		} else if (!this.stateOverride) {
			this.state = "no scheme";
			--this.pointer;
		} else {
			this.parseError = true;
			return failure;
		}
		return true;
	};
	URLStateMachine.prototype["parse scheme"] = function parseScheme(c$1, cStr) {
		if (isASCIIAlphanumeric(c$1) || c$1 === 43 || c$1 === 45 || c$1 === 46) this.buffer += cStr.toLowerCase();
		else if (c$1 === 58) {
			if (this.stateOverride) {
				if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return false;
				if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return false;
				if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") return false;
				if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) return false;
			}
			this.url.scheme = this.buffer;
			this.buffer = "";
			if (this.stateOverride) return false;
			if (this.url.scheme === "file") {
				if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) this.parseError = true;
				this.state = "file";
			} else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) this.state = "special relative or authority";
			else if (isSpecial(this.url)) this.state = "special authority slashes";
			else if (this.input[this.pointer + 1] === 47) {
				this.state = "path or authority";
				++this.pointer;
			} else {
				this.url.cannotBeABaseURL = true;
				this.url.path.push("");
				this.state = "cannot-be-a-base-URL path";
			}
		} else if (!this.stateOverride) {
			this.buffer = "";
			this.state = "no scheme";
			this.pointer = -1;
		} else {
			this.parseError = true;
			return failure;
		}
		return true;
	};
	URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c$1) {
		if (this.base === null || this.base.cannotBeABaseURL && c$1 !== 35) return failure;
		else if (this.base.cannotBeABaseURL && c$1 === 35) {
			this.url.scheme = this.base.scheme;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
			this.url.fragment = "";
			this.url.cannotBeABaseURL = true;
			this.state = "fragment";
		} else if (this.base.scheme === "file") {
			this.state = "file";
			--this.pointer;
		} else {
			this.state = "relative";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c$1) {
		if (c$1 === 47 && this.input[this.pointer + 1] === 47) {
			this.state = "special authority ignore slashes";
			++this.pointer;
		} else {
			this.parseError = true;
			this.state = "relative";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c$1) {
		if (c$1 === 47) this.state = "authority";
		else {
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse relative"] = function parseRelative(c$1) {
		this.url.scheme = this.base.scheme;
		if (isNaN(c$1)) {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
		} else if (c$1 === 47) this.state = "relative slash";
		else if (c$1 === 63) {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice();
			this.url.query = "";
			this.state = "query";
		} else if (c$1 === 35) {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
			this.url.fragment = "";
			this.state = "fragment";
		} else if (isSpecial(this.url) && c$1 === 92) {
			this.parseError = true;
			this.state = "relative slash";
		} else {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice(0, this.base.path.length - 1);
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c$1) {
		if (isSpecial(this.url) && (c$1 === 47 || c$1 === 92)) {
			if (c$1 === 92) this.parseError = true;
			this.state = "special authority ignore slashes";
		} else if (c$1 === 47) this.state = "authority";
		else {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c$1) {
		if (c$1 === 47 && this.input[this.pointer + 1] === 47) {
			this.state = "special authority ignore slashes";
			++this.pointer;
		} else {
			this.parseError = true;
			this.state = "special authority ignore slashes";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c$1) {
		if (c$1 !== 47 && c$1 !== 92) {
			this.state = "authority";
			--this.pointer;
		} else this.parseError = true;
		return true;
	};
	URLStateMachine.prototype["parse authority"] = function parseAuthority(c$1, cStr) {
		if (c$1 === 64) {
			this.parseError = true;
			if (this.atFlag) this.buffer = "%40" + this.buffer;
			this.atFlag = true;
			const len = countSymbols(this.buffer);
			for (let pointer = 0; pointer < len; ++pointer) {
				const codePoint = this.buffer.codePointAt(pointer);
				if (codePoint === 58 && !this.passwordTokenSeenFlag) {
					this.passwordTokenSeenFlag = true;
					continue;
				}
				const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
				if (this.passwordTokenSeenFlag) this.url.password += encodedCodePoints;
				else this.url.username += encodedCodePoints;
			}
			this.buffer = "";
		} else if (isNaN(c$1) || c$1 === 47 || c$1 === 63 || c$1 === 35 || isSpecial(this.url) && c$1 === 92) {
			if (this.atFlag && this.buffer === "") {
				this.parseError = true;
				return failure;
			}
			this.pointer -= countSymbols(this.buffer) + 1;
			this.buffer = "";
			this.state = "host";
		} else this.buffer += cStr;
		return true;
	};
	URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c$1, cStr) {
		if (this.stateOverride && this.url.scheme === "file") {
			--this.pointer;
			this.state = "file host";
		} else if (c$1 === 58 && !this.arrFlag) {
			if (this.buffer === "") {
				this.parseError = true;
				return failure;
			}
			const host = parseHost(this.buffer, isSpecial(this.url));
			if (host === failure) return failure;
			this.url.host = host;
			this.buffer = "";
			this.state = "port";
			if (this.stateOverride === "hostname") return false;
		} else if (isNaN(c$1) || c$1 === 47 || c$1 === 63 || c$1 === 35 || isSpecial(this.url) && c$1 === 92) {
			--this.pointer;
			if (isSpecial(this.url) && this.buffer === "") {
				this.parseError = true;
				return failure;
			} else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
				this.parseError = true;
				return false;
			}
			const host = parseHost(this.buffer, isSpecial(this.url));
			if (host === failure) return failure;
			this.url.host = host;
			this.buffer = "";
			this.state = "path start";
			if (this.stateOverride) return false;
		} else {
			if (c$1 === 91) this.arrFlag = true;
			else if (c$1 === 93) this.arrFlag = false;
			this.buffer += cStr;
		}
		return true;
	};
	URLStateMachine.prototype["parse port"] = function parsePort(c$1, cStr) {
		if (isASCIIDigit(c$1)) this.buffer += cStr;
		else if (isNaN(c$1) || c$1 === 47 || c$1 === 63 || c$1 === 35 || isSpecial(this.url) && c$1 === 92 || this.stateOverride) {
			if (this.buffer !== "") {
				const port = parseInt(this.buffer);
				if (port > Math.pow(2, 16) - 1) {
					this.parseError = true;
					return failure;
				}
				this.url.port = port === defaultPort(this.url.scheme) ? null : port;
				this.buffer = "";
			}
			if (this.stateOverride) return false;
			this.state = "path start";
			--this.pointer;
		} else {
			this.parseError = true;
			return failure;
		}
		return true;
	};
	const fileOtherwiseCodePoints = new Set([
		47,
		92,
		63,
		35
	]);
	URLStateMachine.prototype["parse file"] = function parseFile(c$1) {
		this.url.scheme = "file";
		if (c$1 === 47 || c$1 === 92) {
			if (c$1 === 92) this.parseError = true;
			this.state = "file slash";
		} else if (this.base !== null && this.base.scheme === "file") if (isNaN(c$1)) {
			this.url.host = this.base.host;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
		} else if (c$1 === 63) {
			this.url.host = this.base.host;
			this.url.path = this.base.path.slice();
			this.url.query = "";
			this.state = "query";
		} else if (c$1 === 35) {
			this.url.host = this.base.host;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
			this.url.fragment = "";
			this.state = "fragment";
		} else {
			if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c$1, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
				this.url.host = this.base.host;
				this.url.path = this.base.path.slice();
				shortenPath(this.url);
			} else this.parseError = true;
			this.state = "path";
			--this.pointer;
		}
		else {
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c$1) {
		if (c$1 === 47 || c$1 === 92) {
			if (c$1 === 92) this.parseError = true;
			this.state = "file host";
		} else {
			if (this.base !== null && this.base.scheme === "file") if (isNormalizedWindowsDriveLetterString(this.base.path[0])) this.url.path.push(this.base.path[0]);
			else this.url.host = this.base.host;
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse file host"] = function parseFileHost(c$1, cStr) {
		if (isNaN(c$1) || c$1 === 47 || c$1 === 92 || c$1 === 63 || c$1 === 35) {
			--this.pointer;
			if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
				this.parseError = true;
				this.state = "path";
			} else if (this.buffer === "") {
				this.url.host = "";
				if (this.stateOverride) return false;
				this.state = "path start";
			} else {
				let host = parseHost(this.buffer, isSpecial(this.url));
				if (host === failure) return failure;
				if (host === "localhost") host = "";
				this.url.host = host;
				if (this.stateOverride) return false;
				this.buffer = "";
				this.state = "path start";
			}
		} else this.buffer += cStr;
		return true;
	};
	URLStateMachine.prototype["parse path start"] = function parsePathStart(c$1) {
		if (isSpecial(this.url)) {
			if (c$1 === 92) this.parseError = true;
			this.state = "path";
			if (c$1 !== 47 && c$1 !== 92) --this.pointer;
		} else if (!this.stateOverride && c$1 === 63) {
			this.url.query = "";
			this.state = "query";
		} else if (!this.stateOverride && c$1 === 35) {
			this.url.fragment = "";
			this.state = "fragment";
		} else if (c$1 !== void 0) {
			this.state = "path";
			if (c$1 !== 47) --this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse path"] = function parsePath(c$1) {
		if (isNaN(c$1) || c$1 === 47 || isSpecial(this.url) && c$1 === 92 || !this.stateOverride && (c$1 === 63 || c$1 === 35)) {
			if (isSpecial(this.url) && c$1 === 92) this.parseError = true;
			if (isDoubleDot(this.buffer)) {
				shortenPath(this.url);
				if (c$1 !== 47 && !(isSpecial(this.url) && c$1 === 92)) this.url.path.push("");
			} else if (isSingleDot(this.buffer) && c$1 !== 47 && !(isSpecial(this.url) && c$1 === 92)) this.url.path.push("");
			else if (!isSingleDot(this.buffer)) {
				if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
					if (this.url.host !== "" && this.url.host !== null) {
						this.parseError = true;
						this.url.host = "";
					}
					this.buffer = this.buffer[0] + ":";
				}
				this.url.path.push(this.buffer);
			}
			this.buffer = "";
			if (this.url.scheme === "file" && (c$1 === void 0 || c$1 === 63 || c$1 === 35)) while (this.url.path.length > 1 && this.url.path[0] === "") {
				this.parseError = true;
				this.url.path.shift();
			}
			if (c$1 === 63) {
				this.url.query = "";
				this.state = "query";
			}
			if (c$1 === 35) {
				this.url.fragment = "";
				this.state = "fragment";
			}
		} else {
			if (c$1 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			this.buffer += percentEncodeChar(c$1, isPathPercentEncode);
		}
		return true;
	};
	URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c$1) {
		if (c$1 === 63) {
			this.url.query = "";
			this.state = "query";
		} else if (c$1 === 35) {
			this.url.fragment = "";
			this.state = "fragment";
		} else {
			if (!isNaN(c$1) && c$1 !== 37) this.parseError = true;
			if (c$1 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			if (!isNaN(c$1)) this.url.path[0] = this.url.path[0] + percentEncodeChar(c$1, isC0ControlPercentEncode);
		}
		return true;
	};
	URLStateMachine.prototype["parse query"] = function parseQuery(c$1, cStr) {
		if (isNaN(c$1) || !this.stateOverride && c$1 === 35) {
			if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") this.encodingOverride = "utf-8";
			const buffer = new Buffer(this.buffer);
			for (let i$1 = 0; i$1 < buffer.length; ++i$1) if (buffer[i$1] < 33 || buffer[i$1] > 126 || buffer[i$1] === 34 || buffer[i$1] === 35 || buffer[i$1] === 60 || buffer[i$1] === 62) this.url.query += percentEncode(buffer[i$1]);
			else this.url.query += String.fromCodePoint(buffer[i$1]);
			this.buffer = "";
			if (c$1 === 35) {
				this.url.fragment = "";
				this.state = "fragment";
			}
		} else {
			if (c$1 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			this.buffer += cStr;
		}
		return true;
	};
	URLStateMachine.prototype["parse fragment"] = function parseFragment(c$1) {
		if (isNaN(c$1)) {} else if (c$1 === 0) this.parseError = true;
		else {
			if (c$1 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			this.url.fragment += percentEncodeChar(c$1, isC0ControlPercentEncode);
		}
		return true;
	};
	function serializeURL(url, excludeFragment) {
		let output = url.scheme + ":";
		if (url.host !== null) {
			output += "//";
			if (url.username !== "" || url.password !== "") {
				output += url.username;
				if (url.password !== "") output += ":" + url.password;
				output += "@";
			}
			output += serializeHost(url.host);
			if (url.port !== null) output += ":" + url.port;
		} else if (url.host === null && url.scheme === "file") output += "//";
		if (url.cannotBeABaseURL) output += url.path[0];
		else for (const string of url.path) output += "/" + string;
		if (url.query !== null) output += "?" + url.query;
		if (!excludeFragment && url.fragment !== null) output += "#" + url.fragment;
		return output;
	}
	function serializeOrigin(tuple) {
		let result = tuple.scheme + "://";
		result += serializeHost(tuple.host);
		if (tuple.port !== null) result += ":" + tuple.port;
		return result;
	}
	module.exports.serializeURL = serializeURL;
	module.exports.serializeURLOrigin = function(url) {
		switch (url.scheme) {
			case "blob": try {
				return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
			} catch (e) {
				return "null";
			}
			case "ftp":
			case "gopher":
			case "http":
			case "https":
			case "ws":
			case "wss": return serializeOrigin({
				scheme: url.scheme,
				host: url.host,
				port: url.port
			});
			case "file": return "file://";
			default: return "null";
		}
	};
	module.exports.basicURLParse = function(input, options) {
		if (options === void 0) options = {};
		const usm$1 = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
		if (usm$1.failure) return "failure";
		return usm$1.url;
	};
	module.exports.setTheUsername = function(url, username) {
		url.username = "";
		const decoded = punycode.ucs2.decode(username);
		for (let i$1 = 0; i$1 < decoded.length; ++i$1) url.username += percentEncodeChar(decoded[i$1], isUserinfoPercentEncode);
	};
	module.exports.setThePassword = function(url, password) {
		url.password = "";
		const decoded = punycode.ucs2.decode(password);
		for (let i$1 = 0; i$1 < decoded.length; ++i$1) url.password += percentEncodeChar(decoded[i$1], isUserinfoPercentEncode);
	};
	module.exports.serializeHost = serializeHost;
	module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
	module.exports.serializeInteger = function(integer) {
		return String(integer);
	};
	module.exports.parseURL = function(input, options) {
		if (options === void 0) options = {};
		return module.exports.basicURLParse(input, {
			baseURL: options.baseURL,
			encodingOverride: options.encodingOverride
		});
	};
} });

//#endregion
//#region node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({ "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
	const usm = require_url_state_machine();
	exports.implementation = class URLImpl {
		constructor(constructorArgs) {
			const url = constructorArgs[0];
			const base = constructorArgs[1];
			let parsedBase = null;
			if (base !== void 0) {
				parsedBase = usm.basicURLParse(base);
				if (parsedBase === "failure") throw new TypeError("Invalid base URL");
			}
			const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
			if (parsedURL === "failure") throw new TypeError("Invalid URL");
			this._url = parsedURL;
		}
		get href() {
			return usm.serializeURL(this._url);
		}
		set href(v) {
			const parsedURL = usm.basicURLParse(v);
			if (parsedURL === "failure") throw new TypeError("Invalid URL");
			this._url = parsedURL;
		}
		get origin() {
			return usm.serializeURLOrigin(this._url);
		}
		get protocol() {
			return this._url.scheme + ":";
		}
		set protocol(v) {
			usm.basicURLParse(v + ":", {
				url: this._url,
				stateOverride: "scheme start"
			});
		}
		get username() {
			return this._url.username;
		}
		set username(v) {
			if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
			usm.setTheUsername(this._url, v);
		}
		get password() {
			return this._url.password;
		}
		set password(v) {
			if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
			usm.setThePassword(this._url, v);
		}
		get host() {
			const url = this._url;
			if (url.host === null) return "";
			if (url.port === null) return usm.serializeHost(url.host);
			return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
		}
		set host(v) {
			if (this._url.cannotBeABaseURL) return;
			usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "host"
			});
		}
		get hostname() {
			if (this._url.host === null) return "";
			return usm.serializeHost(this._url.host);
		}
		set hostname(v) {
			if (this._url.cannotBeABaseURL) return;
			usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "hostname"
			});
		}
		get port() {
			if (this._url.port === null) return "";
			return usm.serializeInteger(this._url.port);
		}
		set port(v) {
			if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
			if (v === "") this._url.port = null;
			else usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "port"
			});
		}
		get pathname() {
			if (this._url.cannotBeABaseURL) return this._url.path[0];
			if (this._url.path.length === 0) return "";
			return "/" + this._url.path.join("/");
		}
		set pathname(v) {
			if (this._url.cannotBeABaseURL) return;
			this._url.path = [];
			usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "path start"
			});
		}
		get search() {
			if (this._url.query === null || this._url.query === "") return "";
			return "?" + this._url.query;
		}
		set search(v) {
			const url = this._url;
			if (v === "") {
				url.query = null;
				return;
			}
			const input = v[0] === "?" ? v.substring(1) : v;
			url.query = "";
			usm.basicURLParse(input, {
				url,
				stateOverride: "query"
			});
		}
		get hash() {
			if (this._url.fragment === null || this._url.fragment === "") return "";
			return "#" + this._url.fragment;
		}
		set hash(v) {
			if (v === "") {
				this._url.fragment = null;
				return;
			}
			const input = v[0] === "#" ? v.substring(1) : v;
			this._url.fragment = "";
			usm.basicURLParse(input, {
				url: this._url,
				stateOverride: "fragment"
			});
		}
		toJSON() {
			return this.href;
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({ "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js"(exports, module) {
	const conversions = require_lib$1();
	const utils = require_utils();
	const Impl = require_URL_impl();
	const impl = utils.implSymbol;
	function URL$2(url) {
		if (!this || this[impl] || !(this instanceof URL$2)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
		if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
		const args = [];
		for (let i$1 = 0; i$1 < arguments.length && i$1 < 2; ++i$1) args[i$1] = arguments[i$1];
		args[0] = conversions["USVString"](args[0]);
		if (args[1] !== void 0) args[1] = conversions["USVString"](args[1]);
		module.exports.setup(this, args);
	}
	URL$2.prototype.toJSON = function toJSON() {
		if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
		const args = [];
		for (let i$1 = 0; i$1 < arguments.length && i$1 < 0; ++i$1) args[i$1] = arguments[i$1];
		return this[impl].toJSON.apply(this[impl], args);
	};
	Object.defineProperty(URL$2.prototype, "href", {
		get() {
			return this[impl].href;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].href = V;
		},
		enumerable: true,
		configurable: true
	});
	URL$2.prototype.toString = function() {
		if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
		return this.href;
	};
	Object.defineProperty(URL$2.prototype, "origin", {
		get() {
			return this[impl].origin;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "protocol", {
		get() {
			return this[impl].protocol;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].protocol = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "username", {
		get() {
			return this[impl].username;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].username = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "password", {
		get() {
			return this[impl].password;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].password = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "host", {
		get() {
			return this[impl].host;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].host = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "hostname", {
		get() {
			return this[impl].hostname;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].hostname = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "port", {
		get() {
			return this[impl].port;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].port = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "pathname", {
		get() {
			return this[impl].pathname;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].pathname = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "search", {
		get() {
			return this[impl].search;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].search = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$2.prototype, "hash", {
		get() {
			return this[impl].hash;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].hash = V;
		},
		enumerable: true,
		configurable: true
	});
	module.exports = {
		is(obj) {
			return !!obj && obj[impl] instanceof Impl.implementation;
		},
		create(constructorArgs, privateData$1) {
			let obj = Object.create(URL$2.prototype);
			this.setup(obj, constructorArgs, privateData$1);
			return obj;
		},
		setup(obj, constructorArgs, privateData$1) {
			if (!privateData$1) privateData$1 = {};
			privateData$1.wrapper = obj;
			obj[impl] = new Impl.implementation(constructorArgs, privateData$1);
			obj[impl][utils.wrapperSymbol] = obj;
		},
		interface: URL$2,
		expose: {
			Window: { URL: URL$2 },
			Worker: { URL: URL$2 }
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({ "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js"(exports) {
	exports.URL = require_URL().interface;
	exports.serializeURL = require_url_state_machine().serializeURL;
	exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
	exports.basicURLParse = require_url_state_machine().basicURLParse;
	exports.setTheUsername = require_url_state_machine().setTheUsername;
	exports.setThePassword = require_url_state_machine().setThePassword;
	exports.serializeHost = require_url_state_machine().serializeHost;
	exports.serializeInteger = require_url_state_machine().serializeInteger;
	exports.parseURL = require_url_state_machine().parseURL;
} });

//#endregion
//#region node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.js
var require_lib = __commonJS({ "node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.js"(exports, module) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function _interopDefault(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var Stream$1 = _interopDefault(__require("stream"));
	var http = _interopDefault(__require("http"));
	var Url = _interopDefault(__require("url"));
	var whatwgUrl = _interopDefault(require_public_api());
	var https = _interopDefault(__require("https"));
	var zlib = _interopDefault(__require("zlib"));
	const Readable$1 = Stream$1.Readable;
	const BUFFER = Symbol("buffer");
	const TYPE = Symbol("type");
	var Blob$2 = class Blob$2 {
		constructor() {
			this[TYPE] = "";
			const blobParts = arguments[0];
			const options = arguments[1];
			const buffers = [];
			let size = 0;
			if (blobParts) {
				const a$1 = blobParts;
				const length = Number(a$1.length);
				for (let i$1 = 0; i$1 < length; i$1++) {
					const element = a$1[i$1];
					let buffer;
					if (element instanceof Buffer) buffer = element;
					else if (ArrayBuffer.isView(element)) buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
					else if (element instanceof ArrayBuffer) buffer = Buffer.from(element);
					else if (element instanceof Blob$2) buffer = element[BUFFER];
					else buffer = Buffer.from(typeof element === "string" ? element : String(element));
					size += buffer.length;
					buffers.push(buffer);
				}
			}
			this[BUFFER] = Buffer.concat(buffers);
			let type = options && options.type !== void 0 && String(options.type).toLowerCase();
			if (type && !/[^\u0020-\u007E]/.test(type)) this[TYPE] = type;
		}
		get size() {
			return this[BUFFER].length;
		}
		get type() {
			return this[TYPE];
		}
		text() {
			return Promise.resolve(this[BUFFER].toString());
		}
		arrayBuffer() {
			const buf = this[BUFFER];
			const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
			return Promise.resolve(ab);
		}
		stream() {
			const readable$1 = new Readable$1();
			readable$1._read = function() {};
			readable$1.push(this[BUFFER]);
			readable$1.push(null);
			return readable$1;
		}
		toString() {
			return "[object Blob]";
		}
		slice() {
			const size = this.size;
			const start = arguments[0];
			const end = arguments[1];
			let relativeStart, relativeEnd;
			if (start === void 0) relativeStart = 0;
			else if (start < 0) relativeStart = Math.max(size + start, 0);
			else relativeStart = Math.min(start, size);
			if (end === void 0) relativeEnd = size;
			else if (end < 0) relativeEnd = Math.max(size + end, 0);
			else relativeEnd = Math.min(end, size);
			const span = Math.max(relativeEnd - relativeStart, 0);
			const buffer = this[BUFFER];
			const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
			const blob = new Blob$2([], { type: arguments[2] });
			blob[BUFFER] = slicedBuffer;
			return blob;
		}
	};
	Object.defineProperties(Blob$2.prototype, {
		size: { enumerable: true },
		type: { enumerable: true },
		slice: { enumerable: true }
	});
	Object.defineProperty(Blob$2.prototype, Symbol.toStringTag, {
		value: "Blob",
		writable: false,
		enumerable: false,
		configurable: true
	});
	/**
	* fetch-error.js
	*
	* FetchError interface for operational errors
	*/
	/**
	* Create FetchError instance
	*
	* @param   String      message      Error message for human
	* @param   String      type         Error type for machine
	* @param   String      systemError  For Node.js system error
	* @return  FetchError
	*/
	function FetchError(message, type, systemError) {
		Error.call(this, message);
		this.message = message;
		this.type = type;
		if (systemError) this.code = this.errno = systemError.code;
		Error.captureStackTrace(this, this.constructor);
	}
	FetchError.prototype = Object.create(Error.prototype);
	FetchError.prototype.constructor = FetchError;
	FetchError.prototype.name = "FetchError";
	let convert;
	try {
		convert = __require("encoding").convert;
	} catch (e) {}
	const INTERNALS = Symbol("Body internals");
	const PassThrough$1 = Stream$1.PassThrough;
	/**
	* Body mixin
	*
	* Ref: https://fetch.spec.whatwg.org/#body
	*
	* @param   Stream  body  Readable stream
	* @param   Object  opts  Response options
	* @return  Void
	*/
	function Body(body) {
		var _this = this;
		var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
		let size = _ref$size === void 0 ? 0 : _ref$size;
		var _ref$timeout = _ref.timeout;
		let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
		if (body == null) body = null;
		else if (isURLSearchParams(body)) body = Buffer.from(body.toString());
		else if (isBlob$1(body));
		else if (Buffer.isBuffer(body));
		else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") body = Buffer.from(body);
		else if (ArrayBuffer.isView(body)) body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
		else if (body instanceof Stream$1);
		else body = Buffer.from(String(body));
		this[INTERNALS] = {
			body,
			disturbed: false,
			error: null
		};
		this.size = size;
		this.timeout = timeout;
		if (body instanceof Stream$1) body.on("error", function(err) {
			const error$1 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
			_this[INTERNALS].error = error$1;
		});
	}
	Body.prototype = {
		get body() {
			return this[INTERNALS].body;
		},
		get bodyUsed() {
			return this[INTERNALS].disturbed;
		},
		arrayBuffer() {
			return consumeBody.call(this).then(function(buf) {
				return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
			});
		},
		blob() {
			let ct = this.headers && this.headers.get("content-type") || "";
			return consumeBody.call(this).then(function(buf) {
				return Object.assign(new Blob$2([], { type: ct.toLowerCase() }), { [BUFFER]: buf });
			});
		},
		json() {
			var _this2 = this;
			return consumeBody.call(this).then(function(buffer) {
				try {
					return JSON.parse(buffer.toString());
				} catch (err) {
					return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
				}
			});
		},
		text() {
			return consumeBody.call(this).then(function(buffer) {
				return buffer.toString();
			});
		},
		buffer() {
			return consumeBody.call(this);
		},
		textConverted() {
			var _this3 = this;
			return consumeBody.call(this).then(function(buffer) {
				return convertBody(buffer, _this3.headers);
			});
		}
	};
	Object.defineProperties(Body.prototype, {
		body: { enumerable: true },
		bodyUsed: { enumerable: true },
		arrayBuffer: { enumerable: true },
		blob: { enumerable: true },
		json: { enumerable: true },
		text: { enumerable: true }
	});
	Body.mixIn = function(proto) {
		for (const name of Object.getOwnPropertyNames(Body.prototype))
 // istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	};
	/**
	* Consume and convert an entire Body to a Buffer.
	*
	* Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
	*
	* @return  Promise
	*/
	function consumeBody() {
		var _this4 = this;
		if (this[INTERNALS].disturbed) return Body.Promise.reject(/* @__PURE__ */ new TypeError(`body used already for: ${this.url}`));
		this[INTERNALS].disturbed = true;
		if (this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
		let body = this.body;
		if (body === null) return Body.Promise.resolve(Buffer.alloc(0));
		if (isBlob$1(body)) body = body.stream();
		if (Buffer.isBuffer(body)) return Body.Promise.resolve(body);
		// istanbul ignore if: should never happen
		if (!(body instanceof Stream$1)) return Body.Promise.resolve(Buffer.alloc(0));
		let accum = [];
		let accumBytes = 0;
		let abort$1 = false;
		return new Body.Promise(function(resolve, reject) {
			let resTimeout;
			if (_this4.timeout) resTimeout = setTimeout(function() {
				abort$1 = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
			}, _this4.timeout);
			body.on("error", function(err) {
				if (err.name === "AbortError") {
					abort$1 = true;
					reject(err);
				} else reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
			});
			body.on("data", function(chunk) {
				if (abort$1 || chunk === null) return;
				if (_this4.size && accumBytes + chunk.length > _this4.size) {
					abort$1 = true;
					reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
					return;
				}
				accumBytes += chunk.length;
				accum.push(chunk);
			});
			body.on("end", function() {
				if (abort$1) return;
				clearTimeout(resTimeout);
				try {
					resolve(Buffer.concat(accum, accumBytes));
				} catch (err) {
					reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
				}
			});
		});
	}
	/**
	* Detect buffer encoding and convert to target encoding
	* ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
	*
	* @param   Buffer  buffer    Incoming buffer
	* @param   String  encoding  Target encoding
	* @return  String
	*/
	function convertBody(buffer, headers) {
		if (typeof convert !== "function") throw new Error("The package `encoding` must be installed to use the textConverted() function");
		const ct = headers.get("content-type");
		let charset = "utf-8";
		let res, str$1;
		if (ct) res = /charset=([^;]*)/i.exec(ct);
		str$1 = buffer.slice(0, 1024).toString();
		if (!res && str$1) res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str$1);
		if (!res && str$1) {
			res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str$1);
			if (!res) {
				res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str$1);
				if (res) res.pop();
			}
			if (res) res = /charset=(.*)/i.exec(res.pop());
		}
		if (!res && str$1) res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str$1);
		if (res) {
			charset = res.pop();
			if (charset === "gb2312" || charset === "gbk") charset = "gb18030";
		}
		return convert(buffer, "UTF-8", charset).toString();
	}
	/**
	* Detect a URLSearchParams object
	* ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
	*
	* @param   Object  obj     Object to detect by type or brand
	* @return  String
	*/
	function isURLSearchParams(obj) {
		if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") return false;
		return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
	}
	/**
	* Check if `obj` is a W3C `Blob` object (which `File` inherits from)
	* @param  {*} obj
	* @return {boolean}
	*/
	function isBlob$1(obj) {
		return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
	}
	/**
	* Clone body given Res/Req instance
	*
	* @param   Mixed  instance  Response or Request instance
	* @return  Mixed
	*/
	function clone(instance) {
		let p1, p2;
		let body = instance.body;
		if (instance.bodyUsed) throw new Error("cannot clone body after it is used");
		if (body instanceof Stream$1 && typeof body.getBoundary !== "function") {
			p1 = new PassThrough$1();
			p2 = new PassThrough$1();
			body.pipe(p1);
			body.pipe(p2);
			instance[INTERNALS].body = p1;
			body = p2;
		}
		return body;
	}
	/**
	* Performs the operation "extract a `Content-Type` value from |object|" as
	* specified in the specification:
	* https://fetch.spec.whatwg.org/#concept-bodyinit-extract
	*
	* This function assumes that instance.body is present.
	*
	* @param   Mixed  instance  Any options.body input
	*/
	function extractContentType(body) {
		if (body === null) return null;
		else if (typeof body === "string") return "text/plain;charset=UTF-8";
		else if (isURLSearchParams(body)) return "application/x-www-form-urlencoded;charset=UTF-8";
		else if (isBlob$1(body)) return body.type || null;
		else if (Buffer.isBuffer(body)) return null;
		else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") return null;
		else if (ArrayBuffer.isView(body)) return null;
		else if (typeof body.getBoundary === "function") return `multipart/form-data;boundary=${body.getBoundary()}`;
		else if (body instanceof Stream$1) return null;
		else return "text/plain;charset=UTF-8";
	}
	/**
	* The Fetch Standard treats this as if "total bytes" is a property on the body.
	* For us, we have to explicitly get it with a function.
	*
	* ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
	*
	* @param   Body    instance   Instance of Body
	* @return  Number?            Number of bytes, or null if not possible
	*/
	function getTotalBytes(instance) {
		const body = instance.body;
		if (body === null) return 0;
		else if (isBlob$1(body)) return body.size;
		else if (Buffer.isBuffer(body)) return body.length;
		else if (body && typeof body.getLengthSync === "function") {
			if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) return body.getLengthSync();
			return null;
		} else return null;
	}
	/**
	* Write a Body to a Node.js WritableStream (e.g. http.Request) object.
	*
	* @param   Body    instance   Instance of Body
	* @return  Void
	*/
	function writeToStream(dest, instance) {
		const body = instance.body;
		if (body === null) dest.end();
		else if (isBlob$1(body)) body.stream().pipe(dest);
		else if (Buffer.isBuffer(body)) {
			dest.write(body);
			dest.end();
		} else body.pipe(dest);
	}
	Body.Promise = global.Promise;
	/**
	* headers.js
	*
	* Headers class offers convenient helpers
	*/
	const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
	const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
	function validateName(name) {
		name = `${name}`;
		if (invalidTokenRegex.test(name) || name === "") throw new TypeError(`${name} is not a legal HTTP header name`);
	}
	function validateValue(value) {
		value = `${value}`;
		if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
	}
	/**
	* Find the key in the map object given a header name.
	*
	* Returns undefined if not found.
	*
	* @param   String  name  Header name
	* @return  String|Undefined
	*/
	function find(map, name) {
		name = name.toLowerCase();
		for (const key in map) if (key.toLowerCase() === name) return key;
		return void 0;
	}
	const MAP = Symbol("map");
	var Headers = class Headers {
		/**
		* Headers class
		*
		* @param   Object  headers  Response headers
		* @return  Void
		*/
		constructor() {
			let init$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
			this[MAP] = Object.create(null);
			if (init$1 instanceof Headers) {
				const rawHeaders = init$1.raw();
				const headerNames = Object.keys(rawHeaders);
				for (const headerName of headerNames) for (const value of rawHeaders[headerName]) this.append(headerName, value);
				return;
			}
			if (init$1 == null);
			else if (typeof init$1 === "object") {
				const method = init$1[Symbol.iterator];
				if (method != null) {
					if (typeof method !== "function") throw new TypeError("Header pairs must be iterable");
					const pairs = [];
					for (const pair of init$1) {
						if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") throw new TypeError("Each header pair must be iterable");
						pairs.push(Array.from(pair));
					}
					for (const pair of pairs) {
						if (pair.length !== 2) throw new TypeError("Each header pair must be a name/value tuple");
						this.append(pair[0], pair[1]);
					}
				} else for (const key of Object.keys(init$1)) {
					const value = init$1[key];
					this.append(key, value);
				}
			} else throw new TypeError("Provided initializer must be an object");
		}
		/**
		* Return combined header value given name
		*
		* @param   String  name  Header name
		* @return  Mixed
		*/
		get(name) {
			name = `${name}`;
			validateName(name);
			const key = find(this[MAP], name);
			if (key === void 0) return null;
			return this[MAP][key].join(", ");
		}
		/**
		* Iterate over all headers
		*
		* @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
		* @param   Boolean   thisArg   `this` context for callback function
		* @return  Void
		*/
		forEach(callback) {
			let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
			let pairs = getHeaders(this);
			let i$1 = 0;
			while (i$1 < pairs.length) {
				var _pairs$i = pairs[i$1];
				const name = _pairs$i[0], value = _pairs$i[1];
				callback.call(thisArg, value, name, this);
				pairs = getHeaders(this);
				i$1++;
			}
		}
		/**
		* Overwrite header values given name
		*
		* @param   String  name   Header name
		* @param   String  value  Header value
		* @return  Void
		*/
		set(name, value) {
			name = `${name}`;
			value = `${value}`;
			validateName(name);
			validateValue(value);
			const key = find(this[MAP], name);
			this[MAP][key !== void 0 ? key : name] = [value];
		}
		/**
		* Append a value onto existing header
		*
		* @param   String  name   Header name
		* @param   String  value  Header value
		* @return  Void
		*/
		append(name, value) {
			name = `${name}`;
			value = `${value}`;
			validateName(name);
			validateValue(value);
			const key = find(this[MAP], name);
			if (key !== void 0) this[MAP][key].push(value);
			else this[MAP][name] = [value];
		}
		/**
		* Check for header name existence
		*
		* @param   String   name  Header name
		* @return  Boolean
		*/
		has(name) {
			name = `${name}`;
			validateName(name);
			return find(this[MAP], name) !== void 0;
		}
		/**
		* Delete all header values given name
		*
		* @param   String  name  Header name
		* @return  Void
		*/
		delete(name) {
			name = `${name}`;
			validateName(name);
			const key = find(this[MAP], name);
			if (key !== void 0) delete this[MAP][key];
		}
		/**
		* Return raw headers (non-spec api)
		*
		* @return  Object
		*/
		raw() {
			return this[MAP];
		}
		/**
		* Get an iterator on keys.
		*
		* @return  Iterator
		*/
		keys() {
			return createHeadersIterator(this, "key");
		}
		/**
		* Get an iterator on values.
		*
		* @return  Iterator
		*/
		values() {
			return createHeadersIterator(this, "value");
		}
		/**
		* Get an iterator on entries.
		*
		* This is the default iterator of the Headers object.
		*
		* @return  Iterator
		*/
		[Symbol.iterator]() {
			return createHeadersIterator(this, "key+value");
		}
	};
	Headers.prototype.entries = Headers.prototype[Symbol.iterator];
	Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
		value: "Headers",
		writable: false,
		enumerable: false,
		configurable: true
	});
	Object.defineProperties(Headers.prototype, {
		get: { enumerable: true },
		forEach: { enumerable: true },
		set: { enumerable: true },
		append: { enumerable: true },
		has: { enumerable: true },
		delete: { enumerable: true },
		keys: { enumerable: true },
		values: { enumerable: true },
		entries: { enumerable: true }
	});
	function getHeaders(headers) {
		let kind$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
		const keys = Object.keys(headers[MAP]).sort();
		return keys.map(kind$1 === "key" ? function(k) {
			return k.toLowerCase();
		} : kind$1 === "value" ? function(k) {
			return headers[MAP][k].join(", ");
		} : function(k) {
			return [k.toLowerCase(), headers[MAP][k].join(", ")];
		});
	}
	const INTERNAL = Symbol("internal");
	function createHeadersIterator(target, kind$1) {
		const iterator$1 = Object.create(HeadersIteratorPrototype);
		iterator$1[INTERNAL] = {
			target,
			kind: kind$1,
			index: 0
		};
		return iterator$1;
	}
	const HeadersIteratorPrototype = Object.setPrototypeOf({ next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError("Value of `this` is not a HeadersIterator");
		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target, kind$1 = _INTERNAL.kind, index = _INTERNAL.index;
		const values = getHeaders(target, kind$1);
		const len = values.length;
		if (index >= len) return {
			value: void 0,
			done: true
		};
		this[INTERNAL].index = index + 1;
		return {
			value: values[index],
			done: false
		};
	} }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
	Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
		value: "HeadersIterator",
		writable: false,
		enumerable: false,
		configurable: true
	});
	/**
	* Export the Headers object in a form that Node.js can consume.
	*
	* @param   Headers  headers
	* @return  Object
	*/
	function exportNodeCompatibleHeaders(headers) {
		const obj = Object.assign({ __proto__: null }, headers[MAP]);
		const hostHeaderKey = find(headers[MAP], "Host");
		if (hostHeaderKey !== void 0) obj[hostHeaderKey] = obj[hostHeaderKey][0];
		return obj;
	}
	/**
	* Create a Headers object from an object of headers, ignoring those that do
	* not conform to HTTP grammar productions.
	*
	* @param   Object  obj  Object of headers
	* @return  Headers
	*/
	function createHeadersLenient(obj) {
		const headers = new Headers();
		for (const name of Object.keys(obj)) {
			if (invalidTokenRegex.test(name)) continue;
			if (Array.isArray(obj[name])) for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) continue;
				if (headers[MAP][name] === void 0) headers[MAP][name] = [val];
				else headers[MAP][name].push(val);
			}
			else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [obj[name]];
		}
		return headers;
	}
	const INTERNALS$1 = Symbol("Response internals");
	const STATUS_CODES = http.STATUS_CODES;
	/**
	* Response class
	*
	* @param   Stream  body  Readable stream
	* @param   Object  opts  Response options
	* @return  Void
	*/
	var Response = class Response {
		constructor() {
			let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
			let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			Body.call(this, body, opts);
			const status = opts.status || 200;
			const headers = new Headers(opts.headers);
			if (body != null && !headers.has("Content-Type")) {
				const contentType = extractContentType(body);
				if (contentType) headers.append("Content-Type", contentType);
			}
			this[INTERNALS$1] = {
				url: opts.url,
				status,
				statusText: opts.statusText || STATUS_CODES[status],
				headers,
				counter: opts.counter
			};
		}
		get url() {
			return this[INTERNALS$1].url || "";
		}
		get status() {
			return this[INTERNALS$1].status;
		}
		/**
		* Convenience property representing if the request ended normally
		*/
		get ok() {
			return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
		}
		get redirected() {
			return this[INTERNALS$1].counter > 0;
		}
		get statusText() {
			return this[INTERNALS$1].statusText;
		}
		get headers() {
			return this[INTERNALS$1].headers;
		}
		/**
		* Clone this response
		*
		* @return  Response
		*/
		clone() {
			return new Response(clone(this), {
				url: this.url,
				status: this.status,
				statusText: this.statusText,
				headers: this.headers,
				ok: this.ok,
				redirected: this.redirected
			});
		}
	};
	Body.mixIn(Response.prototype);
	Object.defineProperties(Response.prototype, {
		url: { enumerable: true },
		status: { enumerable: true },
		ok: { enumerable: true },
		redirected: { enumerable: true },
		statusText: { enumerable: true },
		headers: { enumerable: true },
		clone: { enumerable: true }
	});
	Object.defineProperty(Response.prototype, Symbol.toStringTag, {
		value: "Response",
		writable: false,
		enumerable: false,
		configurable: true
	});
	const INTERNALS$2 = Symbol("Request internals");
	const URL$1 = Url.URL || whatwgUrl.URL;
	const parse_url = Url.parse;
	const format_url = Url.format;
	/**
	* Wrapper around `new URL` to handle arbitrary URLs
	*
	* @param  {string} urlStr
	* @return {void}
	*/
	function parseURL(urlStr) {
		if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) urlStr = new URL$1(urlStr).toString();
		return parse_url(urlStr);
	}
	const streamDestructionSupported = "destroy" in Stream$1.Readable.prototype;
	/**
	* Check if a value is an instance of Request.
	*
	* @param   Mixed   input
	* @return  Boolean
	*/
	function isRequest(input) {
		return typeof input === "object" && typeof input[INTERNALS$2] === "object";
	}
	function isAbortSignal(signal) {
		const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
		return !!(proto && proto.constructor.name === "AbortSignal");
	}
	/**
	* Request class
	*
	* @param   Mixed   input  Url or Request instance
	* @param   Object  init   Custom options
	* @return  Void
	*/
	var Request = class Request {
		constructor(input) {
			let init$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			let parsedURL;
			if (!isRequest(input)) {
				if (input && input.href) parsedURL = parseURL(input.href);
				else parsedURL = parseURL(`${input}`);
				input = {};
			} else parsedURL = parseURL(input.url);
			let method = init$1.method || input.method || "GET";
			method = method.toUpperCase();
			if ((init$1.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body");
			let inputBody = init$1.body != null ? init$1.body : isRequest(input) && input.body !== null ? clone(input) : null;
			Body.call(this, inputBody, {
				timeout: init$1.timeout || input.timeout || 0,
				size: init$1.size || input.size || 0
			});
			const headers = new Headers(init$1.headers || input.headers || {});
			if (inputBody != null && !headers.has("Content-Type")) {
				const contentType = extractContentType(inputBody);
				if (contentType) headers.append("Content-Type", contentType);
			}
			let signal = isRequest(input) ? input.signal : null;
			if ("signal" in init$1) signal = init$1.signal;
			if (signal != null && !isAbortSignal(signal)) throw new TypeError("Expected signal to be an instanceof AbortSignal");
			this[INTERNALS$2] = {
				method,
				redirect: init$1.redirect || input.redirect || "follow",
				headers,
				parsedURL,
				signal
			};
			this.follow = init$1.follow !== void 0 ? init$1.follow : input.follow !== void 0 ? input.follow : 20;
			this.compress = init$1.compress !== void 0 ? init$1.compress : input.compress !== void 0 ? input.compress : true;
			this.counter = init$1.counter || input.counter || 0;
			this.agent = init$1.agent || input.agent;
		}
		get method() {
			return this[INTERNALS$2].method;
		}
		get url() {
			return format_url(this[INTERNALS$2].parsedURL);
		}
		get headers() {
			return this[INTERNALS$2].headers;
		}
		get redirect() {
			return this[INTERNALS$2].redirect;
		}
		get signal() {
			return this[INTERNALS$2].signal;
		}
		/**
		* Clone this request
		*
		* @return  Request
		*/
		clone() {
			return new Request(this);
		}
	};
	Body.mixIn(Request.prototype);
	Object.defineProperty(Request.prototype, Symbol.toStringTag, {
		value: "Request",
		writable: false,
		enumerable: false,
		configurable: true
	});
	Object.defineProperties(Request.prototype, {
		method: { enumerable: true },
		url: { enumerable: true },
		headers: { enumerable: true },
		redirect: { enumerable: true },
		clone: { enumerable: true },
		signal: { enumerable: true }
	});
	/**
	* Convert a Request to Node.js http request options.
	*
	* @param   Request  A Request instance
	* @return  Object   The options object to be passed to http.request
	*/
	function getNodeRequestOptions(request$2) {
		const parsedURL = request$2[INTERNALS$2].parsedURL;
		const headers = new Headers(request$2[INTERNALS$2].headers);
		if (!headers.has("Accept")) headers.set("Accept", "*/*");
		if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError("Only absolute URLs are supported");
		if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError("Only HTTP(S) protocols are supported");
		if (request$2.signal && request$2.body instanceof Stream$1.Readable && !streamDestructionSupported) throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
		let contentLengthValue = null;
		if (request$2.body == null && /^(POST|PUT)$/i.test(request$2.method)) contentLengthValue = "0";
		if (request$2.body != null) {
			const totalBytes = getTotalBytes(request$2);
			if (typeof totalBytes === "number") contentLengthValue = String(totalBytes);
		}
		if (contentLengthValue) headers.set("Content-Length", contentLengthValue);
		if (!headers.has("User-Agent")) headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
		if (request$2.compress && !headers.has("Accept-Encoding")) headers.set("Accept-Encoding", "gzip,deflate");
		let agent = request$2.agent;
		if (typeof agent === "function") agent = agent(parsedURL);
		return Object.assign({}, parsedURL, {
			method: request$2.method,
			headers: exportNodeCompatibleHeaders(headers),
			agent
		});
	}
	/**
	* abort-error.js
	*
	* AbortError interface for cancelled requests
	*/
	/**
	* Create AbortError instance
	*
	* @param   String      message      Error message for human
	* @return  AbortError
	*/
	function AbortError(message) {
		Error.call(this, message);
		this.type = "aborted";
		this.message = message;
		Error.captureStackTrace(this, this.constructor);
	}
	AbortError.prototype = Object.create(Error.prototype);
	AbortError.prototype.constructor = AbortError;
	AbortError.prototype.name = "AbortError";
	const URL$1$1 = Url.URL || whatwgUrl.URL;
	const PassThrough$1$1 = Stream$1.PassThrough;
	const isDomainOrSubdomain = function isDomainOrSubdomain$1(destination, original) {
		const orig = new URL$1$1(original).hostname;
		const dest = new URL$1$1(destination).hostname;
		return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
	};
	/**
	* isSameProtocol reports whether the two provided URLs use the same protocol.
	*
	* Both domains must already be in canonical form.
	* @param {string|URL} original
	* @param {string|URL} destination
	*/
	const isSameProtocol = function isSameProtocol$1(destination, original) {
		const orig = new URL$1$1(original).protocol;
		const dest = new URL$1$1(destination).protocol;
		return orig === dest;
	};
	/**
	* Fetch function
	*
	* @param   Mixed    url   Absolute url or Request instance
	* @param   Object   opts  Fetch options
	* @return  Promise
	*/
	function fetch$1(url, opts) {
		if (!fetch$1.Promise) throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
		Body.Promise = fetch$1.Promise;
		return new fetch$1.Promise(function(resolve, reject) {
			const request$2 = new Request(url, opts);
			const options = getNodeRequestOptions(request$2);
			const send = (options.protocol === "https:" ? https : http).request;
			const signal = request$2.signal;
			let response = null;
			const abort$1 = function abort$2() {
				let error$1 = new AbortError("The user aborted a request.");
				reject(error$1);
				if (request$2.body && request$2.body instanceof Stream$1.Readable) destroyStream(request$2.body, error$1);
				if (!response || !response.body) return;
				response.body.emit("error", error$1);
			};
			if (signal && signal.aborted) {
				abort$1();
				return;
			}
			const abortAndFinalize = function abortAndFinalize$1() {
				abort$1();
				finalize();
			};
			const req = send(options);
			let reqTimeout;
			if (signal) signal.addEventListener("abort", abortAndFinalize);
			function finalize() {
				req.abort();
				if (signal) signal.removeEventListener("abort", abortAndFinalize);
				clearTimeout(reqTimeout);
			}
			if (request$2.timeout) req.once("socket", function(socket) {
				reqTimeout = setTimeout(function() {
					reject(new FetchError(`network timeout at: ${request$2.url}`, "request-timeout"));
					finalize();
				}, request$2.timeout);
			});
			req.on("error", function(err) {
				reject(new FetchError(`request to ${request$2.url} failed, reason: ${err.message}`, "system", err));
				if (response && response.body) destroyStream(response.body, err);
				finalize();
			});
			fixResponseChunkedTransferBadEnding(req, function(err) {
				if (signal && signal.aborted) return;
				if (response && response.body) destroyStream(response.body, err);
			});
			/* c8 ignore next 18 */
			if (parseInt(process.version.substring(1)) < 14) req.on("socket", function(s$1) {
				s$1.addListener("close", function(hadError) {
					const hasDataListener = s$1.listenerCount("data") > 0;
					if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
						const err = /* @__PURE__ */ new Error("Premature close");
						err.code = "ERR_STREAM_PREMATURE_CLOSE";
						response.body.emit("error", err);
					}
				});
			});
			req.on("response", function(res) {
				clearTimeout(reqTimeout);
				const headers = createHeadersLenient(res.headers);
				if (fetch$1.isRedirect(res.statusCode)) {
					const location = headers.get("Location");
					let locationURL = null;
					try {
						locationURL = location === null ? null : new URL$1$1(location, request$2.url).toString();
					} catch (err) {
						if (request$2.redirect !== "manual") {
							reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
							finalize();
							return;
						}
					}
					switch (request$2.redirect) {
						case "error":
							reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request$2.url}`, "no-redirect"));
							finalize();
							return;
						case "manual":
							if (locationURL !== null) try {
								headers.set("Location", locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
							break;
						case "follow":
							if (locationURL === null) break;
							if (request$2.counter >= request$2.follow) {
								reject(new FetchError(`maximum redirect reached at: ${request$2.url}`, "max-redirect"));
								finalize();
								return;
							}
							const requestOpts = {
								headers: new Headers(request$2.headers),
								follow: request$2.follow,
								counter: request$2.counter + 1,
								agent: request$2.agent,
								compress: request$2.compress,
								method: request$2.method,
								body: request$2.body,
								signal: request$2.signal,
								timeout: request$2.timeout,
								size: request$2.size
							};
							if (!isDomainOrSubdomain(request$2.url, locationURL) || !isSameProtocol(request$2.url, locationURL)) for (const name of [
								"authorization",
								"www-authenticate",
								"cookie",
								"cookie2"
							]) requestOpts.headers.delete(name);
							if (res.statusCode !== 303 && request$2.body && getTotalBytes(request$2) === null) {
								reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
								finalize();
								return;
							}
							if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request$2.method === "POST") {
								requestOpts.method = "GET";
								requestOpts.body = void 0;
								requestOpts.headers.delete("content-length");
							}
							resolve(fetch$1(new Request(locationURL, requestOpts)));
							finalize();
							return;
					}
				}
				res.once("end", function() {
					if (signal) signal.removeEventListener("abort", abortAndFinalize);
				});
				let body = res.pipe(new PassThrough$1$1());
				const response_options = {
					url: request$2.url,
					status: res.statusCode,
					statusText: res.statusMessage,
					headers,
					size: request$2.size,
					timeout: request$2.timeout,
					counter: request$2.counter
				};
				const codings = headers.get("Content-Encoding");
				if (!request$2.compress || request$2.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
					response = new Response(body, response_options);
					resolve(response);
					return;
				}
				const zlibOptions = {
					flush: zlib.Z_SYNC_FLUSH,
					finishFlush: zlib.Z_SYNC_FLUSH
				};
				if (codings == "gzip" || codings == "x-gzip") {
					body = body.pipe(zlib.createGunzip(zlibOptions));
					response = new Response(body, response_options);
					resolve(response);
					return;
				}
				if (codings == "deflate" || codings == "x-deflate") {
					const raw = res.pipe(new PassThrough$1$1());
					raw.once("data", function(chunk) {
						if ((chunk[0] & 15) === 8) body = body.pipe(zlib.createInflate());
						else body = body.pipe(zlib.createInflateRaw());
						response = new Response(body, response_options);
						resolve(response);
					});
					raw.on("end", function() {
						if (!response) {
							response = new Response(body, response_options);
							resolve(response);
						}
					});
					return;
				}
				if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
					body = body.pipe(zlib.createBrotliDecompress());
					response = new Response(body, response_options);
					resolve(response);
					return;
				}
				response = new Response(body, response_options);
				resolve(response);
			});
			writeToStream(req, request$2);
		});
	}
	function fixResponseChunkedTransferBadEnding(request$2, errorCallback) {
		let socket;
		request$2.on("socket", function(s$1) {
			socket = s$1;
		});
		request$2.on("response", function(response) {
			const headers = response.headers;
			if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) response.once("close", function(hadError) {
				const hasDataListener = socket && socket.listenerCount("data") > 0;
				if (hasDataListener && !hadError) {
					const err = /* @__PURE__ */ new Error("Premature close");
					err.code = "ERR_STREAM_PREMATURE_CLOSE";
					errorCallback(err);
				}
			});
		});
	}
	function destroyStream(stream$2, err) {
		if (stream$2.destroy) stream$2.destroy(err);
		else {
			stream$2.emit("error", err);
			stream$2.end();
		}
	}
	/**
	* Redirect code matching
	*
	* @param   Number   code  Status code
	* @return  Boolean
	*/
	fetch$1.isRedirect = function(code) {
		return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
	};
	fetch$1.Promise = global.Promise;
	module.exports = exports = fetch$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = exports;
	exports.Headers = Headers;
	exports.Request = Request;
	exports.Response = Response;
	exports.FetchError = FetchError;
	exports.AbortError = AbortError;
} });

//#endregion
//#region node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/isBlob.js
const isBlob = (value) => value instanceof Blob$1;

//#endregion
//#region node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/deprecateConstructorEntries.js
const deprecateConstructorEntries = deprecate(() => {}, "Constructor \"entries\" argument is not spec-compliant and will be removed in next major release.");

//#endregion
//#region node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/FormData.js
var __classPrivateFieldGet$8 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormData_instances, _FormData_entries, _FormData_setEntry;
var FormData$1 = class {
	constructor(entries) {
		_FormData_instances.add(this);
		_FormData_entries.set(this, /* @__PURE__ */ new Map());
		if (entries) {
			deprecateConstructorEntries();
			entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));
		}
	}
	static [(_FormData_entries = /* @__PURE__ */ new WeakMap(), _FormData_instances = /* @__PURE__ */ new WeakSet(), Symbol.hasInstance)](value) {
		return Boolean(value && isFunction(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction(value.append) && isFunction(value.set) && isFunction(value.get) && isFunction(value.getAll) && isFunction(value.has) && isFunction(value.delete) && isFunction(value.entries) && isFunction(value.values) && isFunction(value.keys) && isFunction(value[Symbol.iterator]) && isFunction(value.forEach));
	}
	append(name, value, fileName) {
		__classPrivateFieldGet$8(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
			name,
			fileName,
			append: true,
			rawValue: value,
			argsLength: arguments.length
		});
	}
	set(name, value, fileName) {
		__classPrivateFieldGet$8(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
			name,
			fileName,
			append: false,
			rawValue: value,
			argsLength: arguments.length
		});
	}
	get(name) {
		const field = __classPrivateFieldGet$8(this, _FormData_entries, "f").get(String(name));
		if (!field) return null;
		return field[0];
	}
	getAll(name) {
		const field = __classPrivateFieldGet$8(this, _FormData_entries, "f").get(String(name));
		if (!field) return [];
		return field.slice();
	}
	has(name) {
		return __classPrivateFieldGet$8(this, _FormData_entries, "f").has(String(name));
	}
	delete(name) {
		__classPrivateFieldGet$8(this, _FormData_entries, "f").delete(String(name));
	}
	*keys() {
		for (const key of __classPrivateFieldGet$8(this, _FormData_entries, "f").keys()) yield key;
	}
	*entries() {
		for (const name of this.keys()) {
			const values = this.getAll(name);
			for (const value of values) yield [name, value];
		}
	}
	*values() {
		for (const [, value] of this) yield value;
	}
	[(_FormData_setEntry = function _FormData_setEntry$1({ name, rawValue, append, fileName, argsLength }) {
		const methodName = append ? "append" : "set";
		if (argsLength < 2) throw new TypeError(`Failed to execute '${methodName}' on 'FormData': 2 arguments required, but only ${argsLength} present.`);
		name = String(name);
		let value;
		if (isFile(rawValue)) value = fileName === void 0 ? rawValue : new File([rawValue], fileName, {
			type: rawValue.type,
			lastModified: rawValue.lastModified
		});
		else if (isBlob(rawValue)) value = new File([rawValue], fileName === void 0 ? "blob" : fileName, { type: rawValue.type });
		else if (fileName) throw new TypeError(`Failed to execute '${methodName}' on 'FormData': parameter 2 is not of type 'Blob'.`);
		else value = String(rawValue);
		const values = __classPrivateFieldGet$8(this, _FormData_entries, "f").get(name);
		if (!values) return void __classPrivateFieldGet$8(this, _FormData_entries, "f").set(name, [value]);
		if (!append) return void __classPrivateFieldGet$8(this, _FormData_entries, "f").set(name, [value]);
		values.push(value);
	}, Symbol.iterator)]() {
		return this.entries();
	}
	forEach(callback, thisArg) {
		for (const [name, value] of this) callback.call(thisArg, value, name, this);
	}
	get [Symbol.toStringTag]() {
		return "FormData";
	}
	[inspect.custom]() {
		return this[Symbol.toStringTag];
	}
};

//#endregion
//#region node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({ "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h$1 = m * 60;
	var d = h$1 * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$2(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$2(str$1) {
		str$1 = String(str$1);
		if (str$1.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str$1);
		if (!match) return;
		var n$1 = parseFloat(match[1]);
		var type = (match[2] || "ms").toLowerCase();
		switch (type) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n$1 * y;
			case "weeks":
			case "week":
			case "w": return n$1 * w;
			case "days":
			case "day":
			case "d": return n$1 * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n$1 * h$1;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n$1 * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n$1 * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n$1;
			default: return void 0;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d) return Math.round(ms$2 / d) + "d";
		if (msAbs >= h$1) return Math.round(ms$2 / h$1) + "h";
		if (msAbs >= m) return Math.round(ms$2 / m) + "m";
		if (msAbs >= s) return Math.round(ms$2 / s) + "s";
		return ms$2 + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d) return plural(ms$2, msAbs, d, "day");
		if (msAbs >= h$1) return plural(ms$2, msAbs, h$1, "hour");
		if (msAbs >= m) return plural(ms$2, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms$2, msAbs, s, "second");
		return ms$2 + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms$2, msAbs, n$1, name) {
		var isPlural = msAbs >= n$1 * 1.5;
		return Math.round(ms$2 / n$1) + " " + name + (isPlural ? "s" : "");
	}
} });

//#endregion
//#region node_modules/.pnpm/humanize-ms@1.2.1/node_modules/humanize-ms/index.js
var require_humanize_ms = __commonJS({ "node_modules/.pnpm/humanize-ms@1.2.1/node_modules/humanize-ms/index.js"(exports, module) {
	/**
	* Module dependencies.
	*/
	var util = __require("util");
	var ms$1 = require_ms();
	module.exports = function(t) {
		if (typeof t === "number") return t;
		var r = ms$1(t);
		if (r === void 0) {
			var err = new Error(util.format("humanize-ms(%j) result undefined", t));
			console.warn(err.stack);
		}
		return r;
	};
} });

//#endregion
//#region node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/constants.js
var require_constants = __commonJS({ "node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/constants.js"(exports, module) {
	module.exports = {
		CURRENT_ID: Symbol("agentkeepalive#currentId"),
		CREATE_ID: Symbol("agentkeepalive#createId"),
		INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
		CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
		SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
		SOCKET_NAME: Symbol("agentkeepalive#socketName"),
		SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
		SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
	};
} });

//#endregion
//#region node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/agent.js
var require_agent = __commonJS({ "node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/agent.js"(exports, module) {
	const OriginalAgent = __require("http").Agent;
	const ms = require_humanize_ms();
	const debug$1 = __require("util").debuglog("agentkeepalive");
	const { INIT_SOCKET: INIT_SOCKET$1, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = require_constants();
	let defaultTimeoutListenerCount = 1;
	const majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
	if (majorVersion >= 11 && majorVersion <= 12) defaultTimeoutListenerCount = 2;
	else if (majorVersion >= 13) defaultTimeoutListenerCount = 3;
	function deprecate$1(message) {
		console.log("[agentkeepalive:deprecated] %s", message);
	}
	var Agent = class extends OriginalAgent {
		constructor(options) {
			options = options || {};
			options.keepAlive = options.keepAlive !== false;
			if (options.freeSocketTimeout === void 0) options.freeSocketTimeout = 4e3;
			if (options.keepAliveTimeout) {
				deprecate$1("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
				options.freeSocketTimeout = options.keepAliveTimeout;
				delete options.keepAliveTimeout;
			}
			if (options.freeSocketKeepAliveTimeout) {
				deprecate$1("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
				options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
				delete options.freeSocketKeepAliveTimeout;
			}
			if (options.timeout === void 0) options.timeout = Math.max(options.freeSocketTimeout * 2, 8e3);
			options.timeout = ms(options.timeout);
			options.freeSocketTimeout = ms(options.freeSocketTimeout);
			options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;
			super(options);
			this[CURRENT_ID] = 0;
			this.createSocketCount = 0;
			this.createSocketCountLastCheck = 0;
			this.createSocketErrorCount = 0;
			this.createSocketErrorCountLastCheck = 0;
			this.closeSocketCount = 0;
			this.closeSocketCountLastCheck = 0;
			this.errorSocketCount = 0;
			this.errorSocketCountLastCheck = 0;
			this.requestCount = 0;
			this.requestCountLastCheck = 0;
			this.timeoutSocketCount = 0;
			this.timeoutSocketCountLastCheck = 0;
			this.on("free", (socket) => {
				const timeout = this.calcSocketTimeout(socket);
				if (timeout > 0 && socket.timeout !== timeout) socket.setTimeout(timeout);
			});
		}
		get freeSocketKeepAliveTimeout() {
			deprecate$1("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
			return this.options.freeSocketTimeout;
		}
		get timeout() {
			deprecate$1("agent.timeout is deprecated, please use agent.options.timeout instead");
			return this.options.timeout;
		}
		get socketActiveTTL() {
			deprecate$1("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
			return this.options.socketActiveTTL;
		}
		calcSocketTimeout(socket) {
			/**
			* return <= 0: should free socket
			* return > 0: should update socket timeout
			* return undefined: not find custom timeout
			*/
			let freeSocketTimeout = this.options.freeSocketTimeout;
			const socketActiveTTL = this.options.socketActiveTTL;
			if (socketActiveTTL) {
				const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
				const diff = socketActiveTTL - aliveTime;
				if (diff <= 0) return diff;
				if (freeSocketTimeout && diff < freeSocketTimeout) freeSocketTimeout = diff;
			}
			if (freeSocketTimeout) {
				const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
				return customFreeSocketTimeout || freeSocketTimeout;
			}
		}
		keepSocketAlive(socket) {
			const result = super.keepSocketAlive(socket);
			if (!result) return result;
			const customTimeout = this.calcSocketTimeout(socket);
			if (typeof customTimeout === "undefined") return true;
			if (customTimeout <= 0) {
				debug$1("%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);
				return false;
			}
			if (socket.timeout !== customTimeout) socket.setTimeout(customTimeout);
			return true;
		}
		reuseSocket(...args) {
			super.reuseSocket(...args);
			const socket = args[0];
			const req = args[1];
			req.reusedSocket = true;
			const agentTimeout = this.options.timeout;
			if (getSocketTimeout(socket) !== agentTimeout) {
				socket.setTimeout(agentTimeout);
				debug$1("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
			}
			socket[SOCKET_REQUEST_COUNT]++;
			debug$1("%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));
		}
		[CREATE_ID]() {
			const id = this[CURRENT_ID]++;
			if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;
			return id;
		}
		[INIT_SOCKET$1](socket, options) {
			if (options.timeout) {
				const timeout = getSocketTimeout(socket);
				if (!timeout) socket.setTimeout(options.timeout);
			}
			if (this.options.keepAlive) socket.setNoDelay(true);
			this.createSocketCount++;
			if (this.options.socketActiveTTL) socket[SOCKET_CREATED_TIME] = Date.now();
			socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0];
			socket[SOCKET_REQUEST_COUNT] = 1;
			socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
			installListeners(this, socket, options);
		}
		createConnection(options, oncreate) {
			let called = false;
			const onNewCreate = (err, socket) => {
				if (called) return;
				called = true;
				if (err) {
					this.createSocketErrorCount++;
					return oncreate(err);
				}
				this[INIT_SOCKET$1](socket, options);
				oncreate(err, socket);
			};
			const newSocket = super.createConnection(options, onNewCreate);
			if (newSocket) onNewCreate(null, newSocket);
			return newSocket;
		}
		get statusChanged() {
			const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
			if (changed) {
				this.createSocketCountLastCheck = this.createSocketCount;
				this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
				this.closeSocketCountLastCheck = this.closeSocketCount;
				this.errorSocketCountLastCheck = this.errorSocketCount;
				this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
				this.requestCountLastCheck = this.requestCount;
			}
			return changed;
		}
		getCurrentStatus() {
			return {
				createSocketCount: this.createSocketCount,
				createSocketErrorCount: this.createSocketErrorCount,
				closeSocketCount: this.closeSocketCount,
				errorSocketCount: this.errorSocketCount,
				timeoutSocketCount: this.timeoutSocketCount,
				requestCount: this.requestCount,
				freeSockets: inspect$2(this.freeSockets),
				sockets: inspect$2(this.sockets),
				requests: inspect$2(this.requests)
			};
		}
	};
	function getSocketTimeout(socket) {
		return socket.timeout || socket._idleTimeout;
	}
	function installListeners(agent, socket, options) {
		debug$1("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
		function onFree() {
			if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;
			socket[SOCKET_REQUEST_FINISHED_COUNT]++;
			agent.requestCount++;
			debug$1("%s(requests: %s, finished: %s) free", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
			const name = agent.getName(options);
			if (socket.writable && agent.requests[name] && agent.requests[name].length) {
				socket[SOCKET_REQUEST_COUNT]++;
				debug$1("%s(requests: %s, finished: %s) will be reuse on agent free event", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
			}
		}
		socket.on("free", onFree);
		function onClose(isError) {
			debug$1("%s(requests: %s, finished: %s) close, isError: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);
			agent.closeSocketCount++;
		}
		socket.on("close", onClose);
		function onTimeout$1() {
			const listenerCount = socket.listeners("timeout").length;
			const timeout = getSocketTimeout(socket);
			const req = socket._httpMessage;
			const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
			debug$1("%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);
			if (debug$1.enabled) debug$1("timeout listeners: %s", socket.listeners("timeout").map((f) => f.name).join(", "));
			agent.timeoutSocketCount++;
			const name = agent.getName(options);
			if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
				socket.destroy();
				agent.removeSocket(socket, options);
				debug$1("%s is free, destroy quietly", socket[SOCKET_NAME]);
			} else if (reqTimeoutListenerCount === 0) {
				const error$1 = /* @__PURE__ */ new Error("Socket timeout");
				error$1.code = "ERR_SOCKET_TIMEOUT";
				error$1.timeout = timeout;
				socket.destroy(error$1);
				agent.removeSocket(socket, options);
				debug$1("%s destroy with timeout error", socket[SOCKET_NAME]);
			}
		}
		socket.on("timeout", onTimeout$1);
		function onError$1(err) {
			const listenerCount = socket.listeners("error").length;
			debug$1("%s(requests: %s, finished: %s) error: %s, listenerCount: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);
			agent.errorSocketCount++;
			if (listenerCount === 1) {
				debug$1("%s emit uncaught error event", socket[SOCKET_NAME]);
				socket.removeListener("error", onError$1);
				socket.emit("error", err);
			}
		}
		socket.on("error", onError$1);
		function onRemove() {
			debug$1("%s(requests: %s, finished: %s) agentRemove", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
			socket.removeListener("close", onClose);
			socket.removeListener("error", onError$1);
			socket.removeListener("free", onFree);
			socket.removeListener("timeout", onTimeout$1);
			socket.removeListener("agentRemove", onRemove);
		}
		socket.on("agentRemove", onRemove);
	}
	module.exports = Agent;
	function inspect$2(obj) {
		const res = {};
		for (const key in obj) res[key] = obj[key].length;
		return res;
	}
} });

//#endregion
//#region node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/https_agent.js
var require_https_agent = __commonJS({ "node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/https_agent.js"(exports, module) {
	const OriginalHttpsAgent = __require("https").Agent;
	const HttpAgent$1 = require_agent();
	const { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = require_constants();
	var HttpsAgent = class extends HttpAgent$1 {
		constructor(options) {
			super(options);
			this.defaultPort = 443;
			this.protocol = "https:";
			this.maxCachedSessions = this.options.maxCachedSessions;
			/* istanbul ignore next */
			if (this.maxCachedSessions === void 0) this.maxCachedSessions = 100;
			this._sessionCache = {
				map: {},
				list: []
			};
		}
		createConnection(options, oncreate) {
			const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);
			this[INIT_SOCKET](socket, options);
			return socket;
		}
	};
	HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
	[
		"getName",
		"_getSession",
		"_cacheSession",
		"_evictSession"
	].forEach(function(method) {
		/* istanbul ignore next */
		if (typeof OriginalHttpsAgent.prototype[method] === "function") HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
	});
	module.exports = HttpsAgent;
} });

//#endregion
//#region node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/index.js
var require_agentkeepalive = __commonJS({ "node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/index.js"(exports, module) {
	const HttpAgent = require_agent();
	module.exports = HttpAgent;
	module.exports.HttpAgent = HttpAgent;
	module.exports.HttpsAgent = require_https_agent();
	module.exports.constants = require_constants();
} });

//#endregion
//#region node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({ "node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js"(exports, module) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* @typedef {object} PrivateData
	* @property {EventTarget} eventTarget The event target.
	* @property {{type:string}} event The original event object.
	* @property {number} eventPhase The current event phase.
	* @property {EventTarget|null} currentTarget The current event target.
	* @property {boolean} canceled The flag to prevent default.
	* @property {boolean} stopped The flag to stop propagation.
	* @property {boolean} immediateStopped The flag to stop propagation immediately.
	* @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
	* @property {number} timeStamp The unix time.
	* @private
	*/
	/**
	* Private data for event wrappers.
	* @type {WeakMap<Event, PrivateData>}
	* @private
	*/
	const privateData = /* @__PURE__ */ new WeakMap();
	/**
	* Cache for wrapper classes.
	* @type {WeakMap<Object, Function>}
	* @private
	*/
	const wrappers = /* @__PURE__ */ new WeakMap();
	/**
	* Get private data.
	* @param {Event} event The event object to get private data.
	* @returns {PrivateData} The private data of the event.
	* @private
	*/
	function pd(event) {
		const retv = privateData.get(event);
		console.assert(retv != null, "'this' is expected an Event object, but got", event);
		return retv;
	}
	/**
	* https://dom.spec.whatwg.org/#set-the-canceled-flag
	* @param data {PrivateData} private data.
	*/
	function setCancelFlag(data) {
		if (data.passiveListener != null) {
			if (typeof console !== "undefined" && typeof console.error === "function") console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
			return;
		}
		if (!data.event.cancelable) return;
		data.canceled = true;
		if (typeof data.event.preventDefault === "function") data.event.preventDefault();
	}
	/**
	* @see https://dom.spec.whatwg.org/#interface-event
	* @private
	*/
	/**
	* The event wrapper.
	* @constructor
	* @param {EventTarget} eventTarget The event target of this dispatching.
	* @param {Event|{type:string}} event The original event to wrap.
	*/
	function Event$1(eventTarget, event) {
		privateData.set(this, {
			eventTarget,
			event,
			eventPhase: 2,
			currentTarget: eventTarget,
			canceled: false,
			stopped: false,
			immediateStopped: false,
			passiveListener: null,
			timeStamp: event.timeStamp || Date.now()
		});
		Object.defineProperty(this, "isTrusted", {
			value: false,
			enumerable: true
		});
		const keys = Object.keys(event);
		for (let i$1 = 0; i$1 < keys.length; ++i$1) {
			const key = keys[i$1];
			if (!(key in this)) Object.defineProperty(this, key, defineRedirectDescriptor(key));
		}
	}
	Event$1.prototype = {
		get type() {
			return pd(this).event.type;
		},
		get target() {
			return pd(this).eventTarget;
		},
		get currentTarget() {
			return pd(this).currentTarget;
		},
		composedPath() {
			const currentTarget = pd(this).currentTarget;
			if (currentTarget == null) return [];
			return [currentTarget];
		},
		get NONE() {
			return 0;
		},
		get CAPTURING_PHASE() {
			return 1;
		},
		get AT_TARGET() {
			return 2;
		},
		get BUBBLING_PHASE() {
			return 3;
		},
		get eventPhase() {
			return pd(this).eventPhase;
		},
		stopPropagation() {
			const data = pd(this);
			data.stopped = true;
			if (typeof data.event.stopPropagation === "function") data.event.stopPropagation();
		},
		stopImmediatePropagation() {
			const data = pd(this);
			data.stopped = true;
			data.immediateStopped = true;
			if (typeof data.event.stopImmediatePropagation === "function") data.event.stopImmediatePropagation();
		},
		get bubbles() {
			return Boolean(pd(this).event.bubbles);
		},
		get cancelable() {
			return Boolean(pd(this).event.cancelable);
		},
		preventDefault() {
			setCancelFlag(pd(this));
		},
		get defaultPrevented() {
			return pd(this).canceled;
		},
		get composed() {
			return Boolean(pd(this).event.composed);
		},
		get timeStamp() {
			return pd(this).timeStamp;
		},
		get srcElement() {
			return pd(this).eventTarget;
		},
		get cancelBubble() {
			return pd(this).stopped;
		},
		set cancelBubble(value) {
			if (!value) return;
			const data = pd(this);
			data.stopped = true;
			if (typeof data.event.cancelBubble === "boolean") data.event.cancelBubble = true;
		},
		get returnValue() {
			return !pd(this).canceled;
		},
		set returnValue(value) {
			if (!value) setCancelFlag(pd(this));
		},
		initEvent() {}
	};
	Object.defineProperty(Event$1.prototype, "constructor", {
		value: Event$1,
		configurable: true,
		writable: true
	});
	if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
		Object.setPrototypeOf(Event$1.prototype, window.Event.prototype);
		wrappers.set(window.Event.prototype, Event$1);
	}
	/**
	* Get the property descriptor to redirect a given property.
	* @param {string} key Property name to define property descriptor.
	* @returns {PropertyDescriptor} The property descriptor to redirect the property.
	* @private
	*/
	function defineRedirectDescriptor(key) {
		return {
			get() {
				return pd(this).event[key];
			},
			set(value) {
				pd(this).event[key] = value;
			},
			configurable: true,
			enumerable: true
		};
	}
	/**
	* Get the property descriptor to call a given method property.
	* @param {string} key Property name to define property descriptor.
	* @returns {PropertyDescriptor} The property descriptor to call the method property.
	* @private
	*/
	function defineCallDescriptor(key) {
		return {
			value() {
				const event = pd(this).event;
				return event[key].apply(event, arguments);
			},
			configurable: true,
			enumerable: true
		};
	}
	/**
	* Define new wrapper class.
	* @param {Function} BaseEvent The base wrapper class.
	* @param {Object} proto The prototype of the original event.
	* @returns {Function} The defined wrapper class.
	* @private
	*/
	function defineWrapper(BaseEvent, proto) {
		const keys = Object.keys(proto);
		if (keys.length === 0) return BaseEvent;
		/** CustomEvent */
		function CustomEvent(eventTarget, event) {
			BaseEvent.call(this, eventTarget, event);
		}
		CustomEvent.prototype = Object.create(BaseEvent.prototype, { constructor: {
			value: CustomEvent,
			configurable: true,
			writable: true
		} });
		for (let i$1 = 0; i$1 < keys.length; ++i$1) {
			const key = keys[i$1];
			if (!(key in BaseEvent.prototype)) {
				const descriptor = Object.getOwnPropertyDescriptor(proto, key);
				const isFunc = typeof descriptor.value === "function";
				Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
			}
		}
		return CustomEvent;
	}
	/**
	* Get the wrapper class of a given prototype.
	* @param {Object} proto The prototype of the original event to get its wrapper.
	* @returns {Function} The wrapper class.
	* @private
	*/
	function getWrapper(proto) {
		if (proto == null || proto === Object.prototype) return Event$1;
		let wrapper = wrappers.get(proto);
		if (wrapper == null) {
			wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
			wrappers.set(proto, wrapper);
		}
		return wrapper;
	}
	/**
	* Wrap a given event to management a dispatching.
	* @param {EventTarget} eventTarget The event target of this dispatching.
	* @param {Object} event The event to wrap.
	* @returns {Event} The wrapper instance.
	* @private
	*/
	function wrapEvent(eventTarget, event) {
		const Wrapper = getWrapper(Object.getPrototypeOf(event));
		return new Wrapper(eventTarget, event);
	}
	/**
	* Get the immediateStopped flag of a given event.
	* @param {Event} event The event to get.
	* @returns {boolean} The flag to stop propagation immediately.
	* @private
	*/
	function isStopped(event) {
		return pd(event).immediateStopped;
	}
	/**
	* Set the current event phase of a given event.
	* @param {Event} event The event to set current target.
	* @param {number} eventPhase New event phase.
	* @returns {void}
	* @private
	*/
	function setEventPhase(event, eventPhase) {
		pd(event).eventPhase = eventPhase;
	}
	/**
	* Set the current target of a given event.
	* @param {Event} event The event to set current target.
	* @param {EventTarget|null} currentTarget New current target.
	* @returns {void}
	* @private
	*/
	function setCurrentTarget(event, currentTarget) {
		pd(event).currentTarget = currentTarget;
	}
	/**
	* Set a passive listener of a given event.
	* @param {Event} event The event to set current target.
	* @param {Function|null} passiveListener New passive listener.
	* @returns {void}
	* @private
	*/
	function setPassiveListener(event, passiveListener) {
		pd(event).passiveListener = passiveListener;
	}
	/**
	* @typedef {object} ListenerNode
	* @property {Function} listener
	* @property {1|2|3} listenerType
	* @property {boolean} passive
	* @property {boolean} once
	* @property {ListenerNode|null} next
	* @private
	*/
	/**
	* @type {WeakMap<object, Map<string, ListenerNode>>}
	* @private
	*/
	const listenersMap = /* @__PURE__ */ new WeakMap();
	const CAPTURE = 1;
	const BUBBLE = 2;
	const ATTRIBUTE = 3;
	/**
	* Check whether a given value is an object or not.
	* @param {any} x The value to check.
	* @returns {boolean} `true` if the value is an object.
	*/
	function isObject$1(x) {
		return x !== null && typeof x === "object";
	}
	/**
	* Get listeners.
	* @param {EventTarget} eventTarget The event target to get.
	* @returns {Map<string, ListenerNode>} The listeners.
	* @private
	*/
	function getListeners(eventTarget) {
		const listeners = listenersMap.get(eventTarget);
		if (listeners == null) throw new TypeError("'this' is expected an EventTarget object, but got another value.");
		return listeners;
	}
	/**
	* Get the property descriptor for the event attribute of a given event.
	* @param {string} eventName The event name to get property descriptor.
	* @returns {PropertyDescriptor} The property descriptor.
	* @private
	*/
	function defineEventAttributeDescriptor(eventName) {
		return {
			get() {
				const listeners = getListeners(this);
				let node = listeners.get(eventName);
				while (node != null) {
					if (node.listenerType === ATTRIBUTE) return node.listener;
					node = node.next;
				}
				return null;
			},
			set(listener) {
				if (typeof listener !== "function" && !isObject$1(listener)) listener = null;
				const listeners = getListeners(this);
				let prev = null;
				let node = listeners.get(eventName);
				while (node != null) {
					if (node.listenerType === ATTRIBUTE) if (prev !== null) prev.next = node.next;
					else if (node.next !== null) listeners.set(eventName, node.next);
					else listeners.delete(eventName);
					else prev = node;
					node = node.next;
				}
				if (listener !== null) {
					const newNode = {
						listener,
						listenerType: ATTRIBUTE,
						passive: false,
						once: false,
						next: null
					};
					if (prev === null) listeners.set(eventName, newNode);
					else prev.next = newNode;
				}
			},
			configurable: true,
			enumerable: true
		};
	}
	/**
	* Define an event attribute (e.g. `eventTarget.onclick`).
	* @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
	* @param {string} eventName The event name to define.
	* @returns {void}
	*/
	function defineEventAttribute(eventTargetPrototype, eventName) {
		Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
	}
	/**
	* Define a custom EventTarget with event attributes.
	* @param {string[]} eventNames Event names for event attributes.
	* @returns {EventTarget} The custom EventTarget.
	* @private
	*/
	function defineCustomEventTarget(eventNames) {
		/** CustomEventTarget */
		function CustomEventTarget() {
			EventTarget$1.call(this);
		}
		CustomEventTarget.prototype = Object.create(EventTarget$1.prototype, { constructor: {
			value: CustomEventTarget,
			configurable: true,
			writable: true
		} });
		for (let i$1 = 0; i$1 < eventNames.length; ++i$1) defineEventAttribute(CustomEventTarget.prototype, eventNames[i$1]);
		return CustomEventTarget;
	}
	/**
	* EventTarget.
	*
	* - This is constructor if no arguments.
	* - This is a function which returns a CustomEventTarget constructor if there are arguments.
	*
	* For example:
	*
	*     class A extends EventTarget {}
	*     class B extends EventTarget("message") {}
	*     class C extends EventTarget("message", "error") {}
	*     class D extends EventTarget(["message", "error"]) {}
	*/
	function EventTarget$1() {
		if (this instanceof EventTarget$1) {
			listenersMap.set(this, /* @__PURE__ */ new Map());
			return;
		}
		if (arguments.length === 1 && Array.isArray(arguments[0])) return defineCustomEventTarget(arguments[0]);
		if (arguments.length > 0) {
			const types$5 = new Array(arguments.length);
			for (let i$1 = 0; i$1 < arguments.length; ++i$1) types$5[i$1] = arguments[i$1];
			return defineCustomEventTarget(types$5);
		}
		throw new TypeError("Cannot call a class as a function");
	}
	EventTarget$1.prototype = {
		addEventListener(eventName, listener, options) {
			if (listener == null) return;
			if (typeof listener !== "function" && !isObject$1(listener)) throw new TypeError("'listener' should be a function or an object.");
			const listeners = getListeners(this);
			const optionsIsObj = isObject$1(options);
			const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
			const listenerType = capture ? CAPTURE : BUBBLE;
			const newNode = {
				listener,
				listenerType,
				passive: optionsIsObj && Boolean(options.passive),
				once: optionsIsObj && Boolean(options.once),
				next: null
			};
			let node = listeners.get(eventName);
			if (node === void 0) {
				listeners.set(eventName, newNode);
				return;
			}
			let prev = null;
			while (node != null) {
				if (node.listener === listener && node.listenerType === listenerType) return;
				prev = node;
				node = node.next;
			}
			prev.next = newNode;
		},
		removeEventListener(eventName, listener, options) {
			if (listener == null) return;
			const listeners = getListeners(this);
			const capture = isObject$1(options) ? Boolean(options.capture) : Boolean(options);
			const listenerType = capture ? CAPTURE : BUBBLE;
			let prev = null;
			let node = listeners.get(eventName);
			while (node != null) {
				if (node.listener === listener && node.listenerType === listenerType) {
					if (prev !== null) prev.next = node.next;
					else if (node.next !== null) listeners.set(eventName, node.next);
					else listeners.delete(eventName);
					return;
				}
				prev = node;
				node = node.next;
			}
		},
		dispatchEvent(event) {
			if (event == null || typeof event.type !== "string") throw new TypeError("\"event.type\" should be a string.");
			const listeners = getListeners(this);
			const eventName = event.type;
			let node = listeners.get(eventName);
			if (node == null) return true;
			const wrappedEvent = wrapEvent(this, event);
			let prev = null;
			while (node != null) {
				if (node.once) if (prev !== null) prev.next = node.next;
				else if (node.next !== null) listeners.set(eventName, node.next);
				else listeners.delete(eventName);
				else prev = node;
				setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
				if (typeof node.listener === "function") try {
					node.listener.call(this, wrappedEvent);
				} catch (err) {
					if (typeof console !== "undefined" && typeof console.error === "function") console.error(err);
				}
				else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") node.listener.handleEvent(wrappedEvent);
				if (isStopped(wrappedEvent)) break;
				node = node.next;
			}
			setPassiveListener(wrappedEvent, null);
			setEventPhase(wrappedEvent, 0);
			setCurrentTarget(wrappedEvent, null);
			return !wrappedEvent.defaultPrevented;
		}
	};
	Object.defineProperty(EventTarget$1.prototype, "constructor", {
		value: EventTarget$1,
		configurable: true,
		writable: true
	});
	if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") Object.setPrototypeOf(EventTarget$1.prototype, window.EventTarget.prototype);
	exports.defineEventAttribute = defineEventAttribute;
	exports.EventTarget = EventTarget$1;
	exports.default = EventTarget$1;
	module.exports = EventTarget$1;
	module.exports.EventTarget = module.exports["default"] = EventTarget$1;
	module.exports.defineEventAttribute = defineEventAttribute;
} });

//#endregion
//#region node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({ "node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js"(exports, module) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var eventTargetShim = require_event_target_shim();
	/**
	* The signal class.
	* @see https://dom.spec.whatwg.org/#abortsignal
	*/
	var AbortSignal$1 = class extends eventTargetShim.EventTarget {
		/**
		* AbortSignal cannot be constructed directly.
		*/
		constructor() {
			super();
			throw new TypeError("AbortSignal cannot be constructed directly");
		}
		/**
		* Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
		*/
		get aborted() {
			const aborted$1 = abortedFlags.get(this);
			if (typeof aborted$1 !== "boolean") throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
			return aborted$1;
		}
	};
	eventTargetShim.defineEventAttribute(AbortSignal$1.prototype, "abort");
	/**
	* Create an AbortSignal object.
	*/
	function createAbortSignal() {
		const signal = Object.create(AbortSignal$1.prototype);
		eventTargetShim.EventTarget.call(signal);
		abortedFlags.set(signal, false);
		return signal;
	}
	/**
	* Abort a given signal.
	*/
	function abortSignal(signal) {
		if (abortedFlags.get(signal) !== false) return;
		abortedFlags.set(signal, true);
		signal.dispatchEvent({ type: "abort" });
	}
	/**
	* Aborted flag for each instances.
	*/
	const abortedFlags = /* @__PURE__ */ new WeakMap();
	Object.defineProperties(AbortSignal$1.prototype, { aborted: { enumerable: true } });
	if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(AbortSignal$1.prototype, Symbol.toStringTag, {
		configurable: true,
		value: "AbortSignal"
	});
	/**
	* The AbortController.
	* @see https://dom.spec.whatwg.org/#abortcontroller
	*/
	var AbortController$1 = class {
		/**
		* Initialize this controller.
		*/
		constructor() {
			signals$1.set(this, createAbortSignal());
		}
		/**
		* Returns the `AbortSignal` object associated with this object.
		*/
		get signal() {
			return getSignal(this);
		}
		/**
		* Abort and signal to any observers that the associated activity is to be aborted.
		*/
		abort() {
			abortSignal(getSignal(this));
		}
	};
	/**
	* Associated signals.
	*/
	const signals$1 = /* @__PURE__ */ new WeakMap();
	/**
	* Get the associated signal of a given controller.
	*/
	function getSignal(controller) {
		const signal = signals$1.get(controller);
		if (signal == null) throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
		return signal;
	}
	Object.defineProperties(AbortController$1.prototype, {
		signal: { enumerable: true },
		abort: { enumerable: true }
	});
	if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {
		configurable: true,
		value: "AbortController"
	});
	exports.AbortController = AbortController$1;
	exports.AbortSignal = AbortSignal$1;
	exports.default = AbortController$1;
	module.exports = AbortController$1;
	module.exports.AbortController = module.exports["default"] = AbortController$1;
	module.exports.AbortSignal = AbortSignal$1;
} });

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/createBoundary.js
const alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
	let size = 16;
	let res = "";
	while (size--) res += alphabet[Math.random() * 36 << 0];
	return res;
}
var createBoundary_default = createBoundary;

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isPlainObject.js
const getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject$1(value) {
	if (getType(value) !== "object") return false;
	const pp = Object.getPrototypeOf(value);
	if (pp === null || pp === void 0) return true;
	const Ctor = pp.constructor && pp.constructor.toString();
	return Ctor === Object.toString();
}
var isPlainObject_default = isPlainObject$1;

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/normalizeValue.js
const normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i$1, str$1) => {
	if (match === "\r" && str$1[i$1 + 1] !== "\n" || match === "\n" && str$1[i$1 - 1] !== "\r") return "\r\n";
	return match;
});
var normalizeValue_default = normalizeValue;

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/escapeName.js
const escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
var escapeName_default = escapeName;

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isFunction.js
const isFunction$1 = (value) => typeof value === "function";
var isFunction_default = isFunction$1;

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isFileLike.js
const isFileLike$1 = (value) => Boolean(value && typeof value === "object" && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction_default(value.stream) && value.name != null && value.size != null && value.lastModified != null);

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isFormData.js
const isFormData = (value) => Boolean(value && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction_default(value.append) && isFunction_default(value.getAll) && isFunction_default(value.entries) && isFunction_default(value[Symbol.iterator]));

//#endregion
//#region node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/FormDataEncoder.js
var __classPrivateFieldSet$6 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind$1, f) {
	if (kind$1 === "m") throw new TypeError("Private method is not writable");
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind$1 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$7 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormDataEncoder_instances, _FormDataEncoder_CRLF, _FormDataEncoder_CRLF_BYTES, _FormDataEncoder_CRLF_BYTES_LENGTH, _FormDataEncoder_DASHES, _FormDataEncoder_encoder, _FormDataEncoder_footer, _FormDataEncoder_form, _FormDataEncoder_options, _FormDataEncoder_getFieldHeader;
const defaultOptions = { enableAdditionalHeaders: false };
var FormDataEncoder = class {
	constructor(form, boundaryOrOptions, options) {
		_FormDataEncoder_instances.add(this);
		_FormDataEncoder_CRLF.set(this, "\r\n");
		_FormDataEncoder_CRLF_BYTES.set(this, void 0);
		_FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
		_FormDataEncoder_DASHES.set(this, "-".repeat(2));
		_FormDataEncoder_encoder.set(this, new TextEncoder());
		_FormDataEncoder_footer.set(this, void 0);
		_FormDataEncoder_form.set(this, void 0);
		_FormDataEncoder_options.set(this, void 0);
		if (!isFormData(form)) throw new TypeError("Expected first argument to be a FormData instance.");
		let boundary;
		if (isPlainObject_default(boundaryOrOptions)) options = boundaryOrOptions;
		else boundary = boundaryOrOptions;
		if (!boundary) boundary = createBoundary_default();
		if (typeof boundary !== "string") throw new TypeError("Expected boundary argument to be a string.");
		if (options && !isPlainObject_default(options)) throw new TypeError("Expected options argument to be an object.");
		__classPrivateFieldSet$6(this, _FormDataEncoder_form, form, "f");
		__classPrivateFieldSet$6(this, _FormDataEncoder_options, {
			...defaultOptions,
			...options
		}, "f");
		__classPrivateFieldSet$6(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet$7(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet$7(this, _FormDataEncoder_CRLF, "f")), "f");
		__classPrivateFieldSet$6(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet$7(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
		this.boundary = `form-data-boundary-${boundary}`;
		this.contentType = `multipart/form-data; boundary=${this.boundary}`;
		__classPrivateFieldSet$6(this, _FormDataEncoder_footer, __classPrivateFieldGet$7(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet$7(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet$7(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet$7(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
		this.contentLength = String(this.getContentLength());
		this.headers = Object.freeze({
			"Content-Type": this.contentType,
			"Content-Length": this.contentLength
		});
		Object.defineProperties(this, {
			boundary: {
				writable: false,
				configurable: false
			},
			contentType: {
				writable: false,
				configurable: false
			},
			contentLength: {
				writable: false,
				configurable: false
			},
			headers: {
				writable: false,
				configurable: false
			}
		});
	}
	getContentLength() {
		let length = 0;
		for (const [name, raw] of __classPrivateFieldGet$7(this, _FormDataEncoder_form, "f")) {
			const value = isFileLike$1(raw) ? raw : __classPrivateFieldGet$7(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
			length += __classPrivateFieldGet$7(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
			length += isFileLike$1(value) ? value.size : value.byteLength;
			length += __classPrivateFieldGet$7(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
		}
		return length + __classPrivateFieldGet$7(this, _FormDataEncoder_footer, "f").byteLength;
	}
	*values() {
		for (const [name, raw] of __classPrivateFieldGet$7(this, _FormDataEncoder_form, "f").entries()) {
			const value = isFileLike$1(raw) ? raw : __classPrivateFieldGet$7(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
			yield __classPrivateFieldGet$7(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
			yield value;
			yield __classPrivateFieldGet$7(this, _FormDataEncoder_CRLF_BYTES, "f");
		}
		yield __classPrivateFieldGet$7(this, _FormDataEncoder_footer, "f");
	}
	async *encode() {
		for (const part of this.values()) if (isFileLike$1(part)) yield* part.stream();
		else yield part;
	}
	[(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader$1(name, value) {
		let header = "";
		header += `${__classPrivateFieldGet$7(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet$7(this, _FormDataEncoder_CRLF, "f")}`;
		header += `Content-Disposition: form-data; name="${escapeName_default(name)}"`;
		if (isFileLike$1(value)) {
			header += `; filename="${escapeName_default(value.name)}"${__classPrivateFieldGet$7(this, _FormDataEncoder_CRLF, "f")}`;
			header += `Content-Type: ${value.type || "application/octet-stream"}`;
		}
		if (__classPrivateFieldGet$7(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) header += `${__classPrivateFieldGet$7(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFileLike$1(value) ? value.size : value.byteLength}`;
		return __classPrivateFieldGet$7(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet$7(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
	}, Symbol.iterator)]() {
		return this.values();
	}
	[Symbol.asyncIterator]() {
		return this.encode();
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/_shims/MultipartBody.mjs
/**
* Disclaimer: modules in _shims aren't intended to be imported by SDK users.
*/
var MultipartBody = class {
	constructor(body) {
		this.body = body;
	}
	get [Symbol.toStringTag]() {
		return "MultipartBody";
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/_shims/node-runtime.mjs
var import_lib = __toESM(require_lib(), 1);
var import_agentkeepalive = __toESM(require_agentkeepalive(), 1);
var import_abort_controller = __toESM(require_abort_controller(), 1);
let fileFromPathWarned = false;
async function fileFromPath$1(path$9, ...args) {
	const { fileFromPath: _fileFromPath } = await import("./fileFromPath-jp_M4vye.js");
	if (!fileFromPathWarned) {
		console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path$9)}) instead`);
		fileFromPathWarned = true;
	}
	return await _fileFromPath(path$9, ...args);
}
const defaultHttpAgent = new import_agentkeepalive.default({
	keepAlive: true,
	timeout: 5 * 60 * 1e3
});
const defaultHttpsAgent = new import_agentkeepalive.default.HttpsAgent({
	keepAlive: true,
	timeout: 5 * 60 * 1e3
});
async function getMultipartRequestOptions$1(form, opts) {
	const encoder$2 = new FormDataEncoder(form);
	const readable$1 = Readable.from(encoder$2);
	const body = new MultipartBody(readable$1);
	const headers = {
		...opts.headers,
		...encoder$2.headers,
		"Content-Length": encoder$2.contentLength
	};
	return {
		...opts,
		body,
		headers
	};
}
function getRuntime() {
	if (typeof AbortController === "undefined") globalThis.AbortController = import_abort_controller.AbortController;
	return {
		kind: "node",
		fetch: import_lib.default,
		Request: import_lib.Request,
		Response: import_lib.Response,
		Headers: import_lib.Headers,
		FormData: FormData$1,
		Blob: Blob$1,
		File,
		ReadableStream,
		getMultipartRequestOptions: getMultipartRequestOptions$1,
		getDefaultAgent: (url) => url.startsWith("https") ? defaultHttpsAgent : defaultHttpAgent,
		fileFromPath: fileFromPath$1,
		isFsReadStream: (value) => value instanceof ReadStream
	};
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/_shims/index.mjs
const init = () => {
	if (!kind) setShims(getRuntime(), { auto: true });
};
init();

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/error.mjs
var OpenAIError = class extends Error {};
var APIError = class APIError extends OpenAIError {
	constructor(status, error$1, message, headers) {
		super(`${APIError.makeMessage(status, error$1, message)}`);
		this.status = status;
		this.headers = headers;
		this.request_id = headers?.["x-request-id"];
		this.error = error$1;
		const data = error$1;
		this.code = data?.["code"];
		this.param = data?.["param"];
		this.type = data?.["type"];
	}
	static makeMessage(status, error$1, message) {
		const msg = error$1?.message ? typeof error$1.message === "string" ? error$1.message : JSON.stringify(error$1.message) : error$1 ? JSON.stringify(error$1) : message;
		if (status && msg) return `${status} ${msg}`;
		if (status) return `${status} status code (no body)`;
		if (msg) return msg;
		return "(no status code or body)";
	}
	static generate(status, errorResponse, message, headers) {
		if (!status || !headers) return new APIConnectionError({
			message,
			cause: castToError(errorResponse)
		});
		const error$1 = errorResponse?.["error"];
		if (status === 400) return new BadRequestError(status, error$1, message, headers);
		if (status === 401) return new AuthenticationError(status, error$1, message, headers);
		if (status === 403) return new PermissionDeniedError(status, error$1, message, headers);
		if (status === 404) return new NotFoundError(status, error$1, message, headers);
		if (status === 409) return new ConflictError(status, error$1, message, headers);
		if (status === 422) return new UnprocessableEntityError(status, error$1, message, headers);
		if (status === 429) return new RateLimitError(status, error$1, message, headers);
		if (status >= 500) return new InternalServerError(status, error$1, message, headers);
		return new APIError(status, error$1, message, headers);
	}
};
var APIUserAbortError = class extends APIError {
	constructor({ message } = {}) {
		super(void 0, void 0, message || "Request was aborted.", void 0);
	}
};
var APIConnectionError = class extends APIError {
	constructor({ message, cause }) {
		super(void 0, void 0, message || "Connection error.", void 0);
		if (cause) this.cause = cause;
	}
};
var APIConnectionTimeoutError = class extends APIConnectionError {
	constructor({ message } = {}) {
		super({ message: message ?? "Request timed out." });
	}
};
var BadRequestError = class extends APIError {};
var AuthenticationError = class extends APIError {};
var PermissionDeniedError = class extends APIError {};
var NotFoundError = class extends APIError {};
var ConflictError = class extends APIError {};
var UnprocessableEntityError = class extends APIError {};
var RateLimitError = class extends APIError {};
var InternalServerError = class extends APIError {};
var LengthFinishReasonError = class extends OpenAIError {
	constructor() {
		super(`Could not parse response content as the length limit was reached`);
	}
};
var ContentFilterFinishReasonError = class extends OpenAIError {
	constructor() {
		super(`Could not parse response content as the request was rejected by the content filter`);
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/internal/decoders/line.mjs
var __classPrivateFieldSet$5 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind$1, f) {
	if (kind$1 === "m") throw new TypeError("Private method is not writable");
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind$1 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$6 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LineDecoder_carriageReturnIndex;
/**
* A re-implementation of httpx's `LineDecoder` in Python that handles incrementally
* reading lines from text.
*
* https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258
*/
var LineDecoder = class {
	constructor() {
		_LineDecoder_carriageReturnIndex.set(this, void 0);
		this.buffer = new Uint8Array();
		__classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, null, "f");
	}
	decode(chunk) {
		if (chunk == null) return [];
		const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
		let newData = new Uint8Array(this.buffer.length + binaryChunk.length);
		newData.set(this.buffer);
		newData.set(binaryChunk, this.buffer.length);
		this.buffer = newData;
		const lines = [];
		let patternIndex;
		while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
			if (patternIndex.carriage && __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") == null) {
				__classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
				continue;
			}
			if (__classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
				lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
				this.buffer = this.buffer.slice(__classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f"));
				__classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, null, "f");
				continue;
			}
			const endIndex = __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
			const line = this.decodeText(this.buffer.slice(0, endIndex));
			lines.push(line);
			this.buffer = this.buffer.slice(patternIndex.index);
			__classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, null, "f");
		}
		return lines;
	}
	decodeText(bytes) {
		if (bytes == null) return "";
		if (typeof bytes === "string") return bytes;
		if (typeof Buffer !== "undefined") {
			if (bytes instanceof Buffer) return bytes.toString();
			if (bytes instanceof Uint8Array) return Buffer.from(bytes).toString();
			throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
		}
		if (typeof TextDecoder !== "undefined") {
			if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
				this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
				return this.textDecoder.decode(bytes);
			}
			throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
		}
		throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
	}
	flush() {
		if (!this.buffer.length) return [];
		return this.decode("\n");
	}
};
_LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
/**
* This function searches the buffer for the end patterns, (\r or \n)
* and returns an object with the index preceding the matched newline and the
* index after the newline char. `null` is returned if no new line is found.
*
* ```ts
* findNewLineIndex('abc\ndef') -> { preceding: 2, index: 3 }
* ```
*/
function findNewlineIndex(buffer, startIndex) {
	const newline = 10;
	const carriage = 13;
	for (let i$1 = startIndex ?? 0; i$1 < buffer.length; i$1++) {
		if (buffer[i$1] === newline) return {
			preceding: i$1,
			index: i$1 + 1,
			carriage: false
		};
		if (buffer[i$1] === carriage) return {
			preceding: i$1,
			index: i$1 + 1,
			carriage: true
		};
	}
	return null;
}
function findDoubleNewlineIndex(buffer) {
	const newline = 10;
	const carriage = 13;
	for (let i$1 = 0; i$1 < buffer.length - 1; i$1++) {
		if (buffer[i$1] === newline && buffer[i$1 + 1] === newline) return i$1 + 2;
		if (buffer[i$1] === carriage && buffer[i$1 + 1] === carriage) return i$1 + 2;
		if (buffer[i$1] === carriage && buffer[i$1 + 1] === newline && i$1 + 3 < buffer.length && buffer[i$1 + 2] === carriage && buffer[i$1 + 3] === newline) return i$1 + 4;
	}
	return -1;
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/internal/stream-utils.mjs
/**
* Most browsers don't yet have async iterable support for ReadableStream,
* and Node has a very different way of reading bytes from its "ReadableStream".
*
* This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490
*/
function ReadableStreamToAsyncIterable(stream$2) {
	if (stream$2[Symbol.asyncIterator]) return stream$2;
	const reader = stream$2.getReader();
	return {
		async next() {
			try {
				const result = await reader.read();
				if (result?.done) reader.releaseLock();
				return result;
			} catch (e) {
				reader.releaseLock();
				throw e;
			}
		},
		async return() {
			const cancelPromise = reader.cancel();
			reader.releaseLock();
			await cancelPromise;
			return {
				done: true,
				value: void 0
			};
		},
		[Symbol.asyncIterator]() {
			return this;
		}
	};
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/streaming.mjs
var Stream = class Stream {
	constructor(iterator$1, controller) {
		this.iterator = iterator$1;
		this.controller = controller;
	}
	static fromSSEResponse(response, controller) {
		let consumed = false;
		async function* iterator$1() {
			if (consumed) throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
			consumed = true;
			let done = false;
			try {
				for await (const sse of _iterSSEMessages(response, controller)) {
					if (done) continue;
					if (sse.data.startsWith("[DONE]")) {
						done = true;
						continue;
					}
					if (sse.event === null || sse.event.startsWith("response.") || sse.event.startsWith("transcript.")) {
						let data;
						try {
							data = JSON.parse(sse.data);
						} catch (e) {
							console.error(`Could not parse message into JSON:`, sse.data);
							console.error(`From chunk:`, sse.raw);
							throw e;
						}
						if (data && data.error) throw new APIError(void 0, data.error, void 0, createResponseHeaders(response.headers));
						yield data;
					} else {
						let data;
						try {
							data = JSON.parse(sse.data);
						} catch (e) {
							console.error(`Could not parse message into JSON:`, sse.data);
							console.error(`From chunk:`, sse.raw);
							throw e;
						}
						if (sse.event == "error") throw new APIError(void 0, data.error, data.message, void 0);
						yield {
							event: sse.event,
							data
						};
					}
				}
				done = true;
			} catch (e) {
				if (e instanceof Error && e.name === "AbortError") return;
				throw e;
			} finally {
				if (!done) controller.abort();
			}
		}
		return new Stream(iterator$1, controller);
	}
	/**
	* Generates a Stream from a newline-separated ReadableStream
	* where each item is a JSON value.
	*/
	static fromReadableStream(readableStream, controller) {
		let consumed = false;
		async function* iterLines() {
			const lineDecoder = new LineDecoder();
			const iter = ReadableStreamToAsyncIterable(readableStream);
			for await (const chunk of iter) for (const line of lineDecoder.decode(chunk)) yield line;
			for (const line of lineDecoder.flush()) yield line;
		}
		async function* iterator$1() {
			if (consumed) throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
			consumed = true;
			let done = false;
			try {
				for await (const line of iterLines()) {
					if (done) continue;
					if (line) yield JSON.parse(line);
				}
				done = true;
			} catch (e) {
				if (e instanceof Error && e.name === "AbortError") return;
				throw e;
			} finally {
				if (!done) controller.abort();
			}
		}
		return new Stream(iterator$1, controller);
	}
	[Symbol.asyncIterator]() {
		return this.iterator();
	}
	/**
	* Splits the stream into two streams which can be
	* independently read from at different speeds.
	*/
	tee() {
		const left = [];
		const right = [];
		const iterator$1 = this.iterator();
		const teeIterator = (queue) => {
			return { next: () => {
				if (queue.length === 0) {
					const result = iterator$1.next();
					left.push(result);
					right.push(result);
				}
				return queue.shift();
			} };
		};
		return [new Stream(() => teeIterator(left), this.controller), new Stream(() => teeIterator(right), this.controller)];
	}
	/**
	* Converts this stream to a newline-separated ReadableStream of
	* JSON stringified values in the stream
	* which can be turned back into a Stream with `Stream.fromReadableStream()`.
	*/
	toReadableStream() {
		const self = this;
		let iter;
		const encoder$2 = new TextEncoder();
		return new ReadableStream$1({
			async start() {
				iter = self[Symbol.asyncIterator]();
			},
			async pull(ctrl) {
				try {
					const { value, done } = await iter.next();
					if (done) return ctrl.close();
					const bytes = encoder$2.encode(JSON.stringify(value) + "\n");
					ctrl.enqueue(bytes);
				} catch (err) {
					ctrl.error(err);
				}
			},
			async cancel() {
				await iter.return?.();
			}
		});
	}
};
async function* _iterSSEMessages(response, controller) {
	if (!response.body) {
		controller.abort();
		throw new OpenAIError(`Attempted to iterate over a response with no body`);
	}
	const sseDecoder = new SSEDecoder();
	const lineDecoder = new LineDecoder();
	const iter = ReadableStreamToAsyncIterable(response.body);
	for await (const sseChunk of iterSSEChunks(iter)) for (const line of lineDecoder.decode(sseChunk)) {
		const sse = sseDecoder.decode(line);
		if (sse) yield sse;
	}
	for (const line of lineDecoder.flush()) {
		const sse = sseDecoder.decode(line);
		if (sse) yield sse;
	}
}
/**
* Given an async iterable iterator, iterates over it and yields full
* SSE chunks, i.e. yields when a double new-line is encountered.
*/
async function* iterSSEChunks(iterator$1) {
	let data = new Uint8Array();
	for await (const chunk of iterator$1) {
		if (chunk == null) continue;
		const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
		let newData = new Uint8Array(data.length + binaryChunk.length);
		newData.set(data);
		newData.set(binaryChunk, data.length);
		data = newData;
		let patternIndex;
		while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
			yield data.slice(0, patternIndex);
			data = data.slice(patternIndex);
		}
	}
	if (data.length > 0) yield data;
}
var SSEDecoder = class {
	constructor() {
		this.event = null;
		this.data = [];
		this.chunks = [];
	}
	decode(line) {
		if (line.endsWith("\r")) line = line.substring(0, line.length - 1);
		if (!line) {
			if (!this.event && !this.data.length) return null;
			const sse = {
				event: this.event,
				data: this.data.join("\n"),
				raw: this.chunks
			};
			this.event = null;
			this.data = [];
			this.chunks = [];
			return sse;
		}
		this.chunks.push(line);
		if (line.startsWith(":")) return null;
		let [fieldname, _, value] = partition(line, ":");
		if (value.startsWith(" ")) value = value.substring(1);
		if (fieldname === "event") this.event = value;
		else if (fieldname === "data") this.data.push(value);
		return null;
	}
};
function partition(str$1, delimiter) {
	const index = str$1.indexOf(delimiter);
	if (index !== -1) return [
		str$1.substring(0, index),
		delimiter,
		str$1.substring(index + delimiter.length)
	];
	return [
		str$1,
		"",
		""
	];
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/uploads.mjs
const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
/**
* The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check
* adds the arrayBuffer() method type because it is available and used at runtime
*/
const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
const isUploadable = (value) => {
	return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
/**
* Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats
* @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s
* @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible
* @param {Object=} options additional properties
* @param {string=} options.type the MIME type of the content
* @param {number=} options.lastModified the last modified timestamp
* @returns a {@link File} with the given properties
*/
async function toFile(value, name, options) {
	value = await value;
	if (isFileLike(value)) return value;
	if (isResponseLike(value)) {
		const blob = await value.blob();
		name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
		const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
		return new File$1(data, name, options);
	}
	const bits = await getBytes(value);
	name || (name = getName(value) ?? "unknown_file");
	if (!options?.type) {
		const type = bits[0]?.type;
		if (typeof type === "string") options = {
			...options,
			type
		};
	}
	return new File$1(bits, name, options);
}
async function getBytes(value) {
	let parts = [];
	if (typeof value === "string" || ArrayBuffer.isView(value) || value instanceof ArrayBuffer) parts.push(value);
	else if (isBlobLike(value)) parts.push(await value.arrayBuffer());
	else if (isAsyncIterableIterator(value)) for await (const chunk of value) parts.push(chunk);
	else throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
	return parts;
}
function propsForError(value) {
	const props = Object.getOwnPropertyNames(value);
	return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
	return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
const getStringFromMaybeBuffer = (x) => {
	if (typeof x === "string") return x;
	if (typeof Buffer !== "undefined" && x instanceof Buffer) return String(x);
	return void 0;
};
const isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
const isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
const multipartFormRequestOptions = async (opts) => {
	const form = await createForm(opts.body);
	return getMultipartRequestOptions(form, opts);
};
const createForm = async (body) => {
	const form = new FormData();
	await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
	return form;
};
const addFormValue = async (form, key, value) => {
	if (value === void 0) return;
	if (value == null) throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
	if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") form.append(key, String(value));
	else if (isUploadable(value)) {
		const file = await toFile(value);
		form.append(key, file);
	} else if (Array.isArray(value)) await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
	else if (typeof value === "object") await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
	else throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/core.mjs
var __classPrivateFieldSet$4 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind$1, f) {
	if (kind$1 === "m") throw new TypeError("Private method is not writable");
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind$1 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$5 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
init();
async function defaultParseResponse(props) {
	const { response } = props;
	if (props.options.stream) {
		debug("response", response.status, response.url, response.headers, response.body);
		if (props.options.__streamClass) return props.options.__streamClass.fromSSEResponse(response, props.controller);
		return Stream.fromSSEResponse(response, props.controller);
	}
	if (response.status === 204) return null;
	if (props.options.__binaryResponse) return response;
	const contentType = response.headers.get("content-type");
	const mediaType = contentType?.split(";")[0]?.trim();
	const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
	if (isJSON) {
		const json = await response.json();
		debug("response", response.status, response.url, response.headers, json);
		return _addRequestID(json, response);
	}
	const text = await response.text();
	debug("response", response.status, response.url, response.headers, text);
	return text;
}
function _addRequestID(value, response) {
	if (!value || typeof value !== "object" || Array.isArray(value)) return value;
	return Object.defineProperty(value, "_request_id", {
		value: response.headers.get("x-request-id"),
		enumerable: false
	});
}
/**
* A subclass of `Promise` providing additional helper methods
* for interacting with the SDK.
*/
var APIPromise = class APIPromise extends Promise {
	constructor(responsePromise, parseResponse$1 = defaultParseResponse) {
		super((resolve) => {
			resolve(null);
		});
		this.responsePromise = responsePromise;
		this.parseResponse = parseResponse$1;
	}
	_thenUnwrap(transform) {
		return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
	}
	/**
	* Gets the raw `Response` instance instead of parsing the response
	* data.
	*
	* If you want to parse the response body but still get the `Response`
	* instance, you can use {@link withResponse()}.
	*
	* 👋 Getting the wrong TypeScript type for `Response`?
	* Try setting `"moduleResolution": "NodeNext"` if you can,
	* or add one of these imports before your first `import … from 'openai'`:
	* - `import 'openai/shims/node'` (if you're running on Node)
	* - `import 'openai/shims/web'` (otherwise)
	*/
	asResponse() {
		return this.responsePromise.then((p) => p.response);
	}
	/**
	* Gets the parsed response data, the raw `Response` instance and the ID of the request,
	* returned via the X-Request-ID header which is useful for debugging requests and reporting
	* issues to OpenAI.
	*
	* If you just want to get the raw `Response` instance without parsing it,
	* you can use {@link asResponse()}.
	*
	*
	* 👋 Getting the wrong TypeScript type for `Response`?
	* Try setting `"moduleResolution": "NodeNext"` if you can,
	* or add one of these imports before your first `import … from 'openai'`:
	* - `import 'openai/shims/node'` (if you're running on Node)
	* - `import 'openai/shims/web'` (otherwise)
	*/
	async withResponse() {
		const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
		return {
			data,
			response,
			request_id: response.headers.get("x-request-id")
		};
	}
	parse() {
		if (!this.parsedPromise) this.parsedPromise = this.responsePromise.then(this.parseResponse);
		return this.parsedPromise;
	}
	then(onfulfilled, onrejected) {
		return this.parse().then(onfulfilled, onrejected);
	}
	catch(onrejected) {
		return this.parse().catch(onrejected);
	}
	finally(onfinally) {
		return this.parse().finally(onfinally);
	}
};
var APIClient = class {
	constructor({ baseURL, maxRetries = 2, timeout = 6e5, httpAgent, fetch: overriddenFetch }) {
		this.baseURL = baseURL;
		this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
		this.timeout = validatePositiveInteger("timeout", timeout);
		this.httpAgent = httpAgent;
		this.fetch = overriddenFetch ?? fetch;
	}
	authHeaders(opts) {
		return {};
	}
	/**
	* Override this to add your own default headers, for example:
	*
	*  {
	*    ...super.defaultHeaders(),
	*    Authorization: 'Bearer 123',
	*  }
	*/
	defaultHeaders(opts) {
		return {
			Accept: "application/json",
			"Content-Type": "application/json",
			"User-Agent": this.getUserAgent(),
			...getPlatformHeaders(),
			...this.authHeaders(opts)
		};
	}
	/**
	* Override this to add your own headers validation:
	*/
	validateHeaders(headers, customHeaders) {}
	defaultIdempotencyKey() {
		return `stainless-node-retry-${uuid4()}`;
	}
	get(path$9, opts) {
		return this.methodRequest("get", path$9, opts);
	}
	post(path$9, opts) {
		return this.methodRequest("post", path$9, opts);
	}
	patch(path$9, opts) {
		return this.methodRequest("patch", path$9, opts);
	}
	put(path$9, opts) {
		return this.methodRequest("put", path$9, opts);
	}
	delete(path$9, opts) {
		return this.methodRequest("delete", path$9, opts);
	}
	methodRequest(method, path$9, opts) {
		return this.request(Promise.resolve(opts).then(async (opts$1) => {
			const body = opts$1 && isBlobLike(opts$1?.body) ? new DataView(await opts$1.body.arrayBuffer()) : opts$1?.body instanceof DataView ? opts$1.body : opts$1?.body instanceof ArrayBuffer ? new DataView(opts$1.body) : opts$1 && ArrayBuffer.isView(opts$1?.body) ? new DataView(opts$1.body.buffer) : opts$1?.body;
			return {
				method,
				path: path$9,
				...opts$1,
				body
			};
		}));
	}
	getAPIList(path$9, Page$1, opts) {
		return this.requestAPIList(Page$1, {
			method: "get",
			path: path$9,
			...opts
		});
	}
	calculateContentLength(body) {
		if (typeof body === "string") {
			if (typeof Buffer !== "undefined") return Buffer.byteLength(body, "utf8").toString();
			if (typeof TextEncoder !== "undefined") {
				const encoder$2 = new TextEncoder();
				const encoded = encoder$2.encode(body);
				return encoded.length.toString();
			}
		} else if (ArrayBuffer.isView(body)) return body.byteLength.toString();
		return null;
	}
	buildRequest(options, { retryCount = 0 } = {}) {
		options = { ...options };
		const { method, path: path$9, query, headers = {} } = options;
		const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
		const contentLength = this.calculateContentLength(body);
		const url = this.buildURL(path$9, query);
		if ("timeout" in options) validatePositiveInteger("timeout", options.timeout);
		options.timeout = options.timeout ?? this.timeout;
		const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
		const minAgentTimeout = options.timeout + 1e3;
		if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) httpAgent.options.timeout = minAgentTimeout;
		if (this.idempotencyHeader && method !== "get") {
			if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();
			headers[this.idempotencyHeader] = options.idempotencyKey;
		}
		const reqHeaders = this.buildHeaders({
			options,
			headers,
			contentLength,
			retryCount
		});
		const req = {
			method,
			...body && { body },
			headers: reqHeaders,
			...httpAgent && { agent: httpAgent },
			signal: options.signal ?? null
		};
		return {
			req,
			url,
			timeout: options.timeout
		};
	}
	buildHeaders({ options, headers, contentLength, retryCount }) {
		const reqHeaders = {};
		if (contentLength) reqHeaders["content-length"] = contentLength;
		const defaultHeaders = this.defaultHeaders(options);
		applyHeadersMut(reqHeaders, defaultHeaders);
		applyHeadersMut(reqHeaders, headers);
		if (isMultipartBody(options.body) && kind !== "node") delete reqHeaders["content-type"];
		if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) reqHeaders["x-stainless-retry-count"] = String(retryCount);
		if (getHeader(defaultHeaders, "x-stainless-timeout") === void 0 && getHeader(headers, "x-stainless-timeout") === void 0 && options.timeout) reqHeaders["x-stainless-timeout"] = String(Math.trunc(options.timeout / 1e3));
		this.validateHeaders(reqHeaders, headers);
		return reqHeaders;
	}
	/**
	* Used as a callback for mutating the given `FinalRequestOptions` object.
	*/
	async prepareOptions(options) {}
	/**
	* Used as a callback for mutating the given `RequestInit` object.
	*
	* This is useful for cases where you want to add certain headers based off of
	* the request properties, e.g. `method` or `url`.
	*/
	async prepareRequest(request$2, { url, options }) {}
	parseHeaders(headers) {
		return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
	}
	makeStatusError(status, error$1, message, headers) {
		return APIError.generate(status, error$1, message, headers);
	}
	request(options, remainingRetries = null) {
		return new APIPromise(this.makeRequest(options, remainingRetries));
	}
	async makeRequest(optionsInput, retriesRemaining) {
		const options = await optionsInput;
		const maxRetries = options.maxRetries ?? this.maxRetries;
		if (retriesRemaining == null) retriesRemaining = maxRetries;
		await this.prepareOptions(options);
		const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
		await this.prepareRequest(req, {
			url,
			options
		});
		debug("request", url, options, req.headers);
		if (options.signal?.aborted) throw new APIUserAbortError();
		const controller = new AbortController();
		const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
		if (response instanceof Error) {
			if (options.signal?.aborted) throw new APIUserAbortError();
			if (retriesRemaining) return this.retryRequest(options, retriesRemaining);
			if (response.name === "AbortError") throw new APIConnectionTimeoutError();
			throw new APIConnectionError({ cause: response });
		}
		const responseHeaders = createResponseHeaders(response.headers);
		if (!response.ok) {
			if (retriesRemaining && this.shouldRetry(response)) {
				const retryMessage$1 = `retrying, ${retriesRemaining} attempts remaining`;
				debug(`response (error; ${retryMessage$1})`, response.status, url, responseHeaders);
				return this.retryRequest(options, retriesRemaining, responseHeaders);
			}
			const errText = await response.text().catch((e) => castToError(e).message);
			const errJSON = safeJSON(errText);
			const errMessage = errJSON ? void 0 : errText;
			const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
			debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
			const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
			throw err;
		}
		return {
			response,
			options,
			controller
		};
	}
	requestAPIList(Page$1, options) {
		const request$2 = this.makeRequest(options, null);
		return new PagePromise(this, request$2, Page$1);
	}
	buildURL(path$9, query) {
		const url = isAbsoluteURL(path$9) ? new URL(path$9) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path$9.startsWith("/") ? path$9.slice(1) : path$9));
		const defaultQuery = this.defaultQuery();
		if (!isEmptyObj(defaultQuery)) query = {
			...defaultQuery,
			...query
		};
		if (typeof query === "object" && query && !Array.isArray(query)) url.search = this.stringifyQuery(query);
		return url.toString();
	}
	stringifyQuery(query) {
		return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
			if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
			if (value === null) return `${encodeURIComponent(key)}=`;
			throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
		}).join("&");
	}
	async fetchWithTimeout(url, init$1, ms$2, controller) {
		const { signal,...options } = init$1 || {};
		if (signal) signal.addEventListener("abort", () => controller.abort());
		const timeout = setTimeout(() => controller.abort(), ms$2);
		const fetchOptions = {
			signal: controller.signal,
			...options
		};
		if (fetchOptions.method) fetchOptions.method = fetchOptions.method.toUpperCase();
		return this.fetch.call(void 0, url, fetchOptions).finally(() => {
			clearTimeout(timeout);
		});
	}
	shouldRetry(response) {
		const shouldRetryHeader = response.headers.get("x-should-retry");
		if (shouldRetryHeader === "true") return true;
		if (shouldRetryHeader === "false") return false;
		if (response.status === 408) return true;
		if (response.status === 409) return true;
		if (response.status === 429) return true;
		if (response.status >= 500) return true;
		return false;
	}
	async retryRequest(options, retriesRemaining, responseHeaders) {
		let timeoutMillis;
		const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
		if (retryAfterMillisHeader) {
			const timeoutMs = parseFloat(retryAfterMillisHeader);
			if (!Number.isNaN(timeoutMs)) timeoutMillis = timeoutMs;
		}
		const retryAfterHeader = responseHeaders?.["retry-after"];
		if (retryAfterHeader && !timeoutMillis) {
			const timeoutSeconds = parseFloat(retryAfterHeader);
			if (!Number.isNaN(timeoutSeconds)) timeoutMillis = timeoutSeconds * 1e3;
			else timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
		}
		if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
			const maxRetries = options.maxRetries ?? this.maxRetries;
			timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
		}
		await sleep(timeoutMillis);
		return this.makeRequest(options, retriesRemaining - 1);
	}
	calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
		const initialRetryDelay = .5;
		const maxRetryDelay = 8;
		const numRetries = maxRetries - retriesRemaining;
		const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
		const jitter = 1 - Math.random() * .25;
		return sleepSeconds * jitter * 1e3;
	}
	getUserAgent() {
		return `${this.constructor.name}/JS ${VERSION}`;
	}
};
var AbstractPage = class {
	constructor(client, response, body, options) {
		_AbstractPage_client.set(this, void 0);
		__classPrivateFieldSet$4(this, _AbstractPage_client, client, "f");
		this.options = options;
		this.response = response;
		this.body = body;
	}
	hasNextPage() {
		const items = this.getPaginatedItems();
		if (!items.length) return false;
		return this.nextPageInfo() != null;
	}
	async getNextPage() {
		const nextInfo = this.nextPageInfo();
		if (!nextInfo) throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
		const nextOptions = { ...this.options };
		if ("params" in nextInfo && typeof nextOptions.query === "object") nextOptions.query = {
			...nextOptions.query,
			...nextInfo.params
		};
		else if ("url" in nextInfo) {
			const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
			for (const [key, value] of params) nextInfo.url.searchParams.set(key, value);
			nextOptions.query = void 0;
			nextOptions.path = nextInfo.url.toString();
		}
		return await __classPrivateFieldGet$5(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
	}
	async *iterPages() {
		let page = this;
		yield page;
		while (page.hasNextPage()) {
			page = await page.getNextPage();
			yield page;
		}
	}
	async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
		for await (const page of this.iterPages()) for (const item of page.getPaginatedItems()) yield item;
	}
};
/**
* This subclass of Promise will resolve to an instantiated Page once the request completes.
*
* It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:
*
*    for await (const item of client.items.list()) {
*      console.log(item)
*    }
*/
var PagePromise = class extends APIPromise {
	constructor(client, request$2, Page$1) {
		super(request$2, async (props) => new Page$1(client, props.response, await defaultParseResponse(props), props.options));
	}
	/**
	* Allow auto-paginating iteration on an unawaited list call, eg:
	*
	*    for await (const item of client.items.list()) {
	*      console.log(item)
	*    }
	*/
	async *[Symbol.asyncIterator]() {
		const page = await this;
		for await (const item of page) yield item;
	}
};
const createResponseHeaders = (headers) => {
	return new Proxy(Object.fromEntries(headers.entries()), { get(target, name) {
		const key = name.toString();
		return target[key.toLowerCase()] || target[key];
	} });
};
const requestOptionsKeys = {
	method: true,
	path: true,
	query: true,
	body: true,
	headers: true,
	maxRetries: true,
	stream: true,
	timeout: true,
	httpAgent: true,
	signal: true,
	idempotencyKey: true,
	__metadata: true,
	__binaryRequest: true,
	__binaryResponse: true,
	__streamClass: true
};
const isRequestOptions = (obj) => {
	return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
const getPlatformProperties = () => {
	if (typeof Deno !== "undefined" && Deno.build != null) return {
		"X-Stainless-Lang": "js",
		"X-Stainless-Package-Version": VERSION,
		"X-Stainless-OS": normalizePlatform(Deno.build.os),
		"X-Stainless-Arch": normalizeArch(Deno.build.arch),
		"X-Stainless-Runtime": "deno",
		"X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
	};
	if (typeof EdgeRuntime !== "undefined") return {
		"X-Stainless-Lang": "js",
		"X-Stainless-Package-Version": VERSION,
		"X-Stainless-OS": "Unknown",
		"X-Stainless-Arch": `other:${EdgeRuntime}`,
		"X-Stainless-Runtime": "edge",
		"X-Stainless-Runtime-Version": process.version
	};
	if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") return {
		"X-Stainless-Lang": "js",
		"X-Stainless-Package-Version": VERSION,
		"X-Stainless-OS": normalizePlatform(process.platform),
		"X-Stainless-Arch": normalizeArch(process.arch),
		"X-Stainless-Runtime": "node",
		"X-Stainless-Runtime-Version": process.version
	};
	const browserInfo = getBrowserInfo();
	if (browserInfo) return {
		"X-Stainless-Lang": "js",
		"X-Stainless-Package-Version": VERSION,
		"X-Stainless-OS": "Unknown",
		"X-Stainless-Arch": "unknown",
		"X-Stainless-Runtime": `browser:${browserInfo.browser}`,
		"X-Stainless-Runtime-Version": browserInfo.version
	};
	return {
		"X-Stainless-Lang": "js",
		"X-Stainless-Package-Version": VERSION,
		"X-Stainless-OS": "Unknown",
		"X-Stainless-Arch": "unknown",
		"X-Stainless-Runtime": "unknown",
		"X-Stainless-Runtime-Version": "unknown"
	};
};
function getBrowserInfo() {
	if (typeof navigator === "undefined" || !navigator) return null;
	const browserPatterns = [
		{
			key: "edge",
			pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
		},
		{
			key: "ie",
			pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
		},
		{
			key: "ie",
			pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/
		},
		{
			key: "chrome",
			pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
		},
		{
			key: "firefox",
			pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
		},
		{
			key: "safari",
			pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/
		}
	];
	for (const { key, pattern } of browserPatterns) {
		const match = pattern.exec(navigator.userAgent);
		if (match) {
			const major = match[1] || 0;
			const minor = match[2] || 0;
			const patch = match[3] || 0;
			return {
				browser: key,
				version: `${major}.${minor}.${patch}`
			};
		}
	}
	return null;
}
const normalizeArch = (arch) => {
	if (arch === "x32") return "x32";
	if (arch === "x86_64" || arch === "x64") return "x64";
	if (arch === "arm") return "arm";
	if (arch === "aarch64" || arch === "arm64") return "arm64";
	if (arch) return `other:${arch}`;
	return "unknown";
};
const normalizePlatform = (platform$1) => {
	platform$1 = platform$1.toLowerCase();
	if (platform$1.includes("ios")) return "iOS";
	if (platform$1 === "android") return "Android";
	if (platform$1 === "darwin") return "MacOS";
	if (platform$1 === "win32") return "Windows";
	if (platform$1 === "freebsd") return "FreeBSD";
	if (platform$1 === "openbsd") return "OpenBSD";
	if (platform$1 === "linux") return "Linux";
	if (platform$1) return `Other:${platform$1}`;
	return "Unknown";
};
let _platformHeaders;
const getPlatformHeaders = () => {
	return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
const safeJSON = (text) => {
	try {
		return JSON.parse(text);
	} catch (err) {
		return void 0;
	}
};
const startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
const isAbsoluteURL = (url) => {
	return startsWithSchemeRegexp.test(url);
};
const sleep = (ms$2) => new Promise((resolve) => setTimeout(resolve, ms$2));
const validatePositiveInteger = (name, n$1) => {
	if (typeof n$1 !== "number" || !Number.isInteger(n$1)) throw new OpenAIError(`${name} must be an integer`);
	if (n$1 < 0) throw new OpenAIError(`${name} must be a positive integer`);
	return n$1;
};
const castToError = (err) => {
	if (err instanceof Error) return err;
	if (typeof err === "object" && err !== null) try {
		return new Error(JSON.stringify(err));
	} catch {}
	return new Error(err);
};
/**
* Read an environment variable.
*
* Trims beginning and trailing whitespace.
*
* Will return undefined if the environment variable doesn't exist or cannot be accessed.
*/
const readEnv = (env) => {
	if (typeof process !== "undefined") return process.env?.[env]?.trim() ?? void 0;
	if (typeof Deno !== "undefined") return Deno.env?.get?.(env)?.trim();
	return void 0;
};
function isEmptyObj(obj) {
	if (!obj) return true;
	for (const _k in obj) return false;
	return true;
}
function hasOwn(obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key);
}
/**
* Copies headers from "newHeaders" onto "targetHeaders",
* using lower-case for all properties,
* ignoring any keys with undefined values,
* and deleting any keys with null values.
*/
function applyHeadersMut(targetHeaders, newHeaders) {
	for (const k in newHeaders) {
		if (!hasOwn(newHeaders, k)) continue;
		const lowerKey = k.toLowerCase();
		if (!lowerKey) continue;
		const val = newHeaders[k];
		if (val === null) delete targetHeaders[lowerKey];
		else if (val !== void 0) targetHeaders[lowerKey] = val;
	}
}
const SENSITIVE_HEADERS = new Set(["authorization", "api-key"]);
function debug(action, ...args) {
	if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
		const modifiedArgs = args.map((arg) => {
			if (!arg) return arg;
			if (arg["headers"]) {
				const modifiedArg$1 = {
					...arg,
					headers: { ...arg["headers"] }
				};
				for (const header in arg["headers"]) if (SENSITIVE_HEADERS.has(header.toLowerCase())) modifiedArg$1["headers"][header] = "REDACTED";
				return modifiedArg$1;
			}
			let modifiedArg = null;
			for (const header in arg) if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
				modifiedArg ?? (modifiedArg = { ...arg });
				modifiedArg[header] = "REDACTED";
			}
			return modifiedArg ?? arg;
		});
		console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
	}
}
/**
* https://stackoverflow.com/a/2117523
*/
const uuid4 = () => {
	return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c$1) => {
		const r = Math.random() * 16 | 0;
		const v = c$1 === "x" ? r : r & 3 | 8;
		return v.toString(16);
	});
};
const isRunningInBrowser = () => {
	return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof navigator !== "undefined";
};
const isHeadersProtocol = (headers) => {
	return typeof headers?.get === "function";
};
const getHeader = (headers, header) => {
	const lowerCasedHeader = header.toLowerCase();
	if (isHeadersProtocol(headers)) {
		const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
		for (const key of [
			header,
			lowerCasedHeader,
			header.toUpperCase(),
			intercapsHeader
		]) {
			const value = headers.get(key);
			if (value) return value;
		}
	}
	for (const [key, value] of Object.entries(headers)) if (key.toLowerCase() === lowerCasedHeader) {
		if (Array.isArray(value)) {
			if (value.length <= 1) return value[0];
			console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
			return value[0];
		}
		return value;
	}
	return void 0;
};
/**
* Converts a Base64 encoded string to a Float32Array.
* @param base64Str - The Base64 encoded string.
* @returns An Array of numbers interpreted as Float32 values.
*/
const toFloat32Array = (base64Str) => {
	if (typeof Buffer !== "undefined") {
		const buf = Buffer.from(base64Str, "base64");
		return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
	} else {
		const binaryStr = atob(base64Str);
		const len = binaryStr.length;
		const bytes = new Uint8Array(len);
		for (let i$1 = 0; i$1 < len; i$1++) bytes[i$1] = binaryStr.charCodeAt(i$1);
		return Array.from(new Float32Array(bytes.buffer));
	}
};
function isObj(obj) {
	return obj != null && typeof obj === "object" && !Array.isArray(obj);
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/pagination.mjs
/**
* Note: no pagination actually occurs yet, this is for forwards-compatibility.
*/
var Page = class extends AbstractPage {
	constructor(client, response, body, options) {
		super(client, response, body, options);
		this.data = body.data || [];
		this.object = body.object;
	}
	getPaginatedItems() {
		return this.data ?? [];
	}
	/**
	* This page represents a response that isn't actually paginated at the API level
	* so there will never be any next page params.
	*/
	nextPageParams() {
		return null;
	}
	nextPageInfo() {
		return null;
	}
};
var CursorPage = class extends AbstractPage {
	constructor(client, response, body, options) {
		super(client, response, body, options);
		this.data = body.data || [];
		this.has_more = body.has_more || false;
	}
	getPaginatedItems() {
		return this.data ?? [];
	}
	hasNextPage() {
		if (this.has_more === false) return false;
		return super.hasNextPage();
	}
	nextPageParams() {
		const info$1 = this.nextPageInfo();
		if (!info$1) return null;
		if ("params" in info$1) return info$1.params;
		const params = Object.fromEntries(info$1.url.searchParams);
		if (!Object.keys(params).length) return null;
		return params;
	}
	nextPageInfo() {
		const data = this.getPaginatedItems();
		if (!data.length) return null;
		const id = data[data.length - 1]?.id;
		if (!id) return null;
		return { params: { after: id } };
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resource.mjs
var APIResource = class {
	constructor(client) {
		this._client = client;
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/chat/completions/messages.mjs
var Messages$1 = class extends APIResource {
	list(completionId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(completionId, {}, query);
		return this._client.getAPIList(`/chat/completions/${completionId}/messages`, ChatCompletionStoreMessagesPage, {
			query,
			...options
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/chat/completions/completions.mjs
var Completions$2 = class extends APIResource {
	constructor() {
		super(...arguments);
		this.messages = new Messages$1(this._client);
	}
	create(body, options) {
		return this._client.post("/chat/completions", {
			body,
			...options,
			stream: body.stream ?? false
		});
	}
	/**
	* Get a stored chat completion. Only Chat Completions that have been created with
	* the `store` parameter set to `true` will be returned.
	*/
	retrieve(completionId, options) {
		return this._client.get(`/chat/completions/${completionId}`, options);
	}
	/**
	* Modify a stored chat completion. Only Chat Completions that have been created
	* with the `store` parameter set to `true` can be modified. Currently, the only
	* supported modification is to update the `metadata` field.
	*/
	update(completionId, body, options) {
		return this._client.post(`/chat/completions/${completionId}`, {
			body,
			...options
		});
	}
	list(query = {}, options) {
		if (isRequestOptions(query)) return this.list({}, query);
		return this._client.getAPIList("/chat/completions", ChatCompletionsPage, {
			query,
			...options
		});
	}
	/**
	* Delete a stored chat completion. Only Chat Completions that have been created
	* with the `store` parameter set to `true` can be deleted.
	*/
	del(completionId, options) {
		return this._client.delete(`/chat/completions/${completionId}`, options);
	}
};
var ChatCompletionsPage = class extends CursorPage {};
var ChatCompletionStoreMessagesPage = class extends CursorPage {};
Completions$2.ChatCompletionsPage = ChatCompletionsPage;
Completions$2.Messages = Messages$1;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
	constructor() {
		super(...arguments);
		this.completions = new Completions$2(this._client);
	}
};
Chat.Completions = Completions$2;
Chat.ChatCompletionsPage = ChatCompletionsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
	/**
	* Generates audio from the input text.
	*/
	create(body, options) {
		return this._client.post("/audio/speech", {
			body,
			...options,
			headers: {
				Accept: "application/octet-stream",
				...options?.headers
			},
			__binaryResponse: true
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
	create(body, options) {
		return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
			body,
			...options,
			stream: body.stream ?? false,
			__metadata: { model: body.model }
		}));
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
	create(body, options) {
		return this._client.post("/audio/translations", multipartFormRequestOptions({
			body,
			...options,
			__metadata: { model: body.model }
		}));
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
	constructor() {
		super(...arguments);
		this.transcriptions = new Transcriptions(this._client);
		this.translations = new Translations(this._client);
		this.speech = new Speech(this._client);
	}
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
	/**
	* Creates and executes a batch from an uploaded file of requests
	*/
	create(body, options) {
		return this._client.post("/batches", {
			body,
			...options
		});
	}
	/**
	* Retrieves a batch.
	*/
	retrieve(batchId, options) {
		return this._client.get(`/batches/${batchId}`, options);
	}
	list(query = {}, options) {
		if (isRequestOptions(query)) return this.list({}, query);
		return this._client.getAPIList("/batches", BatchesPage, {
			query,
			...options
		});
	}
	/**
	* Cancels an in-progress batch. The batch will be in status `cancelling` for up to
	* 10 minutes, before changing to `cancelled`, where it will have partial results
	* (if any) available in the output file.
	*/
	cancel(batchId, options) {
		return this._client.post(`/batches/${batchId}/cancel`, options);
	}
};
var BatchesPage = class extends CursorPage {};
Batches.BatchesPage = BatchesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource {
	/**
	* Create an assistant with a model and instructions.
	*/
	create(body, options) {
		return this._client.post("/assistants", {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Retrieves an assistant.
	*/
	retrieve(assistantId, options) {
		return this._client.get(`/assistants/${assistantId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Modifies an assistant.
	*/
	update(assistantId, body, options) {
		return this._client.post(`/assistants/${assistantId}`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	list(query = {}, options) {
		if (isRequestOptions(query)) return this.list({}, query);
		return this._client.getAPIList("/assistants", AssistantsPage, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Delete an assistant.
	*/
	del(assistantId, options) {
		return this._client.delete(`/assistants/${assistantId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
};
var AssistantsPage = class extends CursorPage {};
Assistants.AssistantsPage = AssistantsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
	return typeof fn.parse === "function";
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/chatCompletionUtils.mjs
const isAssistantMessage = (message) => {
	return message?.role === "assistant";
};
const isFunctionMessage = (message) => {
	return message?.role === "function";
};
const isToolMessage = (message) => {
	return message?.role === "tool";
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/EventStream.mjs
var __classPrivateFieldSet$3 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind$1, f) {
	if (kind$1 === "m") throw new TypeError("Private method is not writable");
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind$1 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$4 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
var EventStream = class {
	constructor() {
		_EventStream_instances.add(this);
		this.controller = new AbortController();
		_EventStream_connectedPromise.set(this, void 0);
		_EventStream_resolveConnectedPromise.set(this, () => {});
		_EventStream_rejectConnectedPromise.set(this, () => {});
		_EventStream_endPromise.set(this, void 0);
		_EventStream_resolveEndPromise.set(this, () => {});
		_EventStream_rejectEndPromise.set(this, () => {});
		_EventStream_listeners.set(this, {});
		_EventStream_ended.set(this, false);
		_EventStream_errored.set(this, false);
		_EventStream_aborted.set(this, false);
		_EventStream_catchingPromiseCreated.set(this, false);
		__classPrivateFieldSet$3(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
			__classPrivateFieldSet$3(this, _EventStream_resolveConnectedPromise, resolve, "f");
			__classPrivateFieldSet$3(this, _EventStream_rejectConnectedPromise, reject, "f");
		}), "f");
		__classPrivateFieldSet$3(this, _EventStream_endPromise, new Promise((resolve, reject) => {
			__classPrivateFieldSet$3(this, _EventStream_resolveEndPromise, resolve, "f");
			__classPrivateFieldSet$3(this, _EventStream_rejectEndPromise, reject, "f");
		}), "f");
		__classPrivateFieldGet$4(this, _EventStream_connectedPromise, "f").catch(() => {});
		__classPrivateFieldGet$4(this, _EventStream_endPromise, "f").catch(() => {});
	}
	_run(executor) {
		setTimeout(() => {
			executor().then(() => {
				this._emitFinal();
				this._emit("end");
			}, __classPrivateFieldGet$4(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
		}, 0);
	}
	_connected() {
		if (this.ended) return;
		__classPrivateFieldGet$4(this, _EventStream_resolveConnectedPromise, "f").call(this);
		this._emit("connect");
	}
	get ended() {
		return __classPrivateFieldGet$4(this, _EventStream_ended, "f");
	}
	get errored() {
		return __classPrivateFieldGet$4(this, _EventStream_errored, "f");
	}
	get aborted() {
		return __classPrivateFieldGet$4(this, _EventStream_aborted, "f");
	}
	abort() {
		this.controller.abort();
	}
	/**
	* Adds the listener function to the end of the listeners array for the event.
	* No checks are made to see if the listener has already been added. Multiple calls passing
	* the same combination of event and listener will result in the listener being added, and
	* called, multiple times.
	* @returns this ChatCompletionStream, so that calls can be chained
	*/
	on(event, listener) {
		const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] = []);
		listeners.push({ listener });
		return this;
	}
	/**
	* Removes the specified listener from the listener array for the event.
	* off() will remove, at most, one instance of a listener from the listener array. If any single
	* listener has been added multiple times to the listener array for the specified event, then
	* off() must be called multiple times to remove each instance.
	* @returns this ChatCompletionStream, so that calls can be chained
	*/
	off(event, listener) {
		const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event];
		if (!listeners) return this;
		const index = listeners.findIndex((l) => l.listener === listener);
		if (index >= 0) listeners.splice(index, 1);
		return this;
	}
	/**
	* Adds a one-time listener function for the event. The next time the event is triggered,
	* this listener is removed and then invoked.
	* @returns this ChatCompletionStream, so that calls can be chained
	*/
	once(event, listener) {
		const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] = []);
		listeners.push({
			listener,
			once: true
		});
		return this;
	}
	/**
	* This is similar to `.once()`, but returns a Promise that resolves the next time
	* the event is triggered, instead of calling a listener callback.
	* @returns a Promise that resolves the next time given event is triggered,
	* or rejects if an error is emitted.  (If you request the 'error' event,
	* returns a promise that resolves with the error).
	*
	* Example:
	*
	*   const message = await stream.emitted('message') // rejects if the stream errors
	*/
	emitted(event) {
		return new Promise((resolve, reject) => {
			__classPrivateFieldSet$3(this, _EventStream_catchingPromiseCreated, true, "f");
			if (event !== "error") this.once("error", reject);
			this.once(event, resolve);
		});
	}
	async done() {
		__classPrivateFieldSet$3(this, _EventStream_catchingPromiseCreated, true, "f");
		await __classPrivateFieldGet$4(this, _EventStream_endPromise, "f");
	}
	_emit(event, ...args) {
		if (__classPrivateFieldGet$4(this, _EventStream_ended, "f")) return;
		if (event === "end") {
			__classPrivateFieldSet$3(this, _EventStream_ended, true, "f");
			__classPrivateFieldGet$4(this, _EventStream_resolveEndPromise, "f").call(this);
		}
		const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event];
		if (listeners) {
			__classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
			listeners.forEach(({ listener }) => listener(...args));
		}
		if (event === "abort") {
			const error$1 = args[0];
			if (!__classPrivateFieldGet$4(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) Promise.reject(error$1);
			__classPrivateFieldGet$4(this, _EventStream_rejectConnectedPromise, "f").call(this, error$1);
			__classPrivateFieldGet$4(this, _EventStream_rejectEndPromise, "f").call(this, error$1);
			this._emit("end");
			return;
		}
		if (event === "error") {
			const error$1 = args[0];
			if (!__classPrivateFieldGet$4(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) Promise.reject(error$1);
			__classPrivateFieldGet$4(this, _EventStream_rejectConnectedPromise, "f").call(this, error$1);
			__classPrivateFieldGet$4(this, _EventStream_rejectEndPromise, "f").call(this, error$1);
			this._emit("end");
		}
	}
	_emitFinal() {}
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError$1(error$1) {
	__classPrivateFieldSet$3(this, _EventStream_errored, true, "f");
	if (error$1 instanceof Error && error$1.name === "AbortError") error$1 = new APIUserAbortError();
	if (error$1 instanceof APIUserAbortError) {
		__classPrivateFieldSet$3(this, _EventStream_aborted, true, "f");
		return this._emit("abort", error$1);
	}
	if (error$1 instanceof OpenAIError) return this._emit("error", error$1);
	if (error$1 instanceof Error) {
		const openAIError = new OpenAIError(error$1.message);
		openAIError.cause = error$1;
		return this._emit("error", openAIError);
	}
	return this._emit("error", new OpenAIError(String(error$1)));
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/parser.mjs
function isAutoParsableResponseFormat(response_format) {
	return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool$1(tool) {
	return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
	if (!params || !hasAutoParseableInput$1(params)) return {
		...completion,
		choices: completion.choices.map((choice) => ({
			...choice,
			message: {
				...choice.message,
				parsed: null,
				...choice.message.tool_calls ? { tool_calls: choice.message.tool_calls } : void 0
			}
		}))
	};
	return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
	const choices = completion.choices.map((choice) => {
		if (choice.finish_reason === "length") throw new LengthFinishReasonError();
		if (choice.finish_reason === "content_filter") throw new ContentFilterFinishReasonError();
		return {
			...choice,
			message: {
				...choice.message,
				...choice.message.tool_calls ? { tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall$1(params, toolCall)) ?? void 0 } : void 0,
				parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
			}
		};
	});
	return {
		...completion,
		choices
	};
}
function parseResponseFormat(params, content) {
	if (params.response_format?.type !== "json_schema") return null;
	if (params.response_format?.type === "json_schema") {
		if ("$parseRaw" in params.response_format) {
			const response_format = params.response_format;
			return response_format.$parseRaw(content);
		}
		return JSON.parse(content);
	}
	return null;
}
function parseToolCall$1(params, toolCall) {
	const inputTool = params.tools?.find((inputTool$1) => inputTool$1.function?.name === toolCall.function.name);
	return {
		...toolCall,
		function: {
			...toolCall.function,
			parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
		}
	};
}
function shouldParseToolCall(params, toolCall) {
	if (!params) return false;
	const inputTool = params.tools?.find((inputTool$1) => inputTool$1.function?.name === toolCall.function.name);
	return isAutoParsableTool$1(inputTool) || inputTool?.function.strict || false;
}
function hasAutoParseableInput$1(params) {
	if (isAutoParsableResponseFormat(params.response_format)) return true;
	return params.tools?.some((t) => isAutoParsableTool$1(t) || t.type === "function" && t.function.strict === true) ?? false;
}
function validateInputTools(tools) {
	for (const tool of tools ?? []) {
		if (tool.type !== "function") throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
		if (tool.function.strict !== true) throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
	}
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldGet$3 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
	constructor() {
		super(...arguments);
		_AbstractChatCompletionRunner_instances.add(this);
		this._chatCompletions = [];
		this.messages = [];
	}
	_addChatCompletion(chatCompletion) {
		this._chatCompletions.push(chatCompletion);
		this._emit("chatCompletion", chatCompletion);
		const message = chatCompletion.choices[0]?.message;
		if (message) this._addMessage(message);
		return chatCompletion;
	}
	_addMessage(message, emit = true) {
		if (!("content" in message)) message.content = null;
		this.messages.push(message);
		if (emit) {
			this._emit("message", message);
			if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) this._emit("functionCallResult", message.content);
			else if (isAssistantMessage(message) && message.function_call) this._emit("functionCall", message.function_call);
			else if (isAssistantMessage(message) && message.tool_calls) {
				for (const tool_call of message.tool_calls) if (tool_call.type === "function") this._emit("functionCall", tool_call.function);
			}
		}
	}
	/**
	* @returns a promise that resolves with the final ChatCompletion, or rejects
	* if an error occurred or the stream ended prematurely without producing a ChatCompletion.
	*/
	async finalChatCompletion() {
		await this.done();
		const completion = this._chatCompletions[this._chatCompletions.length - 1];
		if (!completion) throw new OpenAIError("stream ended without producing a ChatCompletion");
		return completion;
	}
	/**
	* @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
	* if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
	*/
	async finalContent() {
		await this.done();
		return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
	}
	/**
	* @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
	* or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
	*/
	async finalMessage() {
		await this.done();
		return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
	}
	/**
	* @returns a promise that resolves with the content of the final FunctionCall, or rejects
	* if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
	*/
	async finalFunctionCall() {
		await this.done();
		return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
	}
	async finalFunctionCallResult() {
		await this.done();
		return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
	}
	async totalUsage() {
		await this.done();
		return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
	}
	allChatCompletions() {
		return [...this._chatCompletions];
	}
	_emitFinal() {
		const completion = this._chatCompletions[this._chatCompletions.length - 1];
		if (completion) this._emit("finalChatCompletion", completion);
		const finalMessage = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
		if (finalMessage) this._emit("finalMessage", finalMessage);
		const finalContent = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
		if (finalContent) this._emit("finalContent", finalContent);
		const finalFunctionCall = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
		if (finalFunctionCall) this._emit("finalFunctionCall", finalFunctionCall);
		const finalFunctionCallResult = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
		if (finalFunctionCallResult != null) this._emit("finalFunctionCallResult", finalFunctionCallResult);
		if (this._chatCompletions.some((c$1) => c$1.usage)) this._emit("totalUsage", __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
	}
	async _createChatCompletion(client, params, options) {
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		__classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
		const chatCompletion = await client.chat.completions.create({
			...params,
			stream: false
		}, {
			...options,
			signal: this.controller.signal
		});
		this._connected();
		return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
	}
	async _runChatCompletion(client, params, options) {
		for (const message of params.messages) this._addMessage(message, false);
		return await this._createChatCompletion(client, params, options);
	}
	async _runFunctions(client, params, options) {
		const role = "function";
		const { function_call = "auto", stream: stream$2,...restParams } = params;
		const singleFunctionToCall = typeof function_call !== "string" && function_call?.name;
		const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
		const functionsByName = {};
		for (const f of params.functions) functionsByName[f.name || f.function.name] = f;
		const functions = params.functions.map((f) => ({
			name: f.name || f.function.name,
			parameters: f.parameters,
			description: f.description
		}));
		for (const message of params.messages) this._addMessage(message, false);
		for (let i$1 = 0; i$1 < maxChatCompletions; ++i$1) {
			const chatCompletion = await this._createChatCompletion(client, {
				...restParams,
				function_call,
				functions,
				messages: [...this.messages]
			}, options);
			const message = chatCompletion.choices[0]?.message;
			if (!message) throw new OpenAIError(`missing message in ChatCompletion response`);
			if (!message.function_call) return;
			const { name, arguments: args } = message.function_call;
			const fn = functionsByName[name];
			if (!fn) {
				const content$1 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
				this._addMessage({
					role,
					name,
					content: content$1
				});
				continue;
			} else if (singleFunctionToCall && singleFunctionToCall !== name) {
				const content$1 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
				this._addMessage({
					role,
					name,
					content: content$1
				});
				continue;
			}
			let parsed;
			try {
				parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
			} catch (error$1) {
				this._addMessage({
					role,
					name,
					content: error$1 instanceof Error ? error$1.message : String(error$1)
				});
				continue;
			}
			const rawContent = await fn.function(parsed, this);
			const content = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
			this._addMessage({
				role,
				name,
				content
			});
			if (singleFunctionToCall) return;
		}
	}
	async _runTools(client, params, options) {
		const role = "tool";
		const { tool_choice = "auto", stream: stream$2,...restParams } = params;
		const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice?.function?.name;
		const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
		const inputTools = params.tools.map((tool) => {
			if (isAutoParsableTool$1(tool)) {
				if (!tool.$callback) throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
				return {
					type: "function",
					function: {
						function: tool.$callback,
						name: tool.function.name,
						description: tool.function.description || "",
						parameters: tool.function.parameters,
						parse: tool.$parseRaw,
						strict: true
					}
				};
			}
			return tool;
		});
		const functionsByName = {};
		for (const f of inputTools) if (f.type === "function") functionsByName[f.function.name || f.function.function.name] = f.function;
		const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
			type: "function",
			function: {
				name: t.function.name || t.function.function.name,
				parameters: t.function.parameters,
				description: t.function.description,
				strict: t.function.strict
			}
		} : t) : void 0;
		for (const message of params.messages) this._addMessage(message, false);
		for (let i$1 = 0; i$1 < maxChatCompletions; ++i$1) {
			const chatCompletion = await this._createChatCompletion(client, {
				...restParams,
				tool_choice,
				tools,
				messages: [...this.messages]
			}, options);
			const message = chatCompletion.choices[0]?.message;
			if (!message) throw new OpenAIError(`missing message in ChatCompletion response`);
			if (!message.tool_calls?.length) return;
			for (const tool_call of message.tool_calls) {
				if (tool_call.type !== "function") continue;
				const tool_call_id = tool_call.id;
				const { name, arguments: args } = tool_call.function;
				const fn = functionsByName[name];
				if (!fn) {
					const content$1 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name$1) => JSON.stringify(name$1)).join(", ")}. Please try again`;
					this._addMessage({
						role,
						tool_call_id,
						content: content$1
					});
					continue;
				} else if (singleFunctionToCall && singleFunctionToCall !== name) {
					const content$1 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
					this._addMessage({
						role,
						tool_call_id,
						content: content$1
					});
					continue;
				}
				let parsed;
				try {
					parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
				} catch (error$1) {
					const content$1 = error$1 instanceof Error ? error$1.message : String(error$1);
					this._addMessage({
						role,
						tool_call_id,
						content: content$1
					});
					continue;
				}
				const rawContent = await fn.function(parsed, this);
				const content = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
				this._addMessage({
					role,
					tool_call_id,
					content
				});
				if (singleFunctionToCall) return;
			}
		}
		return;
	}
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent$1() {
	return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage$1() {
	let i$1 = this.messages.length;
	while (i$1-- > 0) {
		const message = this.messages[i$1];
		if (isAssistantMessage(message)) {
			const { function_call,...rest } = message;
			const ret = {
				...rest,
				content: message.content ?? null,
				refusal: message.refusal ?? null
			};
			if (function_call) ret.function_call = function_call;
			return ret;
		}
	}
	throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall$1() {
	for (let i$1 = this.messages.length - 1; i$1 >= 0; i$1--) {
		const message = this.messages[i$1];
		if (isAssistantMessage(message) && message?.function_call) return message.function_call;
		if (isAssistantMessage(message) && message?.tool_calls?.length) return message.tool_calls.at(-1)?.function;
	}
	return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult$1() {
	for (let i$1 = this.messages.length - 1; i$1 >= 0; i$1--) {
		const message = this.messages[i$1];
		if (isFunctionMessage(message) && message.content != null) return message.content;
		if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y$1) => y$1.type === "function" && y$1.id === message.tool_call_id))) return message.content;
	}
	return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage$1() {
	const total = {
		completion_tokens: 0,
		prompt_tokens: 0,
		total_tokens: 0
	};
	for (const { usage } of this._chatCompletions) if (usage) {
		total.completion_tokens += usage.completion_tokens;
		total.prompt_tokens += usage.prompt_tokens;
		total.total_tokens += usage.total_tokens;
	}
	return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams$1(params) {
	if (params.n != null && params.n > 1) throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult$1(rawContent) {
	return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class ChatCompletionRunner extends AbstractChatCompletionRunner {
	/** @deprecated - please use `runTools` instead. */
	static runFunctions(client, params, options) {
		const runner = new ChatCompletionRunner();
		const opts = {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "runFunctions"
			}
		};
		runner._run(() => runner._runFunctions(client, params, opts));
		return runner;
	}
	static runTools(client, params, options) {
		const runner = new ChatCompletionRunner();
		const opts = {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "runTools"
			}
		};
		runner._run(() => runner._runTools(client, params, opts));
		return runner;
	}
	_addMessage(message, emit = true) {
		super._addMessage(message, emit);
		if (isAssistantMessage(message) && message.content) this._emit("content", message.content);
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/_vendor/partial-json-parser/parser.mjs
const STR = 1;
const NUM = 2;
const ARR = 4;
const OBJ = 8;
const NULL = 16;
const BOOL = 32;
const NAN = 64;
const INFINITY = 128;
const MINUS_INFINITY = 256;
const INF = INFINITY | MINUS_INFINITY;
const SPECIAL = 400 | 96;
const ATOM = NUM | 497;
const COLLECTION = ARR | OBJ;
const ALL = ATOM | COLLECTION;
const Allow = {
	STR,
	NUM,
	ARR,
	OBJ,
	NULL,
	BOOL,
	NAN,
	INFINITY,
	MINUS_INFINITY,
	INF,
	SPECIAL,
	ATOM,
	COLLECTION,
	ALL
};
var PartialJSON = class extends Error {};
var MalformedJSON = class extends Error {};
/**
* Parse incomplete JSON
* @param {string} jsonString Partial JSON to be parsed
* @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details
* @returns The parsed JSON
* @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)
* @throws {MalformedJSON} If the JSON is malformed
*/
function parseJSON(jsonString, allowPartial = Allow.ALL) {
	if (typeof jsonString !== "string") throw new TypeError(`expecting str, got ${typeof jsonString}`);
	if (!jsonString.trim()) throw new Error(`${jsonString} is empty`);
	return _parseJSON(jsonString.trim(), allowPartial);
}
const _parseJSON = (jsonString, allow) => {
	const length = jsonString.length;
	let index = 0;
	const markPartialJSON = (msg) => {
		throw new PartialJSON(`${msg} at position ${index}`);
	};
	const throwMalformedError = (msg) => {
		throw new MalformedJSON(`${msg} at position ${index}`);
	};
	const parseAny = () => {
		skipBlank();
		if (index >= length) markPartialJSON("Unexpected end of input");
		if (jsonString[index] === "\"") return parseStr();
		if (jsonString[index] === "{") return parseObj();
		if (jsonString[index] === "[") return parseArr();
		if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
			index += 4;
			return null;
		}
		if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
			index += 4;
			return true;
		}
		if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
			index += 5;
			return false;
		}
		if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
			index += 8;
			return Infinity;
		}
		if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
			index += 9;
			return -Infinity;
		}
		if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
			index += 3;
			return NaN;
		}
		return parseNum();
	};
	const parseStr = () => {
		const start = index;
		let escape$2 = false;
		index++;
		while (index < length && (jsonString[index] !== "\"" || escape$2 && jsonString[index - 1] === "\\")) {
			escape$2 = jsonString[index] === "\\" ? !escape$2 : false;
			index++;
		}
		if (jsonString.charAt(index) == "\"") try {
			return JSON.parse(jsonString.substring(start, ++index - Number(escape$2)));
		} catch (e) {
			throwMalformedError(String(e));
		}
		else if (Allow.STR & allow) try {
			return JSON.parse(jsonString.substring(start, index - Number(escape$2)) + "\"");
		} catch (e) {
			return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + "\"");
		}
		markPartialJSON("Unterminated string literal");
	};
	const parseObj = () => {
		index++;
		skipBlank();
		const obj = {};
		try {
			while (jsonString[index] !== "}") {
				skipBlank();
				if (index >= length && Allow.OBJ & allow) return obj;
				const key = parseStr();
				skipBlank();
				index++;
				try {
					const value = parseAny();
					Object.defineProperty(obj, key, {
						value,
						writable: true,
						enumerable: true,
						configurable: true
					});
				} catch (e) {
					if (Allow.OBJ & allow) return obj;
					else throw e;
				}
				skipBlank();
				if (jsonString[index] === ",") index++;
			}
		} catch (e) {
			if (Allow.OBJ & allow) return obj;
			else markPartialJSON("Expected '}' at end of object");
		}
		index++;
		return obj;
	};
	const parseArr = () => {
		index++;
		const arr = [];
		try {
			while (jsonString[index] !== "]") {
				arr.push(parseAny());
				skipBlank();
				if (jsonString[index] === ",") index++;
			}
		} catch (e) {
			if (Allow.ARR & allow) return arr;
			markPartialJSON("Expected ']' at end of array");
		}
		index++;
		return arr;
	};
	const parseNum = () => {
		if (index === 0) {
			if (jsonString === "-" && Allow.NUM & allow) markPartialJSON("Not sure what '-' is");
			try {
				return JSON.parse(jsonString);
			} catch (e) {
				if (Allow.NUM & allow) try {
					if ("." === jsonString[jsonString.length - 1]) return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
					return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
				} catch (e$1) {}
				throwMalformedError(String(e));
			}
		}
		const start = index;
		if (jsonString[index] === "-") index++;
		while (jsonString[index] && !",]}".includes(jsonString[index])) index++;
		if (index == length && !(Allow.NUM & allow)) markPartialJSON("Unterminated number literal");
		try {
			return JSON.parse(jsonString.substring(start, index));
		} catch (e) {
			if (jsonString.substring(start, index) === "-" && Allow.NUM & allow) markPartialJSON("Not sure what '-' is");
			try {
				return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
			} catch (e$1) {
				throwMalformedError(String(e$1));
			}
		}
	};
	const skipBlank = () => {
		while (index < length && " \n\r	".includes(jsonString[index])) index++;
	};
	return parseAny();
};
const partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldSet$2 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind$1, f) {
	if (kind$1 === "m") throw new TypeError("Private method is not writable");
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind$1 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$2 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class ChatCompletionStream extends AbstractChatCompletionRunner {
	constructor(params) {
		super();
		_ChatCompletionStream_instances.add(this);
		_ChatCompletionStream_params.set(this, void 0);
		_ChatCompletionStream_choiceEventStates.set(this, void 0);
		_ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
		__classPrivateFieldSet$2(this, _ChatCompletionStream_params, params, "f");
		__classPrivateFieldSet$2(this, _ChatCompletionStream_choiceEventStates, [], "f");
	}
	get currentChatCompletionSnapshot() {
		return __classPrivateFieldGet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
	}
	/**
	* Intended for use on the frontend, consuming a stream produced with
	* `.toReadableStream()` on the backend.
	*
	* Note that messages sent to the model do not appear in `.on('message')`
	* in this context.
	*/
	static fromReadableStream(stream$2) {
		const runner = new ChatCompletionStream(null);
		runner._run(() => runner._fromReadableStream(stream$2));
		return runner;
	}
	static createChatCompletion(client, params, options) {
		const runner = new ChatCompletionStream(params);
		runner._run(() => runner._runChatCompletion(client, {
			...params,
			stream: true
		}, {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "stream"
			}
		}));
		return runner;
	}
	async _createChatCompletion(client, params, options) {
		super._createChatCompletion;
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
		const stream$2 = await client.chat.completions.create({
			...params,
			stream: true
		}, {
			...options,
			signal: this.controller.signal
		});
		this._connected();
		for await (const chunk of stream$2) __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
		if (stream$2.controller.signal?.aborted) throw new APIUserAbortError();
		return this._addChatCompletion(__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
	}
	async _fromReadableStream(readableStream, options) {
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
		this._connected();
		const stream$2 = Stream.fromReadableStream(readableStream, this.controller);
		let chatId;
		for await (const chunk of stream$2) {
			if (chatId && chatId !== chunk.id) this._addChatCompletion(__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
			__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
			chatId = chunk.id;
		}
		if (stream$2.controller.signal?.aborted) throw new APIUserAbortError();
		return this._addChatCompletion(__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
	}
	[(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest$1() {
		if (this.ended) return;
		__classPrivateFieldSet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
	}, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState$1(choice) {
		let state = __classPrivateFieldGet$2(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
		if (state) return state;
		state = {
			content_done: false,
			refusal_done: false,
			logprobs_content_done: false,
			logprobs_refusal_done: false,
			done_tool_calls: /* @__PURE__ */ new Set(),
			current_tool_call_index: null
		};
		__classPrivateFieldGet$2(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
		return state;
	}, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk$1(chunk) {
		if (this.ended) return;
		const completion = __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
		this._emit("chunk", chunk, completion);
		for (const choice of chunk.choices) {
			const choiceSnapshot = completion.choices[choice.index];
			if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
				this._emit("content", choice.delta.content, choiceSnapshot.message.content);
				this._emit("content.delta", {
					delta: choice.delta.content,
					snapshot: choiceSnapshot.message.content,
					parsed: choiceSnapshot.message.parsed
				});
			}
			if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) this._emit("refusal.delta", {
				delta: choice.delta.refusal,
				snapshot: choiceSnapshot.message.refusal
			});
			if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") this._emit("logprobs.content.delta", {
				content: choice.logprobs?.content,
				snapshot: choiceSnapshot.logprobs?.content ?? []
			});
			if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") this._emit("logprobs.refusal.delta", {
				refusal: choice.logprobs?.refusal,
				snapshot: choiceSnapshot.logprobs?.refusal ?? []
			});
			const state = __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
			if (choiceSnapshot.finish_reason) {
				__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
				if (state.current_tool_call_index != null) __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
			}
			for (const toolCall of choice.delta.tool_calls ?? []) {
				if (state.current_tool_call_index !== toolCall.index) {
					__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
					if (state.current_tool_call_index != null) __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
				}
				state.current_tool_call_index = toolCall.index;
			}
			for (const toolCallDelta of choice.delta.tool_calls ?? []) {
				const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
				if (!toolCallSnapshot?.type) continue;
				if (toolCallSnapshot?.type === "function") this._emit("tool_calls.function.arguments.delta", {
					name: toolCallSnapshot.function?.name,
					index: toolCallDelta.index,
					arguments: toolCallSnapshot.function.arguments,
					parsed_arguments: toolCallSnapshot.function.parsed_arguments,
					arguments_delta: toolCallDelta.function?.arguments ?? ""
				});
				else assertNever$1(toolCallSnapshot?.type);
			}
		}
	}, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent$1(choiceSnapshot, toolCallIndex) {
		const state = __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
		if (state.done_tool_calls.has(toolCallIndex)) return;
		const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
		if (!toolCallSnapshot) throw new Error("no tool call snapshot");
		if (!toolCallSnapshot.type) throw new Error("tool call snapshot missing `type`");
		if (toolCallSnapshot.type === "function") {
			const inputTool = __classPrivateFieldGet$2(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
			this._emit("tool_calls.function.arguments.done", {
				name: toolCallSnapshot.function.name,
				index: toolCallIndex,
				arguments: toolCallSnapshot.function.arguments,
				parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
			});
		} else assertNever$1(toolCallSnapshot.type);
	}, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents$1(choiceSnapshot) {
		const state = __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
		if (choiceSnapshot.message.content && !state.content_done) {
			state.content_done = true;
			const responseFormat = __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
			this._emit("content.done", {
				content: choiceSnapshot.message.content,
				parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
			});
		}
		if (choiceSnapshot.message.refusal && !state.refusal_done) {
			state.refusal_done = true;
			this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
		}
		if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
			state.logprobs_content_done = true;
			this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
		}
		if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
			state.logprobs_refusal_done = true;
			this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
		}
	}, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest$1() {
		if (this.ended) throw new OpenAIError(`stream has ended, this shouldn't happen`);
		const snapshot = __classPrivateFieldGet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
		if (!snapshot) throw new OpenAIError(`request ended without sending any chunks`);
		__classPrivateFieldSet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
		__classPrivateFieldSet$2(this, _ChatCompletionStream_choiceEventStates, [], "f");
		return finalizeChatCompletion(snapshot, __classPrivateFieldGet$2(this, _ChatCompletionStream_params, "f"));
	}, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat$1() {
		const responseFormat = __classPrivateFieldGet$2(this, _ChatCompletionStream_params, "f")?.response_format;
		if (isAutoParsableResponseFormat(responseFormat)) return responseFormat;
		return null;
	}, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion$1(chunk) {
		var _a$2, _b, _c, _d;
		let snapshot = __classPrivateFieldGet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
		const { choices,...rest } = chunk;
		if (!snapshot) snapshot = __classPrivateFieldSet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
			...rest,
			choices: []
		}, "f");
		else Object.assign(snapshot, rest);
		for (const { delta, finish_reason, index, logprobs = null,...other } of chunk.choices) {
			let choice = snapshot.choices[index];
			if (!choice) choice = snapshot.choices[index] = {
				finish_reason,
				index,
				message: {},
				logprobs,
				...other
			};
			if (logprobs) if (!choice.logprobs) choice.logprobs = Object.assign({}, logprobs);
			else {
				const { content: content$1, refusal: refusal$1,...rest$2 } = logprobs;
				assertIsEmpty(rest$2);
				Object.assign(choice.logprobs, rest$2);
				if (content$1) {
					(_a$2 = choice.logprobs).content ?? (_a$2.content = []);
					choice.logprobs.content.push(...content$1);
				}
				if (refusal$1) {
					(_b = choice.logprobs).refusal ?? (_b.refusal = []);
					choice.logprobs.refusal.push(...refusal$1);
				}
			}
			if (finish_reason) {
				choice.finish_reason = finish_reason;
				if (__classPrivateFieldGet$2(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput$1(__classPrivateFieldGet$2(this, _ChatCompletionStream_params, "f"))) {
					if (finish_reason === "length") throw new LengthFinishReasonError();
					if (finish_reason === "content_filter") throw new ContentFilterFinishReasonError();
				}
			}
			Object.assign(choice, other);
			if (!delta) continue;
			const { content, refusal, function_call, role, tool_calls,...rest$1 } = delta;
			assertIsEmpty(rest$1);
			Object.assign(choice.message, rest$1);
			if (refusal) choice.message.refusal = (choice.message.refusal || "") + refusal;
			if (role) choice.message.role = role;
			if (function_call) if (!choice.message.function_call) choice.message.function_call = function_call;
			else {
				if (function_call.name) choice.message.function_call.name = function_call.name;
				if (function_call.arguments) {
					(_c = choice.message.function_call).arguments ?? (_c.arguments = "");
					choice.message.function_call.arguments += function_call.arguments;
				}
			}
			if (content) {
				choice.message.content = (choice.message.content || "") + content;
				if (!choice.message.refusal && __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) choice.message.parsed = partialParse(choice.message.content);
			}
			if (tool_calls) {
				if (!choice.message.tool_calls) choice.message.tool_calls = [];
				for (const { index: index$1, id, type, function: fn,...rest$2 } of tool_calls) {
					const tool_call = (_d = choice.message.tool_calls)[index$1] ?? (_d[index$1] = {});
					Object.assign(tool_call, rest$2);
					if (id) tool_call.id = id;
					if (type) tool_call.type = type;
					if (fn) tool_call.function ?? (tool_call.function = {
						name: fn.name ?? "",
						arguments: ""
					});
					if (fn?.name) tool_call.function.name = fn.name;
					if (fn?.arguments) {
						tool_call.function.arguments += fn.arguments;
						if (shouldParseToolCall(__classPrivateFieldGet$2(this, _ChatCompletionStream_params, "f"), tool_call)) tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
					}
				}
			}
		}
		return snapshot;
	}, Symbol.asyncIterator)]() {
		const pushQueue = [];
		const readQueue = [];
		let done = false;
		this.on("chunk", (chunk) => {
			const reader = readQueue.shift();
			if (reader) reader.resolve(chunk);
			else pushQueue.push(chunk);
		});
		this.on("end", () => {
			done = true;
			for (const reader of readQueue) reader.resolve(void 0);
			readQueue.length = 0;
		});
		this.on("abort", (err) => {
			done = true;
			for (const reader of readQueue) reader.reject(err);
			readQueue.length = 0;
		});
		this.on("error", (err) => {
			done = true;
			for (const reader of readQueue) reader.reject(err);
			readQueue.length = 0;
		});
		return {
			next: async () => {
				if (!pushQueue.length) {
					if (done) return {
						value: void 0,
						done: true
					};
					return new Promise((resolve, reject) => readQueue.push({
						resolve,
						reject
					})).then((chunk$1) => chunk$1 ? {
						value: chunk$1,
						done: false
					} : {
						value: void 0,
						done: true
					});
				}
				const chunk = pushQueue.shift();
				return {
					value: chunk,
					done: false
				};
			},
			return: async () => {
				this.abort();
				return {
					value: void 0,
					done: true
				};
			}
		};
	}
	toReadableStream() {
		const stream$2 = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
		return stream$2.toReadableStream();
	}
};
function finalizeChatCompletion(snapshot, params) {
	const { id, choices, created, model, system_fingerprint,...rest } = snapshot;
	const completion = {
		...rest,
		id,
		choices: choices.map(({ message, finish_reason, index, logprobs,...choiceRest }) => {
			if (!finish_reason) throw new OpenAIError(`missing finish_reason for choice ${index}`);
			const { content = null, function_call, tool_calls,...messageRest } = message;
			const role = message.role;
			if (!role) throw new OpenAIError(`missing role for choice ${index}`);
			if (function_call) {
				const { arguments: args, name } = function_call;
				if (args == null) throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
				if (!name) throw new OpenAIError(`missing function_call.name for choice ${index}`);
				return {
					...choiceRest,
					message: {
						content,
						function_call: {
							arguments: args,
							name
						},
						role,
						refusal: message.refusal ?? null
					},
					finish_reason,
					index,
					logprobs
				};
			}
			if (tool_calls) return {
				...choiceRest,
				index,
				finish_reason,
				logprobs,
				message: {
					...messageRest,
					role,
					content,
					refusal: message.refusal ?? null,
					tool_calls: tool_calls.map((tool_call, i$1) => {
						const { function: fn, type, id: id$1,...toolRest } = tool_call;
						const { arguments: args, name,...fnRest } = fn || {};
						if (id$1 == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i$1}].id\n${str(snapshot)}`);
						if (type == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i$1}].type\n${str(snapshot)}`);
						if (name == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i$1}].function.name\n${str(snapshot)}`);
						if (args == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i$1}].function.arguments\n${str(snapshot)}`);
						return {
							...toolRest,
							id: id$1,
							type,
							function: {
								...fnRest,
								name,
								arguments: args
							}
						};
					})
				}
			};
			return {
				...choiceRest,
				message: {
					...messageRest,
					content,
					role,
					refusal: message.refusal ?? null
				},
				finish_reason,
				index,
				logprobs
			};
		}),
		created,
		model,
		object: "chat.completion",
		...system_fingerprint ? { system_fingerprint } : {}
	};
	return maybeParseChatCompletion(completion, params);
}
function str(x) {
	return JSON.stringify(x);
}
/**
* Ensures the given argument is an empty object, useful for
* asserting that all known properties on an object have been
* destructured.
*/
function assertIsEmpty(obj) {
	return;
}
function assertNever$1(_x) {}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class ChatCompletionStreamingRunner extends ChatCompletionStream {
	static fromReadableStream(stream$2) {
		const runner = new ChatCompletionStreamingRunner(null);
		runner._run(() => runner._fromReadableStream(stream$2));
		return runner;
	}
	/** @deprecated - please use `runTools` instead. */
	static runFunctions(client, params, options) {
		const runner = new ChatCompletionStreamingRunner(null);
		const opts = {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "runFunctions"
			}
		};
		runner._run(() => runner._runFunctions(client, params, opts));
		return runner;
	}
	static runTools(client, params, options) {
		const runner = new ChatCompletionStreamingRunner(params);
		const opts = {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "runTools"
			}
		};
		runner._run(() => runner._runTools(client, params, opts));
		return runner;
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/chat/completions.mjs
var Completions$1 = class extends APIResource {
	parse(body, options) {
		validateInputTools(body.tools);
		return this._client.chat.completions.create(body, {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "beta.chat.completions.parse"
			}
		})._thenUnwrap((completion) => parseChatCompletion(completion, body));
	}
	runFunctions(body, options) {
		if (body.stream) return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
		return ChatCompletionRunner.runFunctions(this._client, body, options);
	}
	runTools(body, options) {
		if (body.stream) return ChatCompletionStreamingRunner.runTools(this._client, body, options);
		return ChatCompletionRunner.runTools(this._client, body, options);
	}
	/**
	* Creates a chat completion stream
	*/
	stream(body, options) {
		return ChatCompletionStream.createChatCompletion(this._client, body, options);
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/chat/chat.mjs
var Chat$1 = class extends APIResource {
	constructor() {
		super(...arguments);
		this.completions = new Completions$1(this._client);
	}
};
(function(Chat$2) {
	Chat$2.Completions = Completions$1;
})(Chat$1 || (Chat$1 = {}));

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
	/**
	* Create an ephemeral API token for use in client-side applications with the
	* Realtime API. Can be configured with the same session parameters as the
	* `session.update` client event.
	*
	* It responds with a session object, plus a `client_secret` key which contains a
	* usable ephemeral API token that can be used to authenticate browser clients for
	* the Realtime API.
	*/
	create(body, options) {
		return this._client.post("/realtime/sessions", {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions = class extends APIResource {
	/**
	* Create an ephemeral API token for use in client-side applications with the
	* Realtime API specifically for realtime transcriptions. Can be configured with
	* the same session parameters as the `transcription_session.update` client event.
	*
	* It responds with a session object, plus a `client_secret` key which contains a
	* usable ephemeral API token that can be used to authenticate browser clients for
	* the Realtime API.
	*/
	create(body, options) {
		return this._client.post("/realtime/transcription_sessions", {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
	constructor() {
		super(...arguments);
		this.sessions = new Sessions(this._client);
		this.transcriptionSessions = new TranscriptionSessions(this._client);
	}
};
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/AssistantStream.mjs
var __classPrivateFieldGet$1 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$1 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind$1, f) {
	if (kind$1 === "m") throw new TypeError("Private method is not writable");
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind$1 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
var AssistantStream = class AssistantStream extends EventStream {
	constructor() {
		super(...arguments);
		_AssistantStream_instances.add(this);
		_AssistantStream_events.set(this, []);
		_AssistantStream_runStepSnapshots.set(this, {});
		_AssistantStream_messageSnapshots.set(this, {});
		_AssistantStream_messageSnapshot.set(this, void 0);
		_AssistantStream_finalRun.set(this, void 0);
		_AssistantStream_currentContentIndex.set(this, void 0);
		_AssistantStream_currentContent.set(this, void 0);
		_AssistantStream_currentToolCallIndex.set(this, void 0);
		_AssistantStream_currentToolCall.set(this, void 0);
		_AssistantStream_currentEvent.set(this, void 0);
		_AssistantStream_currentRunSnapshot.set(this, void 0);
		_AssistantStream_currentRunStepSnapshot.set(this, void 0);
	}
	[(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
		const pushQueue = [];
		const readQueue = [];
		let done = false;
		this.on("event", (event) => {
			const reader = readQueue.shift();
			if (reader) reader.resolve(event);
			else pushQueue.push(event);
		});
		this.on("end", () => {
			done = true;
			for (const reader of readQueue) reader.resolve(void 0);
			readQueue.length = 0;
		});
		this.on("abort", (err) => {
			done = true;
			for (const reader of readQueue) reader.reject(err);
			readQueue.length = 0;
		});
		this.on("error", (err) => {
			done = true;
			for (const reader of readQueue) reader.reject(err);
			readQueue.length = 0;
		});
		return {
			next: async () => {
				if (!pushQueue.length) {
					if (done) return {
						value: void 0,
						done: true
					};
					return new Promise((resolve, reject) => readQueue.push({
						resolve,
						reject
					})).then((chunk$1) => chunk$1 ? {
						value: chunk$1,
						done: false
					} : {
						value: void 0,
						done: true
					});
				}
				const chunk = pushQueue.shift();
				return {
					value: chunk,
					done: false
				};
			},
			return: async () => {
				this.abort();
				return {
					value: void 0,
					done: true
				};
			}
		};
	}
	static fromReadableStream(stream$2) {
		const runner = new AssistantStream();
		runner._run(() => runner._fromReadableStream(stream$2));
		return runner;
	}
	async _fromReadableStream(readableStream, options) {
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		this._connected();
		const stream$2 = Stream.fromReadableStream(readableStream, this.controller);
		for await (const event of stream$2) __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
		if (stream$2.controller.signal?.aborted) throw new APIUserAbortError();
		return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
	}
	toReadableStream() {
		const stream$2 = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
		return stream$2.toReadableStream();
	}
	static createToolAssistantStream(threadId, runId, runs, params, options) {
		const runner = new AssistantStream();
		runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "stream"
			}
		}));
		return runner;
	}
	async _createToolAssistantStream(run$1, threadId, runId, params, options) {
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		const body = {
			...params,
			stream: true
		};
		const stream$2 = await run$1.submitToolOutputs(threadId, runId, body, {
			...options,
			signal: this.controller.signal
		});
		this._connected();
		for await (const event of stream$2) __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
		if (stream$2.controller.signal?.aborted) throw new APIUserAbortError();
		return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
	}
	static createThreadAssistantStream(params, thread, options) {
		const runner = new AssistantStream();
		runner._run(() => runner._threadAssistantStream(params, thread, {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "stream"
			}
		}));
		return runner;
	}
	static createAssistantStream(threadId, runs, params, options) {
		const runner = new AssistantStream();
		runner._run(() => runner._runAssistantStream(threadId, runs, params, {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "stream"
			}
		}));
		return runner;
	}
	currentEvent() {
		return __classPrivateFieldGet$1(this, _AssistantStream_currentEvent, "f");
	}
	currentRun() {
		return __classPrivateFieldGet$1(this, _AssistantStream_currentRunSnapshot, "f");
	}
	currentMessageSnapshot() {
		return __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f");
	}
	currentRunStepSnapshot() {
		return __classPrivateFieldGet$1(this, _AssistantStream_currentRunStepSnapshot, "f");
	}
	async finalRunSteps() {
		await this.done();
		return Object.values(__classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f"));
	}
	async finalMessages() {
		await this.done();
		return Object.values(__classPrivateFieldGet$1(this, _AssistantStream_messageSnapshots, "f"));
	}
	async finalRun() {
		await this.done();
		if (!__classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f")) throw Error("Final run was not received.");
		return __classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f");
	}
	async _createThreadAssistantStream(thread, params, options) {
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		const body = {
			...params,
			stream: true
		};
		const stream$2 = await thread.createAndRun(body, {
			...options,
			signal: this.controller.signal
		});
		this._connected();
		for await (const event of stream$2) __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
		if (stream$2.controller.signal?.aborted) throw new APIUserAbortError();
		return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
	}
	async _createAssistantStream(run$1, threadId, params, options) {
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		const body = {
			...params,
			stream: true
		};
		const stream$2 = await run$1.create(threadId, body, {
			...options,
			signal: this.controller.signal
		});
		this._connected();
		for await (const event of stream$2) __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
		if (stream$2.controller.signal?.aborted) throw new APIUserAbortError();
		return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
	}
	static accumulateDelta(acc, delta) {
		for (const [key, deltaValue] of Object.entries(delta)) {
			if (!acc.hasOwnProperty(key)) {
				acc[key] = deltaValue;
				continue;
			}
			let accValue = acc[key];
			if (accValue === null || accValue === void 0) {
				acc[key] = deltaValue;
				continue;
			}
			if (key === "index" || key === "type") {
				acc[key] = deltaValue;
				continue;
			}
			if (typeof accValue === "string" && typeof deltaValue === "string") accValue += deltaValue;
			else if (typeof accValue === "number" && typeof deltaValue === "number") accValue += deltaValue;
			else if (isObj(accValue) && isObj(deltaValue)) accValue = this.accumulateDelta(accValue, deltaValue);
			else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
				if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
					accValue.push(...deltaValue);
					continue;
				}
				for (const deltaEntry of deltaValue) {
					if (!isObj(deltaEntry)) throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
					const index = deltaEntry["index"];
					if (index == null) {
						console.error(deltaEntry);
						throw new Error("Expected array delta entry to have an `index` property");
					}
					if (typeof index !== "number") throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
					const accEntry = accValue[index];
					if (accEntry == null) accValue.push(deltaEntry);
					else accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
				}
				continue;
			} else throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
			acc[key] = accValue;
		}
		return acc;
	}
	_addRun(run$1) {
		return run$1;
	}
	async _threadAssistantStream(params, thread, options) {
		return await this._createThreadAssistantStream(thread, params, options);
	}
	async _runAssistantStream(threadId, runs, params, options) {
		return await this._createAssistantStream(runs, threadId, params, options);
	}
	async _runToolAssistantStream(threadId, runId, runs, params, options) {
		return await this._createToolAssistantStream(runs, threadId, runId, params, options);
	}
};
_AssistantStream_addEvent = function _AssistantStream_addEvent$1(event) {
	if (this.ended) return;
	__classPrivateFieldSet$1(this, _AssistantStream_currentEvent, event, "f");
	__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
	switch (event.event) {
		case "thread.created": break;
		case "thread.run.created":
		case "thread.run.queued":
		case "thread.run.in_progress":
		case "thread.run.requires_action":
		case "thread.run.completed":
		case "thread.run.incomplete":
		case "thread.run.failed":
		case "thread.run.cancelling":
		case "thread.run.cancelled":
		case "thread.run.expired":
			__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
			break;
		case "thread.run.step.created":
		case "thread.run.step.in_progress":
		case "thread.run.step.delta":
		case "thread.run.step.completed":
		case "thread.run.step.failed":
		case "thread.run.step.cancelled":
		case "thread.run.step.expired":
			__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
			break;
		case "thread.message.created":
		case "thread.message.in_progress":
		case "thread.message.delta":
		case "thread.message.completed":
		case "thread.message.incomplete":
			__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
			break;
		case "error": throw new Error("Encountered an error event in event processing - errors should be processed earlier");
		default: assertNever(event);
	}
}, _AssistantStream_endRequest = function _AssistantStream_endRequest$1() {
	if (this.ended) throw new OpenAIError(`stream has ended, this shouldn't happen`);
	if (!__classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f")) throw Error("Final run has not been received");
	return __classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage$1(event) {
	const [accumulatedMessage, newContent] = __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
	__classPrivateFieldSet$1(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
	__classPrivateFieldGet$1(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
	for (const content of newContent) {
		const snapshotContent = accumulatedMessage.content[content.index];
		if (snapshotContent?.type == "text") this._emit("textCreated", snapshotContent.text);
	}
	switch (event.event) {
		case "thread.message.created":
			this._emit("messageCreated", event.data);
			break;
		case "thread.message.in_progress": break;
		case "thread.message.delta":
			this._emit("messageDelta", event.data.delta, accumulatedMessage);
			if (event.data.delta.content) for (const content of event.data.delta.content) {
				if (content.type == "text" && content.text) {
					let textDelta = content.text;
					let snapshot = accumulatedMessage.content[content.index];
					if (snapshot && snapshot.type == "text") this._emit("textDelta", textDelta, snapshot.text);
					else throw Error("The snapshot associated with this text delta is not text or missing");
				}
				if (content.index != __classPrivateFieldGet$1(this, _AssistantStream_currentContentIndex, "f")) {
					if (__classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f")) switch (__classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f").type) {
						case "text":
							this._emit("textDone", __classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
							break;
						case "image_file":
							this._emit("imageFileDone", __classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
							break;
					}
					__classPrivateFieldSet$1(this, _AssistantStream_currentContentIndex, content.index, "f");
				}
				__classPrivateFieldSet$1(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
			}
			break;
		case "thread.message.completed":
		case "thread.message.incomplete":
			if (__classPrivateFieldGet$1(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
				const currentContent = event.data.content[__classPrivateFieldGet$1(this, _AssistantStream_currentContentIndex, "f")];
				if (currentContent) switch (currentContent.type) {
					case "image_file":
						this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
						break;
					case "text":
						this._emit("textDone", currentContent.text, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
						break;
				}
			}
			if (__classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f")) this._emit("messageDone", event.data);
			__classPrivateFieldSet$1(this, _AssistantStream_messageSnapshot, void 0, "f");
	}
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep$1(event) {
	const accumulatedRunStep = __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
	__classPrivateFieldSet$1(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
	switch (event.event) {
		case "thread.run.step.created":
			this._emit("runStepCreated", event.data);
			break;
		case "thread.run.step.delta":
			const delta = event.data.delta;
			if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") for (const toolCall of delta.step_details.tool_calls) if (toolCall.index == __classPrivateFieldGet$1(this, _AssistantStream_currentToolCallIndex, "f")) this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
			else {
				if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f")) this._emit("toolCallDone", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
				__classPrivateFieldSet$1(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
				__classPrivateFieldSet$1(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
				if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f")) this._emit("toolCallCreated", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
			}
			this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
			break;
		case "thread.run.step.completed":
		case "thread.run.step.failed":
		case "thread.run.step.cancelled":
		case "thread.run.step.expired":
			__classPrivateFieldSet$1(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
			const details = event.data.step_details;
			if (details.type == "tool_calls") {
				if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f")) {
					this._emit("toolCallDone", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
					__classPrivateFieldSet$1(this, _AssistantStream_currentToolCall, void 0, "f");
				}
			}
			this._emit("runStepDone", event.data, accumulatedRunStep);
			break;
		case "thread.run.step.in_progress": break;
	}
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent$1(event) {
	__classPrivateFieldGet$1(this, _AssistantStream_events, "f").push(event);
	this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep$1(event) {
	switch (event.event) {
		case "thread.run.step.created":
			__classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
			return event.data;
		case "thread.run.step.delta":
			let snapshot = __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
			if (!snapshot) throw Error("Received a RunStepDelta before creation of a snapshot");
			let data = event.data;
			if (data.delta) {
				const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
				__classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
			}
			return __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
		case "thread.run.step.completed":
		case "thread.run.step.failed":
		case "thread.run.step.cancelled":
		case "thread.run.step.expired":
		case "thread.run.step.in_progress":
			__classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
			break;
	}
	if (__classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id]) return __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
	throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage$1(event, snapshot) {
	let newContent = [];
	switch (event.event) {
		case "thread.message.created": return [event.data, newContent];
		case "thread.message.delta":
			if (!snapshot) throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
			let data = event.data;
			if (data.delta.content) for (const contentElement of data.delta.content) if (contentElement.index in snapshot.content) {
				let currentContent = snapshot.content[contentElement.index];
				snapshot.content[contentElement.index] = __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
			} else {
				snapshot.content[contentElement.index] = contentElement;
				newContent.push(contentElement);
			}
			return [snapshot, newContent];
		case "thread.message.in_progress":
		case "thread.message.completed":
		case "thread.message.incomplete": if (snapshot) return [snapshot, newContent];
		else throw Error("Received thread message event with no existing snapshot");
	}
	throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent$1(contentElement, currentContent) {
	return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun$1(event) {
	__classPrivateFieldSet$1(this, _AssistantStream_currentRunSnapshot, event.data, "f");
	switch (event.event) {
		case "thread.run.created": break;
		case "thread.run.queued": break;
		case "thread.run.in_progress": break;
		case "thread.run.requires_action":
		case "thread.run.cancelled":
		case "thread.run.failed":
		case "thread.run.completed":
		case "thread.run.expired":
			__classPrivateFieldSet$1(this, _AssistantStream_finalRun, event.data, "f");
			if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f")) {
				this._emit("toolCallDone", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
				__classPrivateFieldSet$1(this, _AssistantStream_currentToolCall, void 0, "f");
			}
			break;
		case "thread.run.cancelling": break;
	}
};
function assertNever(_x) {}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/threads/messages.mjs
var Messages = class extends APIResource {
	/**
	* Create a message.
	*/
	create(threadId, body, options) {
		return this._client.post(`/threads/${threadId}/messages`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Retrieve a message.
	*/
	retrieve(threadId, messageId, options) {
		return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Modifies a message.
	*/
	update(threadId, messageId, body, options) {
		return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	list(threadId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(threadId, {}, query);
		return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Deletes a message.
	*/
	del(threadId, messageId, options) {
		return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
};
var MessagesPage = class extends CursorPage {};
Messages.MessagesPage = MessagesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
	retrieve(threadId, runId, stepId, query = {}, options) {
		if (isRequestOptions(query)) return this.retrieve(threadId, runId, stepId, {}, query);
		return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	list(threadId, runId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(threadId, runId, {}, query);
		return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
};
var RunStepsPage = class extends CursorPage {};
Steps.RunStepsPage = RunStepsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs$1 = class extends APIResource {
	constructor() {
		super(...arguments);
		this.steps = new Steps(this._client);
	}
	create(threadId, params, options) {
		const { include,...body } = params;
		return this._client.post(`/threads/${threadId}/runs`, {
			query: { include },
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			},
			stream: params.stream ?? false
		});
	}
	/**
	* Retrieves a run.
	*/
	retrieve(threadId, runId, options) {
		return this._client.get(`/threads/${threadId}/runs/${runId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Modifies a run.
	*/
	update(threadId, runId, body, options) {
		return this._client.post(`/threads/${threadId}/runs/${runId}`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	list(threadId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(threadId, {}, query);
		return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Cancels a run that is `in_progress`.
	*/
	cancel(threadId, runId, options) {
		return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* A helper to create a run an poll for a terminal state. More information on Run
	* lifecycles can be found here:
	* https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
	*/
	async createAndPoll(threadId, body, options) {
		const run$1 = await this.create(threadId, body, options);
		return await this.poll(threadId, run$1.id, options);
	}
	/**
	* Create a Run stream
	*
	* @deprecated use `stream` instead
	*/
	createAndStream(threadId, body, options) {
		return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
	}
	/**
	* A helper to poll a run status until it reaches a terminal state. More
	* information on Run lifecycles can be found here:
	* https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
	*/
	async poll(threadId, runId, options) {
		const headers = {
			...options?.headers,
			"X-Stainless-Poll-Helper": "true"
		};
		if (options?.pollIntervalMs) headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
		while (true) {
			const { data: run$1, response } = await this.retrieve(threadId, runId, {
				...options,
				headers: {
					...options?.headers,
					...headers
				}
			}).withResponse();
			switch (run$1.status) {
				case "queued":
				case "in_progress":
				case "cancelling":
					let sleepInterval = 5e3;
					if (options?.pollIntervalMs) sleepInterval = options.pollIntervalMs;
					else {
						const headerInterval = response.headers.get("openai-poll-after-ms");
						if (headerInterval) {
							const headerIntervalMs = parseInt(headerInterval);
							if (!isNaN(headerIntervalMs)) sleepInterval = headerIntervalMs;
						}
					}
					await sleep(sleepInterval);
					break;
				case "requires_action":
				case "incomplete":
				case "cancelled":
				case "completed":
				case "failed":
				case "expired": return run$1;
			}
		}
	}
	/**
	* Create a Run stream
	*/
	stream(threadId, body, options) {
		return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
	}
	submitToolOutputs(threadId, runId, body, options) {
		return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			},
			stream: body.stream ?? false
		});
	}
	/**
	* A helper to submit a tool output to a run and poll for a terminal run state.
	* More information on Run lifecycles can be found here:
	* https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
	*/
	async submitToolOutputsAndPoll(threadId, runId, body, options) {
		const run$1 = await this.submitToolOutputs(threadId, runId, body, options);
		return await this.poll(threadId, run$1.id, options);
	}
	/**
	* Submit the tool outputs from a previous run and stream the run to a terminal
	* state. More information on Run lifecycles can be found here:
	* https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
	*/
	submitToolOutputsStream(threadId, runId, body, options) {
		return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
	}
};
var RunsPage = class extends CursorPage {};
Runs$1.RunsPage = RunsPage;
Runs$1.Steps = Steps;
Runs$1.RunStepsPage = RunStepsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
	constructor() {
		super(...arguments);
		this.runs = new Runs$1(this._client);
		this.messages = new Messages(this._client);
	}
	create(body = {}, options) {
		if (isRequestOptions(body)) return this.create({}, body);
		return this._client.post("/threads", {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Retrieves a thread.
	*/
	retrieve(threadId, options) {
		return this._client.get(`/threads/${threadId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Modifies a thread.
	*/
	update(threadId, body, options) {
		return this._client.post(`/threads/${threadId}`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Delete a thread.
	*/
	del(threadId, options) {
		return this._client.delete(`/threads/${threadId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	createAndRun(body, options) {
		return this._client.post("/threads/runs", {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			},
			stream: body.stream ?? false
		});
	}
	/**
	* A helper to create a thread, start a run and then poll for a terminal state.
	* More information on Run lifecycles can be found here:
	* https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
	*/
	async createAndRunPoll(body, options) {
		const run$1 = await this.createAndRun(body, options);
		return await this.runs.poll(run$1.thread_id, run$1.id, options);
	}
	/**
	* Create a thread and stream the run back
	*/
	createAndRunStream(body, options) {
		return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
	}
};
Threads.Runs = Runs$1;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages;
Threads.MessagesPage = MessagesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
	constructor() {
		super(...arguments);
		this.realtime = new Realtime(this._client);
		this.chat = new Chat$1(this._client);
		this.assistants = new Assistants(this._client);
		this.threads = new Threads(this._client);
	}
};
Beta.Realtime = Realtime;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/completions.mjs
var Completions = class extends APIResource {
	create(body, options) {
		return this._client.post("/completions", {
			body,
			...options,
			stream: body.stream ?? false
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
	/**
	* Creates an embedding vector representing the input text.
	*/
	create(body, options) {
		const hasUserProvidedEncodingFormat = !!body.encoding_format;
		let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
		if (hasUserProvidedEncodingFormat) debug("Request", "User defined encoding_format:", body.encoding_format);
		const response = this._client.post("/embeddings", {
			body: {
				...body,
				encoding_format
			},
			...options
		});
		if (hasUserProvidedEncodingFormat) return response;
		debug("response", "Decoding base64 embeddings to float32 array");
		return response._thenUnwrap((response$1) => {
			if (response$1 && response$1.data) response$1.data.forEach((embeddingBase64Obj) => {
				const embeddingBase64Str = embeddingBase64Obj.embedding;
				embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
			});
			return response$1;
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems = class extends APIResource {
	/**
	* Get an evaluation run output item by ID.
	*/
	retrieve(evalId, runId, outputItemId, options) {
		return this._client.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`, options);
	}
	list(evalId, runId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(evalId, runId, {}, query);
		return this._client.getAPIList(`/evals/${evalId}/runs/${runId}/output_items`, OutputItemListResponsesPage, {
			query,
			...options
		});
	}
};
var OutputItemListResponsesPage = class extends CursorPage {};
OutputItems.OutputItemListResponsesPage = OutputItemListResponsesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/evals/runs/runs.mjs
var Runs = class extends APIResource {
	constructor() {
		super(...arguments);
		this.outputItems = new OutputItems(this._client);
	}
	/**
	* Create a new evaluation run. This is the endpoint that will kick off grading.
	*/
	create(evalId, body, options) {
		return this._client.post(`/evals/${evalId}/runs`, {
			body,
			...options
		});
	}
	/**
	* Get an evaluation run by ID.
	*/
	retrieve(evalId, runId, options) {
		return this._client.get(`/evals/${evalId}/runs/${runId}`, options);
	}
	list(evalId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(evalId, {}, query);
		return this._client.getAPIList(`/evals/${evalId}/runs`, RunListResponsesPage, {
			query,
			...options
		});
	}
	/**
	* Delete an eval run.
	*/
	del(evalId, runId, options) {
		return this._client.delete(`/evals/${evalId}/runs/${runId}`, options);
	}
	/**
	* Cancel an ongoing evaluation run.
	*/
	cancel(evalId, runId, options) {
		return this._client.post(`/evals/${evalId}/runs/${runId}`, options);
	}
};
var RunListResponsesPage = class extends CursorPage {};
Runs.RunListResponsesPage = RunListResponsesPage;
Runs.OutputItems = OutputItems;
Runs.OutputItemListResponsesPage = OutputItemListResponsesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/evals/evals.mjs
var Evals = class extends APIResource {
	constructor() {
		super(...arguments);
		this.runs = new Runs(this._client);
	}
	/**
	* Create the structure of an evaluation that can be used to test a model's
	* performance. An evaluation is a set of testing criteria and a datasource. After
	* creating an evaluation, you can run it on different models and model parameters.
	* We support several types of graders and datasources. For more information, see
	* the [Evals guide](https://platform.openai.com/docs/guides/evals).
	*/
	create(body, options) {
		return this._client.post("/evals", {
			body,
			...options
		});
	}
	/**
	* Get an evaluation by ID.
	*/
	retrieve(evalId, options) {
		return this._client.get(`/evals/${evalId}`, options);
	}
	/**
	* Update certain properties of an evaluation.
	*/
	update(evalId, body, options) {
		return this._client.post(`/evals/${evalId}`, {
			body,
			...options
		});
	}
	list(query = {}, options) {
		if (isRequestOptions(query)) return this.list({}, query);
		return this._client.getAPIList("/evals", EvalListResponsesPage, {
			query,
			...options
		});
	}
	/**
	* Delete an evaluation.
	*/
	del(evalId, options) {
		return this._client.delete(`/evals/${evalId}`, options);
	}
};
var EvalListResponsesPage = class extends CursorPage {};
Evals.EvalListResponsesPage = EvalListResponsesPage;
Evals.Runs = Runs;
Evals.RunListResponsesPage = RunListResponsesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/files.mjs
var Files = class extends APIResource {
	/**
	* Upload a file that can be used across various endpoints. Individual files can be
	* up to 512 MB, and the size of all files uploaded by one organization can be up
	* to 100 GB.
	*
	* The Assistants API supports files up to 2 million tokens and of specific file
	* types. See the
	* [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
	* details.
	*
	* The Fine-tuning API only supports `.jsonl` files. The input also has certain
	* required formats for fine-tuning
	* [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
	* [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
	* models.
	*
	* The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
	* has a specific required
	* [format](https://platform.openai.com/docs/api-reference/batch/request-input).
	*
	* Please [contact us](https://help.openai.com/) if you need to increase these
	* storage limits.
	*/
	create(body, options) {
		return this._client.post("/files", multipartFormRequestOptions({
			body,
			...options
		}));
	}
	/**
	* Returns information about a specific file.
	*/
	retrieve(fileId, options) {
		return this._client.get(`/files/${fileId}`, options);
	}
	list(query = {}, options) {
		if (isRequestOptions(query)) return this.list({}, query);
		return this._client.getAPIList("/files", FileObjectsPage, {
			query,
			...options
		});
	}
	/**
	* Delete a file.
	*/
	del(fileId, options) {
		return this._client.delete(`/files/${fileId}`, options);
	}
	/**
	* Returns the contents of the specified file.
	*/
	content(fileId, options) {
		return this._client.get(`/files/${fileId}/content`, {
			...options,
			headers: {
				Accept: "application/binary",
				...options?.headers
			},
			__binaryResponse: true
		});
	}
	/**
	* Returns the contents of the specified file.
	*
	* @deprecated The `.content()` method should be used instead
	*/
	retrieveContent(fileId, options) {
		return this._client.get(`/files/${fileId}/content`, options);
	}
	/**
	* Waits for the given file to be processed, default timeout is 30 mins.
	*/
	async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
		const TERMINAL_STATES = new Set([
			"processed",
			"error",
			"deleted"
		]);
		const start = Date.now();
		let file = await this.retrieve(id);
		while (!file.status || !TERMINAL_STATES.has(file.status)) {
			await sleep(pollInterval);
			file = await this.retrieve(id);
			if (Date.now() - start > maxWait) throw new APIConnectionTimeoutError({ message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.` });
		}
		return file;
	}
};
var FileObjectsPage = class extends CursorPage {};
Files.FileObjectsPage = FileObjectsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions = class extends APIResource {
	/**
	* **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
	*
	* This enables organization owners to share fine-tuned models with other projects
	* in their organization.
	*/
	create(fineTunedModelCheckpoint, body, options) {
		return this._client.getAPIList(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, PermissionCreateResponsesPage, {
			body,
			method: "post",
			...options
		});
	}
	retrieve(fineTunedModelCheckpoint, query = {}, options) {
		if (isRequestOptions(query)) return this.retrieve(fineTunedModelCheckpoint, {}, query);
		return this._client.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
			query,
			...options
		});
	}
	/**
	* **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
	*
	* Organization owners can use this endpoint to delete a permission for a
	* fine-tuned model checkpoint.
	*/
	del(fineTunedModelCheckpoint, options) {
		return this._client.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, options);
	}
};
/**
* Note: no pagination actually occurs yet, this is for forwards-compatibility.
*/
var PermissionCreateResponsesPage = class extends Page {};
Permissions.PermissionCreateResponsesPage = PermissionCreateResponsesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints = class extends APIResource {
	constructor() {
		super(...arguments);
		this.permissions = new Permissions(this._client);
	}
};
Checkpoints.Permissions = Permissions;
Checkpoints.PermissionCreateResponsesPage = PermissionCreateResponsesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints$1 = class extends APIResource {
	list(fineTuningJobId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(fineTuningJobId, {}, query);
		return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, {
			query,
			...options
		});
	}
};
var FineTuningJobCheckpointsPage = class extends CursorPage {};
Checkpoints$1.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
	constructor() {
		super(...arguments);
		this.checkpoints = new Checkpoints$1(this._client);
	}
	/**
	* Creates a fine-tuning job which begins the process of creating a new model from
	* a given dataset.
	*
	* Response includes details of the enqueued job including job status and the name
	* of the fine-tuned models once complete.
	*
	* [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
	*/
	create(body, options) {
		return this._client.post("/fine_tuning/jobs", {
			body,
			...options
		});
	}
	/**
	* Get info about a fine-tuning job.
	*
	* [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
	*/
	retrieve(fineTuningJobId, options) {
		return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
	}
	list(query = {}, options) {
		if (isRequestOptions(query)) return this.list({}, query);
		return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, {
			query,
			...options
		});
	}
	/**
	* Immediately cancel a fine-tune job.
	*/
	cancel(fineTuningJobId, options) {
		return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
	}
	listEvents(fineTuningJobId, query = {}, options) {
		if (isRequestOptions(query)) return this.listEvents(fineTuningJobId, {}, query);
		return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
			query,
			...options
		});
	}
};
var FineTuningJobsPage = class extends CursorPage {};
var FineTuningJobEventsPage = class extends CursorPage {};
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints$1;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
	constructor() {
		super(...arguments);
		this.jobs = new Jobs(this._client);
		this.checkpoints = new Checkpoints(this._client);
	}
};
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;
FineTuning.Checkpoints = Checkpoints;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
	/**
	* Creates a variation of a given image.
	*/
	createVariation(body, options) {
		return this._client.post("/images/variations", multipartFormRequestOptions({
			body,
			...options
		}));
	}
	/**
	* Creates an edited or extended image given an original image and a prompt.
	*/
	edit(body, options) {
		return this._client.post("/images/edits", multipartFormRequestOptions({
			body,
			...options
		}));
	}
	/**
	* Creates an image given a prompt.
	*/
	generate(body, options) {
		return this._client.post("/images/generations", {
			body,
			...options
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
	/**
	* Retrieves a model instance, providing basic information about the model such as
	* the owner and permissioning.
	*/
	retrieve(model, options) {
		return this._client.get(`/models/${model}`, options);
	}
	/**
	* Lists the currently available models, and provides basic information about each
	* one such as the owner and availability.
	*/
	list(options) {
		return this._client.getAPIList("/models", ModelsPage, options);
	}
	/**
	* Delete a fine-tuned model. You must have the Owner role in your organization to
	* delete a model.
	*/
	del(model, options) {
		return this._client.delete(`/models/${model}`, options);
	}
};
/**
* Note: no pagination actually occurs yet, this is for forwards-compatibility.
*/
var ModelsPage = class extends Page {};
Models.ModelsPage = ModelsPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
	/**
	* Classifies if text and/or image inputs are potentially harmful. Learn more in
	* the [moderation guide](https://platform.openai.com/docs/guides/moderation).
	*/
	create(body, options) {
		return this._client.post("/moderations", {
			body,
			...options
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
	if (!params || !hasAutoParseableInput(params)) return {
		...response,
		output_parsed: null,
		output: response.output.map((item) => {
			if (item.type === "function_call") return {
				...item,
				parsed_arguments: null
			};
			if (item.type === "message") return {
				...item,
				content: item.content.map((content) => ({
					...content,
					parsed: null
				}))
			};
			else return item;
		})
	};
	return parseResponse(response, params);
}
function parseResponse(response, params) {
	const output = response.output.map((item) => {
		if (item.type === "function_call") return {
			...item,
			parsed_arguments: parseToolCall(params, item)
		};
		if (item.type === "message") {
			const content = item.content.map((content$1) => {
				if (content$1.type === "output_text") return {
					...content$1,
					parsed: parseTextFormat(params, content$1.text)
				};
				return content$1;
			});
			return {
				...item,
				content
			};
		}
		return item;
	});
	const parsed = Object.assign({}, response, { output });
	if (!Object.getOwnPropertyDescriptor(response, "output_text")) addOutputText(parsed);
	Object.defineProperty(parsed, "output_parsed", {
		enumerable: true,
		get() {
			for (const output$1 of parsed.output) {
				if (output$1.type !== "message") continue;
				for (const content of output$1.content) if (content.type === "output_text" && content.parsed !== null) return content.parsed;
			}
			return null;
		}
	});
	return parsed;
}
function parseTextFormat(params, content) {
	if (params.text?.format?.type !== "json_schema") return null;
	if ("$parseRaw" in params.text?.format) {
		const text_format = params.text?.format;
		return text_format.$parseRaw(content);
	}
	return JSON.parse(content);
}
function hasAutoParseableInput(params) {
	if (isAutoParsableResponseFormat(params.text?.format)) return true;
	return false;
}
function isAutoParsableTool(tool) {
	return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
	return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall(params, toolCall) {
	const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
	return {
		...toolCall,
		...toolCall,
		parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
	};
}
function addOutputText(rsp) {
	const texts = [];
	for (const output of rsp.output) {
		if (output.type !== "message") continue;
		for (const content of output.content) if (content.type === "output_text") texts.push(content.text);
	}
	rsp.output_text = texts.join("");
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/responses/input-items.mjs
var InputItems = class extends APIResource {
	list(responseId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(responseId, {}, query);
		return this._client.getAPIList(`/responses/${responseId}/input_items`, ResponseItemsPage, {
			query,
			...options
		});
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/responses/ResponseStream.mjs
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind$1, f) {
	if (kind$1 === "m") throw new TypeError("Private method is not writable");
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind$1 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind$1, f) {
	if (kind$1 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind$1 === "m" ? f : kind$1 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;
var ResponseStream = class ResponseStream extends EventStream {
	constructor(params) {
		super();
		_ResponseStream_instances.add(this);
		_ResponseStream_params.set(this, void 0);
		_ResponseStream_currentResponseSnapshot.set(this, void 0);
		_ResponseStream_finalResponse.set(this, void 0);
		__classPrivateFieldSet(this, _ResponseStream_params, params, "f");
	}
	static createResponse(client, params, options) {
		const runner = new ResponseStream(params);
		runner._run(() => runner._createResponse(client, params, {
			...options,
			headers: {
				...options?.headers,
				"X-Stainless-Helper-Method": "stream"
			}
		}));
		return runner;
	}
	async _createResponse(client, params, options) {
		const signal = options?.signal;
		if (signal) {
			if (signal.aborted) this.controller.abort();
			signal.addEventListener("abort", () => this.controller.abort());
		}
		__classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
		const stream$2 = await client.responses.create({
			...params,
			stream: true
		}, {
			...options,
			signal: this.controller.signal
		});
		this._connected();
		for await (const event of stream$2) __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event);
		if (stream$2.controller.signal?.aborted) throw new APIUserAbortError();
		return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
	}
	[(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest$1() {
		if (this.ended) return;
		__classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
	}, _ResponseStream_addEvent = function _ResponseStream_addEvent$1(event) {
		if (this.ended) return;
		const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
		this._emit("event", event);
		switch (event.type) {
			case "response.output_text.delta": {
				const output = response.output[event.output_index];
				if (!output) throw new OpenAIError(`missing output at index ${event.output_index}`);
				if (output.type === "message") {
					const content = output.content[event.content_index];
					if (!content) throw new OpenAIError(`missing content at index ${event.content_index}`);
					if (content.type !== "output_text") throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
					this._emit("response.output_text.delta", {
						...event,
						snapshot: content.text
					});
				}
				break;
			}
			case "response.function_call_arguments.delta": {
				const output = response.output[event.output_index];
				if (!output) throw new OpenAIError(`missing output at index ${event.output_index}`);
				if (output.type === "function_call") this._emit("response.function_call_arguments.delta", {
					...event,
					snapshot: output.arguments
				});
				break;
			}
			default:
				this._emit(event.type, event);
				break;
		}
	}, _ResponseStream_endRequest = function _ResponseStream_endRequest$1() {
		if (this.ended) throw new OpenAIError(`stream has ended, this shouldn't happen`);
		const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
		if (!snapshot) throw new OpenAIError(`request ended without sending any events`);
		__classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
		const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
		__classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
		return parsedResponse;
	}, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse$1(event) {
		let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
		if (!snapshot) {
			if (event.type !== "response.created") throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
			snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
			return snapshot;
		}
		switch (event.type) {
			case "response.output_item.added": {
				snapshot.output.push(event.item);
				break;
			}
			case "response.content_part.added": {
				const output = snapshot.output[event.output_index];
				if (!output) throw new OpenAIError(`missing output at index ${event.output_index}`);
				if (output.type === "message") output.content.push(event.part);
				break;
			}
			case "response.output_text.delta": {
				const output = snapshot.output[event.output_index];
				if (!output) throw new OpenAIError(`missing output at index ${event.output_index}`);
				if (output.type === "message") {
					const content = output.content[event.content_index];
					if (!content) throw new OpenAIError(`missing content at index ${event.content_index}`);
					if (content.type !== "output_text") throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
					content.text += event.delta;
				}
				break;
			}
			case "response.function_call_arguments.delta": {
				const output = snapshot.output[event.output_index];
				if (!output) throw new OpenAIError(`missing output at index ${event.output_index}`);
				if (output.type === "function_call") output.arguments += event.delta;
				break;
			}
			case "response.completed": {
				__classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
				break;
			}
		}
		return snapshot;
	}, Symbol.asyncIterator)]() {
		const pushQueue = [];
		const readQueue = [];
		let done = false;
		this.on("event", (event) => {
			const reader = readQueue.shift();
			if (reader) reader.resolve(event);
			else pushQueue.push(event);
		});
		this.on("end", () => {
			done = true;
			for (const reader of readQueue) reader.resolve(void 0);
			readQueue.length = 0;
		});
		this.on("abort", (err) => {
			done = true;
			for (const reader of readQueue) reader.reject(err);
			readQueue.length = 0;
		});
		this.on("error", (err) => {
			done = true;
			for (const reader of readQueue) reader.reject(err);
			readQueue.length = 0;
		});
		return {
			next: async () => {
				if (!pushQueue.length) {
					if (done) return {
						value: void 0,
						done: true
					};
					return new Promise((resolve, reject) => readQueue.push({
						resolve,
						reject
					})).then((event$1) => event$1 ? {
						value: event$1,
						done: false
					} : {
						value: void 0,
						done: true
					});
				}
				const event = pushQueue.shift();
				return {
					value: event,
					done: false
				};
			},
			return: async () => {
				this.abort();
				return {
					value: void 0,
					done: true
				};
			}
		};
	}
	/**
	* @returns a promise that resolves with the final Response, or rejects
	* if an error occurred or the stream ended prematurely without producing a REsponse.
	*/
	async finalResponse() {
		await this.done();
		const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
		if (!response) throw new OpenAIError("stream ended without producing a ChatCompletion");
		return response;
	}
};
function finalizeResponse(snapshot, params) {
	return maybeParseResponse(snapshot, params);
}

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/responses/responses.mjs
var Responses = class extends APIResource {
	constructor() {
		super(...arguments);
		this.inputItems = new InputItems(this._client);
	}
	create(body, options) {
		return this._client.post("/responses", {
			body,
			...options,
			stream: body.stream ?? false
		})._thenUnwrap((rsp) => {
			if ("object" in rsp && rsp.object === "response") addOutputText(rsp);
			return rsp;
		});
	}
	retrieve(responseId, query = {}, options) {
		if (isRequestOptions(query)) return this.retrieve(responseId, {}, query);
		return this._client.get(`/responses/${responseId}`, {
			query,
			...options
		});
	}
	/**
	* Deletes a model response with the given ID.
	*/
	del(responseId, options) {
		return this._client.delete(`/responses/${responseId}`, {
			...options,
			headers: {
				Accept: "*/*",
				...options?.headers
			}
		});
	}
	parse(body, options) {
		return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
	}
	/**
	* Creates a model response stream
	*/
	stream(body, options) {
		return ResponseStream.createResponse(this._client, body, options);
	}
};
var ResponseItemsPage = class extends CursorPage {};
Responses.InputItems = InputItems;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
	/**
	* Adds a
	* [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
	* [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
	* A Part represents a chunk of bytes from the file you are trying to upload.
	*
	* Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
	* maximum of 8 GB.
	*
	* It is possible to add multiple Parts in parallel. You can decide the intended
	* order of the Parts when you
	* [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
	*/
	create(uploadId, body, options) {
		return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({
			body,
			...options
		}));
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
	constructor() {
		super(...arguments);
		this.parts = new Parts(this._client);
	}
	/**
	* Creates an intermediate
	* [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
	* that you can add
	* [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
	* Currently, an Upload can accept at most 8 GB in total and expires after an hour
	* after you create it.
	*
	* Once you complete the Upload, we will create a
	* [File](https://platform.openai.com/docs/api-reference/files/object) object that
	* contains all the parts you uploaded. This File is usable in the rest of our
	* platform as a regular File object.
	*
	* For certain `purpose` values, the correct `mime_type` must be specified. Please
	* refer to documentation for the
	* [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
	*
	* For guidance on the proper filename extensions for each purpose, please follow
	* the documentation on
	* [creating a File](https://platform.openai.com/docs/api-reference/files/create).
	*/
	create(body, options) {
		return this._client.post("/uploads", {
			body,
			...options
		});
	}
	/**
	* Cancels the Upload. No Parts may be added after an Upload is cancelled.
	*/
	cancel(uploadId, options) {
		return this._client.post(`/uploads/${uploadId}/cancel`, options);
	}
	/**
	* Completes the
	* [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
	*
	* Within the returned Upload object, there is a nested
	* [File](https://platform.openai.com/docs/api-reference/files/object) object that
	* is ready to use in the rest of the platform.
	*
	* You can specify the order of the Parts by passing in an ordered list of the Part
	* IDs.
	*
	* The number of bytes uploaded upon completion must match the number of bytes
	* initially specified when creating the Upload object. No Parts may be added after
	* an Upload is completed.
	*/
	complete(uploadId, body, options) {
		return this._client.post(`/uploads/${uploadId}/complete`, {
			body,
			...options
		});
	}
};
Uploads.Parts = Parts;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/lib/Util.mjs
/**
* Like `Promise.allSettled()` but throws an error if any promises are rejected.
*/
const allSettledWithThrow = async (promises) => {
	const results = await Promise.allSettled(promises);
	const rejected = results.filter((result) => result.status === "rejected");
	if (rejected.length) {
		for (const result of rejected) console.error(result.reason);
		throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
	}
	const values = [];
	for (const result of results) if (result.status === "fulfilled") values.push(result.value);
	return values;
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/vector-stores/files.mjs
var Files$1 = class extends APIResource {
	/**
	* Create a vector store file by attaching a
	* [File](https://platform.openai.com/docs/api-reference/files) to a
	* [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
	*/
	create(vectorStoreId, body, options) {
		return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Retrieves a vector store file.
	*/
	retrieve(vectorStoreId, fileId, options) {
		return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Update attributes on a vector store file.
	*/
	update(vectorStoreId, fileId, body, options) {
		return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	list(vectorStoreId, query = {}, options) {
		if (isRequestOptions(query)) return this.list(vectorStoreId, {}, query);
		return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Delete a vector store file. This will remove the file from the vector store but
	* the file itself will not be deleted. To delete the file, use the
	* [delete file](https://platform.openai.com/docs/api-reference/files/delete)
	* endpoint.
	*/
	del(vectorStoreId, fileId, options) {
		return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Attach a file to the given vector store and wait for it to be processed.
	*/
	async createAndPoll(vectorStoreId, body, options) {
		const file = await this.create(vectorStoreId, body, options);
		return await this.poll(vectorStoreId, file.id, options);
	}
	/**
	* Wait for the vector store file to finish processing.
	*
	* Note: this will return even if the file failed to process, you need to check
	* file.last_error and file.status to handle these cases
	*/
	async poll(vectorStoreId, fileId, options) {
		const headers = {
			...options?.headers,
			"X-Stainless-Poll-Helper": "true"
		};
		if (options?.pollIntervalMs) headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
		while (true) {
			const fileResponse = await this.retrieve(vectorStoreId, fileId, {
				...options,
				headers
			}).withResponse();
			const file = fileResponse.data;
			switch (file.status) {
				case "in_progress":
					let sleepInterval = 5e3;
					if (options?.pollIntervalMs) sleepInterval = options.pollIntervalMs;
					else {
						const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
						if (headerInterval) {
							const headerIntervalMs = parseInt(headerInterval);
							if (!isNaN(headerIntervalMs)) sleepInterval = headerIntervalMs;
						}
					}
					await sleep(sleepInterval);
					break;
				case "failed":
				case "completed": return file;
			}
		}
	}
	/**
	* Upload a file to the `files` API and then attach it to the given vector store.
	*
	* Note the file will be asynchronously processed (you can use the alternative
	* polling helper method to wait for processing to complete).
	*/
	async upload(vectorStoreId, file, options) {
		const fileInfo = await this._client.files.create({
			file,
			purpose: "assistants"
		}, options);
		return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
	}
	/**
	* Add a file to a vector store and poll until processing is complete.
	*/
	async uploadAndPoll(vectorStoreId, file, options) {
		const fileInfo = await this.upload(vectorStoreId, file, options);
		return await this.poll(vectorStoreId, fileInfo.id, options);
	}
	/**
	* Retrieve the parsed contents of a vector store file.
	*/
	content(vectorStoreId, fileId, options) {
		return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
};
var VectorStoreFilesPage = class extends CursorPage {};
/**
* Note: no pagination actually occurs yet, this is for forwards-compatibility.
*/
var FileContentResponsesPage = class extends Page {};
Files$1.VectorStoreFilesPage = VectorStoreFilesPage;
Files$1.FileContentResponsesPage = FileContentResponsesPage;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
	/**
	* Create a vector store file batch.
	*/
	create(vectorStoreId, body, options) {
		return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Retrieves a vector store file batch.
	*/
	retrieve(vectorStoreId, batchId, options) {
		return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Cancel a vector store file batch. This attempts to cancel the processing of
	* files in this batch as soon as possible.
	*/
	cancel(vectorStoreId, batchId, options) {
		return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Create a vector store batch and poll until all files have been processed.
	*/
	async createAndPoll(vectorStoreId, body, options) {
		const batch = await this.create(vectorStoreId, body);
		return await this.poll(vectorStoreId, batch.id, options);
	}
	listFiles(vectorStoreId, batchId, query = {}, options) {
		if (isRequestOptions(query)) return this.listFiles(vectorStoreId, batchId, {}, query);
		return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Wait for the given file batch to be processed.
	*
	* Note: this will return even if one of the files failed to process, you need to
	* check batch.file_counts.failed_count to handle this case.
	*/
	async poll(vectorStoreId, batchId, options) {
		const headers = {
			...options?.headers,
			"X-Stainless-Poll-Helper": "true"
		};
		if (options?.pollIntervalMs) headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
		while (true) {
			const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
				...options,
				headers
			}).withResponse();
			switch (batch.status) {
				case "in_progress":
					let sleepInterval = 5e3;
					if (options?.pollIntervalMs) sleepInterval = options.pollIntervalMs;
					else {
						const headerInterval = response.headers.get("openai-poll-after-ms");
						if (headerInterval) {
							const headerIntervalMs = parseInt(headerInterval);
							if (!isNaN(headerIntervalMs)) sleepInterval = headerIntervalMs;
						}
					}
					await sleep(sleepInterval);
					break;
				case "failed":
				case "cancelled":
				case "completed": return batch;
			}
		}
	}
	/**
	* Uploads the given files concurrently and then creates a vector store file batch.
	*
	* The concurrency limit is configurable using the `maxConcurrency` parameter.
	*/
	async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
		if (files == null || files.length == 0) throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
		const configuredConcurrency = options?.maxConcurrency ?? 5;
		const concurrencyLimit = Math.min(configuredConcurrency, files.length);
		const client = this._client;
		const fileIterator = files.values();
		const allFileIds = [...fileIds];
		async function processFiles(iterator$1) {
			for (let item of iterator$1) {
				const fileObj = await client.files.create({
					file: item,
					purpose: "assistants"
				}, options);
				allFileIds.push(fileObj.id);
			}
		}
		const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
		await allSettledWithThrow(workers);
		return await this.createAndPoll(vectorStoreId, { file_ids: allFileIds });
	}
};

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
	constructor() {
		super(...arguments);
		this.files = new Files$1(this._client);
		this.fileBatches = new FileBatches(this._client);
	}
	/**
	* Create a vector store.
	*/
	create(body, options) {
		return this._client.post("/vector_stores", {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Retrieves a vector store.
	*/
	retrieve(vectorStoreId, options) {
		return this._client.get(`/vector_stores/${vectorStoreId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Modifies a vector store.
	*/
	update(vectorStoreId, body, options) {
		return this._client.post(`/vector_stores/${vectorStoreId}`, {
			body,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	list(query = {}, options) {
		if (isRequestOptions(query)) return this.list({}, query);
		return this._client.getAPIList("/vector_stores", VectorStoresPage, {
			query,
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Delete a vector store.
	*/
	del(vectorStoreId, options) {
		return this._client.delete(`/vector_stores/${vectorStoreId}`, {
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
	/**
	* Search a vector store for relevant chunks based on a query and file attributes
	* filter.
	*/
	search(vectorStoreId, body, options) {
		return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {
			body,
			method: "post",
			...options,
			headers: {
				"OpenAI-Beta": "assistants=v2",
				...options?.headers
			}
		});
	}
};
var VectorStoresPage = class extends CursorPage {};
/**
* Note: no pagination actually occurs yet, this is for forwards-compatibility.
*/
var VectorStoreSearchResponsesPage = class extends Page {};
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
VectorStores.Files = Files$1;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileContentResponsesPage = FileContentResponsesPage;
VectorStores.FileBatches = FileBatches;

//#endregion
//#region node_modules/.pnpm/openai@4.93.0/node_modules/openai/index.mjs
var _a;
/**
* API Client for interfacing with the OpenAI API.
*/
var OpenAI = class extends APIClient {
	/**
	* API Client for interfacing with the OpenAI API.
	*
	* @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
	* @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
	* @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
	* @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
	* @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
	* @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
	* @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
	* @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
	* @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
	* @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
	* @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
	*/
	constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null,...opts } = {}) {
		if (apiKey === void 0) throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
		const options = {
			apiKey,
			organization,
			project,
			...opts,
			baseURL: baseURL || `https://api.openai.com/v1`
		};
		if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
		super({
			baseURL: options.baseURL,
			timeout: options.timeout ?? 6e5,
			httpAgent: options.httpAgent,
			maxRetries: options.maxRetries,
			fetch: options.fetch
		});
		this.completions = new Completions(this);
		this.chat = new Chat(this);
		this.embeddings = new Embeddings(this);
		this.files = new Files(this);
		this.images = new Images(this);
		this.audio = new Audio(this);
		this.moderations = new Moderations(this);
		this.models = new Models(this);
		this.fineTuning = new FineTuning(this);
		this.vectorStores = new VectorStores(this);
		this.beta = new Beta(this);
		this.batches = new Batches(this);
		this.uploads = new Uploads(this);
		this.responses = new Responses(this);
		this.evals = new Evals(this);
		this._options = options;
		this.apiKey = apiKey;
		this.organization = organization;
		this.project = project;
	}
	defaultQuery() {
		return this._options.defaultQuery;
	}
	defaultHeaders(opts) {
		return {
			...super.defaultHeaders(opts),
			"OpenAI-Organization": this.organization,
			"OpenAI-Project": this.project,
			...this._options.defaultHeaders
		};
	}
	authHeaders(opts) {
		return { Authorization: `Bearer ${this.apiKey}` };
	}
	stringifyQuery(query) {
		return stringify(query, { arrayFormat: "brackets" });
	}
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions;
OpenAI.Chat = Chat;
OpenAI.ChatCompletionsPage = ChatCompletionsPage;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.VectorStores = VectorStores;
OpenAI.VectorStoresPage = VectorStoresPage;
OpenAI.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Evals = Evals;
OpenAI.EvalListResponsesPage = EvalListResponsesPage;
var openai_default = OpenAI;

//#endregion
//#region node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js
function isPlainObject(value) {
	if (typeof value !== "object" || value === null) return false;
	const prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/file-url.js
const safeNormalizeFileUrl = (file, name) => {
	const fileString = normalizeFileUrl(file);
	if (typeof fileString !== "string") throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
	return fileString;
};
const normalizeFileUrl = (file) => file instanceof URL ? fileURLToPath(file) : file;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/parameters.js
const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {
	const filePath = safeNormalizeFileUrl(rawFile, "First argument");
	const [commandArguments, options] = isPlainObject(rawArguments) ? [[], rawArguments] : [rawArguments, rawOptions];
	if (!Array.isArray(commandArguments)) throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
	if (commandArguments.some((commandArgument) => typeof commandArgument === "object" && commandArgument !== null)) throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
	const normalizedArguments = commandArguments.map(String);
	const nullByteArgument = normalizedArguments.find((normalizedArgument) => normalizedArgument.includes("\0"));
	if (nullByteArgument !== void 0) throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
	if (!isPlainObject(options)) throw new TypeError(`Last argument must be an options object: ${options}`);
	return [
		filePath,
		normalizedArguments,
		options
	];
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/utils/uint-array.js
const { toString: objectToString$1 } = Object.prototype;
const isArrayBuffer = (value) => objectToString$1.call(value) === "[object ArrayBuffer]";
const isUint8Array = (value) => objectToString$1.call(value) === "[object Uint8Array]";
const bufferToUint8Array = (buffer) => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
const textEncoder$1 = new TextEncoder();
const stringToUint8Array = (string) => textEncoder$1.encode(string);
const textDecoder = new TextDecoder();
const uint8ArrayToString = (uint8Array) => textDecoder.decode(uint8Array);
const joinToString = (uint8ArraysOrStrings, encoding) => {
	const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
	return strings.join("");
};
const uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {
	if (encoding === "utf8" && uint8ArraysOrStrings.every((uint8ArrayOrString) => typeof uint8ArrayOrString === "string")) return uint8ArraysOrStrings;
	const decoder = new StringDecoder(encoding);
	const strings = uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array) => decoder.write(uint8Array));
	const finalString = decoder.end();
	return finalString === "" ? strings : [...strings, finalString];
};
const joinToUint8Array = (uint8ArraysOrStrings) => {
	if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) return uint8ArraysOrStrings[0];
	return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};
const stringsToUint8Arrays = (uint8ArraysOrStrings) => uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
const concatUint8Arrays = (uint8Arrays) => {
	const result = new Uint8Array(getJoinLength(uint8Arrays));
	let index = 0;
	for (const uint8Array of uint8Arrays) {
		result.set(uint8Array, index);
		index += uint8Array.length;
	}
	return result;
};
const getJoinLength = (uint8Arrays) => {
	let joinLength = 0;
	for (const uint8Array of uint8Arrays) joinLength += uint8Array.length;
	return joinLength;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/template.js
const isTemplateString = (templates) => Array.isArray(templates) && Array.isArray(templates.raw);
const parseTemplates = (templates, expressions) => {
	let tokens = [];
	for (const [index, template] of templates.entries()) tokens = parseTemplate({
		templates,
		expressions,
		tokens,
		index,
		template
	});
	if (tokens.length === 0) throw new TypeError("Template script must not be empty");
	const [file, ...commandArguments] = tokens;
	return [
		file,
		commandArguments,
		{}
	];
};
const parseTemplate = ({ templates, expressions, tokens, index, template }) => {
	if (template === void 0) throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
	const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
	const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
	if (index === expressions.length) return newTokens;
	const expression = expressions[index];
	const expressionTokens = Array.isArray(expression) ? expression.map((expression$1) => parseExpression(expression$1)) : [parseExpression(expression)];
	return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
};
const splitByWhitespaces = (template, rawTemplate) => {
	if (rawTemplate.length === 0) return {
		nextTokens: [],
		leadingWhitespaces: false,
		trailingWhitespaces: false
	};
	const nextTokens = [];
	let templateStart = 0;
	const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
	for (let templateIndex = 0, rawIndex = 0; templateIndex < template.length; templateIndex += 1, rawIndex += 1) {
		const rawCharacter = rawTemplate[rawIndex];
		if (DELIMITERS.has(rawCharacter)) {
			if (templateStart !== templateIndex) nextTokens.push(template.slice(templateStart, templateIndex));
			templateStart = templateIndex + 1;
		} else if (rawCharacter === "\\") {
			const nextRawCharacter = rawTemplate[rawIndex + 1];
			if (nextRawCharacter === "u" && rawTemplate[rawIndex + 2] === "{") rawIndex = rawTemplate.indexOf("}", rawIndex + 3);
			else rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
		}
	}
	const trailingWhitespaces = templateStart === template.length;
	if (!trailingWhitespaces) nextTokens.push(template.slice(templateStart));
	return {
		nextTokens,
		leadingWhitespaces,
		trailingWhitespaces
	};
};
const DELIMITERS = new Set([
	" ",
	"	",
	"\r",
	"\n"
]);
const ESCAPE_LENGTH = {
	x: 3,
	u: 5
};
const concatTokens = (tokens, nextTokens, isSeparated) => isSeparated || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
	...tokens.slice(0, -1),
	`${tokens.at(-1)}${nextTokens[0]}`,
	...nextTokens.slice(1)
];
const parseExpression = (expression) => {
	const typeOfExpression = typeof expression;
	if (typeOfExpression === "string") return expression;
	if (typeOfExpression === "number") return String(expression);
	if (isPlainObject(expression) && ("stdout" in expression || "isMaxBuffer" in expression)) return getSubprocessResult(expression);
	if (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === "[object Promise]") throw new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");
	throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
const getSubprocessResult = ({ stdout: stdout$1 }) => {
	if (typeof stdout$1 === "string") return stdout$1;
	if (isUint8Array(stdout$1)) return uint8ArrayToString(stdout$1);
	if (stdout$1 === void 0) throw new TypeError("Missing result.stdout in template expression. This is probably due to the previous subprocess' \"stdout\" option.");
	throw new TypeError(`Unexpected "${typeof stdout$1}" stdout in template expression`);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/utils/standard-stream.js
const isStandardStream = (stream$2) => STANDARD_STREAMS.includes(stream$2);
const STANDARD_STREAMS = [
	process$1.stdin,
	process$1.stdout,
	process$1.stderr
];
const STANDARD_STREAMS_ALIASES = [
	"stdin",
	"stdout",
	"stderr"
];
const getStreamName = (fdNumber) => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/specific.js
const normalizeFdSpecificOptions = (options) => {
	const optionsCopy = { ...options };
	for (const optionName of FD_SPECIFIC_OPTIONS) optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
	return optionsCopy;
};
const normalizeFdSpecificOption = (options, optionName) => {
	const optionBaseArray = Array.from({ length: getStdioLength(options) + 1 });
	const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
	return addDefaultValue$1(optionArray, optionName);
};
const getStdioLength = ({ stdio }) => Array.isArray(stdio) ? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length) : STANDARD_STREAMS_ALIASES.length;
const normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
const normalizeOptionObject = (optionValue, optionArray, optionName) => {
	for (const fdName of Object.keys(optionValue).sort(compareFdName)) for (const fdNumber of parseFdName(fdName, optionName, optionArray)) optionArray[fdNumber] = optionValue[fdName];
	return optionArray;
};
const compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
const getFdNameOrder = (fdName) => {
	if (fdName === "stdout" || fdName === "stderr") return 0;
	return fdName === "all" ? 2 : 1;
};
const parseFdName = (fdName, optionName, optionArray) => {
	if (fdName === "ipc") return [optionArray.length - 1];
	const fdNumber = parseFd(fdName);
	if (fdNumber === void 0 || fdNumber === 0) throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
	if (fdNumber >= optionArray.length) throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
	return fdNumber === "all" ? [1, 2] : [fdNumber];
};
const parseFd = (fdName) => {
	if (fdName === "all") return fdName;
	if (STANDARD_STREAMS_ALIASES.includes(fdName)) return STANDARD_STREAMS_ALIASES.indexOf(fdName);
	const regexpResult = FD_REGEXP.exec(fdName);
	if (regexpResult !== null) return Number(regexpResult[1]);
};
const FD_REGEXP = /^fd(\d+)$/;
const addDefaultValue$1 = (optionArray, optionName) => optionArray.map((optionValue) => optionValue === void 0 ? DEFAULT_OPTIONS[optionName] : optionValue);
const verboseDefault = debuglog("execa").enabled ? "full" : "none";
const DEFAULT_OPTIONS = {
	lines: false,
	buffer: true,
	maxBuffer: 1e3 * 1e3 * 100,
	verbose: verboseDefault,
	stripFinalNewline: true
};
const FD_SPECIFIC_OPTIONS = [
	"lines",
	"buffer",
	"maxBuffer",
	"verbose",
	"stripFinalNewline"
];
const getFdSpecificValue = (optionArray, fdNumber) => fdNumber === "ipc" ? optionArray.at(-1) : optionArray[fdNumber];

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/values.js
const isVerbose = ({ verbose }, fdNumber) => getFdVerbose(verbose, fdNumber) !== "none";
const isFullVerbose = ({ verbose }, fdNumber) => !["none", "short"].includes(getFdVerbose(verbose, fdNumber));
const getVerboseFunction = ({ verbose }, fdNumber) => {
	const fdVerbose = getFdVerbose(verbose, fdNumber);
	return isVerboseFunction(fdVerbose) ? fdVerbose : void 0;
};
const getFdVerbose = (verbose, fdNumber) => fdNumber === void 0 ? getFdGenericVerbose(verbose) : getFdSpecificValue(verbose, fdNumber);
const getFdGenericVerbose = (verbose) => verbose.find((fdVerbose) => isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose) => verbose.includes(fdVerbose));
const isVerboseFunction = (fdVerbose) => typeof fdVerbose === "function";
const VERBOSE_VALUES = [
	"none",
	"short",
	"full"
];

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/escape.js
const joinCommand = (filePath, rawArguments) => {
	const fileAndArguments = [filePath, ...rawArguments];
	const command = fileAndArguments.join(" ");
	const escapedCommand = fileAndArguments.map((fileAndArgument) => quoteString(escapeControlCharacters(fileAndArgument))).join(" ");
	return {
		command,
		escapedCommand
	};
};
const escapeLines = (lines) => stripVTControlCharacters(lines).split("\n").map((line) => escapeControlCharacters(line)).join("\n");
const escapeControlCharacters = (line) => line.replaceAll(SPECIAL_CHAR_REGEXP, (character) => escapeControlCharacter(character));
const escapeControlCharacter = (character) => {
	const commonEscape = COMMON_ESCAPES[character];
	if (commonEscape !== void 0) return commonEscape;
	const codepoint = character.codePointAt(0);
	const codepointHex = codepoint.toString(16);
	return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, "0")}` : `\\U${codepointHex}`;
};
const getSpecialCharRegExp = () => {
	try {
		return new RegExp("\\p{Separator}|\\p{Other}", "gu");
	} catch {
		return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
	}
};
const SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
const COMMON_ESCAPES = {
	" ": " ",
	"\b": "\\b",
	"\f": "\\f",
	"\n": "\\n",
	"\r": "\\r",
	"	": "\\t"
};
const ASTRAL_START = 65535;
const quoteString = (escapedArgument) => {
	if (NO_ESCAPE_REGEXP.test(escapedArgument)) return escapedArgument;
	return platform === "win32" ? `"${escapedArgument.replaceAll("\"", "\"\"")}"` : `'${escapedArgument.replaceAll("'", "'\\''")}'`;
};
const NO_ESCAPE_REGEXP = /^[\w./-]+$/;

//#endregion
//#region node_modules/.pnpm/is-unicode-supported@2.1.0/node_modules/is-unicode-supported/index.js
function isUnicodeSupported() {
	const { env } = process$1;
	const { TERM, TERM_PROGRAM } = env;
	if (process$1.platform !== "win32") return TERM !== "linux";
	return Boolean(env.WT_SESSION) || Boolean(env.TERMINUS_SUBLIME) || env.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

//#endregion
//#region node_modules/.pnpm/figures@6.1.0/node_modules/figures/index.js
const common = {
	circleQuestionMark: "(?)",
	questionMarkPrefix: "(?)",
	square: "█",
	squareDarkShade: "▓",
	squareMediumShade: "▒",
	squareLightShade: "░",
	squareTop: "▀",
	squareBottom: "▄",
	squareLeft: "▌",
	squareRight: "▐",
	squareCenter: "■",
	bullet: "●",
	dot: "․",
	ellipsis: "…",
	pointerSmall: "›",
	triangleUp: "▲",
	triangleUpSmall: "▴",
	triangleDown: "▼",
	triangleDownSmall: "▾",
	triangleLeftSmall: "◂",
	triangleRightSmall: "▸",
	home: "⌂",
	heart: "♥",
	musicNote: "♪",
	musicNoteBeamed: "♫",
	arrowUp: "↑",
	arrowDown: "↓",
	arrowLeft: "←",
	arrowRight: "→",
	arrowLeftRight: "↔",
	arrowUpDown: "↕",
	almostEqual: "≈",
	notEqual: "≠",
	lessOrEqual: "≤",
	greaterOrEqual: "≥",
	identical: "≡",
	infinity: "∞",
	subscriptZero: "₀",
	subscriptOne: "₁",
	subscriptTwo: "₂",
	subscriptThree: "₃",
	subscriptFour: "₄",
	subscriptFive: "₅",
	subscriptSix: "₆",
	subscriptSeven: "₇",
	subscriptEight: "₈",
	subscriptNine: "₉",
	oneHalf: "½",
	oneThird: "⅓",
	oneQuarter: "¼",
	oneFifth: "⅕",
	oneSixth: "⅙",
	oneEighth: "⅛",
	twoThirds: "⅔",
	twoFifths: "⅖",
	threeQuarters: "¾",
	threeFifths: "⅗",
	threeEighths: "⅜",
	fourFifths: "⅘",
	fiveSixths: "⅚",
	fiveEighths: "⅝",
	sevenEighths: "⅞",
	line: "─",
	lineBold: "━",
	lineDouble: "═",
	lineDashed0: "┄",
	lineDashed1: "┅",
	lineDashed2: "┈",
	lineDashed3: "┉",
	lineDashed4: "╌",
	lineDashed5: "╍",
	lineDashed6: "╴",
	lineDashed7: "╶",
	lineDashed8: "╸",
	lineDashed9: "╺",
	lineDashed10: "╼",
	lineDashed11: "╾",
	lineDashed12: "−",
	lineDashed13: "–",
	lineDashed14: "‐",
	lineDashed15: "⁃",
	lineVertical: "│",
	lineVerticalBold: "┃",
	lineVerticalDouble: "║",
	lineVerticalDashed0: "┆",
	lineVerticalDashed1: "┇",
	lineVerticalDashed2: "┊",
	lineVerticalDashed3: "┋",
	lineVerticalDashed4: "╎",
	lineVerticalDashed5: "╏",
	lineVerticalDashed6: "╵",
	lineVerticalDashed7: "╷",
	lineVerticalDashed8: "╹",
	lineVerticalDashed9: "╻",
	lineVerticalDashed10: "╽",
	lineVerticalDashed11: "╿",
	lineDownLeft: "┐",
	lineDownLeftArc: "╮",
	lineDownBoldLeftBold: "┓",
	lineDownBoldLeft: "┒",
	lineDownLeftBold: "┑",
	lineDownDoubleLeftDouble: "╗",
	lineDownDoubleLeft: "╖",
	lineDownLeftDouble: "╕",
	lineDownRight: "┌",
	lineDownRightArc: "╭",
	lineDownBoldRightBold: "┏",
	lineDownBoldRight: "┎",
	lineDownRightBold: "┍",
	lineDownDoubleRightDouble: "╔",
	lineDownDoubleRight: "╓",
	lineDownRightDouble: "╒",
	lineUpLeft: "┘",
	lineUpLeftArc: "╯",
	lineUpBoldLeftBold: "┛",
	lineUpBoldLeft: "┚",
	lineUpLeftBold: "┙",
	lineUpDoubleLeftDouble: "╝",
	lineUpDoubleLeft: "╜",
	lineUpLeftDouble: "╛",
	lineUpRight: "└",
	lineUpRightArc: "╰",
	lineUpBoldRightBold: "┗",
	lineUpBoldRight: "┖",
	lineUpRightBold: "┕",
	lineUpDoubleRightDouble: "╚",
	lineUpDoubleRight: "╙",
	lineUpRightDouble: "╘",
	lineUpDownLeft: "┤",
	lineUpBoldDownBoldLeftBold: "┫",
	lineUpBoldDownBoldLeft: "┨",
	lineUpDownLeftBold: "┥",
	lineUpBoldDownLeftBold: "┩",
	lineUpDownBoldLeftBold: "┪",
	lineUpDownBoldLeft: "┧",
	lineUpBoldDownLeft: "┦",
	lineUpDoubleDownDoubleLeftDouble: "╣",
	lineUpDoubleDownDoubleLeft: "╢",
	lineUpDownLeftDouble: "╡",
	lineUpDownRight: "├",
	lineUpBoldDownBoldRightBold: "┣",
	lineUpBoldDownBoldRight: "┠",
	lineUpDownRightBold: "┝",
	lineUpBoldDownRightBold: "┡",
	lineUpDownBoldRightBold: "┢",
	lineUpDownBoldRight: "┟",
	lineUpBoldDownRight: "┞",
	lineUpDoubleDownDoubleRightDouble: "╠",
	lineUpDoubleDownDoubleRight: "╟",
	lineUpDownRightDouble: "╞",
	lineDownLeftRight: "┬",
	lineDownBoldLeftBoldRightBold: "┳",
	lineDownLeftBoldRightBold: "┯",
	lineDownBoldLeftRight: "┰",
	lineDownBoldLeftBoldRight: "┱",
	lineDownBoldLeftRightBold: "┲",
	lineDownLeftRightBold: "┮",
	lineDownLeftBoldRight: "┭",
	lineDownDoubleLeftDoubleRightDouble: "╦",
	lineDownDoubleLeftRight: "╥",
	lineDownLeftDoubleRightDouble: "╤",
	lineUpLeftRight: "┴",
	lineUpBoldLeftBoldRightBold: "┻",
	lineUpLeftBoldRightBold: "┷",
	lineUpBoldLeftRight: "┸",
	lineUpBoldLeftBoldRight: "┹",
	lineUpBoldLeftRightBold: "┺",
	lineUpLeftRightBold: "┶",
	lineUpLeftBoldRight: "┵",
	lineUpDoubleLeftDoubleRightDouble: "╩",
	lineUpDoubleLeftRight: "╨",
	lineUpLeftDoubleRightDouble: "╧",
	lineUpDownLeftRight: "┼",
	lineUpBoldDownBoldLeftBoldRightBold: "╋",
	lineUpDownBoldLeftBoldRightBold: "╈",
	lineUpBoldDownLeftBoldRightBold: "╇",
	lineUpBoldDownBoldLeftRightBold: "╊",
	lineUpBoldDownBoldLeftBoldRight: "╉",
	lineUpBoldDownLeftRight: "╀",
	lineUpDownBoldLeftRight: "╁",
	lineUpDownLeftBoldRight: "┽",
	lineUpDownLeftRightBold: "┾",
	lineUpBoldDownBoldLeftRight: "╂",
	lineUpDownLeftBoldRightBold: "┿",
	lineUpBoldDownLeftBoldRight: "╃",
	lineUpBoldDownLeftRightBold: "╄",
	lineUpDownBoldLeftBoldRight: "╅",
	lineUpDownBoldLeftRightBold: "╆",
	lineUpDoubleDownDoubleLeftDoubleRightDouble: "╬",
	lineUpDoubleDownDoubleLeftRight: "╫",
	lineUpDownLeftDoubleRightDouble: "╪",
	lineCross: "╳",
	lineBackslash: "╲",
	lineSlash: "╱"
};
const specialMainSymbols = {
	tick: "✔",
	info: "ℹ",
	warning: "⚠",
	cross: "✘",
	squareSmall: "◻",
	squareSmallFilled: "◼",
	circle: "◯",
	circleFilled: "◉",
	circleDotted: "◌",
	circleDouble: "◎",
	circleCircle: "ⓞ",
	circleCross: "ⓧ",
	circlePipe: "Ⓘ",
	radioOn: "◉",
	radioOff: "◯",
	checkboxOn: "☒",
	checkboxOff: "☐",
	checkboxCircleOn: "ⓧ",
	checkboxCircleOff: "Ⓘ",
	pointer: "❯",
	triangleUpOutline: "△",
	triangleLeft: "◀",
	triangleRight: "▶",
	lozenge: "◆",
	lozengeOutline: "◇",
	hamburger: "☰",
	smiley: "㋡",
	mustache: "෴",
	star: "★",
	play: "▶",
	nodejs: "⬢",
	oneSeventh: "⅐",
	oneNinth: "⅑",
	oneTenth: "⅒"
};
const specialFallbackSymbols = {
	tick: "√",
	info: "i",
	warning: "‼",
	cross: "×",
	squareSmall: "□",
	squareSmallFilled: "■",
	circle: "( )",
	circleFilled: "(*)",
	circleDotted: "( )",
	circleDouble: "( )",
	circleCircle: "(○)",
	circleCross: "(×)",
	circlePipe: "(│)",
	radioOn: "(*)",
	radioOff: "( )",
	checkboxOn: "[×]",
	checkboxOff: "[ ]",
	checkboxCircleOn: "(×)",
	checkboxCircleOff: "( )",
	pointer: ">",
	triangleUpOutline: "∆",
	triangleLeft: "◄",
	triangleRight: "►",
	lozenge: "♦",
	lozengeOutline: "◊",
	hamburger: "≡",
	smiley: "☺",
	mustache: "┌─┐",
	star: "✶",
	play: "►",
	nodejs: "♦",
	oneSeventh: "1/7",
	oneNinth: "1/9",
	oneTenth: "1/10"
};
const mainSymbols = {
	...common,
	...specialMainSymbols
};
const fallbackSymbols = {
	...common,
	...specialFallbackSymbols
};
const shouldUseMain = isUnicodeSupported();
const figures = shouldUseMain ? mainSymbols : fallbackSymbols;
var figures_default = figures;
const replacements = Object.entries(specialMainSymbols);

//#endregion
//#region node_modules/.pnpm/yoctocolors@2.1.1/node_modules/yoctocolors/base.js
const hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;
const format = (open, close) => {
	if (!hasColors) return (input) => input;
	const openCode = `\u001B[${open}m`;
	const closeCode = `\u001B[${close}m`;
	return (input) => {
		const string = input + "";
		let index = string.indexOf(closeCode);
		if (index === -1) return openCode + string + closeCode;
		let result = openCode;
		let lastIndex = 0;
		while (index !== -1) {
			result += string.slice(lastIndex, index) + openCode;
			lastIndex = index + closeCode.length;
			index = string.indexOf(closeCode, lastIndex);
		}
		result += string.slice(lastIndex) + closeCode;
		return result;
	};
};
const reset = format(0, 0);
const bold = format(1, 22);
const dim = format(2, 22);
const italic = format(3, 23);
const underline = format(4, 24);
const overline = format(53, 55);
const inverse = format(7, 27);
const hidden = format(8, 28);
const strikethrough = format(9, 29);
const black = format(30, 39);
const red = format(31, 39);
const green = format(32, 39);
const yellow = format(33, 39);
const blue = format(34, 39);
const magenta = format(35, 39);
const cyan = format(36, 39);
const white = format(37, 39);
const gray = format(90, 39);
const bgBlack = format(40, 49);
const bgRed = format(41, 49);
const bgGreen = format(42, 49);
const bgYellow = format(43, 49);
const bgBlue = format(44, 49);
const bgMagenta = format(45, 49);
const bgCyan = format(46, 49);
const bgWhite = format(47, 49);
const bgGray = format(100, 49);
const redBright = format(91, 39);
const greenBright = format(92, 39);
const yellowBright = format(93, 39);
const blueBright = format(94, 39);
const magentaBright = format(95, 39);
const cyanBright = format(96, 39);
const whiteBright = format(97, 39);
const bgRedBright = format(101, 49);
const bgGreenBright = format(102, 49);
const bgYellowBright = format(103, 49);
const bgBlueBright = format(104, 49);
const bgMagentaBright = format(105, 49);
const bgCyanBright = format(106, 49);
const bgWhiteBright = format(107, 49);

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/default.js
const defaultVerboseFunction = ({ type, message, timestamp, piped, commandId, result: { failed = false } = {}, options: { reject = true } }) => {
	const timestampString = serializeTimestamp(timestamp);
	const icon = ICONS[type]({
		failed,
		reject,
		piped
	});
	const color = COLORS[type]({ reject });
	return `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
};
const serializeTimestamp = (timestamp) => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;
const padField = (field, padding) => String(field).padStart(padding, "0");
const getFinalIcon = ({ failed, reject }) => {
	if (!failed) return figures_default.tick;
	return reject ? figures_default.cross : figures_default.warning;
};
const ICONS = {
	command: ({ piped }) => piped ? "|" : "$",
	output: () => " ",
	ipc: () => "*",
	error: getFinalIcon,
	duration: getFinalIcon
};
const identity$1 = (string) => string;
const COLORS = {
	command: () => bold,
	output: () => identity$1,
	ipc: () => identity$1,
	error: ({ reject }) => reject ? redBright : yellowBright,
	duration: () => gray
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/custom.js
const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {
	const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
	return printedLines.map(({ verboseLine, verboseObject }) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine) => printedLine !== void 0).map((printedLine) => appendNewline(printedLine)).join("");
};
const applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {
	if (verboseFunction === void 0) return verboseLine;
	const printedLine = verboseFunction(verboseLine, verboseObject);
	if (typeof printedLine === "string") return printedLine;
};
const appendNewline = (printedLine) => printedLine.endsWith("\n") ? printedLine : `${printedLine}\n`;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/log.js
const verboseLog = ({ type, verboseMessage, fdNumber, verboseInfo, result }) => {
	const verboseObject = getVerboseObject({
		type,
		result,
		verboseInfo
	});
	const printedLines = getPrintedLines(verboseMessage, verboseObject);
	const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
	writeFileSync(STDERR_FD, finalLines);
};
const getVerboseObject = ({ type, result, verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false,...options } } }) => ({
	type,
	escapedCommand,
	commandId: `${commandId}`,
	timestamp: /* @__PURE__ */ new Date(),
	piped,
	result,
	options
});
const getPrintedLines = (verboseMessage, verboseObject) => verboseMessage.split("\n").map((message) => getPrintedLine({
	...verboseObject,
	message
}));
const getPrintedLine = (verboseObject) => {
	const verboseLine = defaultVerboseFunction(verboseObject);
	return {
		verboseLine,
		verboseObject
	};
};
const STDERR_FD = 2;
const serializeVerboseMessage = (message) => {
	const messageString = typeof message === "string" ? message : inspect$1(message);
	const escapedMessage = escapeLines(messageString);
	return escapedMessage.replaceAll("	", " ".repeat(TAB_SIZE));
};
const TAB_SIZE = 2;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/start.js
const logCommand = (escapedCommand, verboseInfo) => {
	if (!isVerbose(verboseInfo)) return;
	verboseLog({
		type: "command",
		verboseMessage: escapedCommand,
		verboseInfo
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/info.js
const getVerboseInfo = (verbose, escapedCommand, rawOptions) => {
	validateVerbose(verbose);
	const commandId = getCommandId(verbose);
	return {
		verbose,
		escapedCommand,
		commandId,
		rawOptions
	};
};
const getCommandId = (verbose) => isVerbose({ verbose }) ? COMMAND_ID++ : void 0;
let COMMAND_ID = 0n;
const validateVerbose = (verbose) => {
	for (const fdVerbose of verbose) {
		if (fdVerbose === false) throw new TypeError("The \"verbose: false\" option was renamed to \"verbose: 'none'\".");
		if (fdVerbose === true) throw new TypeError("The \"verbose: true\" option was renamed to \"verbose: 'short'\".");
		if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
			const allowedValues = VERBOSE_VALUES.map((allowedValue) => `'${allowedValue}'`).join(", ");
			throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
		}
	}
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/return/duration.js
const getStartTime = () => hrtime.bigint();
const getDurationMs = (startTime) => Number(hrtime.bigint() - startTime) / 1e6;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/command.js
const handleCommand = (filePath, rawArguments, rawOptions) => {
	const startTime = getStartTime();
	const { command, escapedCommand } = joinCommand(filePath, rawArguments);
	const verbose = normalizeFdSpecificOption(rawOptions, "verbose");
	const verboseInfo = getVerboseInfo(verbose, escapedCommand, { ...rawOptions });
	logCommand(escapedCommand, verboseInfo);
	return {
		command,
		escapedCommand,
		startTime,
		verboseInfo
	};
};

//#endregion
//#region node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS({ "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports, module) {
	module.exports = isexe$3;
	isexe$3.sync = sync$2;
	var fs$3 = __require("fs");
	function checkPathExt(path$9, options) {
		var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
		if (!pathext) return true;
		pathext = pathext.split(";");
		if (pathext.indexOf("") !== -1) return true;
		for (var i$1 = 0; i$1 < pathext.length; i$1++) {
			var p = pathext[i$1].toLowerCase();
			if (p && path$9.substr(-p.length).toLowerCase() === p) return true;
		}
		return false;
	}
	function checkStat$1(stat, path$9, options) {
		if (!stat.isSymbolicLink() && !stat.isFile()) return false;
		return checkPathExt(path$9, options);
	}
	function isexe$3(path$9, options, cb) {
		fs$3.stat(path$9, function(er, stat) {
			cb(er, er ? false : checkStat$1(stat, path$9, options));
		});
	}
	function sync$2(path$9, options) {
		return checkStat$1(fs$3.statSync(path$9), path$9, options);
	}
} });

//#endregion
//#region node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS({ "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports, module) {
	module.exports = isexe$2;
	isexe$2.sync = sync$1;
	var fs$2 = __require("fs");
	function isexe$2(path$9, options, cb) {
		fs$2.stat(path$9, function(er, stat) {
			cb(er, er ? false : checkStat(stat, options));
		});
	}
	function sync$1(path$9, options) {
		return checkStat(fs$2.statSync(path$9), options);
	}
	function checkStat(stat, options) {
		return stat.isFile() && checkMode(stat, options);
	}
	function checkMode(stat, options) {
		var mod = stat.mode;
		var uid$2 = stat.uid;
		var gid = stat.gid;
		var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
		var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
		var u$1 = parseInt("100", 8);
		var g = parseInt("010", 8);
		var o$1 = parseInt("001", 8);
		var ug = u$1 | g;
		var ret = mod & o$1 || mod & g && gid === myGid || mod & u$1 && uid$2 === myUid || mod & ug && myUid === 0;
		return ret;
	}
} });

//#endregion
//#region node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS({ "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports, module) {
	var fs$1 = __require("fs");
	var core;
	if (process.platform === "win32" || global.TESTING_WINDOWS) core = require_windows();
	else core = require_mode();
	module.exports = isexe$1;
	isexe$1.sync = sync;
	function isexe$1(path$9, options, cb) {
		if (typeof options === "function") {
			cb = options;
			options = {};
		}
		if (!cb) {
			if (typeof Promise !== "function") throw new TypeError("callback not provided");
			return new Promise(function(resolve, reject) {
				isexe$1(path$9, options || {}, function(er, is) {
					if (er) reject(er);
					else resolve(is);
				});
			});
		}
		core(path$9, options || {}, function(er, is) {
			if (er) {
				if (er.code === "EACCES" || options && options.ignoreErrors) {
					er = null;
					is = false;
				}
			}
			cb(er, is);
		});
	}
	function sync(path$9, options) {
		try {
			return core.sync(path$9, options || {});
		} catch (er) {
			if (options && options.ignoreErrors || er.code === "EACCES") return false;
			else throw er;
		}
	}
} });

//#endregion
//#region node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS({ "node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports, module) {
	const isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
	const path$3 = __require("path");
	const COLON = isWindows ? ";" : ":";
	const isexe = require_isexe();
	const getNotFoundError = (cmd) => Object.assign(/* @__PURE__ */ new Error(`not found: ${cmd}`), { code: "ENOENT" });
	const getPathInfo = (cmd, opt) => {
		const colon = opt.colon || COLON;
		const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [...isWindows ? [process.cwd()] : [], ...(opt.path || process.env.PATH || "").split(colon)];
		const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
		const pathExt = isWindows ? pathExtExe.split(colon) : [""];
		if (isWindows) {
			if (cmd.indexOf(".") !== -1 && pathExt[0] !== "") pathExt.unshift("");
		}
		return {
			pathEnv,
			pathExt,
			pathExtExe
		};
	};
	const which$1 = (cmd, opt, cb) => {
		if (typeof opt === "function") {
			cb = opt;
			opt = {};
		}
		if (!opt) opt = {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found = [];
		const step = (i$1) => new Promise((resolve, reject) => {
			if (i$1 === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
			const ppRaw = pathEnv[i$1];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$3.join(pathPart, cmd);
			const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
			resolve(subStep(p, i$1, 0));
		});
		const subStep = (p, i$1, ii) => new Promise((resolve, reject) => {
			if (ii === pathExt.length) return resolve(step(i$1 + 1));
			const ext = pathExt[ii];
			isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
				if (!er && is) if (opt.all) found.push(p + ext);
				else return resolve(p + ext);
				return resolve(subStep(p, i$1, ii + 1));
			});
		});
		return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
	};
	const whichSync = (cmd, opt) => {
		opt = opt || {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found = [];
		for (let i$1 = 0; i$1 < pathEnv.length; i$1++) {
			const ppRaw = pathEnv[i$1];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$3.join(pathPart, cmd);
			const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
			for (let j = 0; j < pathExt.length; j++) {
				const cur = p + pathExt[j];
				try {
					const is = isexe.sync(cur, { pathExt: pathExtExe });
					if (is) if (opt.all) found.push(cur);
					else return cur;
				} catch (ex) {}
			}
		}
		if (opt.all && found.length) return found;
		if (opt.nothrow) return null;
		throw getNotFoundError(cmd);
	};
	module.exports = which$1;
	which$1.sync = whichSync;
} });

//#endregion
//#region node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = __commonJS({ "node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports, module) {
	const pathKey$1 = (options = {}) => {
		const environment = options.env || process.env;
		const platform$1 = options.platform || process.platform;
		if (platform$1 !== "win32") return "PATH";
		return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
	};
	module.exports = pathKey$1;
	module.exports.default = pathKey$1;
} });

//#endregion
//#region node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({ "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module) {
	const path$2 = __require("path");
	const which = require_which();
	const getPathKey = require_path_key();
	function resolveCommandAttempt(parsed, withoutPathExt) {
		const env = parsed.options.env || process.env;
		const cwd = process.cwd();
		const hasCustomCwd = parsed.options.cwd != null;
		const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
		if (shouldSwitchCwd) try {
			process.chdir(parsed.options.cwd);
		} catch (err) {}
		let resolved;
		try {
			resolved = which.sync(parsed.command, {
				path: env[getPathKey({ env })],
				pathExt: withoutPathExt ? path$2.delimiter : void 0
			});
		} catch (e) {} finally {
			if (shouldSwitchCwd) process.chdir(cwd);
		}
		if (resolved) resolved = path$2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
		return resolved;
	}
	function resolveCommand$1(parsed) {
		return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
	}
	module.exports = resolveCommand$1;
} });

//#endregion
//#region node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({ "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js"(exports, module) {
	const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
	function escapeCommand(arg) {
		arg = arg.replace(metaCharsRegExp, "^$1");
		return arg;
	}
	function escapeArgument(arg, doubleEscapeMetaChars) {
		arg = `${arg}`;
		arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
		arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
		arg = `"${arg}"`;
		arg = arg.replace(metaCharsRegExp, "^$1");
		if (doubleEscapeMetaChars) arg = arg.replace(metaCharsRegExp, "^$1");
		return arg;
	}
	module.exports.command = escapeCommand;
	module.exports.argument = escapeArgument;
} });

//#endregion
//#region node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({ "node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports, module) {
	module.exports = /^#!(.*)/;
} });

//#endregion
//#region node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({ "node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports, module) {
	const shebangRegex = require_shebang_regex();
	module.exports = (string = "") => {
		const match = string.match(shebangRegex);
		if (!match) return null;
		const [path$9, argument] = match[0].replace(/#! ?/, "").split(" ");
		const binary = path$9.split("/").pop();
		if (binary === "env") return argument;
		return argument ? `${binary} ${argument}` : binary;
	};
} });

//#endregion
//#region node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({ "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module) {
	const fs = __require("fs");
	const shebangCommand = require_shebang_command();
	function readShebang$1(command) {
		const size = 150;
		const buffer = Buffer.alloc(size);
		let fd;
		try {
			fd = fs.openSync(command, "r");
			fs.readSync(fd, buffer, 0, size, 0);
			fs.closeSync(fd);
		} catch (e) {}
		return shebangCommand(buffer.toString());
	}
	module.exports = readShebang$1;
} });

//#endregion
//#region node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({ "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js"(exports, module) {
	const path$1 = __require("path");
	const resolveCommand = require_resolveCommand();
	const escape$1 = require_escape();
	const readShebang = require_readShebang();
	const isWin$1 = process.platform === "win32";
	const isExecutableRegExp = /\.(?:com|exe)$/i;
	const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
	function detectShebang(parsed) {
		parsed.file = resolveCommand(parsed);
		const shebang = parsed.file && readShebang(parsed.file);
		if (shebang) {
			parsed.args.unshift(parsed.file);
			parsed.command = shebang;
			return resolveCommand(parsed);
		}
		return parsed.file;
	}
	function parseNonShell(parsed) {
		if (!isWin$1) return parsed;
		const commandFile = detectShebang(parsed);
		const needsShell = !isExecutableRegExp.test(commandFile);
		if (parsed.options.forceShell || needsShell) {
			const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
			parsed.command = path$1.normalize(parsed.command);
			parsed.command = escape$1.command(parsed.command);
			parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
			const shellCommand = [parsed.command].concat(parsed.args).join(" ");
			parsed.args = [
				"/d",
				"/s",
				"/c",
				`"${shellCommand}"`
			];
			parsed.command = process.env.comspec || "cmd.exe";
			parsed.options.windowsVerbatimArguments = true;
		}
		return parsed;
	}
	function parse$1(command, args, options) {
		if (args && !Array.isArray(args)) {
			options = args;
			args = null;
		}
		args = args ? args.slice(0) : [];
		options = Object.assign({}, options);
		const parsed = {
			command,
			args,
			options,
			file: void 0,
			original: {
				command,
				args
			}
		};
		return options.shell ? parsed : parseNonShell(parsed);
	}
	module.exports = parse$1;
} });

//#endregion
//#region node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({ "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js"(exports, module) {
	const isWin = process.platform === "win32";
	function notFoundError(original, syscall) {
		return Object.assign(/* @__PURE__ */ new Error(`${syscall} ${original.command} ENOENT`), {
			code: "ENOENT",
			errno: "ENOENT",
			syscall: `${syscall} ${original.command}`,
			path: original.command,
			spawnargs: original.args
		});
	}
	function hookChildProcess(cp$2, parsed) {
		if (!isWin) return;
		const originalEmit = cp$2.emit;
		cp$2.emit = function(name, arg1) {
			if (name === "exit") {
				const err = verifyENOENT(arg1, parsed);
				if (err) return originalEmit.call(cp$2, "error", err);
			}
			return originalEmit.apply(cp$2, arguments);
		};
	}
	function verifyENOENT(status, parsed) {
		if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, "spawn");
		return null;
	}
	function verifyENOENTSync(status, parsed) {
		if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, "spawnSync");
		return null;
	}
	module.exports = {
		hookChildProcess,
		verifyENOENT,
		verifyENOENTSync,
		notFoundError
	};
} });

//#endregion
//#region node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({ "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js"(exports, module) {
	const cp = __require("child_process");
	const parse = require_parse();
	const enoent = require_enoent();
	function spawn$1(command, args, options) {
		const parsed = parse(command, args, options);
		const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
		enoent.hookChildProcess(spawned, parsed);
		return spawned;
	}
	function spawnSync$1(command, args, options) {
		const parsed = parse(command, args, options);
		const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
		result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
		return result;
	}
	module.exports = spawn$1;
	module.exports.spawn = spawn$1;
	module.exports.sync = spawnSync$1;
	module.exports._parse = parse;
	module.exports._enoent = enoent;
} });

//#endregion
//#region node_modules/.pnpm/path-key@4.0.0/node_modules/path-key/index.js
function pathKey(options = {}) {
	const { env = process.env, platform: platform$1 = process.platform } = options;
	if (platform$1 !== "win32") return "PATH";
	return Object.keys(env).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

//#endregion
//#region node_modules/.pnpm/npm-run-path@5.3.0/node_modules/npm-run-path/index.js
const npmRunPath = ({ cwd = process$1.cwd(), path: pathOption = process$1.env[pathKey()], preferLocal = true, execPath: execPath$1 = process$1.execPath, addExecPath = true } = {}) => {
	const cwdString = cwd instanceof URL ? fileURLToPath(cwd) : cwd;
	const cwdPath = path.resolve(cwdString);
	const result = [];
	if (preferLocal) applyPreferLocal(result, cwdPath);
	if (addExecPath) applyExecPath(result, execPath$1, cwdPath);
	return [...result, pathOption].join(path.delimiter);
};
const applyPreferLocal = (result, cwdPath) => {
	let previous;
	while (previous !== cwdPath) {
		result.push(path.join(cwdPath, "node_modules/.bin"));
		previous = cwdPath;
		cwdPath = path.resolve(cwdPath, "..");
	}
};
const applyExecPath = (result, execPath$1, cwdPath) => {
	const execPathString = execPath$1 instanceof URL ? fileURLToPath(execPath$1) : execPath$1;
	result.push(path.resolve(cwdPath, execPathString, ".."));
};
const npmRunPathEnv = ({ env = process$1.env,...options } = {}) => {
	env = { ...env };
	const pathName = pathKey({ env });
	options.path = env[pathName];
	env[pathName] = npmRunPath(options);
	return env;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/return/final-error.js
const getFinalError = (originalError, message, isSync) => {
	const ErrorClass = isSync ? ExecaSyncError : ExecaError;
	const options = originalError instanceof DiscardedError ? {} : { cause: originalError };
	return new ErrorClass(message, options);
};
var DiscardedError = class extends Error {};
const setErrorName = (ErrorClass, value) => {
	Object.defineProperty(ErrorClass.prototype, "name", {
		value,
		writable: true,
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
		value: true,
		writable: false,
		enumerable: false,
		configurable: false
	});
};
const isExecaError = (error$1) => isErrorInstance(error$1) && execaErrorSymbol in error$1;
const execaErrorSymbol = Symbol("isExecaError");
const isErrorInstance = (value) => Object.prototype.toString.call(value) === "[object Error]";
var ExecaError = class extends Error {};
setErrorName(ExecaError, ExecaError.name);
var ExecaSyncError = class extends Error {};
setErrorName(ExecaSyncError, ExecaSyncError.name);

//#endregion
//#region node_modules/.pnpm/human-signals@8.0.0/node_modules/human-signals/build/src/realtime.js
const getRealtimeSignals = () => {
	const length = SIGRTMAX - SIGRTMIN + 1;
	return Array.from({ length }, getRealtimeSignal);
};
const getRealtimeSignal = (value, index) => ({
	name: `SIGRT${index + 1}`,
	number: SIGRTMIN + index,
	action: "terminate",
	description: "Application-specific signal (realtime)",
	standard: "posix"
});
const SIGRTMIN = 34;
const SIGRTMAX = 64;

//#endregion
//#region node_modules/.pnpm/human-signals@8.0.0/node_modules/human-signals/build/src/core.js
const SIGNALS = [
	{
		name: "SIGHUP",
		number: 1,
		action: "terminate",
		description: "Terminal closed",
		standard: "posix"
	},
	{
		name: "SIGINT",
		number: 2,
		action: "terminate",
		description: "User interruption with CTRL-C",
		standard: "ansi"
	},
	{
		name: "SIGQUIT",
		number: 3,
		action: "core",
		description: "User interruption with CTRL-\\",
		standard: "posix"
	},
	{
		name: "SIGILL",
		number: 4,
		action: "core",
		description: "Invalid machine instruction",
		standard: "ansi"
	},
	{
		name: "SIGTRAP",
		number: 5,
		action: "core",
		description: "Debugger breakpoint",
		standard: "posix"
	},
	{
		name: "SIGABRT",
		number: 6,
		action: "core",
		description: "Aborted",
		standard: "ansi"
	},
	{
		name: "SIGIOT",
		number: 6,
		action: "core",
		description: "Aborted",
		standard: "bsd"
	},
	{
		name: "SIGBUS",
		number: 7,
		action: "core",
		description: "Bus error due to misaligned, non-existing address or paging error",
		standard: "bsd"
	},
	{
		name: "SIGEMT",
		number: 7,
		action: "terminate",
		description: "Command should be emulated but is not implemented",
		standard: "other"
	},
	{
		name: "SIGFPE",
		number: 8,
		action: "core",
		description: "Floating point arithmetic error",
		standard: "ansi"
	},
	{
		name: "SIGKILL",
		number: 9,
		action: "terminate",
		description: "Forced termination",
		standard: "posix",
		forced: true
	},
	{
		name: "SIGUSR1",
		number: 10,
		action: "terminate",
		description: "Application-specific signal",
		standard: "posix"
	},
	{
		name: "SIGSEGV",
		number: 11,
		action: "core",
		description: "Segmentation fault",
		standard: "ansi"
	},
	{
		name: "SIGUSR2",
		number: 12,
		action: "terminate",
		description: "Application-specific signal",
		standard: "posix"
	},
	{
		name: "SIGPIPE",
		number: 13,
		action: "terminate",
		description: "Broken pipe or socket",
		standard: "posix"
	},
	{
		name: "SIGALRM",
		number: 14,
		action: "terminate",
		description: "Timeout or timer",
		standard: "posix"
	},
	{
		name: "SIGTERM",
		number: 15,
		action: "terminate",
		description: "Termination",
		standard: "ansi"
	},
	{
		name: "SIGSTKFLT",
		number: 16,
		action: "terminate",
		description: "Stack is empty or overflowed",
		standard: "other"
	},
	{
		name: "SIGCHLD",
		number: 17,
		action: "ignore",
		description: "Child process terminated, paused or unpaused",
		standard: "posix"
	},
	{
		name: "SIGCLD",
		number: 17,
		action: "ignore",
		description: "Child process terminated, paused or unpaused",
		standard: "other"
	},
	{
		name: "SIGCONT",
		number: 18,
		action: "unpause",
		description: "Unpaused",
		standard: "posix",
		forced: true
	},
	{
		name: "SIGSTOP",
		number: 19,
		action: "pause",
		description: "Paused",
		standard: "posix",
		forced: true
	},
	{
		name: "SIGTSTP",
		number: 20,
		action: "pause",
		description: "Paused using CTRL-Z or \"suspend\"",
		standard: "posix"
	},
	{
		name: "SIGTTIN",
		number: 21,
		action: "pause",
		description: "Background process cannot read terminal input",
		standard: "posix"
	},
	{
		name: "SIGBREAK",
		number: 21,
		action: "terminate",
		description: "User interruption with CTRL-BREAK",
		standard: "other"
	},
	{
		name: "SIGTTOU",
		number: 22,
		action: "pause",
		description: "Background process cannot write to terminal output",
		standard: "posix"
	},
	{
		name: "SIGURG",
		number: 23,
		action: "ignore",
		description: "Socket received out-of-band data",
		standard: "bsd"
	},
	{
		name: "SIGXCPU",
		number: 24,
		action: "core",
		description: "Process timed out",
		standard: "bsd"
	},
	{
		name: "SIGXFSZ",
		number: 25,
		action: "core",
		description: "File too big",
		standard: "bsd"
	},
	{
		name: "SIGVTALRM",
		number: 26,
		action: "terminate",
		description: "Timeout or timer",
		standard: "bsd"
	},
	{
		name: "SIGPROF",
		number: 27,
		action: "terminate",
		description: "Timeout or timer",
		standard: "bsd"
	},
	{
		name: "SIGWINCH",
		number: 28,
		action: "ignore",
		description: "Terminal window size changed",
		standard: "bsd"
	},
	{
		name: "SIGIO",
		number: 29,
		action: "terminate",
		description: "I/O is available",
		standard: "other"
	},
	{
		name: "SIGPOLL",
		number: 29,
		action: "terminate",
		description: "Watched event",
		standard: "other"
	},
	{
		name: "SIGINFO",
		number: 29,
		action: "ignore",
		description: "Request for process information",
		standard: "other"
	},
	{
		name: "SIGPWR",
		number: 30,
		action: "terminate",
		description: "Device running out of power",
		standard: "systemv"
	},
	{
		name: "SIGSYS",
		number: 31,
		action: "core",
		description: "Invalid system call",
		standard: "other"
	},
	{
		name: "SIGUNUSED",
		number: 31,
		action: "terminate",
		description: "Invalid system call",
		standard: "other"
	}
];

//#endregion
//#region node_modules/.pnpm/human-signals@8.0.0/node_modules/human-signals/build/src/signals.js
const getSignals = () => {
	const realtimeSignals = getRealtimeSignals();
	const signals$2 = [...SIGNALS, ...realtimeSignals].map(normalizeSignal$1);
	return signals$2;
};
const normalizeSignal$1 = ({ name, number: defaultNumber, description, action, forced = false, standard }) => {
	const { signals: { [name]: constantSignal } } = constants;
	const supported = constantSignal !== void 0;
	const number = supported ? constantSignal : defaultNumber;
	return {
		name,
		number,
		description,
		supported,
		action,
		forced,
		standard
	};
};

//#endregion
//#region node_modules/.pnpm/human-signals@8.0.0/node_modules/human-signals/build/src/main.js
const getSignalsByName = () => {
	const signals$2 = getSignals();
	return Object.fromEntries(signals$2.map(getSignalByName));
};
const getSignalByName = ({ name, number, description, supported, action, forced, standard }) => [name, {
	name,
	number,
	description,
	supported,
	action,
	forced,
	standard
}];
const signalsByName = getSignalsByName();
const getSignalsByNumber = () => {
	const signals$2 = getSignals();
	const length = SIGRTMAX + 1;
	const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals$2));
	return Object.assign({}, ...signalsA);
};
const getSignalByNumber = (number, signals$2) => {
	const signal = findSignalByNumber(number, signals$2);
	if (signal === void 0) return {};
	const { name, description, supported, action, forced, standard } = signal;
	return { [number]: {
		name,
		number,
		description,
		supported,
		action,
		forced,
		standard
	} };
};
const findSignalByNumber = (number, signals$2) => {
	const signal = signals$2.find(({ name }) => constants.signals[name] === number);
	if (signal !== void 0) return signal;
	return signals$2.find((signalA) => signalA.number === number);
};
const signalsByNumber = getSignalsByNumber();

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/terminate/signal.js
const normalizeKillSignal = (killSignal) => {
	const optionName = "option `killSignal`";
	if (killSignal === 0) throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
	return normalizeSignal(killSignal, optionName);
};
const normalizeSignalArgument = (signal) => signal === 0 ? signal : normalizeSignal(signal, "`subprocess.kill()`'s argument");
const normalizeSignal = (signalNameOrInteger, optionName) => {
	if (Number.isInteger(signalNameOrInteger)) return normalizeSignalInteger(signalNameOrInteger, optionName);
	if (typeof signalNameOrInteger === "string") return normalizeSignalName(signalNameOrInteger, optionName);
	throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\n${getAvailableSignals()}`);
};
const normalizeSignalInteger = (signalInteger, optionName) => {
	if (signalsIntegerToName.has(signalInteger)) return signalsIntegerToName.get(signalInteger);
	throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\n${getAvailableSignals()}`);
};
const getSignalsIntegerToName = () => new Map(Object.entries(constants.signals).reverse().map(([signalName, signalInteger]) => [signalInteger, signalName]));
const signalsIntegerToName = getSignalsIntegerToName();
const normalizeSignalName = (signalName, optionName) => {
	if (signalName in constants.signals) return signalName;
	if (signalName.toUpperCase() in constants.signals) throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
	throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\n${getAvailableSignals()}`);
};
const getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;
const getAvailableSignalNames = () => Object.keys(constants.signals).sort().map((signalName) => `'${signalName}'`).join(", ");
const getAvailableSignalIntegers = () => [...new Set(Object.values(constants.signals).sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))].join(", ");
const getSignalDescription = (signal) => signalsByName[signal].description;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/terminate/kill.js
const normalizeForceKillAfterDelay = (forceKillAfterDelay) => {
	if (forceKillAfterDelay === false) return forceKillAfterDelay;
	if (forceKillAfterDelay === true) return DEFAULT_FORCE_KILL_TIMEOUT;
	if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
	return forceKillAfterDelay;
};
const DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
const subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context: context$1, controller }, signalOrError, errorArgument) => {
	const { signal, error: error$1 } = parseKillArguments(signalOrError, errorArgument, killSignal);
	emitKillError(error$1, onInternalError);
	const killResult = kill(signal);
	setKillTimeout({
		kill,
		signal,
		forceKillAfterDelay,
		killSignal,
		killResult,
		context: context$1,
		controller
	});
	return killResult;
};
const parseKillArguments = (signalOrError, errorArgument, killSignal) => {
	const [signal = killSignal, error$1] = isErrorInstance(signalOrError) ? [void 0, signalOrError] : [signalOrError, errorArgument];
	if (typeof signal !== "string" && !Number.isInteger(signal)) throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
	if (error$1 !== void 0 && !isErrorInstance(error$1)) throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error$1}`);
	return {
		signal: normalizeSignalArgument(signal),
		error: error$1
	};
};
const emitKillError = (error$1, onInternalError) => {
	if (error$1 !== void 0) onInternalError.reject(error$1);
};
const setKillTimeout = async ({ kill, signal, forceKillAfterDelay, killSignal, killResult, context: context$1, controller }) => {
	if (signal === killSignal && killResult) killOnTimeout({
		kill,
		forceKillAfterDelay,
		context: context$1,
		controllerSignal: controller.signal
	});
};
const killOnTimeout = async ({ kill, forceKillAfterDelay, context: context$1, controllerSignal }) => {
	if (forceKillAfterDelay === false) return;
	try {
		await setTimeout$1(forceKillAfterDelay, void 0, { signal: controllerSignal });
		if (kill("SIGKILL")) context$1.isForcefullyTerminated ??= true;
	} catch {}
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/utils/abort-signal.js
const onAbortedSignal = async (mainSignal, stopSignal) => {
	if (!mainSignal.aborted) await once(mainSignal, "abort", { signal: stopSignal });
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/terminate/cancel.js
const validateCancelSignal = ({ cancelSignal }) => {
	if (cancelSignal !== void 0 && Object.prototype.toString.call(cancelSignal) !== "[object AbortSignal]") throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
};
const throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context: context$1, controller }) => cancelSignal === void 0 || gracefulCancel ? [] : [terminateOnCancel(subprocess, cancelSignal, context$1, controller)];
const terminateOnCancel = async (subprocess, cancelSignal, context$1, { signal }) => {
	await onAbortedSignal(cancelSignal, signal);
	context$1.terminationReason ??= "cancel";
	subprocess.kill();
	throw cancelSignal.reason;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/validation.js
const validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected: isConnected$1 }) => {
	validateIpcOption(methodName, isSubprocess, ipc);
	validateConnection(methodName, isSubprocess, isConnected$1);
};
const validateIpcOption = (methodName, isSubprocess, ipc) => {
	if (!ipc) throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
};
const validateConnection = (methodName, isSubprocess, isConnected$1) => {
	if (!isConnected$1) throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
};
const throwOnEarlyDisconnect = (isSubprocess) => {
	throw new Error(`${getMethodName("getOneMessage", isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
};
const throwOnStrictDeadlockError = (isSubprocess) => {
	throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName("getOneMessage", isSubprocess)},
	${getMethodName("sendMessage", isSubprocess, "message, {strict: true}")},
]);`);
};
const getStrictResponseError = (error$1, isSubprocess) => new Error(`${getMethodName("sendMessage", isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, { cause: error$1 });
const throwOnMissingStrict = (isSubprocess) => {
	throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
};
const throwOnStrictDisconnect = (isSubprocess) => {
	throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
};
const getAbortDisconnectError = () => /* @__PURE__ */ new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);
const throwOnMissingParent = () => {
	throw new Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.");
};
const handleEpipeError = ({ error: error$1, methodName, isSubprocess }) => {
	if (error$1.code === "EPIPE") throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, { cause: error$1 });
};
const handleSerializationError = ({ error: error$1, methodName, isSubprocess, message }) => {
	if (isSerializationError(error$1)) throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, { cause: error$1 });
};
const isSerializationError = ({ code, message }) => SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage) => message.includes(serializationErrorMessage));
const SERIALIZATION_ERROR_CODES = new Set(["ERR_MISSING_ARGS", "ERR_INVALID_ARG_TYPE"]);
const SERIALIZATION_ERROR_MESSAGES = [
	"could not be cloned",
	"circular structure",
	"call stack size exceeded"
];
const getMethodName = (methodName, isSubprocess, parameters = "") => methodName === "cancelSignal" ? "`cancelSignal`'s `controller.abort()`" : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;
const getNamespaceName = (isSubprocess) => isSubprocess ? "" : "subprocess.";
const getOtherProcessName = (isSubprocess) => isSubprocess ? "parent process" : "subprocess";
const disconnect = (anyProcess) => {
	if (anyProcess.connected) anyProcess.disconnect();
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/utils/deferred.js
const createDeferred = () => {
	const methods = {};
	const promise = new Promise((resolve, reject) => {
		Object.assign(methods, {
			resolve,
			reject
		});
	});
	return Object.assign(promise, methods);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/fd-options.js
const getToStream = (destination, to = "stdin") => {
	const isWritable = true;
	const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
	const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
	const destinationStream = destination.stdio[fdNumber];
	if (destinationStream === null) throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
	return destinationStream;
};
const getFromStream = (source, from = "stdout") => {
	const isWritable = false;
	const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
	const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
	const sourceStream = fdNumber === "all" ? source.all : source.stdio[fdNumber];
	if (sourceStream === null || sourceStream === void 0) throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
	return sourceStream;
};
const SUBPROCESS_OPTIONS = /* @__PURE__ */ new WeakMap();
const getFdNumber = (fileDescriptors, fdName, isWritable) => {
	const fdNumber = parseFdNumber(fdName, isWritable);
	validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
	return fdNumber;
};
const parseFdNumber = (fdName, isWritable) => {
	const fdNumber = parseFd(fdName);
	if (fdNumber !== void 0) return fdNumber;
	const { validOptions, defaultValue } = isWritable ? {
		validOptions: "\"stdin\"",
		defaultValue: "stdin"
	} : {
		validOptions: "\"stdout\", \"stderr\", \"all\"",
		defaultValue: "stdout"
	};
	throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
};
const validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {
	const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
	if (fileDescriptor === void 0) throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
	if (fileDescriptor.direction === "input" && !isWritable) throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
	if (fileDescriptor.direction !== "input" && isWritable) throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
};
const getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {
	if (fdNumber === "all" && !options.all) return "The \"all\" option must be true to use \"from: 'all'\".";
	const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
	return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
};
const getInvalidStdioOption = (fdNumber, { stdin, stdout: stdout$1, stderr, stdio }) => {
	const usedDescriptor = getUsedDescriptor(fdNumber);
	if (usedDescriptor === 0 && stdin !== void 0) return {
		optionName: "stdin",
		optionValue: stdin
	};
	if (usedDescriptor === 1 && stdout$1 !== void 0) return {
		optionName: "stdout",
		optionValue: stdout$1
	};
	if (usedDescriptor === 2 && stderr !== void 0) return {
		optionName: "stderr",
		optionValue: stderr
	};
	return {
		optionName: `stdio[${usedDescriptor}]`,
		optionValue: stdio[usedDescriptor]
	};
};
const getUsedDescriptor = (fdNumber) => fdNumber === "all" ? 1 : fdNumber;
const getOptionName = (isWritable) => isWritable ? "to" : "from";
const serializeOptionValue = (value) => {
	if (typeof value === "string") return `'${value}'`;
	return typeof value === "number" ? `${value}` : "Stream";
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/utils/max-listeners.js
const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {
	const maxListeners = eventEmitter.getMaxListeners();
	if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) return;
	eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
	addAbortListener(signal, () => {
		eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/reference.js
const addReference = (channel$1, reference) => {
	if (reference) addReferenceCount(channel$1);
};
const addReferenceCount = (channel$1) => {
	channel$1.refCounted();
};
const removeReference = (channel$1, reference) => {
	if (reference) removeReferenceCount(channel$1);
};
const removeReferenceCount = (channel$1) => {
	channel$1.unrefCounted();
};
const undoAddedReferences = (channel$1, isSubprocess) => {
	if (isSubprocess) {
		removeReferenceCount(channel$1);
		removeReferenceCount(channel$1);
	}
};
const redoAddedReferences = (channel$1, isSubprocess) => {
	if (isSubprocess) {
		addReferenceCount(channel$1);
		addReferenceCount(channel$1);
	}
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/incoming.js
const onMessage = async ({ anyProcess, channel: channel$1, isSubprocess, ipcEmitter }, wrappedMessage) => {
	if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) return;
	if (!INCOMING_MESSAGES.has(anyProcess)) INCOMING_MESSAGES.set(anyProcess, []);
	const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
	incomingMessages.push(wrappedMessage);
	if (incomingMessages.length > 1) return;
	while (incomingMessages.length > 0) {
		await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
		await scheduler.yield();
		const message = await handleStrictRequest({
			wrappedMessage: incomingMessages[0],
			anyProcess,
			channel: channel$1,
			isSubprocess,
			ipcEmitter
		});
		incomingMessages.shift();
		ipcEmitter.emit("message", message);
		ipcEmitter.emit("message:done");
	}
};
const onDisconnect = async ({ anyProcess, channel: channel$1, isSubprocess, ipcEmitter, boundOnMessage }) => {
	abortOnDisconnect();
	const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
	while (incomingMessages?.length > 0) await once(ipcEmitter, "message:done");
	anyProcess.removeListener("message", boundOnMessage);
	redoAddedReferences(channel$1, isSubprocess);
	ipcEmitter.connected = false;
	ipcEmitter.emit("disconnect");
};
const INCOMING_MESSAGES = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/forward.js
const getIpcEmitter = (anyProcess, channel$1, isSubprocess) => {
	if (IPC_EMITTERS.has(anyProcess)) return IPC_EMITTERS.get(anyProcess);
	const ipcEmitter = new EventEmitter();
	ipcEmitter.connected = true;
	IPC_EMITTERS.set(anyProcess, ipcEmitter);
	forwardEvents({
		ipcEmitter,
		anyProcess,
		channel: channel$1,
		isSubprocess
	});
	return ipcEmitter;
};
const IPC_EMITTERS = /* @__PURE__ */ new WeakMap();
const forwardEvents = ({ ipcEmitter, anyProcess, channel: channel$1, isSubprocess }) => {
	const boundOnMessage = onMessage.bind(void 0, {
		anyProcess,
		channel: channel$1,
		isSubprocess,
		ipcEmitter
	});
	anyProcess.on("message", boundOnMessage);
	anyProcess.once("disconnect", onDisconnect.bind(void 0, {
		anyProcess,
		channel: channel$1,
		isSubprocess,
		ipcEmitter,
		boundOnMessage
	}));
	undoAddedReferences(channel$1, isSubprocess);
};
const isConnected = (anyProcess) => {
	const ipcEmitter = IPC_EMITTERS.get(anyProcess);
	return ipcEmitter === void 0 ? anyProcess.channel !== null : ipcEmitter.connected;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/strict.js
const handleSendStrict = ({ anyProcess, channel: channel$1, isSubprocess, message, strict }) => {
	if (!strict) return message;
	const ipcEmitter = getIpcEmitter(anyProcess, channel$1, isSubprocess);
	const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
	return {
		id: count++,
		type: REQUEST_TYPE,
		message,
		hasListeners
	};
};
let count = 0n;
const validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {
	if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) return;
	for (const { id } of outgoingMessages) if (id !== void 0) STRICT_RESPONSES[id].resolve({
		isDeadlock: true,
		hasListeners: false
	});
};
const handleStrictRequest = async ({ wrappedMessage, anyProcess, channel: channel$1, isSubprocess, ipcEmitter }) => {
	if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) return wrappedMessage;
	const { id, message } = wrappedMessage;
	const response = {
		id,
		type: RESPONSE_TYPE,
		message: hasMessageListeners(anyProcess, ipcEmitter)
	};
	try {
		await sendMessage$1({
			anyProcess,
			channel: channel$1,
			isSubprocess,
			ipc: true
		}, response);
	} catch (error$1) {
		ipcEmitter.emit("strict:error", error$1);
	}
	return message;
};
const handleStrictResponse = (wrappedMessage) => {
	if (wrappedMessage?.type !== RESPONSE_TYPE) return false;
	const { id, message: hasListeners } = wrappedMessage;
	STRICT_RESPONSES[id]?.resolve({
		isDeadlock: false,
		hasListeners
	});
	return true;
};
const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {
	if (wrappedMessage?.type !== REQUEST_TYPE) return;
	const deferred = createDeferred();
	STRICT_RESPONSES[wrappedMessage.id] = deferred;
	const controller = new AbortController();
	try {
		const { isDeadlock, hasListeners } = await Promise.race([deferred, throwOnDisconnect$1(anyProcess, isSubprocess, controller)]);
		if (isDeadlock) throwOnStrictDeadlockError(isSubprocess);
		if (!hasListeners) throwOnMissingStrict(isSubprocess);
	} finally {
		controller.abort();
		delete STRICT_RESPONSES[wrappedMessage.id];
	}
};
const STRICT_RESPONSES = {};
const throwOnDisconnect$1 = async (anyProcess, isSubprocess, { signal }) => {
	incrementMaxListeners(anyProcess, 1, signal);
	await once(anyProcess, "disconnect", { signal });
	throwOnStrictDisconnect(isSubprocess);
};
const REQUEST_TYPE = "execa:ipc:request";
const RESPONSE_TYPE = "execa:ipc:response";

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/outgoing.js
const startSendMessage = (anyProcess, wrappedMessage, strict) => {
	if (!OUTGOING_MESSAGES.has(anyProcess)) OUTGOING_MESSAGES.set(anyProcess, /* @__PURE__ */ new Set());
	const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
	const onMessageSent = createDeferred();
	const id = strict ? wrappedMessage.id : void 0;
	const outgoingMessage = {
		onMessageSent,
		id
	};
	outgoingMessages.add(outgoingMessage);
	return {
		outgoingMessages,
		outgoingMessage
	};
};
const endSendMessage = ({ outgoingMessages, outgoingMessage }) => {
	outgoingMessages.delete(outgoingMessage);
	outgoingMessage.onMessageSent.resolve();
};
const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {
	while (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {
		const outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];
		validateStrictDeadlock(outgoingMessages, wrappedMessage);
		await Promise.all(outgoingMessages.map(({ onMessageSent }) => onMessageSent));
	}
};
const OUTGOING_MESSAGES = /* @__PURE__ */ new WeakMap();
const hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount("message") > getMinListenerCount(anyProcess);
const getMinListenerCount = (anyProcess) => SUBPROCESS_OPTIONS.has(anyProcess) && !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, "ipc") ? 1 : 0;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/send.js
const sendMessage$1 = ({ anyProcess, channel: channel$1, isSubprocess, ipc }, message, { strict = false } = {}) => {
	const methodName = "sendMessage";
	validateIpcMethod({
		methodName,
		isSubprocess,
		ipc,
		isConnected: anyProcess.connected
	});
	return sendMessageAsync({
		anyProcess,
		channel: channel$1,
		methodName,
		isSubprocess,
		message,
		strict
	});
};
const sendMessageAsync = async ({ anyProcess, channel: channel$1, methodName, isSubprocess, message, strict }) => {
	const wrappedMessage = handleSendStrict({
		anyProcess,
		channel: channel$1,
		isSubprocess,
		message,
		strict
	});
	const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);
	try {
		await sendOneMessage({
			anyProcess,
			methodName,
			isSubprocess,
			wrappedMessage,
			message
		});
	} catch (error$1) {
		disconnect(anyProcess);
		throw error$1;
	} finally {
		endSendMessage(outgoingMessagesState);
	}
};
const sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message }) => {
	const sendMethod = getSendMethod(anyProcess);
	try {
		await Promise.all([waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess), sendMethod(wrappedMessage)]);
	} catch (error$1) {
		handleEpipeError({
			error: error$1,
			methodName,
			isSubprocess
		});
		handleSerializationError({
			error: error$1,
			methodName,
			isSubprocess,
			message
		});
		throw error$1;
	}
};
const getSendMethod = (anyProcess) => {
	if (PROCESS_SEND_METHODS.has(anyProcess)) return PROCESS_SEND_METHODS.get(anyProcess);
	const sendMethod = promisify(anyProcess.send.bind(anyProcess));
	PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
	return sendMethod;
};
const PROCESS_SEND_METHODS = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/graceful.js
const sendAbort = (subprocess, message) => {
	const methodName = "cancelSignal";
	validateConnection(methodName, false, subprocess.connected);
	return sendOneMessage({
		anyProcess: subprocess,
		methodName,
		isSubprocess: false,
		wrappedMessage: {
			type: GRACEFUL_CANCEL_TYPE,
			message
		},
		message
	});
};
const getCancelSignal$1 = async ({ anyProcess, channel: channel$1, isSubprocess, ipc }) => {
	await startIpc({
		anyProcess,
		channel: channel$1,
		isSubprocess,
		ipc
	});
	return cancelController.signal;
};
const startIpc = async ({ anyProcess, channel: channel$1, isSubprocess, ipc }) => {
	if (cancelListening) return;
	cancelListening = true;
	if (!ipc) {
		throwOnMissingParent();
		return;
	}
	if (channel$1 === null) {
		abortOnDisconnect();
		return;
	}
	getIpcEmitter(anyProcess, channel$1, isSubprocess);
	await scheduler.yield();
};
let cancelListening = false;
const handleAbort = (wrappedMessage) => {
	if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) return false;
	cancelController.abort(wrappedMessage.message);
	return true;
};
const GRACEFUL_CANCEL_TYPE = "execa:ipc:cancel";
const abortOnDisconnect = () => {
	cancelController.abort(getAbortDisconnectError());
};
const cancelController = new AbortController();

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/terminate/graceful.js
const validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization }) => {
	if (!gracefulCancel) return;
	if (cancelSignal === void 0) throw new Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");
	if (!ipc) throw new Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");
	if (serialization === "json") throw new Error("The `serialization` option cannot be 'json' when setting the `gracefulCancel` option.");
};
const throwOnGracefulCancel = ({ subprocess, cancelSignal, gracefulCancel, forceKillAfterDelay, context: context$1, controller }) => gracefulCancel ? [sendOnAbort({
	subprocess,
	cancelSignal,
	forceKillAfterDelay,
	context: context$1,
	controller
})] : [];
const sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context: context$1, controller: { signal } }) => {
	await onAbortedSignal(cancelSignal, signal);
	const reason = getReason(cancelSignal);
	await sendAbort(subprocess, reason);
	killOnTimeout({
		kill: subprocess.kill,
		forceKillAfterDelay,
		context: context$1,
		controllerSignal: signal
	});
	context$1.terminationReason ??= "gracefulCancel";
	throw cancelSignal.reason;
};
const getReason = ({ reason }) => {
	if (!(reason instanceof DOMException)) return reason;
	const error$1 = new Error(reason.message);
	Object.defineProperty(error$1, "stack", {
		value: reason.stack,
		enumerable: false,
		configurable: true,
		writable: true
	});
	return error$1;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/terminate/timeout.js
const validateTimeout = ({ timeout }) => {
	if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
};
const throwOnTimeout = (subprocess, timeout, context$1, controller) => timeout === 0 || timeout === void 0 ? [] : [killAfterTimeout(subprocess, timeout, context$1, controller)];
const killAfterTimeout = async (subprocess, timeout, context$1, { signal }) => {
	await setTimeout$1(timeout, void 0, { signal });
	context$1.terminationReason ??= "timeout";
	subprocess.kill();
	throw new DiscardedError();
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/node.js
const mapNode = ({ options }) => {
	if (options.node === false) throw new TypeError("The \"node\" option cannot be false with `execaNode()`.");
	return { options: {
		...options,
		node: true
	} };
};
const handleNodeOption = (file, commandArguments, { node: shouldHandleNode = false, nodePath = execPath, nodeOptions = execArgv.filter((nodeOption) => !nodeOption.startsWith("--inspect")), cwd, execPath: formerNodePath,...options }) => {
	if (formerNodePath !== void 0) throw new TypeError("The \"execPath\" option has been removed. Please use the \"nodePath\" option instead.");
	const normalizedNodePath = safeNormalizeFileUrl(nodePath, "The \"nodePath\" option");
	const resolvedNodePath = path.resolve(cwd, normalizedNodePath);
	const newOptions = {
		...options,
		nodePath: resolvedNodePath,
		node: shouldHandleNode,
		cwd
	};
	if (!shouldHandleNode) return [
		file,
		commandArguments,
		newOptions
	];
	if (path.basename(file, ".exe") === "node") throw new TypeError("When the \"node\" option is true, the first argument does not need to be \"node\".");
	return [
		resolvedNodePath,
		[
			...nodeOptions,
			file,
			...commandArguments
		],
		{
			ipc: true,
			...newOptions,
			shell: false
		}
	];
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/ipc-input.js
const validateIpcInputOption = ({ ipcInput, ipc, serialization }) => {
	if (ipcInput === void 0) return;
	if (!ipc) throw new Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");
	validateIpcInput[serialization](ipcInput);
};
const validateAdvancedInput = (ipcInput) => {
	try {
		serialize(ipcInput);
	} catch (error$1) {
		throw new Error("The `ipcInput` option is not serializable with a structured clone.", { cause: error$1 });
	}
};
const validateJsonInput = (ipcInput) => {
	try {
		JSON.stringify(ipcInput);
	} catch (error$1) {
		throw new Error("The `ipcInput` option is not serializable with JSON.", { cause: error$1 });
	}
};
const validateIpcInput = {
	advanced: validateAdvancedInput,
	json: validateJsonInput
};
const sendIpcInput = async (subprocess, ipcInput) => {
	if (ipcInput === void 0) return;
	await subprocess.sendMessage(ipcInput);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/encoding-option.js
const validateEncoding = ({ encoding }) => {
	if (ENCODINGS.has(encoding)) return;
	const correctEncoding = getCorrectEncoding(encoding);
	if (correctEncoding !== void 0) throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
	const correctEncodings = [...ENCODINGS].map((correctEncoding$1) => serializeEncoding(correctEncoding$1)).join(", ");
	throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
};
const TEXT_ENCODINGS = new Set(["utf8", "utf16le"]);
const BINARY_ENCODINGS = new Set([
	"buffer",
	"hex",
	"base64",
	"base64url",
	"latin1",
	"ascii"
]);
const ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);
const getCorrectEncoding = (encoding) => {
	if (encoding === null) return "buffer";
	if (typeof encoding !== "string") return;
	const lowerEncoding = encoding.toLowerCase();
	if (lowerEncoding in ENCODING_ALIASES) return ENCODING_ALIASES[lowerEncoding];
	if (ENCODINGS.has(lowerEncoding)) return lowerEncoding;
};
const ENCODING_ALIASES = {
	"utf-8": "utf8",
	"utf-16le": "utf16le",
	"ucs-2": "utf16le",
	ucs2: "utf16le",
	binary: "latin1"
};
const serializeEncoding = (encoding) => typeof encoding === "string" ? `"${encoding}"` : String(encoding);

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/cwd.js
const normalizeCwd = (cwd = getDefaultCwd()) => {
	const cwdString = safeNormalizeFileUrl(cwd, "The \"cwd\" option");
	return path.resolve(cwdString);
};
const getDefaultCwd = () => {
	try {
		return process$1.cwd();
	} catch (error$1) {
		error$1.message = `The current directory does not exist.\n${error$1.message}`;
		throw error$1;
	}
};
const fixCwdError = (originalMessage, cwd) => {
	if (cwd === getDefaultCwd()) return originalMessage;
	let cwdStat;
	try {
		cwdStat = statSync(cwd);
	} catch (error$1) {
		return `The "cwd" option is invalid: ${cwd}.\n${error$1.message}\n${originalMessage}`;
	}
	if (!cwdStat.isDirectory()) return `The "cwd" option is not a directory: ${cwd}.\n${originalMessage}`;
	return originalMessage;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/arguments/options.js
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
const normalizeOptions = (filePath, rawArguments, rawOptions) => {
	rawOptions.cwd = normalizeCwd(rawOptions.cwd);
	const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);
	const { command: file, args: commandArguments, options: initialOptions } = import_cross_spawn.default._parse(processedFile, processedArguments, processedOptions);
	const fdOptions = normalizeFdSpecificOptions(initialOptions);
	const options = addDefaultOptions(fdOptions);
	validateTimeout(options);
	validateEncoding(options);
	validateIpcInputOption(options);
	validateCancelSignal(options);
	validateGracefulCancel(options);
	options.shell = normalizeFileUrl(options.shell);
	options.env = getEnv(options);
	options.killSignal = normalizeKillSignal(options.killSignal);
	options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
	options.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);
	if (process$1.platform === "win32" && path.basename(file, ".exe") === "cmd") commandArguments.unshift("/q");
	return {
		file,
		commandArguments,
		options
	};
};
const addDefaultOptions = ({ extendEnv = true, preferLocal = false, cwd, localDir: localDirectory = cwd, encoding = "utf8", reject = true, cleanup = true, all = false, windowsHide = true, killSignal = "SIGTERM", forceKillAfterDelay = true, gracefulCancel = false, ipcInput, ipc = ipcInput !== void 0 || gracefulCancel, serialization = "advanced",...options }) => ({
	...options,
	extendEnv,
	preferLocal,
	cwd,
	localDirectory,
	encoding,
	reject,
	cleanup,
	all,
	windowsHide,
	killSignal,
	forceKillAfterDelay,
	gracefulCancel,
	ipcInput,
	ipc,
	serialization
});
const getEnv = ({ env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath }) => {
	const env = extendEnv ? {
		...process$1.env,
		...envOption
	} : envOption;
	if (preferLocal || node) return npmRunPathEnv({
		env,
		cwd: localDirectory,
		execPath: nodePath,
		preferLocal,
		addExecPath: node
	});
	return env;
};

//#endregion
//#region node_modules/.pnpm/strip-final-newline@4.0.0/node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
	if (typeof input === "string") return stripFinalNewlineString(input);
	if (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) throw new Error("Input must be a string or a Uint8Array");
	return stripFinalNewlineBinary(input);
}
const stripFinalNewlineString = (input) => input.at(-1) === LF ? input.slice(0, input.at(-2) === CR ? -2 : -1) : input;
const stripFinalNewlineBinary = (input) => input.at(-1) === LF_BINARY ? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1) : input;
const LF = "\n";
const LF_BINARY = LF.codePointAt(0);
const CR = "\r";
const CR_BINARY = CR.codePointAt(0);

//#endregion
//#region node_modules/.pnpm/is-stream@4.0.1/node_modules/is-stream/index.js
function isStream(stream$2, { checkOpen = true } = {}) {
	return stream$2 !== null && typeof stream$2 === "object" && (stream$2.writable || stream$2.readable || !checkOpen || stream$2.writable === void 0 && stream$2.readable === void 0) && typeof stream$2.pipe === "function";
}
function isWritableStream(stream$2, { checkOpen = true } = {}) {
	return isStream(stream$2, { checkOpen }) && (stream$2.writable || !checkOpen) && typeof stream$2.write === "function" && typeof stream$2.end === "function" && typeof stream$2.writable === "boolean" && typeof stream$2.writableObjectMode === "boolean" && typeof stream$2.destroy === "function" && typeof stream$2.destroyed === "boolean";
}
function isReadableStream(stream$2, { checkOpen = true } = {}) {
	return isStream(stream$2, { checkOpen }) && (stream$2.readable || !checkOpen) && typeof stream$2.read === "function" && typeof stream$2.readable === "boolean" && typeof stream$2.readableObjectMode === "boolean" && typeof stream$2.destroy === "function" && typeof stream$2.destroyed === "boolean";
}
function isDuplexStream(stream$2, options) {
	return isWritableStream(stream$2, options) && isReadableStream(stream$2, options);
}

//#endregion
//#region node_modules/.pnpm/@sec-ant+readable-stream@0.4.1/node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
const a = Object.getPrototypeOf(Object.getPrototypeOf(
	/* istanbul ignore next */
	async function* () {}
).prototype);
var c = class {
	#t;
	#n;
	#r = !1;
	#e = void 0;
	constructor(e, t) {
		this.#t = e, this.#n = t;
	}
	next() {
		const e = () => this.#s();
		return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
	}
	return(e) {
		const t = () => this.#i(e);
		return this.#e ? this.#e.then(t, t) : t();
	}
	async #s() {
		if (this.#r) return {
			done: !0,
			value: void 0
		};
		let e;
		try {
			e = await this.#t.read();
		} catch (t) {
			throw this.#e = void 0, this.#r = !0, this.#t.releaseLock(), t;
		}
		return e.done && (this.#e = void 0, this.#r = !0, this.#t.releaseLock()), e;
	}
	async #i(e) {
		if (this.#r) return {
			done: !0,
			value: e
		};
		if (this.#r = !0, !this.#n) {
			const t = this.#t.cancel(e);
			return this.#t.releaseLock(), await t, {
				done: !0,
				value: e
			};
		}
		return this.#t.releaseLock(), {
			done: !0,
			value: e
		};
	}
};
const n = Symbol();
function i() {
	return this[n].next();
}
Object.defineProperty(i, "name", { value: "next" });
function o(r) {
	return this[n].return(r);
}
Object.defineProperty(o, "name", { value: "return" });
const u = Object.create(a, {
	next: {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: i
	},
	return: {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: o
	}
});
function h({ preventCancel: r = !1 } = {}) {
	const e = this.getReader(), t = new c(e, r), s$1 = Object.create(u);
	return s$1[n] = t, s$1;
}

//#endregion
//#region node_modules/.pnpm/get-stream@9.0.1/node_modules/get-stream/source/stream.js
const getAsyncIterable = (stream$2) => {
	if (isReadableStream(stream$2, { checkOpen: false }) && nodeImports.on !== void 0) return getStreamIterable(stream$2);
	if (typeof stream$2?.[Symbol.asyncIterator] === "function") return stream$2;
	if (toString.call(stream$2) === "[object ReadableStream]") return h.call(stream$2);
	throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
};
const { toString } = Object.prototype;
const getStreamIterable = async function* (stream$2) {
	const controller = new AbortController();
	const state = {};
	handleStreamEnd(stream$2, controller, state);
	try {
		for await (const [chunk] of nodeImports.on(stream$2, "data", { signal: controller.signal })) yield chunk;
	} catch (error$1) {
		if (state.error !== void 0) throw state.error;
		else if (!controller.signal.aborted) throw error$1;
	} finally {
		stream$2.destroy();
	}
};
const handleStreamEnd = async (stream$2, controller, state) => {
	try {
		await nodeImports.finished(stream$2, {
			cleanup: true,
			readable: true,
			writable: false,
			error: false
		});
	} catch (error$1) {
		state.error = error$1;
	} finally {
		controller.abort();
	}
};
const nodeImports = {};

//#endregion
//#region node_modules/.pnpm/get-stream@9.0.1/node_modules/get-stream/source/contents.js
const getStreamContents$1 = async (stream$2, { init: init$1, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
	const asyncIterable = getAsyncIterable(stream$2);
	const state = init$1();
	state.length = 0;
	try {
		for await (const chunk of asyncIterable) {
			const chunkType = getChunkType(chunk);
			const convertedChunk = convertChunk[chunkType](chunk, state);
			appendChunk({
				convertedChunk,
				state,
				getSize,
				truncateChunk,
				addChunk,
				maxBuffer
			});
		}
		appendFinalChunk({
			state,
			convertChunk,
			getSize,
			truncateChunk,
			addChunk,
			getFinalChunk,
			maxBuffer
		});
		return finalize(state);
	} catch (error$1) {
		const normalizedError = typeof error$1 === "object" && error$1 !== null ? error$1 : new Error(error$1);
		normalizedError.bufferedData = finalize(state);
		throw normalizedError;
	}
};
const appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
	const convertedChunk = getFinalChunk(state);
	if (convertedChunk !== void 0) appendChunk({
		convertedChunk,
		state,
		getSize,
		truncateChunk,
		addChunk,
		maxBuffer
	});
};
const appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
	const chunkSize = getSize(convertedChunk);
	const newLength = state.length + chunkSize;
	if (newLength <= maxBuffer) {
		addNewChunk(convertedChunk, state, addChunk, newLength);
		return;
	}
	const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
	if (truncatedChunk !== void 0) addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
	throw new MaxBufferError();
};
const addNewChunk = (convertedChunk, state, addChunk, newLength) => {
	state.contents = addChunk(convertedChunk, state, newLength);
	state.length = newLength;
};
const getChunkType = (chunk) => {
	const typeOfChunk = typeof chunk;
	if (typeOfChunk === "string") return "string";
	if (typeOfChunk !== "object" || chunk === null) return "others";
	if (globalThis.Buffer?.isBuffer(chunk)) return "buffer";
	const prototypeName = objectToString.call(chunk);
	if (prototypeName === "[object ArrayBuffer]") return "arrayBuffer";
	if (prototypeName === "[object DataView]") return "dataView";
	if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString.call(chunk.buffer) === "[object ArrayBuffer]") return "typedArray";
	return "others";
};
const { toString: objectToString } = Object.prototype;
var MaxBufferError = class extends Error {
	name = "MaxBufferError";
	constructor() {
		super("maxBuffer exceeded");
	}
};

//#endregion
//#region node_modules/.pnpm/get-stream@9.0.1/node_modules/get-stream/source/utils.js
const identity = (value) => value;
const noop$1 = () => void 0;
const getContentsProperty = ({ contents }) => contents;
const throwObjectStream = (chunk) => {
	throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};
const getLengthProperty = (convertedChunk) => convertedChunk.length;

//#endregion
//#region node_modules/.pnpm/get-stream@9.0.1/node_modules/get-stream/source/array.js
async function getStreamAsArray(stream$2, options) {
	return getStreamContents$1(stream$2, arrayMethods, options);
}
const initArray = () => ({ contents: [] });
const increment = () => 1;
const addArrayChunk = (convertedChunk, { contents }) => {
	contents.push(convertedChunk);
	return contents;
};
const arrayMethods = {
	init: initArray,
	convertChunk: {
		string: identity,
		buffer: identity,
		arrayBuffer: identity,
		dataView: identity,
		typedArray: identity,
		others: identity
	},
	getSize: increment,
	truncateChunk: noop$1,
	addChunk: addArrayChunk,
	getFinalChunk: noop$1,
	finalize: getContentsProperty
};

//#endregion
//#region node_modules/.pnpm/get-stream@9.0.1/node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream$2, options) {
	return getStreamContents$1(stream$2, arrayBufferMethods, options);
}
const initArrayBuffer = () => ({ contents: /* @__PURE__ */ new ArrayBuffer(0) });
const useTextEncoder = (chunk) => textEncoder.encode(chunk);
const textEncoder = new TextEncoder();
const useUint8Array = (chunk) => new Uint8Array(chunk);
const useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
const truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
const addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
	const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
	new Uint8Array(newContents).set(convertedChunk, previousLength);
	return newContents;
};
const resizeArrayBufferSlow = (contents, length) => {
	if (length <= contents.byteLength) return contents;
	const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
	new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
	return arrayBuffer;
};
const resizeArrayBuffer = (contents, length) => {
	if (length <= contents.maxByteLength) {
		contents.resize(length);
		return contents;
	}
	const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
	new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
	return arrayBuffer;
};
const getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
const SCALE_FACTOR = 2;
const finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
const hasArrayBufferResize = () => "resize" in ArrayBuffer.prototype;
const arrayBufferMethods = {
	init: initArrayBuffer,
	convertChunk: {
		string: useTextEncoder,
		buffer: useUint8Array,
		arrayBuffer: useUint8Array,
		dataView: useUint8ArrayWithOffset,
		typedArray: useUint8ArrayWithOffset,
		others: throwObjectStream
	},
	getSize: getLengthProperty,
	truncateChunk: truncateArrayBufferChunk,
	addChunk: addArrayBufferChunk,
	getFinalChunk: noop$1,
	finalize: finalizeArrayBuffer
};

//#endregion
//#region node_modules/.pnpm/get-stream@9.0.1/node_modules/get-stream/source/string.js
async function getStreamAsString(stream$2, options) {
	return getStreamContents$1(stream$2, stringMethods, options);
}
const initString = () => ({
	contents: "",
	textDecoder: new TextDecoder()
});
const useTextDecoder = (chunk, { textDecoder: textDecoder$2 }) => textDecoder$2.decode(chunk, { stream: true });
const addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk;
const truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
const getFinalStringChunk = ({ textDecoder: textDecoder$2 }) => {
	const finalChunk = textDecoder$2.decode();
	return finalChunk === "" ? void 0 : finalChunk;
};
const stringMethods = {
	init: initString,
	convertChunk: {
		string: identity,
		buffer: useTextDecoder,
		arrayBuffer: useTextDecoder,
		dataView: useTextDecoder,
		typedArray: useTextDecoder,
		others: throwObjectStream
	},
	getSize: getLengthProperty,
	truncateChunk: truncateStringChunk,
	addChunk: addStringChunk,
	getFinalChunk: getFinalStringChunk,
	finalize: getContentsProperty
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/max-buffer.js
const handleMaxBuffer = ({ error: error$1, stream: stream$2, readableObjectMode, lines, encoding, fdNumber }) => {
	if (!(error$1 instanceof MaxBufferError)) throw error$1;
	if (fdNumber === "all") return error$1;
	const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
	error$1.maxBufferInfo = {
		fdNumber,
		unit
	};
	stream$2.destroy();
	throw error$1;
};
const getMaxBufferUnit = (readableObjectMode, lines, encoding) => {
	if (readableObjectMode) return "objects";
	if (lines) return "lines";
	if (encoding === "buffer") return "bytes";
	return "characters";
};
const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {
	if (ipcOutput.length !== maxBuffer) return;
	const error$1 = new MaxBufferError();
	error$1.maxBufferInfo = { fdNumber: "ipc" };
	throw error$1;
};
const getMaxBufferMessage = (error$1, maxBuffer) => {
	const { streamName, threshold, unit } = getMaxBufferInfo(error$1, maxBuffer);
	return `Command's ${streamName} was larger than ${threshold} ${unit}`;
};
const getMaxBufferInfo = (error$1, maxBuffer) => {
	if (error$1?.maxBufferInfo === void 0) return {
		streamName: "output",
		threshold: maxBuffer[1],
		unit: "bytes"
	};
	const { maxBufferInfo: { fdNumber, unit } } = error$1;
	delete error$1.maxBufferInfo;
	const threshold = getFdSpecificValue(maxBuffer, fdNumber);
	if (fdNumber === "ipc") return {
		streamName: "IPC output",
		threshold,
		unit: "messages"
	};
	return {
		streamName: getStreamName(fdNumber),
		threshold,
		unit
	};
};
const isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === "ENOBUFS" && output !== null && output.some((result) => result !== null && result.length > getMaxBufferSync(maxBuffer));
const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {
	if (!isMaxBuffer) return result;
	const maxBufferValue = getMaxBufferSync(maxBuffer);
	return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};
const getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/return/message.js
const createMessages = ({ stdio, all, ipcOutput, originalError, signal, signalDescription, exitCode, escapedCommand, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, forceKillAfterDelay, killSignal, maxBuffer, timeout, cwd }) => {
	const errorCode = originalError?.code;
	const prefix = getErrorPrefix({
		originalError,
		timedOut,
		timeout,
		isMaxBuffer,
		maxBuffer,
		errorCode,
		signal,
		signalDescription,
		exitCode,
		isCanceled,
		isGracefullyCanceled,
		isForcefullyTerminated,
		forceKillAfterDelay,
		killSignal
	});
	const originalMessage = getOriginalMessage(originalError, cwd);
	const suffix = originalMessage === void 0 ? "" : `\n${originalMessage}`;
	const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
	const messageStdio = all === void 0 ? [stdio[2], stdio[1]] : [all];
	const message = [
		shortMessage,
		...messageStdio,
		...stdio.slice(3),
		ipcOutput.map((ipcMessage) => serializeIpcMessage(ipcMessage)).join("\n")
	].map((messagePart) => escapeLines(stripFinalNewline(serializeMessagePart(messagePart)))).filter(Boolean).join("\n\n");
	return {
		originalMessage,
		shortMessage,
		message
	};
};
const getErrorPrefix = ({ originalError, timedOut, timeout, isMaxBuffer, maxBuffer, errorCode, signal, signalDescription, exitCode, isCanceled, isGracefullyCanceled, isForcefullyTerminated, forceKillAfterDelay, killSignal }) => {
	const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
	if (timedOut) return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
	if (isGracefullyCanceled) {
		if (signal === void 0) return `Command was gracefully canceled with exit code ${exitCode}`;
		return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal} (${signalDescription})`;
	}
	if (isCanceled) return `Command was canceled${forcefulSuffix}`;
	if (isMaxBuffer) return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
	if (errorCode !== void 0) return `Command failed with ${errorCode}${forcefulSuffix}`;
	if (isForcefullyTerminated) return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
	if (signal !== void 0) return `Command was killed with ${signal} (${signalDescription})`;
	if (exitCode !== void 0) return `Command failed with exit code ${exitCode}`;
	return "Command failed";
};
const getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : "";
const getOriginalMessage = (originalError, cwd) => {
	if (originalError instanceof DiscardedError) return;
	const originalMessage = isExecaError(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
	const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));
	return escapedOriginalMessage === "" ? void 0 : escapedOriginalMessage;
};
const serializeIpcMessage = (ipcMessage) => typeof ipcMessage === "string" ? ipcMessage : inspect$1(ipcMessage);
const serializeMessagePart = (messagePart) => Array.isArray(messagePart) ? messagePart.map((messageItem) => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join("\n") : serializeMessageItem(messagePart);
const serializeMessageItem = (messageItem) => {
	if (typeof messageItem === "string") return messageItem;
	if (isUint8Array(messageItem)) return uint8ArrayToString(messageItem);
	return "";
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/return/result.js
const makeSuccessResult = ({ command, escapedCommand, stdio, all, ipcOutput, options: { cwd }, startTime }) => omitUndefinedProperties({
	command,
	escapedCommand,
	cwd,
	durationMs: getDurationMs(startTime),
	failed: false,
	timedOut: false,
	isCanceled: false,
	isGracefullyCanceled: false,
	isTerminated: false,
	isMaxBuffer: false,
	isForcefullyTerminated: false,
	exitCode: 0,
	stdout: stdio[1],
	stderr: stdio[2],
	all,
	stdio,
	ipcOutput,
	pipedFrom: []
});
const makeEarlyError = ({ error: error$1, command, escapedCommand, fileDescriptors, options, startTime, isSync }) => makeError({
	error: error$1,
	command,
	escapedCommand,
	startTime,
	timedOut: false,
	isCanceled: false,
	isGracefullyCanceled: false,
	isMaxBuffer: false,
	isForcefullyTerminated: false,
	stdio: Array.from({ length: fileDescriptors.length }),
	ipcOutput: [],
	options,
	isSync
});
const makeError = ({ error: originalError, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode: rawExitCode, signal: rawSignal, stdio, all, ipcOutput, options: { timeoutDuration, timeout = timeoutDuration, forceKillAfterDelay, killSignal, cwd, maxBuffer }, isSync }) => {
	const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
	const { originalMessage, shortMessage, message } = createMessages({
		stdio,
		all,
		ipcOutput,
		originalError,
		signal,
		signalDescription,
		exitCode,
		escapedCommand,
		timedOut,
		isCanceled,
		isGracefullyCanceled,
		isMaxBuffer,
		isForcefullyTerminated,
		forceKillAfterDelay,
		killSignal,
		maxBuffer,
		timeout,
		cwd
	});
	const error$1 = getFinalError(originalError, message, isSync);
	Object.assign(error$1, getErrorProperties({
		error: error$1,
		command,
		escapedCommand,
		startTime,
		timedOut,
		isCanceled,
		isGracefullyCanceled,
		isMaxBuffer,
		isForcefullyTerminated,
		exitCode,
		signal,
		signalDescription,
		stdio,
		all,
		ipcOutput,
		cwd,
		originalMessage,
		shortMessage
	}));
	return error$1;
};
const getErrorProperties = ({ error: error$1, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode, signal, signalDescription, stdio, all, ipcOutput, cwd, originalMessage, shortMessage }) => omitUndefinedProperties({
	shortMessage,
	originalMessage,
	command,
	escapedCommand,
	cwd,
	durationMs: getDurationMs(startTime),
	failed: true,
	timedOut,
	isCanceled,
	isGracefullyCanceled,
	isTerminated: signal !== void 0,
	isMaxBuffer,
	isForcefullyTerminated,
	exitCode,
	signal,
	signalDescription,
	code: error$1.cause?.code,
	stdout: stdio[1],
	stderr: stdio[2],
	all,
	stdio,
	ipcOutput,
	pipedFrom: []
});
const omitUndefinedProperties = (result) => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== void 0));
const normalizeExitPayload = (rawExitCode, rawSignal) => {
	const exitCode = rawExitCode === null ? void 0 : rawExitCode;
	const signal = rawSignal === null ? void 0 : rawSignal;
	const signalDescription = signal === void 0 ? void 0 : getSignalDescription(rawSignal);
	return {
		exitCode,
		signal,
		signalDescription
	};
};

//#endregion
//#region node_modules/.pnpm/parse-ms@4.0.0/node_modules/parse-ms/index.js
const toZeroIfInfinity = (value) => Number.isFinite(value) ? value : 0;
function parseNumber(milliseconds) {
	return {
		days: Math.trunc(milliseconds / 864e5),
		hours: Math.trunc(milliseconds / 36e5 % 24),
		minutes: Math.trunc(milliseconds / 6e4 % 60),
		seconds: Math.trunc(milliseconds / 1e3 % 60),
		milliseconds: Math.trunc(milliseconds % 1e3),
		microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e3) % 1e3),
		nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1e3)
	};
}
function parseBigint(milliseconds) {
	return {
		days: milliseconds / 86400000n,
		hours: milliseconds / 3600000n % 24n,
		minutes: milliseconds / 60000n % 60n,
		seconds: milliseconds / 1000n % 60n,
		milliseconds: milliseconds % 1000n,
		microseconds: 0n,
		nanoseconds: 0n
	};
}
function parseMilliseconds(milliseconds) {
	switch (typeof milliseconds) {
		case "number": {
			if (Number.isFinite(milliseconds)) return parseNumber(milliseconds);
			break;
		}
		case "bigint": return parseBigint(milliseconds);
	}
	throw new TypeError("Expected a finite number or bigint");
}

//#endregion
//#region node_modules/.pnpm/pretty-ms@9.2.0/node_modules/pretty-ms/index.js
const isZero = (value) => value === 0 || value === 0n;
const pluralize = (word, count$1) => count$1 === 1 || count$1 === 1n ? word : `${word}s`;
const SECOND_ROUNDING_EPSILON = 1e-7;
const ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
function prettyMilliseconds(milliseconds, options) {
	const isBigInt = typeof milliseconds === "bigint";
	if (!isBigInt && !Number.isFinite(milliseconds)) throw new TypeError("Expected a finite number or bigint");
	options = { ...options };
	const sign$1 = milliseconds < 0 ? "-" : "";
	milliseconds = milliseconds < 0 ? -milliseconds : milliseconds;
	if (options.colonNotation) {
		options.compact = false;
		options.formatSubMilliseconds = false;
		options.separateMilliseconds = false;
		options.verbose = false;
	}
	if (options.compact) {
		options.unitCount = 1;
		options.secondsDecimalDigits = 0;
		options.millisecondsDecimalDigits = 0;
	}
	let result = [];
	const floorDecimals = (value, decimalDigits) => {
		const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
		const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
		return flooredValue.toFixed(decimalDigits);
	};
	const add = (value, long, short, valueString) => {
		if ((result.length === 0 || !options.colonNotation) && isZero(value) && !(options.colonNotation && short === "m")) return;
		valueString ??= String(value);
		if (options.colonNotation) {
			const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length;
			const minLength = result.length > 0 ? 2 : 1;
			valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
		} else valueString += options.verbose ? " " + pluralize(long, value) : short;
		result.push(valueString);
	};
	const parsed = parseMilliseconds(milliseconds);
	const days = BigInt(parsed.days);
	if (options.hideYearAndDays) add(BigInt(days) * 24n + BigInt(parsed.hours), "hour", "h");
	else {
		if (options.hideYear) add(days, "day", "d");
		else {
			add(days / 365n, "year", "y");
			add(days % 365n, "day", "d");
		}
		add(Number(parsed.hours), "hour", "h");
	}
	add(Number(parsed.minutes), "minute", "m");
	if (!options.hideSeconds) if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1e3) {
		const seconds = Number(parsed.seconds);
		const milliseconds$1 = Number(parsed.milliseconds);
		const microseconds = Number(parsed.microseconds);
		const nanoseconds = Number(parsed.nanoseconds);
		add(seconds, "second", "s");
		if (options.formatSubMilliseconds) {
			add(milliseconds$1, "millisecond", "ms");
			add(microseconds, "microsecond", "µs");
			add(nanoseconds, "nanosecond", "ns");
		} else {
			const millisecondsAndBelow = milliseconds$1 + microseconds / 1e3 + nanoseconds / 1e6;
			const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0;
			const roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
			const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
			add(Number.parseFloat(millisecondsString), "millisecond", "ms", millisecondsString);
		}
	} else {
		const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1e3 % 60;
		const secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1;
		const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
		const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
		add(Number.parseFloat(secondsString), "second", "s", secondsString);
	}
	if (result.length === 0) return sign$1 + "0" + (options.verbose ? " milliseconds" : "ms");
	const separator = options.colonNotation ? ":" : " ";
	if (typeof options.unitCount === "number") result = result.slice(0, Math.max(options.unitCount, 1));
	return sign$1 + result.join(separator);
}

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/error.js
const logError = (result, verboseInfo) => {
	if (result.failed) verboseLog({
		type: "error",
		verboseMessage: result.shortMessage,
		verboseInfo,
		result
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/complete.js
const logResult = (result, verboseInfo) => {
	if (!isVerbose(verboseInfo)) return;
	logError(result, verboseInfo);
	logDuration(result, verboseInfo);
};
const logDuration = (result, verboseInfo) => {
	const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
	verboseLog({
		type: "duration",
		verboseMessage,
		verboseInfo,
		result
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/return/reject.js
const handleResult = (result, verboseInfo, { reject }) => {
	logResult(result, verboseInfo);
	if (result.failed && reject) throw result;
	return result;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/type.js
const getStdioItemType = (value, optionName) => {
	if (isAsyncGenerator(value)) return "asyncGenerator";
	if (isSyncGenerator(value)) return "generator";
	if (isUrl(value)) return "fileUrl";
	if (isFilePathObject(value)) return "filePath";
	if (isWebStream(value)) return "webStream";
	if (isStream(value, { checkOpen: false })) return "native";
	if (isUint8Array(value)) return "uint8Array";
	if (isAsyncIterableObject(value)) return "asyncIterable";
	if (isIterableObject(value)) return "iterable";
	if (isTransformStream(value)) return getTransformStreamType({ transform: value }, optionName);
	if (isTransformOptions(value)) return getTransformObjectType(value, optionName);
	return "native";
};
const getTransformObjectType = (value, optionName) => {
	if (isDuplexStream(value.transform, { checkOpen: false })) return getDuplexType(value, optionName);
	if (isTransformStream(value.transform)) return getTransformStreamType(value, optionName);
	return getGeneratorObjectType(value, optionName);
};
const getDuplexType = (value, optionName) => {
	validateNonGeneratorType(value, optionName, "Duplex stream");
	return "duplex";
};
const getTransformStreamType = (value, optionName) => {
	validateNonGeneratorType(value, optionName, "web TransformStream");
	return "webTransform";
};
const validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName) => {
	checkUndefinedOption(final, `${optionName}.final`, typeName);
	checkUndefinedOption(binary, `${optionName}.binary`, typeName);
	checkBooleanOption(objectMode, `${optionName}.objectMode`);
};
const checkUndefinedOption = (value, optionName, typeName) => {
	if (value !== void 0) throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
};
const getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName) => {
	if (transform !== void 0 && !isGenerator(transform)) throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
	if (isDuplexStream(final, { checkOpen: false })) throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
	if (isTransformStream(final)) throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
	if (final !== void 0 && !isGenerator(final)) throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
	checkBooleanOption(binary, `${optionName}.binary`);
	checkBooleanOption(objectMode, `${optionName}.objectMode`);
	return isAsyncGenerator(transform) || isAsyncGenerator(final) ? "asyncGenerator" : "generator";
};
const checkBooleanOption = (value, optionName) => {
	if (value !== void 0 && typeof value !== "boolean") throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
};
const isGenerator = (value) => isAsyncGenerator(value) || isSyncGenerator(value);
const isAsyncGenerator = (value) => Object.prototype.toString.call(value) === "[object AsyncGeneratorFunction]";
const isSyncGenerator = (value) => Object.prototype.toString.call(value) === "[object GeneratorFunction]";
const isTransformOptions = (value) => isPlainObject(value) && (value.transform !== void 0 || value.final !== void 0);
const isUrl = (value) => Object.prototype.toString.call(value) === "[object URL]";
const isRegularUrl = (value) => isUrl(value) && value.protocol !== "file:";
const isFilePathObject = (value) => isPlainObject(value) && Object.keys(value).length === 1 && isFilePathString(value.file);
const isFilePathString = (file) => typeof file === "string";
const isUnknownStdioString = (type, value) => type === "native" && typeof value === "string" && !KNOWN_STDIO_STRINGS.has(value);
const KNOWN_STDIO_STRINGS = new Set([
	"ipc",
	"ignore",
	"inherit",
	"overlapped",
	"pipe"
]);
const isReadableStream$1 = (value) => Object.prototype.toString.call(value) === "[object ReadableStream]";
const isWritableStream$1 = (value) => Object.prototype.toString.call(value) === "[object WritableStream]";
const isWebStream = (value) => isReadableStream$1(value) || isWritableStream$1(value);
const isTransformStream = (value) => isReadableStream$1(value?.readable) && isWritableStream$1(value?.writable);
const isAsyncIterableObject = (value) => isObject(value) && typeof value[Symbol.asyncIterator] === "function";
const isIterableObject = (value) => isObject(value) && typeof value[Symbol.iterator] === "function";
const isObject = (value) => typeof value === "object" && value !== null;
const TRANSFORM_TYPES = new Set([
	"generator",
	"asyncGenerator",
	"duplex",
	"webTransform"
]);
const FILE_TYPES = new Set([
	"fileUrl",
	"filePath",
	"fileNumber"
]);
const SPECIAL_DUPLICATE_TYPES_SYNC = new Set(["fileUrl", "filePath"]);
const SPECIAL_DUPLICATE_TYPES = new Set([
	...SPECIAL_DUPLICATE_TYPES_SYNC,
	"webStream",
	"nodeStream"
]);
const FORBID_DUPLICATE_TYPES = new Set(["webTransform", "duplex"]);
const TYPE_TO_MESSAGE = {
	generator: "a generator",
	asyncGenerator: "an async generator",
	fileUrl: "a file URL",
	filePath: "a file path string",
	fileNumber: "a file descriptor number",
	webStream: "a web stream",
	nodeStream: "a Node.js stream",
	webTransform: "a web TransformStream",
	duplex: "a Duplex stream",
	native: "any value",
	iterable: "an iterable",
	asyncIterable: "an async iterable",
	string: "a string",
	uint8Array: "a Uint8Array"
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/object-mode.js
const getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === "output" ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
const getOutputObjectModes = (objectMode, index, newTransforms) => {
	const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
	const readableObjectMode = objectMode ?? writableObjectMode;
	return {
		writableObjectMode,
		readableObjectMode
	};
};
const getInputObjectModes = (objectMode, index, newTransforms) => {
	const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
	const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
	return {
		writableObjectMode,
		readableObjectMode
	};
};
const getFdObjectMode = (stdioItems, direction) => {
	const lastTransform = stdioItems.findLast(({ type }) => TRANSFORM_TYPES.has(type));
	if (lastTransform === void 0) return false;
	return direction === "input" ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/normalize.js
const normalizeTransforms = (stdioItems, optionName, direction, options) => [...stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type)), ...getTransforms(stdioItems, optionName, direction, options)];
const getTransforms = (stdioItems, optionName, direction, { encoding }) => {
	const transforms = stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type));
	const newTransforms = Array.from({ length: transforms.length });
	for (const [index, stdioItem] of Object.entries(transforms)) newTransforms[index] = normalizeTransform({
		stdioItem,
		index: Number(index),
		newTransforms,
		optionName,
		direction,
		encoding
	});
	return sortTransforms(newTransforms, direction);
};
const normalizeTransform = ({ stdioItem, stdioItem: { type }, index, newTransforms, optionName, direction, encoding }) => {
	if (type === "duplex") return normalizeDuplex({
		stdioItem,
		optionName
	});
	if (type === "webTransform") return normalizeTransformStream({
		stdioItem,
		index,
		newTransforms,
		direction
	});
	return normalizeGenerator({
		stdioItem,
		index,
		newTransforms,
		direction,
		encoding
	});
};
const normalizeDuplex = ({ stdioItem, stdioItem: { value: { transform, transform: { writableObjectMode, readableObjectMode }, objectMode = readableObjectMode } }, optionName }) => {
	if (objectMode && !readableObjectMode) throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
	if (!objectMode && readableObjectMode) throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
	return {
		...stdioItem,
		value: {
			transform,
			writableObjectMode,
			readableObjectMode
		}
	};
};
const normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction }) => {
	const { transform, objectMode } = isPlainObject(value) ? value : { transform: value };
	const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
	return {
		...stdioItem,
		value: {
			transform,
			writableObjectMode,
			readableObjectMode
		}
	};
};
const normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding }) => {
	const { transform, final, binary: binaryOption = false, preserveNewlines = false, objectMode } = isPlainObject(value) ? value : { transform: value };
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
	return {
		...stdioItem,
		value: {
			transform,
			final,
			binary,
			preserveNewlines,
			writableObjectMode,
			readableObjectMode
		}
	};
};
const sortTransforms = (newTransforms, direction) => direction === "input" ? newTransforms.reverse() : newTransforms;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/direction.js
const getStreamDirection = (stdioItems, fdNumber, optionName) => {
	const directions = stdioItems.map((stdioItem) => getStdioItemDirection(stdioItem, fdNumber));
	if (directions.includes("input") && directions.includes("output")) throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
	return directions.find(Boolean) ?? DEFAULT_DIRECTION;
};
const getStdioItemDirection = ({ type, value }, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);
const KNOWN_DIRECTIONS = [
	"input",
	"output",
	"output"
];
const anyDirection = () => void 0;
const alwaysInput = () => "input";
const guessStreamDirection = {
	generator: anyDirection,
	asyncGenerator: anyDirection,
	fileUrl: anyDirection,
	filePath: anyDirection,
	iterable: alwaysInput,
	asyncIterable: alwaysInput,
	uint8Array: alwaysInput,
	webStream: (value) => isWritableStream$1(value) ? "output" : "input",
	nodeStream(value) {
		if (!isReadableStream(value, { checkOpen: false })) return "output";
		return isWritableStream(value, { checkOpen: false }) ? void 0 : "input";
	},
	webTransform: anyDirection,
	duplex: anyDirection,
	native(value) {
		const standardStreamDirection = getStandardStreamDirection(value);
		if (standardStreamDirection !== void 0) return standardStreamDirection;
		if (isStream(value, { checkOpen: false })) return guessStreamDirection.nodeStream(value);
	}
};
const getStandardStreamDirection = (value) => {
	if ([0, process$1.stdin].includes(value)) return "input";
	if ([
		1,
		2,
		process$1.stdout,
		process$1.stderr
	].includes(value)) return "output";
};
const DEFAULT_DIRECTION = "output";

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/array.js
const normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes("ipc") ? [...stdioArray, "ipc"] : stdioArray;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/stdio-option.js
const normalizeStdioOption = ({ stdio, ipc, buffer,...options }, verboseInfo, isSync) => {
	const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue(stdioOption, fdNumber));
	return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : normalizeIpcStdioArray(stdioArray, ipc);
};
const getStdioArray = (stdio, options) => {
	if (stdio === void 0) return STANDARD_STREAMS_ALIASES.map((alias) => options[alias]);
	if (hasAlias(options)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map((alias) => `\`${alias}\``).join(", ")}`);
	if (typeof stdio === "string") return [
		stdio,
		stdio,
		stdio
	];
	if (!Array.isArray(stdio)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
	const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
	return Array.from({ length }, (_, fdNumber) => stdio[fdNumber]);
};
const hasAlias = (options) => STANDARD_STREAMS_ALIASES.some((alias) => options[alias] !== void 0);
const addDefaultValue = (stdioOption, fdNumber) => {
	if (Array.isArray(stdioOption)) return stdioOption.map((item) => addDefaultValue(item, fdNumber));
	if (stdioOption === null || stdioOption === void 0) return fdNumber >= STANDARD_STREAMS_ALIASES.length ? "ignore" : "pipe";
	return stdioOption;
};
const normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) => !buffer[fdNumber] && fdNumber !== 0 && !isFullVerbose(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? "ignore" : stdioOption);
const isOutputPipeOnly = (stdioOption) => stdioOption === "pipe" || Array.isArray(stdioOption) && stdioOption.every((item) => item === "pipe");

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/native.js
const handleNativeStream = ({ stdioItem, stdioItem: { type }, isStdioArray, fdNumber, direction, isSync }) => {
	if (!isStdioArray || type !== "native") return stdioItem;
	return isSync ? handleNativeStreamSync({
		stdioItem,
		fdNumber,
		direction
	}) : handleNativeStreamAsync({
		stdioItem,
		fdNumber
	});
};
const handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction }) => {
	const targetFd = getTargetFd({
		value,
		optionName,
		fdNumber,
		direction
	});
	if (targetFd !== void 0) return targetFd;
	if (isStream(value, { checkOpen: false })) throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
	return stdioItem;
};
const getTargetFd = ({ value, optionName, fdNumber, direction }) => {
	const targetFdNumber = getTargetFdNumber(value, fdNumber);
	if (targetFdNumber === void 0) return;
	if (direction === "output") return {
		type: "fileNumber",
		value: targetFdNumber,
		optionName
	};
	if (tty.isatty(targetFdNumber)) throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
	return {
		type: "uint8Array",
		value: bufferToUint8Array(readFileSync(targetFdNumber)),
		optionName
	};
};
const getTargetFdNumber = (value, fdNumber) => {
	if (value === "inherit") return fdNumber;
	if (typeof value === "number") return value;
	const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
	if (standardStreamIndex !== -1) return standardStreamIndex;
};
const handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber }) => {
	if (value === "inherit") return {
		type: "nodeStream",
		value: getStandardStream(fdNumber, value, optionName),
		optionName
	};
	if (typeof value === "number") return {
		type: "nodeStream",
		value: getStandardStream(value, value, optionName),
		optionName
	};
	if (isStream(value, { checkOpen: false })) return {
		type: "nodeStream",
		value,
		optionName
	};
	return stdioItem;
};
const getStandardStream = (fdNumber, value, optionName) => {
	const standardStream = STANDARD_STREAMS[fdNumber];
	if (standardStream === void 0) throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
	return standardStream;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/input-option.js
const handleInputOptions = ({ input, inputFile }, fdNumber) => fdNumber === 0 ? [...handleInputOption(input), ...handleInputFileOption(inputFile)] : [];
const handleInputOption = (input) => input === void 0 ? [] : [{
	type: getInputType(input),
	value: input,
	optionName: "input"
}];
const getInputType = (input) => {
	if (isReadableStream(input, { checkOpen: false })) return "nodeStream";
	if (typeof input === "string") return "string";
	if (isUint8Array(input)) return "uint8Array";
	throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.");
};
const handleInputFileOption = (inputFile) => inputFile === void 0 ? [] : [{
	...getInputFileType(inputFile),
	optionName: "inputFile"
}];
const getInputFileType = (inputFile) => {
	if (isUrl(inputFile)) return {
		type: "fileUrl",
		value: inputFile
	};
	if (isFilePathString(inputFile)) return {
		type: "filePath",
		value: { file: inputFile }
	};
	throw new Error("The `inputFile` option must be a file path string or a file URL.");
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/duplicate.js
const filterDuplicates = (stdioItems) => stdioItems.filter((stdioItemOne, indexOne) => stdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === "generator" || stdioItemOne.type === "asyncGenerator"));
const getDuplicateStream = ({ stdioItem: { type, value, optionName }, direction, fileDescriptors, isSync }) => {
	const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
	if (otherStdioItems.length === 0) return;
	if (isSync) {
		validateDuplicateStreamSync({
			otherStdioItems,
			type,
			value,
			optionName,
			direction
		});
		return;
	}
	if (SPECIAL_DUPLICATE_TYPES.has(type)) return getDuplicateStreamInstance({
		otherStdioItems,
		type,
		value,
		optionName,
		direction
	});
	if (FORBID_DUPLICATE_TYPES.has(type)) validateDuplicateTransform({
		otherStdioItems,
		type,
		value,
		optionName
	});
};
const getOtherStdioItems = (fileDescriptors, type) => fileDescriptors.flatMap(({ direction, stdioItems }) => stdioItems.filter((stdioItem) => stdioItem.type === type).map((stdioItem) => ({
	...stdioItem,
	direction
})));
const validateDuplicateStreamSync = ({ otherStdioItems, type, value, optionName, direction }) => {
	if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) getDuplicateStreamInstance({
		otherStdioItems,
		type,
		value,
		optionName,
		direction
	});
};
const getDuplicateStreamInstance = ({ otherStdioItems, type, value, optionName, direction }) => {
	const duplicateStdioItems = otherStdioItems.filter((stdioItem) => hasSameValue(stdioItem, value));
	if (duplicateStdioItems.length === 0) return;
	const differentStdioItem = duplicateStdioItems.find((stdioItem) => stdioItem.direction !== direction);
	throwOnDuplicateStream(differentStdioItem, optionName, type);
	return direction === "output" ? duplicateStdioItems[0].stream : void 0;
};
const hasSameValue = ({ type, value }, secondValue) => {
	if (type === "filePath") return value.file === secondValue.file;
	if (type === "fileUrl") return value.href === secondValue.href;
	return value === secondValue;
};
const validateDuplicateTransform = ({ otherStdioItems, type, value, optionName }) => {
	const duplicateStdioItem = otherStdioItems.find(({ value: { transform } }) => transform === value.transform);
	throwOnDuplicateStream(duplicateStdioItem, optionName, type);
};
const throwOnDuplicateStream = (stdioItem, optionName, type) => {
	if (stdioItem !== void 0) throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/handle.js
const handleStdio = (addProperties$2, options, verboseInfo, isSync) => {
	const stdio = normalizeStdioOption(options, verboseInfo, isSync);
	const initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({
		stdioOption,
		fdNumber,
		options,
		isSync
	}));
	const fileDescriptors = getFinalFileDescriptors({
		initialFileDescriptors,
		addProperties: addProperties$2,
		options,
		isSync
	});
	options.stdio = fileDescriptors.map(({ stdioItems }) => forwardStdio(stdioItems));
	return fileDescriptors;
};
const getFileDescriptor = ({ stdioOption, fdNumber, options, isSync }) => {
	const optionName = getStreamName(fdNumber);
	const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
		stdioOption,
		fdNumber,
		options,
		optionName
	});
	const direction = getStreamDirection(initialStdioItems, fdNumber, optionName);
	const stdioItems = initialStdioItems.map((stdioItem) => handleNativeStream({
		stdioItem,
		isStdioArray,
		fdNumber,
		direction,
		isSync
	}));
	const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);
	const objectMode = getFdObjectMode(normalizedStdioItems, direction);
	validateFileObjectMode(normalizedStdioItems, objectMode);
	return {
		direction,
		objectMode,
		stdioItems: normalizedStdioItems
	};
};
const initializeStdioItems = ({ stdioOption, fdNumber, options, optionName }) => {
	const values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];
	const initialStdioItems = [...values.map((value) => initializeStdioItem(value, optionName)), ...handleInputOptions(options, fdNumber)];
	const stdioItems = filterDuplicates(initialStdioItems);
	const isStdioArray = stdioItems.length > 1;
	validateStdioArray(stdioItems, isStdioArray, optionName);
	validateStreams(stdioItems);
	return {
		stdioItems,
		isStdioArray
	};
};
const initializeStdioItem = (value, optionName) => ({
	type: getStdioItemType(value, optionName),
	value,
	optionName
});
const validateStdioArray = (stdioItems, isStdioArray, optionName) => {
	if (stdioItems.length === 0) throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
	if (!isStdioArray) return;
	for (const { value, optionName: optionName$1 } of stdioItems) if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) throw new Error(`The \`${optionName$1}\` option must not include \`${value}\`.`);
};
const INVALID_STDIO_ARRAY_OPTIONS = new Set(["ignore", "ipc"]);
const validateStreams = (stdioItems) => {
	for (const stdioItem of stdioItems) validateFileStdio(stdioItem);
};
const validateFileStdio = ({ type, value, optionName }) => {
	if (isRegularUrl(value)) throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
	if (isUnknownStdioString(type, value)) throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
};
const validateFileObjectMode = (stdioItems, objectMode) => {
	if (!objectMode) return;
	const fileStdioItem = stdioItems.find(({ type }) => FILE_TYPES.has(type));
	if (fileStdioItem !== void 0) throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
};
const getFinalFileDescriptors = ({ initialFileDescriptors, addProperties: addProperties$2, options, isSync }) => {
	const fileDescriptors = [];
	try {
		for (const fileDescriptor of initialFileDescriptors) fileDescriptors.push(getFinalFileDescriptor({
			fileDescriptor,
			fileDescriptors,
			addProperties: addProperties$2,
			options,
			isSync
		}));
		return fileDescriptors;
	} catch (error$1) {
		cleanupCustomStreams(fileDescriptors);
		throw error$1;
	}
};
const getFinalFileDescriptor = ({ fileDescriptor: { direction, objectMode, stdioItems }, fileDescriptors, addProperties: addProperties$2, options, isSync }) => {
	const finalStdioItems = stdioItems.map((stdioItem) => addStreamProperties({
		stdioItem,
		addProperties: addProperties$2,
		direction,
		options,
		fileDescriptors,
		isSync
	}));
	return {
		direction,
		objectMode,
		stdioItems: finalStdioItems
	};
};
const addStreamProperties = ({ stdioItem, addProperties: addProperties$2, direction, options, fileDescriptors, isSync }) => {
	const duplicateStream = getDuplicateStream({
		stdioItem,
		direction,
		fileDescriptors,
		isSync
	});
	if (duplicateStream !== void 0) return {
		...stdioItem,
		stream: duplicateStream
	};
	return {
		...stdioItem,
		...addProperties$2[direction][stdioItem.type](stdioItem, options)
	};
};
const cleanupCustomStreams = (fileDescriptors) => {
	for (const { stdioItems } of fileDescriptors) for (const { stream: stream$2 } of stdioItems) if (stream$2 !== void 0 && !isStandardStream(stream$2)) stream$2.destroy();
};
const forwardStdio = (stdioItems) => {
	if (stdioItems.length > 1) return stdioItems.some(({ value: value$1 }) => value$1 === "overlapped") ? "overlapped" : "pipe";
	const [{ type, value }] = stdioItems;
	return type === "native" ? value : "pipe";
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/handle-sync.js
const handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);
const forbiddenIfSync = ({ type, optionName }) => {
	throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);
};
const forbiddenNativeIfSync = ({ optionName, value }) => {
	if (value === "ipc" || value === "overlapped") throwInvalidSyncValue(optionName, `"${value}"`);
	return {};
};
const throwInvalidSyncValue = (optionName, value) => {
	throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
};
const addProperties$1 = {
	generator() {},
	asyncGenerator: forbiddenIfSync,
	webStream: forbiddenIfSync,
	nodeStream: forbiddenIfSync,
	webTransform: forbiddenIfSync,
	duplex: forbiddenIfSync,
	asyncIterable: forbiddenIfSync,
	native: forbiddenNativeIfSync
};
const addPropertiesSync = {
	input: {
		...addProperties$1,
		fileUrl: ({ value }) => ({ contents: [bufferToUint8Array(readFileSync(value))] }),
		filePath: ({ value: { file } }) => ({ contents: [bufferToUint8Array(readFileSync(file))] }),
		fileNumber: forbiddenIfSync,
		iterable: ({ value }) => ({ contents: [...value] }),
		string: ({ value }) => ({ contents: [value] }),
		uint8Array: ({ value }) => ({ contents: [value] })
	},
	output: {
		...addProperties$1,
		fileUrl: ({ value }) => ({ path: value }),
		filePath: ({ value: { file } }) => ({ path: file }),
		fileNumber: ({ value }) => ({ path: value }),
		iterable: forbiddenIfSync,
		string: forbiddenIfSync,
		uint8Array: forbiddenIfSync
	}
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/strip-newline.js
const stripNewline = (value, { stripFinalNewline: stripFinalNewline$1 }, fdNumber) => getStripFinalNewline(stripFinalNewline$1, fdNumber) && value !== void 0 && !Array.isArray(value) ? stripFinalNewline(value) : value;
const getStripFinalNewline = (stripFinalNewline$1, fdNumber) => fdNumber === "all" ? stripFinalNewline$1[1] || stripFinalNewline$1[2] : stripFinalNewline$1[fdNumber];

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/split.js
const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped ? void 0 : initializeSplitLines(preserveNewlines, state);
const splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode ? chunk.flatMap((item) => splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
const splitLinesItemSync = (chunk, preserveNewlines) => {
	const { transform, final } = initializeSplitLines(preserveNewlines, {});
	return [...transform(chunk), ...final()];
};
const initializeSplitLines = (preserveNewlines, state) => {
	state.previousChunks = "";
	return {
		transform: splitGenerator.bind(void 0, state, preserveNewlines),
		final: linesFinal.bind(void 0, state)
	};
};
const splitGenerator = function* (state, preserveNewlines, chunk) {
	if (typeof chunk !== "string") {
		yield chunk;
		return;
	}
	let { previousChunks } = state;
	let start = -1;
	for (let end = 0; end < chunk.length; end += 1) if (chunk[end] === "\n") {
		const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
		let line = chunk.slice(start + 1, end + 1 - newlineLength);
		if (previousChunks.length > 0) {
			line = concatString(previousChunks, line);
			previousChunks = "";
		}
		yield line;
		start = end;
	}
	if (start !== chunk.length - 1) previousChunks = concatString(previousChunks, chunk.slice(start + 1));
	state.previousChunks = previousChunks;
};
const getNewlineLength = (chunk, end, preserveNewlines, state) => {
	if (preserveNewlines) return 0;
	state.isWindowsNewline = end !== 0 && chunk[end - 1] === "\r";
	return state.isWindowsNewline ? 2 : 1;
};
const linesFinal = function* ({ previousChunks }) {
	if (previousChunks.length > 0) yield previousChunks;
};
const getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state }) => binary || preserveNewlines || readableObjectMode ? void 0 : { transform: appendNewlineGenerator.bind(void 0, state) };
const appendNewlineGenerator = function* ({ isWindowsNewline = false }, chunk) {
	const { unixNewline, windowsNewline, LF: LF$1, concatBytes } = typeof chunk === "string" ? linesStringInfo : linesUint8ArrayInfo;
	if (chunk.at(-1) === LF$1) {
		yield chunk;
		return;
	}
	const newline = isWindowsNewline ? windowsNewline : unixNewline;
	yield concatBytes(chunk, newline);
};
const concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;
const linesStringInfo = {
	windowsNewline: "\r\n",
	unixNewline: "\n",
	LF: "\n",
	concatBytes: concatString
};
const concatUint8Array = (firstChunk, secondChunk) => {
	const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
	chunk.set(firstChunk, 0);
	chunk.set(secondChunk, firstChunk.length);
	return chunk;
};
const linesUint8ArrayInfo = {
	windowsNewline: new Uint8Array([13, 10]),
	unixNewline: new Uint8Array([10]),
	LF: 10,
	concatBytes: concatUint8Array
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/validate.js
const getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode ? void 0 : validateStringTransformInput.bind(void 0, optionName);
const validateStringTransformInput = function* (optionName, chunk) {
	if (typeof chunk !== "string" && !isUint8Array(chunk) && !Buffer$1.isBuffer(chunk)) throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
	yield chunk;
};
const getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode ? validateObjectTransformReturn.bind(void 0, optionName) : validateStringTransformReturn.bind(void 0, optionName);
const validateObjectTransformReturn = function* (optionName, chunk) {
	validateEmptyReturn(optionName, chunk);
	yield chunk;
};
const validateStringTransformReturn = function* (optionName, chunk) {
	validateEmptyReturn(optionName, chunk);
	if (typeof chunk !== "string" && !isUint8Array(chunk)) throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
	yield chunk;
};
const validateEmptyReturn = (optionName, chunk) => {
	if (chunk === null || chunk === void 0) throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/encoding-transform.js
const getEncodingTransformGenerator = (binary, encoding, skipped) => {
	if (skipped) return;
	if (binary) return { transform: encodingUint8ArrayGenerator.bind(void 0, new TextEncoder()) };
	const stringDecoder = new StringDecoder(encoding);
	return {
		transform: encodingStringGenerator.bind(void 0, stringDecoder),
		final: encodingStringFinal.bind(void 0, stringDecoder)
	};
};
const encodingUint8ArrayGenerator = function* (textEncoder$4, chunk) {
	if (Buffer$1.isBuffer(chunk)) yield bufferToUint8Array(chunk);
	else if (typeof chunk === "string") yield textEncoder$4.encode(chunk);
	else yield chunk;
};
const encodingStringGenerator = function* (stringDecoder, chunk) {
	yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
};
const encodingStringFinal = function* (stringDecoder) {
	const lastChunk = stringDecoder.end();
	if (lastChunk !== "") yield lastChunk;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/run-async.js
const pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {
	state.currentIterable = getChunks(...getChunksArguments);
	try {
		for await (const chunk of state.currentIterable) transformStream.push(chunk);
	} finally {
		delete state.currentIterable;
	}
});
const transformChunk = async function* (chunk, generators, index) {
	if (index === generators.length) {
		yield chunk;
		return;
	}
	const { transform = identityGenerator$1 } = generators[index];
	for await (const transformedChunk of transform(chunk)) yield* transformChunk(transformedChunk, generators, index + 1);
};
const finalChunks = async function* (generators) {
	for (const [index, { final }] of Object.entries(generators)) yield* generatorFinalChunks(final, Number(index), generators);
};
const generatorFinalChunks = async function* (final, index, generators) {
	if (final === void 0) return;
	for await (const finalChunk of final()) yield* transformChunk(finalChunk, generators, index + 1);
};
const destroyTransform = callbackify(async ({ currentIterable }, error$1) => {
	if (currentIterable !== void 0) {
		await (error$1 ? currentIterable.throw(error$1) : currentIterable.return());
		return;
	}
	if (error$1) throw error$1;
});
const identityGenerator$1 = function* (chunk) {
	yield chunk;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/run-sync.js
const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {
	try {
		for (const chunk of getChunksSync(...getChunksArguments)) transformStream.push(chunk);
		done();
	} catch (error$1) {
		done(error$1);
	}
};
const runTransformSync = (generators, chunks) => [...chunks.flatMap((chunk) => [...transformChunkSync(chunk, generators, 0)]), ...finalChunksSync(generators)];
const transformChunkSync = function* (chunk, generators, index) {
	if (index === generators.length) {
		yield chunk;
		return;
	}
	const { transform = identityGenerator } = generators[index];
	for (const transformedChunk of transform(chunk)) yield* transformChunkSync(transformedChunk, generators, index + 1);
};
const finalChunksSync = function* (generators) {
	for (const [index, { final }] of Object.entries(generators)) yield* generatorFinalChunksSync(final, Number(index), generators);
};
const generatorFinalChunksSync = function* (final, index, generators) {
	if (final === void 0) return;
	for (const finalChunk of final()) yield* transformChunkSync(finalChunk, generators, index + 1);
};
const identityGenerator = function* (chunk) {
	yield chunk;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/transform/generator.js
const generatorToStream = ({ value, value: { transform, final, writableObjectMode, readableObjectMode }, optionName }, { encoding }) => {
	const state = {};
	const generators = addInternalGenerators(value, encoding, optionName);
	const transformAsync = isAsyncGenerator(transform);
	const finalAsync = isAsyncGenerator(final);
	const transformMethod = transformAsync ? pushChunks.bind(void 0, transformChunk, state) : pushChunksSync.bind(void 0, transformChunkSync);
	const finalMethod = transformAsync || finalAsync ? pushChunks.bind(void 0, finalChunks, state) : pushChunksSync.bind(void 0, finalChunksSync);
	const destroyMethod = transformAsync || finalAsync ? destroyTransform.bind(void 0, state) : void 0;
	const stream$2 = new Transform({
		writableObjectMode,
		writableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),
		readableObjectMode,
		readableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),
		transform(chunk, encoding$1, done) {
			transformMethod([
				chunk,
				generators,
				0
			], this, done);
		},
		flush(done) {
			finalMethod([generators], this, done);
		},
		destroy: destroyMethod
	});
	return { stream: stream$2 };
};
const runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {
	const generators = stdioItems.filter(({ type }) => type === "generator");
	const reversedGenerators = isInput ? generators.reverse() : generators;
	for (const { value, optionName } of reversedGenerators) {
		const generators$1 = addInternalGenerators(value, encoding, optionName);
		chunks = runTransformSync(generators$1, chunks);
	}
	return chunks;
};
const addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName) => {
	const state = {};
	return [
		{ transform: getValidateTransformInput(writableObjectMode, optionName) },
		getEncodingTransformGenerator(binary, encoding, writableObjectMode),
		getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
		{
			transform,
			final
		},
		{ transform: getValidateTransformReturn(readableObjectMode, optionName) },
		getAppendNewlineGenerator({
			binary,
			preserveNewlines,
			readableObjectMode,
			state
		})
	].filter(Boolean);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/input-sync.js
const addInputOptionsSync = (fileDescriptors, options) => {
	for (const fdNumber of getInputFdNumbers(fileDescriptors)) addInputOptionSync(fileDescriptors, fdNumber, options);
};
const getInputFdNumbers = (fileDescriptors) => new Set(Object.entries(fileDescriptors).filter(([, { direction }]) => direction === "input").map(([fdNumber]) => Number(fdNumber)));
const addInputOptionSync = (fileDescriptors, fdNumber, options) => {
	const { stdioItems } = fileDescriptors[fdNumber];
	const allStdioItems = stdioItems.filter(({ contents }) => contents !== void 0);
	if (allStdioItems.length === 0) return;
	if (fdNumber !== 0) {
		const [{ type, optionName }] = allStdioItems;
		throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);
	}
	const allContents = allStdioItems.map(({ contents }) => contents);
	const transformedContents = allContents.map((contents) => applySingleInputGeneratorsSync(contents, stdioItems));
	options.input = joinToUint8Array(transformedContents);
};
const applySingleInputGeneratorsSync = (contents, stdioItems) => {
	const newContents = runGeneratorsSync(contents, stdioItems, "utf8", true);
	validateSerializable(newContents);
	return joinToUint8Array(newContents);
};
const validateSerializable = (newContents) => {
	const invalidItem = newContents.find((item) => typeof item !== "string" && !isUint8Array(item));
	if (invalidItem !== void 0) throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/output.js
const shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber }) => fdNumber !== "all" && isFullVerbose(verboseInfo, fdNumber) && !BINARY_ENCODINGS.has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type, value }) => type === "native" && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type }) => TRANSFORM_TYPES.has(type)));
const fdUsesVerbose = (fdNumber) => fdNumber === 1 || fdNumber === 2;
const PIPED_STDIO_VALUES = new Set(["pipe", "overlapped"]);
const logLines = async (linesIterable, stream$2, fdNumber, verboseInfo) => {
	for await (const line of linesIterable) if (!isPipingStream(stream$2)) logLine(line, fdNumber, verboseInfo);
};
const logLinesSync = (linesArray, fdNumber, verboseInfo) => {
	for (const line of linesArray) logLine(line, fdNumber, verboseInfo);
};
const isPipingStream = (stream$2) => stream$2._readableState.pipes.length > 0;
const logLine = (line, fdNumber, verboseInfo) => {
	const verboseMessage = serializeVerboseMessage(line);
	verboseLog({
		type: "output",
		verboseMessage,
		fdNumber,
		verboseInfo
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/output-sync.js
const transformOutputSync = ({ fileDescriptors, syncResult: { output }, options, isMaxBuffer, verboseInfo }) => {
	if (output === null) return { output: Array.from({ length: 3 }) };
	const state = {};
	const outputFiles = /* @__PURE__ */ new Set([]);
	const transformedOutput = output.map((result, fdNumber) => transformOutputResultSync({
		result,
		fileDescriptors,
		fdNumber,
		state,
		outputFiles,
		isMaxBuffer,
		verboseInfo
	}, options));
	return {
		output: transformedOutput,
		...state
	};
};
const transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines, stripFinalNewline: stripFinalNewline$1, maxBuffer }) => {
	if (result === null) return;
	const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
	const uint8ArrayResult = bufferToUint8Array(truncatedResult);
	const { stdioItems, objectMode } = fileDescriptors[fdNumber];
	const chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);
	const { serializedResult, finalResult = serializedResult } = serializeChunks({
		chunks,
		objectMode,
		encoding,
		lines,
		stripFinalNewline: stripFinalNewline$1,
		fdNumber
	});
	logOutputSync({
		serializedResult,
		fdNumber,
		state,
		verboseInfo,
		encoding,
		stdioItems,
		objectMode
	});
	const returnedResult = buffer[fdNumber] ? finalResult : void 0;
	try {
		if (state.error === void 0) writeToFiles(serializedResult, stdioItems, outputFiles);
		return returnedResult;
	} catch (error$1) {
		state.error = error$1;
		return returnedResult;
	}
};
const runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {
	try {
		return runGeneratorsSync(chunks, stdioItems, encoding, false);
	} catch (error$1) {
		state.error = error$1;
		return chunks;
	}
};
const serializeChunks = ({ chunks, objectMode, encoding, lines, stripFinalNewline: stripFinalNewline$1, fdNumber }) => {
	if (objectMode) return { serializedResult: chunks };
	if (encoding === "buffer") return { serializedResult: joinToUint8Array(chunks) };
	const serializedResult = joinToString(chunks, encoding);
	if (lines[fdNumber]) return {
		serializedResult,
		finalResult: splitLinesSync(serializedResult, !stripFinalNewline$1[fdNumber], objectMode)
	};
	return { serializedResult };
};
const logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode }) => {
	if (!shouldLogOutput({
		stdioItems,
		encoding,
		verboseInfo,
		fdNumber
	})) return;
	const linesArray = splitLinesSync(serializedResult, false, objectMode);
	try {
		logLinesSync(linesArray, fdNumber, verboseInfo);
	} catch (error$1) {
		state.error ??= error$1;
	}
};
const writeToFiles = (serializedResult, stdioItems, outputFiles) => {
	for (const { path: path$9 } of stdioItems.filter(({ type }) => FILE_TYPES.has(type))) {
		const pathString = typeof path$9 === "string" ? path$9 : path$9.toString();
		if (outputFiles.has(pathString)) appendFileSync(path$9, serializedResult);
		else {
			outputFiles.add(pathString);
			writeFileSync(path$9, serializedResult);
		}
	}
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/resolve/all-sync.js
const getAllSync = ([, stdout$1, stderr], options) => {
	if (!options.all) return;
	if (stdout$1 === void 0) return stderr;
	if (stderr === void 0) return stdout$1;
	if (Array.isArray(stdout$1)) return Array.isArray(stderr) ? [...stdout$1, ...stderr] : [...stdout$1, stripNewline(stderr, options, "all")];
	if (Array.isArray(stderr)) return [stripNewline(stdout$1, options, "all"), ...stderr];
	if (isUint8Array(stdout$1) && isUint8Array(stderr)) return concatUint8Arrays([stdout$1, stderr]);
	return `${stdout$1}${stderr}`;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/resolve/exit-async.js
const waitForExit = async (subprocess, context$1) => {
	const [exitCode, signal] = await waitForExitOrError(subprocess);
	context$1.isForcefullyTerminated ??= false;
	return [exitCode, signal];
};
const waitForExitOrError = async (subprocess) => {
	const [spawnPayload, exitPayload] = await Promise.allSettled([once(subprocess, "spawn"), once(subprocess, "exit")]);
	if (spawnPayload.status === "rejected") return [];
	return exitPayload.status === "rejected" ? waitForSubprocessExit(subprocess) : exitPayload.value;
};
const waitForSubprocessExit = async (subprocess) => {
	try {
		return await once(subprocess, "exit");
	} catch {
		return waitForSubprocessExit(subprocess);
	}
};
const waitForSuccessfulExit = async (exitPromise) => {
	const [exitCode, signal] = await exitPromise;
	if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) throw new DiscardedError();
	return [exitCode, signal];
};
const isSubprocessErrorExit = (exitCode, signal) => exitCode === void 0 && signal === void 0;
const isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/resolve/exit-sync.js
const getExitResultSync = ({ error: error$1, status: exitCode, signal, output }, { maxBuffer }) => {
	const resultError = getResultError(error$1, exitCode, signal);
	const timedOut = resultError?.code === "ETIMEDOUT";
	const isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);
	return {
		resultError,
		exitCode,
		signal,
		timedOut,
		isMaxBuffer
	};
};
const getResultError = (error$1, exitCode, signal) => {
	if (error$1 !== void 0) return error$1;
	return isFailedExit(exitCode, signal) ? new DiscardedError() : void 0;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/main-sync.js
const execaCoreSync = (rawFile, rawArguments, rawOptions) => {
	const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
	const result = spawnSubprocessSync({
		file,
		commandArguments,
		options,
		command,
		escapedCommand,
		verboseInfo,
		fileDescriptors,
		startTime
	});
	return handleResult(result, verboseInfo, options);
};
const handleSyncArguments = (rawFile, rawArguments, rawOptions) => {
	const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
	const syncOptions = normalizeSyncOptions(rawOptions);
	const { file, commandArguments, options } = normalizeOptions(rawFile, rawArguments, syncOptions);
	validateSyncOptions(options);
	const fileDescriptors = handleStdioSync(options, verboseInfo);
	return {
		file,
		commandArguments,
		command,
		escapedCommand,
		startTime,
		verboseInfo,
		options,
		fileDescriptors
	};
};
const normalizeSyncOptions = (options) => options.node && !options.ipc ? {
	...options,
	ipc: false
} : options;
const validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal }) => {
	if (ipcInput) throwInvalidSyncOption("ipcInput");
	if (ipc) throwInvalidSyncOption("ipc: true");
	if (detached) throwInvalidSyncOption("detached: true");
	if (cancelSignal) throwInvalidSyncOption("cancelSignal");
};
const throwInvalidSyncOption = (value) => {
	throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
};
const spawnSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime }) => {
	const syncResult = runSubprocessSync({
		file,
		commandArguments,
		options,
		command,
		escapedCommand,
		fileDescriptors,
		startTime
	});
	if (syncResult.failed) return syncResult;
	const { resultError, exitCode, signal, timedOut, isMaxBuffer } = getExitResultSync(syncResult, options);
	const { output, error: error$1 = resultError } = transformOutputSync({
		fileDescriptors,
		syncResult,
		options,
		isMaxBuffer,
		verboseInfo
	});
	const stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));
	const all = stripNewline(getAllSync(output, options), options, "all");
	return getSyncResult({
		error: error$1,
		exitCode,
		signal,
		timedOut,
		isMaxBuffer,
		stdio,
		all,
		options,
		command,
		escapedCommand,
		startTime
	});
};
const runSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime }) => {
	try {
		addInputOptionsSync(fileDescriptors, options);
		const normalizedOptions = normalizeSpawnSyncOptions(options);
		return spawnSync(file, commandArguments, normalizedOptions);
	} catch (error$1) {
		return makeEarlyError({
			error: error$1,
			command,
			escapedCommand,
			fileDescriptors,
			options,
			startTime,
			isSync: true
		});
	}
};
const normalizeSpawnSyncOptions = ({ encoding, maxBuffer,...options }) => ({
	...options,
	encoding: "buffer",
	maxBuffer: getMaxBufferSync(maxBuffer)
});
const getSyncResult = ({ error: error$1, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime }) => error$1 === void 0 ? makeSuccessResult({
	command,
	escapedCommand,
	stdio,
	all,
	ipcOutput: [],
	options,
	startTime
}) : makeError({
	error: error$1,
	command,
	escapedCommand,
	timedOut,
	isCanceled: false,
	isGracefullyCanceled: false,
	isMaxBuffer,
	isForcefullyTerminated: false,
	exitCode,
	signal,
	stdio,
	all,
	ipcOutput: [],
	options,
	startTime,
	isSync: true
});

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/get-one.js
const getOneMessage$1 = ({ anyProcess, channel: channel$1, isSubprocess, ipc }, { reference = true, filter } = {}) => {
	validateIpcMethod({
		methodName: "getOneMessage",
		isSubprocess,
		ipc,
		isConnected: isConnected(anyProcess)
	});
	return getOneMessageAsync({
		anyProcess,
		channel: channel$1,
		isSubprocess,
		filter,
		reference
	});
};
const getOneMessageAsync = async ({ anyProcess, channel: channel$1, isSubprocess, filter, reference }) => {
	addReference(channel$1, reference);
	const ipcEmitter = getIpcEmitter(anyProcess, channel$1, isSubprocess);
	const controller = new AbortController();
	try {
		return await Promise.race([
			getMessage(ipcEmitter, filter, controller),
			throwOnDisconnect(ipcEmitter, isSubprocess, controller),
			throwOnStrictError(ipcEmitter, isSubprocess, controller)
		]);
	} catch (error$1) {
		disconnect(anyProcess);
		throw error$1;
	} finally {
		controller.abort();
		removeReference(channel$1, reference);
	}
};
const getMessage = async (ipcEmitter, filter, { signal }) => {
	if (filter === void 0) {
		const [message] = await once(ipcEmitter, "message", { signal });
		return message;
	}
	for await (const [message] of on(ipcEmitter, "message", { signal })) if (filter(message)) return message;
};
const throwOnDisconnect = async (ipcEmitter, isSubprocess, { signal }) => {
	await once(ipcEmitter, "disconnect", { signal });
	throwOnEarlyDisconnect(isSubprocess);
};
const throwOnStrictError = async (ipcEmitter, isSubprocess, { signal }) => {
	const [error$1] = await once(ipcEmitter, "strict:error", { signal });
	throw getStrictResponseError(error$1, isSubprocess);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/get-each.js
const getEachMessage$1 = ({ anyProcess, channel: channel$1, isSubprocess, ipc }, { reference = true } = {}) => loopOnMessages({
	anyProcess,
	channel: channel$1,
	isSubprocess,
	ipc,
	shouldAwait: !isSubprocess,
	reference
});
const loopOnMessages = ({ anyProcess, channel: channel$1, isSubprocess, ipc, shouldAwait, reference }) => {
	validateIpcMethod({
		methodName: "getEachMessage",
		isSubprocess,
		ipc,
		isConnected: isConnected(anyProcess)
	});
	addReference(channel$1, reference);
	const ipcEmitter = getIpcEmitter(anyProcess, channel$1, isSubprocess);
	const controller = new AbortController();
	const state = {};
	stopOnDisconnect(anyProcess, ipcEmitter, controller);
	abortOnStrictError({
		ipcEmitter,
		isSubprocess,
		controller,
		state
	});
	return iterateOnMessages({
		anyProcess,
		channel: channel$1,
		ipcEmitter,
		isSubprocess,
		shouldAwait,
		controller,
		state,
		reference
	});
};
const stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {
	try {
		await once(ipcEmitter, "disconnect", { signal: controller.signal });
		controller.abort();
	} catch {}
};
const abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state }) => {
	try {
		const [error$1] = await once(ipcEmitter, "strict:error", { signal: controller.signal });
		state.error = getStrictResponseError(error$1, isSubprocess);
		controller.abort();
	} catch {}
};
const iterateOnMessages = async function* ({ anyProcess, channel: channel$1, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference }) {
	try {
		for await (const [message] of on(ipcEmitter, "message", { signal: controller.signal })) {
			throwIfStrictError(state);
			yield message;
		}
	} catch {
		throwIfStrictError(state);
	} finally {
		controller.abort();
		removeReference(channel$1, reference);
		if (!isSubprocess) disconnect(anyProcess);
		if (shouldAwait) await anyProcess;
	}
};
const throwIfStrictError = ({ error: error$1 }) => {
	if (error$1) throw error$1;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/methods.js
const addIpcMethods = (subprocess, { ipc }) => {
	Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};
const getIpcExport = () => {
	const anyProcess = process$1;
	const isSubprocess = true;
	const ipc = process$1.channel !== void 0;
	return {
		...getIpcMethods(anyProcess, isSubprocess, ipc),
		getCancelSignal: getCancelSignal$1.bind(void 0, {
			anyProcess,
			channel: anyProcess.channel,
			isSubprocess,
			ipc
		})
	};
};
const getIpcMethods = (anyProcess, isSubprocess, ipc) => ({
	sendMessage: sendMessage$1.bind(void 0, {
		anyProcess,
		channel: anyProcess.channel,
		isSubprocess,
		ipc
	}),
	getOneMessage: getOneMessage$1.bind(void 0, {
		anyProcess,
		channel: anyProcess.channel,
		isSubprocess,
		ipc
	}),
	getEachMessage: getEachMessage$1.bind(void 0, {
		anyProcess,
		channel: anyProcess.channel,
		isSubprocess,
		ipc
	})
});

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/return/early-error.js
const handleEarlyError = ({ error: error$1, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo }) => {
	cleanupCustomStreams(fileDescriptors);
	const subprocess = new ChildProcess();
	createDummyStreams(subprocess, fileDescriptors);
	Object.assign(subprocess, {
		readable,
		writable,
		duplex
	});
	const earlyError = makeEarlyError({
		error: error$1,
		command,
		escapedCommand,
		fileDescriptors,
		options,
		startTime,
		isSync: false
	});
	const promise = handleDummyPromise(earlyError, verboseInfo, options);
	return {
		subprocess,
		promise
	};
};
const createDummyStreams = (subprocess, fileDescriptors) => {
	const stdin = createDummyStream();
	const stdout$1 = createDummyStream();
	const stderr = createDummyStream();
	const extraStdio = Array.from({ length: fileDescriptors.length - 3 }, createDummyStream);
	const all = createDummyStream();
	const stdio = [
		stdin,
		stdout$1,
		stderr,
		...extraStdio
	];
	Object.assign(subprocess, {
		stdin,
		stdout: stdout$1,
		stderr,
		all,
		stdio
	});
};
const createDummyStream = () => {
	const stream$2 = new PassThrough();
	stream$2.end();
	return stream$2;
};
const readable = () => new Readable({ read() {} });
const writable = () => new Writable({ write() {} });
const duplex = () => new Duplex({
	read() {},
	write() {}
});
const handleDummyPromise = async (error$1, verboseInfo, options) => handleResult(error$1, verboseInfo, options);

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/stdio/handle-async.js
const handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);
const forbiddenIfAsync = ({ type, optionName }) => {
	throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);
};
const addProperties = {
	fileNumber: forbiddenIfAsync,
	generator: generatorToStream,
	asyncGenerator: generatorToStream,
	nodeStream: ({ value }) => ({ stream: value }),
	webTransform({ value: { transform, writableObjectMode, readableObjectMode } }) {
		const objectMode = writableObjectMode || readableObjectMode;
		const stream$2 = Duplex.fromWeb(transform, { objectMode });
		return { stream: stream$2 };
	},
	duplex: ({ value: { transform } }) => ({ stream: transform }),
	native() {}
};
const addPropertiesAsync = {
	input: {
		...addProperties,
		fileUrl: ({ value }) => ({ stream: createReadStream(value) }),
		filePath: ({ value: { file } }) => ({ stream: createReadStream(file) }),
		webStream: ({ value }) => ({ stream: Readable.fromWeb(value) }),
		iterable: ({ value }) => ({ stream: Readable.from(value) }),
		asyncIterable: ({ value }) => ({ stream: Readable.from(value) }),
		string: ({ value }) => ({ stream: Readable.from(value) }),
		uint8Array: ({ value }) => ({ stream: Readable.from(Buffer$1.from(value)) })
	},
	output: {
		...addProperties,
		fileUrl: ({ value }) => ({ stream: createWriteStream(value) }),
		filePath: ({ value: { file } }) => ({ stream: createWriteStream(file) }),
		webStream: ({ value }) => ({ stream: Writable.fromWeb(value) }),
		iterable: forbiddenIfAsync,
		asyncIterable: forbiddenIfAsync,
		string: forbiddenIfAsync,
		uint8Array: forbiddenIfAsync
	}
};

//#endregion
//#region node_modules/.pnpm/@sindresorhus+merge-streams@4.0.0/node_modules/@sindresorhus/merge-streams/index.js
function mergeStreams(streams) {
	if (!Array.isArray(streams)) throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
	for (const stream$2 of streams) validateStream(stream$2);
	const objectMode = streams.some(({ readableObjectMode }) => readableObjectMode);
	const highWaterMark = getHighWaterMark(streams, objectMode);
	const passThroughStream = new MergedStream({
		objectMode,
		writableHighWaterMark: highWaterMark,
		readableHighWaterMark: highWaterMark
	});
	for (const stream$2 of streams) passThroughStream.add(stream$2);
	return passThroughStream;
}
const getHighWaterMark = (streams, objectMode) => {
	if (streams.length === 0) return getDefaultHighWaterMark(objectMode);
	const highWaterMarks = streams.filter(({ readableObjectMode }) => readableObjectMode === objectMode).map(({ readableHighWaterMark }) => readableHighWaterMark);
	return Math.max(...highWaterMarks);
};
var MergedStream = class extends PassThrough {
	#streams = /* @__PURE__ */ new Set([]);
	#ended = /* @__PURE__ */ new Set([]);
	#aborted = /* @__PURE__ */ new Set([]);
	#onFinished;
	#unpipeEvent = Symbol("unpipe");
	#streamPromises = /* @__PURE__ */ new WeakMap();
	add(stream$2) {
		validateStream(stream$2);
		if (this.#streams.has(stream$2)) return;
		this.#streams.add(stream$2);
		this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
		const streamPromise = endWhenStreamsDone({
			passThroughStream: this,
			stream: stream$2,
			streams: this.#streams,
			ended: this.#ended,
			aborted: this.#aborted,
			onFinished: this.#onFinished,
			unpipeEvent: this.#unpipeEvent
		});
		this.#streamPromises.set(stream$2, streamPromise);
		stream$2.pipe(this, { end: false });
	}
	async remove(stream$2) {
		validateStream(stream$2);
		if (!this.#streams.has(stream$2)) return false;
		const streamPromise = this.#streamPromises.get(stream$2);
		if (streamPromise === void 0) return false;
		this.#streamPromises.delete(stream$2);
		stream$2.unpipe(this);
		await streamPromise;
		return true;
	}
};
const onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {
	updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
	const controller = new AbortController();
	try {
		await Promise.race([onMergedStreamEnd(passThroughStream, controller), onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller)]);
	} finally {
		controller.abort();
		updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);
	}
};
const onMergedStreamEnd = async (passThroughStream, { signal }) => {
	try {
		await finished(passThroughStream, {
			signal,
			cleanup: true
		});
	} catch (error$1) {
		errorOrAbortStream(passThroughStream, error$1);
		throw error$1;
	}
};
const onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, { signal }) => {
	for await (const [unpipedStream] of on(passThroughStream, "unpipe", { signal })) if (streams.has(unpipedStream)) unpipedStream.emit(unpipeEvent);
};
const validateStream = (stream$2) => {
	if (typeof stream$2?.pipe !== "function") throw new TypeError(`Expected a readable stream, got: \`${typeof stream$2}\`.`);
};
const endWhenStreamsDone = async ({ passThroughStream, stream: stream$2, streams, ended, aborted: aborted$1, onFinished, unpipeEvent }) => {
	updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
	const controller = new AbortController();
	try {
		await Promise.race([
			afterMergedStreamFinished(onFinished, stream$2, controller),
			onInputStreamEnd({
				passThroughStream,
				stream: stream$2,
				streams,
				ended,
				aborted: aborted$1,
				controller
			}),
			onInputStreamUnpipe({
				stream: stream$2,
				streams,
				ended,
				aborted: aborted$1,
				unpipeEvent,
				controller
			})
		]);
	} finally {
		controller.abort();
		updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);
	}
	if (streams.size > 0 && streams.size === ended.size + aborted$1.size) if (ended.size === 0 && aborted$1.size > 0) abortStream(passThroughStream);
	else endStream(passThroughStream);
};
const afterMergedStreamFinished = async (onFinished, stream$2, { signal }) => {
	try {
		await onFinished;
		if (!signal.aborted) abortStream(stream$2);
	} catch (error$1) {
		if (!signal.aborted) errorOrAbortStream(stream$2, error$1);
	}
};
const onInputStreamEnd = async ({ passThroughStream, stream: stream$2, streams, ended, aborted: aborted$1, controller: { signal } }) => {
	try {
		await finished(stream$2, {
			signal,
			cleanup: true,
			readable: true,
			writable: false
		});
		if (streams.has(stream$2)) ended.add(stream$2);
	} catch (error$1) {
		if (signal.aborted || !streams.has(stream$2)) return;
		if (isAbortError(error$1)) aborted$1.add(stream$2);
		else errorStream(passThroughStream, error$1);
	}
};
const onInputStreamUnpipe = async ({ stream: stream$2, streams, ended, aborted: aborted$1, unpipeEvent, controller: { signal } }) => {
	await once(stream$2, unpipeEvent, { signal });
	if (!stream$2.readable) return once(signal, "abort", { signal });
	streams.delete(stream$2);
	ended.delete(stream$2);
	aborted$1.delete(stream$2);
};
const endStream = (stream$2) => {
	if (stream$2.writable) stream$2.end();
};
const errorOrAbortStream = (stream$2, error$1) => {
	if (isAbortError(error$1)) abortStream(stream$2);
	else errorStream(stream$2, error$1);
};
const isAbortError = (error$1) => error$1?.code === "ERR_STREAM_PREMATURE_CLOSE";
const abortStream = (stream$2) => {
	if (stream$2.readable || stream$2.writable) stream$2.destroy();
};
const errorStream = (stream$2, error$1) => {
	if (!stream$2.destroyed) {
		stream$2.once("error", noop);
		stream$2.destroy(error$1);
	}
};
const noop = () => {};
const updateMaxListeners = (passThroughStream, increment$1) => {
	const maxListeners = passThroughStream.getMaxListeners();
	if (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) passThroughStream.setMaxListeners(maxListeners + increment$1);
};
const PASSTHROUGH_LISTENERS_COUNT = 2;
const PASSTHROUGH_LISTENERS_PER_STREAM = 1;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/pipeline.js
const pipeStreams = (source, destination) => {
	source.pipe(destination);
	onSourceFinish(source, destination);
	onDestinationFinish(source, destination);
};
const onSourceFinish = async (source, destination) => {
	if (isStandardStream(source) || isStandardStream(destination)) return;
	try {
		await finished(source, {
			cleanup: true,
			readable: true,
			writable: false
		});
	} catch {}
	endDestinationStream(destination);
};
const endDestinationStream = (destination) => {
	if (destination.writable) destination.end();
};
const onDestinationFinish = async (source, destination) => {
	if (isStandardStream(source) || isStandardStream(destination)) return;
	try {
		await finished(destination, {
			cleanup: true,
			readable: false,
			writable: true
		});
	} catch {}
	abortSourceStream(source);
};
const abortSourceStream = (source) => {
	if (source.readable) source.destroy();
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/output-async.js
const pipeOutputAsync = (subprocess, fileDescriptors, controller) => {
	const pipeGroups = /* @__PURE__ */ new Map();
	for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)) {
		for (const { stream: stream$2 } of stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type))) pipeTransform(subprocess, stream$2, direction, fdNumber);
		for (const { stream: stream$2 } of stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type))) pipeStdioItem({
			subprocess,
			stream: stream$2,
			direction,
			fdNumber,
			pipeGroups,
			controller
		});
	}
	for (const [outputStream, inputStreams] of pipeGroups.entries()) {
		const inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);
		pipeStreams(inputStream, outputStream);
	}
};
const pipeTransform = (subprocess, stream$2, direction, fdNumber) => {
	if (direction === "output") pipeStreams(subprocess.stdio[fdNumber], stream$2);
	else pipeStreams(stream$2, subprocess.stdio[fdNumber]);
	const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
	if (streamProperty !== void 0) subprocess[streamProperty] = stream$2;
	subprocess.stdio[fdNumber] = stream$2;
};
const SUBPROCESS_STREAM_PROPERTIES = [
	"stdin",
	"stdout",
	"stderr"
];
const pipeStdioItem = ({ subprocess, stream: stream$2, direction, fdNumber, pipeGroups, controller }) => {
	if (stream$2 === void 0) return;
	setStandardStreamMaxListeners(stream$2, controller);
	const [inputStream, outputStream] = direction === "output" ? [stream$2, subprocess.stdio[fdNumber]] : [subprocess.stdio[fdNumber], stream$2];
	const outputStreams = pipeGroups.get(inputStream) ?? [];
	pipeGroups.set(inputStream, [...outputStreams, outputStream]);
};
const setStandardStreamMaxListeners = (stream$2, { signal }) => {
	if (isStandardStream(stream$2)) incrementMaxListeners(stream$2, MAX_LISTENERS_INCREMENT, signal);
};
const MAX_LISTENERS_INCREMENT = 2;

//#endregion
//#region node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/signals.js
/**
* This is not the set of all possible signals.
*
* It IS, however, the set of all signals that trigger
* an exit on either Linux or BSD systems.  Linux is a
* superset of the signal names supported on BSD, and
* the unknown signals just fail to register, so we can
* catch that easily enough.
*
* Windows signals are a different set, since there are
* signals that terminate Windows processes, but don't
* terminate (or don't even exist) on Posix systems.
*
* Don't bother with SIGKILL.  It's uncatchable, which
* means that we can't fire any callbacks anyway.
*
* If a user does happen to register a handler on a non-
* fatal signal like SIGWINCH or something, and then
* exit, it'll end up firing `process.emit('exit')`, so
* the handler will be fired anyway.
*
* SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
* artificially, inherently leave the process in a
* state from which it is not safe to try and enter JS
* listeners.
*/
const signals = [];
signals.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
if (process.platform === "linux") signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");

//#endregion
//#region node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/index.js
const processOk = (process$3) => !!process$3 && typeof process$3 === "object" && typeof process$3.removeListener === "function" && typeof process$3.emit === "function" && typeof process$3.reallyExit === "function" && typeof process$3.listeners === "function" && typeof process$3.kill === "function" && typeof process$3.pid === "number" && typeof process$3.on === "function";
const kExitEmitter = Symbol.for("signal-exit emitter");
const global$1 = globalThis;
const ObjectDefineProperty = Object.defineProperty.bind(Object);
var Emitter = class {
	emitted = {
		afterExit: false,
		exit: false
	};
	listeners = {
		afterExit: [],
		exit: []
	};
	count = 0;
	id = Math.random();
	constructor() {
		if (global$1[kExitEmitter]) return global$1[kExitEmitter];
		ObjectDefineProperty(global$1, kExitEmitter, {
			value: this,
			writable: false,
			enumerable: false,
			configurable: false
		});
	}
	on(ev, fn) {
		this.listeners[ev].push(fn);
	}
	removeListener(ev, fn) {
		const list = this.listeners[ev];
		const i$1 = list.indexOf(fn);
		/* c8 ignore start */
		if (i$1 === -1) return;
		/* c8 ignore stop */
		if (i$1 === 0 && list.length === 1) list.length = 0;
		else list.splice(i$1, 1);
	}
	emit(ev, code, signal) {
		if (this.emitted[ev]) return false;
		this.emitted[ev] = true;
		let ret = false;
		for (const fn of this.listeners[ev]) ret = fn(code, signal) === true || ret;
		if (ev === "exit") ret = this.emit("afterExit", code, signal) || ret;
		return ret;
	}
};
var SignalExitBase = class {};
const signalExitWrap = (handler$1) => {
	return {
		onExit(cb, opts) {
			return handler$1.onExit(cb, opts);
		},
		load() {
			return handler$1.load();
		},
		unload() {
			return handler$1.unload();
		}
	};
};
var SignalExitFallback = class extends SignalExitBase {
	onExit() {
		return () => {};
	}
	load() {}
	unload() {}
};
var SignalExit = class extends SignalExitBase {
	/* c8 ignore start */
	#hupSig = process$2.platform === "win32" ? "SIGINT" : "SIGHUP";
	/* c8 ignore stop */
	#emitter = new Emitter();
	#process;
	#originalProcessEmit;
	#originalProcessReallyExit;
	#sigListeners = {};
	#loaded = false;
	constructor(process$3) {
		super();
		this.#process = process$3;
		this.#sigListeners = {};
		for (const sig of signals) this.#sigListeners[sig] = () => {
			const listeners = this.#process.listeners(sig);
			let { count: count$1 } = this.#emitter;
			/* c8 ignore start */
			const p = process$3;
			if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") count$1 += p.__signal_exit_emitter__.count;
			/* c8 ignore stop */
			if (listeners.length === count$1) {
				this.unload();
				const ret = this.#emitter.emit("exit", null, sig);
				/* c8 ignore start */
				const s$1 = sig === "SIGHUP" ? this.#hupSig : sig;
				if (!ret) process$3.kill(process$3.pid, s$1);
			}
		};
		this.#originalProcessReallyExit = process$3.reallyExit;
		this.#originalProcessEmit = process$3.emit;
	}
	onExit(cb, opts) {
		/* c8 ignore start */
		if (!processOk(this.#process)) return () => {};
		/* c8 ignore stop */
		if (this.#loaded === false) this.load();
		const ev = opts?.alwaysLast ? "afterExit" : "exit";
		this.#emitter.on(ev, cb);
		return () => {
			this.#emitter.removeListener(ev, cb);
			if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) this.unload();
		};
	}
	load() {
		if (this.#loaded) return;
		this.#loaded = true;
		this.#emitter.count += 1;
		for (const sig of signals) try {
			const fn = this.#sigListeners[sig];
			if (fn) this.#process.on(sig, fn);
		} catch (_) {}
		this.#process.emit = (ev, ...a$1) => {
			return this.#processEmit(ev, ...a$1);
		};
		this.#process.reallyExit = (code) => {
			return this.#processReallyExit(code);
		};
	}
	unload() {
		if (!this.#loaded) return;
		this.#loaded = false;
		signals.forEach((sig) => {
			const listener = this.#sigListeners[sig];
			/* c8 ignore start */
			if (!listener) throw new Error("Listener not defined for signal: " + sig);
			/* c8 ignore stop */
			try {
				this.#process.removeListener(sig, listener);
			} catch (_) {}
			/* c8 ignore stop */
		});
		this.#process.emit = this.#originalProcessEmit;
		this.#process.reallyExit = this.#originalProcessReallyExit;
		this.#emitter.count -= 1;
	}
	#processReallyExit(code) {
		/* c8 ignore start */
		if (!processOk(this.#process)) return 0;
		this.#process.exitCode = code || 0;
		/* c8 ignore stop */
		this.#emitter.emit("exit", this.#process.exitCode, null);
		return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
	}
	#processEmit(ev, ...args) {
		const og = this.#originalProcessEmit;
		if (ev === "exit" && processOk(this.#process)) {
			if (typeof args[0] === "number") this.#process.exitCode = args[0];
			/* c8 ignore start */
			const ret = og.call(this.#process, ev, ...args);
			/* c8 ignore start */
			this.#emitter.emit("exit", this.#process.exitCode, null);
			/* c8 ignore stop */
			return ret;
		} else return og.call(this.#process, ev, ...args);
	}
};
const process$2 = globalThis.process;
const { onExit, load, unload } = signalExitWrap(processOk(process$2) ? new SignalExit(process$2) : new SignalExitFallback());

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/terminate/cleanup.js
const cleanupOnExit = (subprocess, { cleanup, detached }, { signal }) => {
	if (!cleanup || detached) return;
	const removeExitHandler = onExit(() => {
		subprocess.kill();
	});
	addAbortListener(signal, () => {
		removeExitHandler();
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/pipe/pipe-arguments.js
const normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments) => {
	const startTime = getStartTime();
	const { destination, destinationStream, destinationError, from, unpipeSignal } = getDestinationStream(boundOptions, createNested, pipeArguments);
	const { sourceStream, sourceError } = getSourceStream(source, from);
	const { options: sourceOptions, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
	return {
		sourcePromise,
		sourceStream,
		sourceOptions,
		sourceError,
		destination,
		destinationStream,
		destinationError,
		unpipeSignal,
		fileDescriptors,
		startTime
	};
};
const getDestinationStream = (boundOptions, createNested, pipeArguments) => {
	try {
		const { destination, pipeOptions: { from, to, unpipeSignal } = {} } = getDestination(boundOptions, createNested, ...pipeArguments);
		const destinationStream = getToStream(destination, to);
		return {
			destination,
			destinationStream,
			from,
			unpipeSignal
		};
	} catch (error$1) {
		return { destinationError: error$1 };
	}
};
const getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {
	if (Array.isArray(firstArgument)) {
		const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
		return {
			destination,
			pipeOptions: boundOptions
		};
	}
	if (typeof firstArgument === "string" || firstArgument instanceof URL) {
		if (Object.keys(boundOptions).length > 0) throw new TypeError("Please use .pipe(\"file\", ..., options) or .pipe(execa(\"file\", ..., options)) instead of .pipe(options)(\"file\", ...).");
		const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
		const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
		return {
			destination,
			pipeOptions: rawOptions
		};
	}
	if (SUBPROCESS_OPTIONS.has(firstArgument)) {
		if (Object.keys(boundOptions).length > 0) throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");
		return {
			destination: firstArgument,
			pipeOptions: pipeArguments[0]
		};
	}
	throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
};
const mapDestinationArguments = ({ options }) => ({ options: {
	...options,
	stdin: "pipe",
	piped: true
} });
const getSourceStream = (source, from) => {
	try {
		const sourceStream = getFromStream(source, from);
		return { sourceStream };
	} catch (error$1) {
		return { sourceError: error$1 };
	}
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/pipe/throw.js
const handlePipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError, fileDescriptors, sourceOptions, startTime }) => {
	const error$1 = getPipeArgumentsError({
		sourceStream,
		sourceError,
		destinationStream,
		destinationError
	});
	if (error$1 !== void 0) throw createNonCommandError({
		error: error$1,
		fileDescriptors,
		sourceOptions,
		startTime
	});
};
const getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError }) => {
	if (sourceError !== void 0 && destinationError !== void 0) return destinationError;
	if (destinationError !== void 0) {
		abortSourceStream(sourceStream);
		return destinationError;
	}
	if (sourceError !== void 0) {
		endDestinationStream(destinationStream);
		return sourceError;
	}
};
const createNonCommandError = ({ error: error$1, fileDescriptors, sourceOptions, startTime }) => makeEarlyError({
	error: error$1,
	command: PIPE_COMMAND_MESSAGE,
	escapedCommand: PIPE_COMMAND_MESSAGE,
	fileDescriptors,
	options: sourceOptions,
	startTime,
	isSync: false
});
const PIPE_COMMAND_MESSAGE = "source.pipe(destination)";

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/pipe/sequence.js
const waitForBothSubprocesses = async (subprocessPromises) => {
	const [{ status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason }, { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }] = await subprocessPromises;
	if (!destinationResult.pipedFrom.includes(sourceResult)) destinationResult.pipedFrom.push(sourceResult);
	if (destinationStatus === "rejected") throw destinationResult;
	if (sourceStatus === "rejected") throw sourceResult;
	return destinationResult;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/pipe/streaming.js
const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {
	const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
	incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
	incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
	cleanupMergedStreamsMap(destinationStream);
	return mergedStream;
};
const pipeFirstSubprocessStream = (sourceStream, destinationStream) => {
	const mergedStream = mergeStreams([sourceStream]);
	pipeStreams(mergedStream, destinationStream);
	MERGED_STREAMS.set(destinationStream, mergedStream);
	return mergedStream;
};
const pipeMoreSubprocessStream = (sourceStream, destinationStream) => {
	const mergedStream = MERGED_STREAMS.get(destinationStream);
	mergedStream.add(sourceStream);
	return mergedStream;
};
const cleanupMergedStreamsMap = async (destinationStream) => {
	try {
		await finished(destinationStream, {
			cleanup: true,
			readable: false,
			writable: true
		});
	} catch {}
	MERGED_STREAMS.delete(destinationStream);
};
const MERGED_STREAMS = /* @__PURE__ */ new WeakMap();
const SOURCE_LISTENERS_PER_PIPE = 2;
const DESTINATION_LISTENERS_PER_PIPE = 1;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/pipe/abort.js
const unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === void 0 ? [] : [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];
const unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime }) => {
	await aborted(unpipeSignal, sourceStream);
	await mergedStream.remove(sourceStream);
	const error$1 = /* @__PURE__ */ new Error("Pipe canceled by `unpipeSignal` option.");
	throw createNonCommandError({
		error: error$1,
		fileDescriptors,
		sourceOptions,
		startTime
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/pipe/setup.js
const pipeToSubprocess = (sourceInfo, ...pipeArguments) => {
	if (isPlainObject(pipeArguments[0])) return pipeToSubprocess.bind(void 0, {
		...sourceInfo,
		boundOptions: {
			...sourceInfo.boundOptions,
			...pipeArguments[0]
		}
	});
	const { destination,...normalizedInfo } = normalizePipeArguments(sourceInfo, ...pipeArguments);
	const promise = handlePipePromise({
		...normalizedInfo,
		destination
	});
	promise.pipe = pipeToSubprocess.bind(void 0, {
		...sourceInfo,
		source: destination,
		sourcePromise: promise,
		boundOptions: {}
	});
	return promise;
};
const handlePipePromise = async ({ sourcePromise, sourceStream, sourceOptions, sourceError, destination, destinationStream, destinationError, unpipeSignal, fileDescriptors, startTime }) => {
	const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
	handlePipeArgumentsError({
		sourceStream,
		sourceError,
		destinationStream,
		destinationError,
		fileDescriptors,
		sourceOptions,
		startTime
	});
	const maxListenersController = new AbortController();
	try {
		const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
		return await Promise.race([waitForBothSubprocesses(subprocessPromises), ...unpipeOnAbort(unpipeSignal, {
			sourceStream,
			mergedStream,
			sourceOptions,
			fileDescriptors,
			startTime
		})]);
	} finally {
		maxListenersController.abort();
	}
};
const getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/iterate.js
const iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines }) => {
	const controller = new AbortController();
	stopReadingOnExit(subprocess, controller);
	return iterateOnStream({
		stream: subprocessStdout,
		controller,
		binary,
		shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
		encoding,
		shouldSplit: !subprocessStdout.readableObjectMode,
		preserveNewlines
	});
};
const stopReadingOnExit = async (subprocess, controller) => {
	try {
		await subprocess;
	} catch {} finally {
		controller.abort();
	}
};
const iterateForResult = ({ stream: stream$2, onStreamEnd, lines, encoding, stripFinalNewline: stripFinalNewline$1, allMixed }) => {
	const controller = new AbortController();
	stopReadingOnStreamEnd(onStreamEnd, controller, stream$2);
	const objectMode = stream$2.readableObjectMode && !allMixed;
	return iterateOnStream({
		stream: stream$2,
		controller,
		binary: encoding === "buffer",
		shouldEncode: !objectMode,
		encoding,
		shouldSplit: !objectMode && lines,
		preserveNewlines: !stripFinalNewline$1
	});
};
const stopReadingOnStreamEnd = async (onStreamEnd, controller, stream$2) => {
	try {
		await onStreamEnd;
	} catch {
		stream$2.destroy();
	} finally {
		controller.abort();
	}
};
const iterateOnStream = ({ stream: stream$2, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => {
	const onStdoutChunk = on(stream$2, "data", {
		signal: controller.signal,
		highWaterMark: HIGH_WATER_MARK,
		highWatermark: HIGH_WATER_MARK
	});
	return iterateOnData({
		onStdoutChunk,
		controller,
		binary,
		shouldEncode,
		encoding,
		shouldSplit,
		preserveNewlines
	});
};
const DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark(true);
const HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
const iterateOnData = async function* ({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
	const generators = getGenerators({
		binary,
		shouldEncode,
		encoding,
		shouldSplit,
		preserveNewlines
	});
	try {
		for await (const [chunk] of onStdoutChunk) yield* transformChunkSync(chunk, generators, 0);
	} catch (error$1) {
		if (!controller.signal.aborted) throw error$1;
	} finally {
		yield* finalChunksSync(generators);
	}
};
const getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => [getEncodingTransformGenerator(binary, encoding, !shouldEncode), getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {})].filter(Boolean);

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/io/contents.js
const getStreamOutput = async ({ stream: stream$2, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline$1, verboseInfo, streamInfo }) => {
	const logPromise = logOutputAsync({
		stream: stream$2,
		onStreamEnd,
		fdNumber,
		encoding,
		allMixed,
		verboseInfo,
		streamInfo
	});
	if (!buffer) {
		await Promise.all([resumeStream(stream$2), logPromise]);
		return;
	}
	const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline$1, fdNumber);
	const iterable = iterateForResult({
		stream: stream$2,
		onStreamEnd,
		lines,
		encoding,
		stripFinalNewline: stripFinalNewlineValue,
		allMixed
	});
	const [output] = await Promise.all([getStreamContents({
		stream: stream$2,
		iterable,
		fdNumber,
		encoding,
		maxBuffer,
		lines
	}), logPromise]);
	return output;
};
const logOutputAsync = async ({ stream: stream$2, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } }) => {
	if (!shouldLogOutput({
		stdioItems: fileDescriptors[fdNumber]?.stdioItems,
		encoding,
		verboseInfo,
		fdNumber
	})) return;
	const linesIterable = iterateForResult({
		stream: stream$2,
		onStreamEnd,
		lines: true,
		encoding,
		stripFinalNewline: true,
		allMixed
	});
	await logLines(linesIterable, stream$2, fdNumber, verboseInfo);
};
const resumeStream = async (stream$2) => {
	await setImmediate$1();
	if (stream$2.readableFlowing === null) stream$2.resume();
};
const getStreamContents = async ({ stream: stream$2, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines }) => {
	try {
		if (readableObjectMode || lines) return await getStreamAsArray(iterable, { maxBuffer });
		if (encoding === "buffer") return new Uint8Array(await getStreamAsArrayBuffer(iterable, { maxBuffer }));
		return await getStreamAsString(iterable, { maxBuffer });
	} catch (error$1) {
		return handleBufferedData(handleMaxBuffer({
			error: error$1,
			stream: stream$2,
			readableObjectMode,
			lines,
			encoding,
			fdNumber
		}));
	}
};
const getBufferedData = async (streamPromise) => {
	try {
		return await streamPromise;
	} catch (error$1) {
		return handleBufferedData(error$1);
	}
};
const handleBufferedData = ({ bufferedData }) => isArrayBuffer(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/resolve/wait-stream.js
const waitForStream = async (stream$2, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {}) => {
	const state = handleStdinDestroy(stream$2, streamInfo);
	const abortController = new AbortController();
	try {
		await Promise.race([...stopOnExit ? [streamInfo.exitPromise] : [], finished(stream$2, {
			cleanup: true,
			signal: abortController.signal
		})]);
	} catch (error$1) {
		if (!state.stdinCleanedUp) handleStreamError(error$1, fdNumber, streamInfo, isSameDirection);
	} finally {
		abortController.abort();
	}
};
const handleStdinDestroy = (stream$2, { originalStreams: [originalStdin], subprocess }) => {
	const state = { stdinCleanedUp: false };
	if (stream$2 === originalStdin) spyOnStdinDestroy(stream$2, subprocess, state);
	return state;
};
const spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {
	const { _destroy } = subprocessStdin;
	subprocessStdin._destroy = (...destroyArguments) => {
		setStdinCleanedUp(subprocess, state);
		_destroy.call(subprocessStdin, ...destroyArguments);
	};
};
const setStdinCleanedUp = ({ exitCode, signalCode }, state) => {
	if (exitCode !== null || signalCode !== null) state.stdinCleanedUp = true;
};
const handleStreamError = (error$1, fdNumber, streamInfo, isSameDirection) => {
	if (!shouldIgnoreStreamError(error$1, fdNumber, streamInfo, isSameDirection)) throw error$1;
};
const shouldIgnoreStreamError = (error$1, fdNumber, streamInfo, isSameDirection = true) => {
	if (streamInfo.propagating) return isStreamEpipe(error$1) || isStreamAbort(error$1);
	streamInfo.propagating = true;
	return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error$1) : isStreamAbort(error$1);
};
const isInputFileDescriptor = ({ fileDescriptors }, fdNumber) => fdNumber !== "all" && fileDescriptors[fdNumber].direction === "input";
const isStreamAbort = (error$1) => error$1?.code === "ERR_STREAM_PREMATURE_CLOSE";
const isStreamEpipe = (error$1) => error$1?.code === "EPIPE";

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/resolve/stdio.js
const waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline$1, verboseInfo, streamInfo }) => subprocess.stdio.map((stream$2, fdNumber) => waitForSubprocessStream({
	stream: stream$2,
	fdNumber,
	encoding,
	buffer: buffer[fdNumber],
	maxBuffer: maxBuffer[fdNumber],
	lines: lines[fdNumber],
	allMixed: false,
	stripFinalNewline: stripFinalNewline$1,
	verboseInfo,
	streamInfo
}));
const waitForSubprocessStream = async ({ stream: stream$2, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline$1, verboseInfo, streamInfo }) => {
	if (!stream$2) return;
	const onStreamEnd = waitForStream(stream$2, fdNumber, streamInfo);
	if (isInputFileDescriptor(streamInfo, fdNumber)) {
		await onStreamEnd;
		return;
	}
	const [output] = await Promise.all([getStreamOutput({
		stream: stream$2,
		onStreamEnd,
		fdNumber,
		encoding,
		buffer,
		maxBuffer,
		lines,
		allMixed,
		stripFinalNewline: stripFinalNewline$1,
		verboseInfo,
		streamInfo
	}), onStreamEnd]);
	return output;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/resolve/all-async.js
const makeAllStream = ({ stdout: stdout$1, stderr }, { all }) => all && (stdout$1 || stderr) ? mergeStreams([stdout$1, stderr].filter(Boolean)) : void 0;
const waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline$1, verboseInfo, streamInfo }) => waitForSubprocessStream({
	...getAllStream(subprocess, buffer),
	fdNumber: "all",
	encoding,
	maxBuffer: maxBuffer[1] + maxBuffer[2],
	lines: lines[1] || lines[2],
	allMixed: getAllMixed(subprocess),
	stripFinalNewline: stripFinalNewline$1,
	verboseInfo,
	streamInfo
});
const getAllStream = ({ stdout: stdout$1, stderr, all }, [, bufferStdout, bufferStderr]) => {
	const buffer = bufferStdout || bufferStderr;
	if (!buffer) return {
		stream: all,
		buffer
	};
	if (!bufferStdout) return {
		stream: stderr,
		buffer
	};
	if (!bufferStderr) return {
		stream: stdout$1,
		buffer
	};
	return {
		stream: all,
		buffer
	};
};
const getAllMixed = ({ all, stdout: stdout$1, stderr }) => all && stdout$1 && stderr && stdout$1.readableObjectMode !== stderr.readableObjectMode;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/verbose/ipc.js
const shouldLogIpc = (verboseInfo) => isFullVerbose(verboseInfo, "ipc");
const logIpcOutput = (message, verboseInfo) => {
	const verboseMessage = serializeVerboseMessage(message);
	verboseLog({
		type: "ipc",
		verboseMessage,
		fdNumber: "ipc",
		verboseInfo
	});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/ipc/buffer-messages.js
const waitForIpcOutput = async ({ subprocess, buffer: bufferArray, maxBuffer: maxBufferArray, ipc, ipcOutput, verboseInfo }) => {
	if (!ipc) return ipcOutput;
	const isVerbose$1 = shouldLogIpc(verboseInfo);
	const buffer = getFdSpecificValue(bufferArray, "ipc");
	const maxBuffer = getFdSpecificValue(maxBufferArray, "ipc");
	for await (const message of loopOnMessages({
		anyProcess: subprocess,
		channel: subprocess.channel,
		isSubprocess: false,
		ipc,
		shouldAwait: false,
		reference: true
	})) {
		if (buffer) {
			checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
			ipcOutput.push(message);
		}
		if (isVerbose$1) logIpcOutput(message, verboseInfo);
	}
	return ipcOutput;
};
const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {
	await Promise.allSettled([ipcOutputPromise]);
	return ipcOutput;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/resolve/wait-subprocess.js
const waitForSubprocessResult = async ({ subprocess, options: { encoding, buffer, maxBuffer, lines, timeoutDuration: timeout, cancelSignal, gracefulCancel, forceKillAfterDelay, stripFinalNewline: stripFinalNewline$1, ipc, ipcInput }, context: context$1, verboseInfo, fileDescriptors, originalStreams, onInternalError, controller }) => {
	const exitPromise = waitForExit(subprocess, context$1);
	const streamInfo = {
		originalStreams,
		fileDescriptors,
		subprocess,
		exitPromise,
		propagating: false
	};
	const stdioPromises = waitForStdioStreams({
		subprocess,
		encoding,
		buffer,
		maxBuffer,
		lines,
		stripFinalNewline: stripFinalNewline$1,
		verboseInfo,
		streamInfo
	});
	const allPromise = waitForAllStream({
		subprocess,
		encoding,
		buffer,
		maxBuffer,
		lines,
		stripFinalNewline: stripFinalNewline$1,
		verboseInfo,
		streamInfo
	});
	const ipcOutput = [];
	const ipcOutputPromise = waitForIpcOutput({
		subprocess,
		buffer,
		maxBuffer,
		ipc,
		ipcOutput,
		verboseInfo
	});
	const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
	const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
	try {
		return await Promise.race([
			Promise.all([
				{},
				waitForSuccessfulExit(exitPromise),
				Promise.all(stdioPromises),
				allPromise,
				ipcOutputPromise,
				sendIpcInput(subprocess, ipcInput),
				...originalPromises,
				...customStreamsEndPromises
			]),
			onInternalError,
			throwOnSubprocessError(subprocess, controller),
			...throwOnTimeout(subprocess, timeout, context$1, controller),
			...throwOnCancel({
				subprocess,
				cancelSignal,
				gracefulCancel,
				context: context$1,
				controller
			}),
			...throwOnGracefulCancel({
				subprocess,
				cancelSignal,
				gracefulCancel,
				forceKillAfterDelay,
				context: context$1,
				controller
			})
		]);
	} catch (error$1) {
		context$1.terminationReason ??= "other";
		return Promise.all([
			{ error: error$1 },
			exitPromise,
			Promise.all(stdioPromises.map((stdioPromise) => getBufferedData(stdioPromise))),
			getBufferedData(allPromise),
			getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
			Promise.allSettled(originalPromises),
			Promise.allSettled(customStreamsEndPromises)
		]);
	}
};
const waitForOriginalStreams = (originalStreams, subprocess, streamInfo) => originalStreams.map((stream$2, fdNumber) => stream$2 === subprocess.stdio[fdNumber] ? void 0 : waitForStream(stream$2, fdNumber, streamInfo));
const waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({ stdioItems }, fdNumber) => stdioItems.filter(({ value, stream: stream$2 = value }) => isStream(stream$2, { checkOpen: false }) && !isStandardStream(stream$2)).map(({ type, value, stream: stream$2 = value }) => waitForStream(stream$2, fdNumber, streamInfo, {
	isSameDirection: TRANSFORM_TYPES.has(type),
	stopOnExit: type === "native"
})));
const throwOnSubprocessError = async (subprocess, { signal }) => {
	const [error$1] = await once(subprocess, "error", { signal });
	throw error$1;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/convert/concurrent.js
const initializeConcurrentStreams = () => ({
	readableDestroy: /* @__PURE__ */ new WeakMap(),
	writableFinal: /* @__PURE__ */ new WeakMap(),
	writableDestroy: /* @__PURE__ */ new WeakMap()
});
const addConcurrentStream = (concurrentStreams, stream$2, waitName) => {
	const weakMap = concurrentStreams[waitName];
	if (!weakMap.has(stream$2)) weakMap.set(stream$2, []);
	const promises = weakMap.get(stream$2);
	const promise = createDeferred();
	promises.push(promise);
	const resolve = promise.resolve.bind(promise);
	return {
		resolve,
		promises
	};
};
const waitForConcurrentStreams = async ({ resolve, promises }, subprocess) => {
	resolve();
	const [isSubprocessExit] = await Promise.race([Promise.allSettled([true, subprocess]), Promise.all([false, ...promises])]);
	return !isSubprocessExit;
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/convert/shared.js
const safeWaitForSubprocessStdin = async (subprocessStdin) => {
	if (subprocessStdin === void 0) return;
	try {
		await waitForSubprocessStdin(subprocessStdin);
	} catch {}
};
const safeWaitForSubprocessStdout = async (subprocessStdout) => {
	if (subprocessStdout === void 0) return;
	try {
		await waitForSubprocessStdout(subprocessStdout);
	} catch {}
};
const waitForSubprocessStdin = async (subprocessStdin) => {
	await finished(subprocessStdin, {
		cleanup: true,
		readable: false,
		writable: true
	});
};
const waitForSubprocessStdout = async (subprocessStdout) => {
	await finished(subprocessStdout, {
		cleanup: true,
		readable: true,
		writable: false
	});
};
const waitForSubprocess = async (subprocess, error$1) => {
	await subprocess;
	if (error$1) throw error$1;
};
const destroyOtherStream = (stream$2, isOpen, error$1) => {
	if (error$1 && !isStreamAbort(error$1)) stream$2.destroy(error$1);
	else if (isOpen) stream$2.destroy();
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/convert/readable.js
const createReadable = ({ subprocess, concurrentStreams, encoding }, { from, binary: binaryOption = true, preserveNewlines = true } = {}) => {
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
	const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
	const { read, onStdoutDataDone } = getReadableMethods({
		subprocessStdout,
		subprocess,
		binary,
		encoding,
		preserveNewlines
	});
	const readable$1 = new Readable({
		read,
		destroy: callbackify(onReadableDestroy.bind(void 0, {
			subprocessStdout,
			subprocess,
			waitReadableDestroy
		})),
		highWaterMark: readableHighWaterMark,
		objectMode: readableObjectMode,
		encoding: readableEncoding
	});
	onStdoutFinished({
		subprocessStdout,
		onStdoutDataDone,
		readable: readable$1,
		subprocess
	});
	return readable$1;
};
const getSubprocessStdout = (subprocess, from, concurrentStreams) => {
	const subprocessStdout = getFromStream(subprocess, from);
	const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, "readableDestroy");
	return {
		subprocessStdout,
		waitReadableDestroy
	};
};
const getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary) => binary ? {
	readableEncoding,
	readableObjectMode,
	readableHighWaterMark
} : {
	readableEncoding,
	readableObjectMode: true,
	readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK
};
const getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines }) => {
	const onStdoutDataDone = createDeferred();
	const onStdoutData = iterateOnSubprocessStream({
		subprocessStdout,
		subprocess,
		binary,
		shouldEncode: !binary,
		encoding,
		preserveNewlines
	});
	return {
		read() {
			onRead(this, onStdoutData, onStdoutDataDone);
		},
		onStdoutDataDone
	};
};
const onRead = async (readable$1, onStdoutData, onStdoutDataDone) => {
	try {
		const { value, done } = await onStdoutData.next();
		if (done) onStdoutDataDone.resolve();
		else readable$1.push(value);
	} catch {}
};
const onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable: readable$1, subprocess, subprocessStdin }) => {
	try {
		await waitForSubprocessStdout(subprocessStdout);
		await subprocess;
		await safeWaitForSubprocessStdin(subprocessStdin);
		await onStdoutDataDone;
		if (readable$1.readable) readable$1.push(null);
	} catch (error$1) {
		await safeWaitForSubprocessStdin(subprocessStdin);
		destroyOtherReadable(readable$1, error$1);
	}
};
const onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error$1) => {
	if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
		destroyOtherReadable(subprocessStdout, error$1);
		await waitForSubprocess(subprocess, error$1);
	}
};
const destroyOtherReadable = (stream$2, error$1) => {
	destroyOtherStream(stream$2, stream$2.readable, error$1);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/convert/writable.js
const createWritable = ({ subprocess, concurrentStreams }, { to } = {}) => {
	const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
	const writable$1 = new Writable({
		...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
		destroy: callbackify(onWritableDestroy.bind(void 0, {
			subprocessStdin,
			subprocess,
			waitWritableFinal,
			waitWritableDestroy
		})),
		highWaterMark: subprocessStdin.writableHighWaterMark,
		objectMode: subprocessStdin.writableObjectMode
	});
	onStdinFinished(subprocessStdin, writable$1);
	return writable$1;
};
const getSubprocessStdin = (subprocess, to, concurrentStreams) => {
	const subprocessStdin = getToStream(subprocess, to);
	const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, "writableFinal");
	const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, "writableDestroy");
	return {
		subprocessStdin,
		waitWritableFinal,
		waitWritableDestroy
	};
};
const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({
	write: onWrite.bind(void 0, subprocessStdin),
	final: callbackify(onWritableFinal.bind(void 0, subprocessStdin, subprocess, waitWritableFinal))
});
const onWrite = (subprocessStdin, chunk, encoding, done) => {
	if (subprocessStdin.write(chunk, encoding)) done();
	else subprocessStdin.once("drain", done);
};
const onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {
	if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
		if (subprocessStdin.writable) subprocessStdin.end();
		await subprocess;
	}
};
const onStdinFinished = async (subprocessStdin, writable$1, subprocessStdout) => {
	try {
		await waitForSubprocessStdin(subprocessStdin);
		if (writable$1.writable) writable$1.end();
	} catch (error$1) {
		await safeWaitForSubprocessStdout(subprocessStdout);
		destroyOtherWritable(writable$1, error$1);
	}
};
const onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error$1) => {
	await waitForConcurrentStreams(waitWritableFinal, subprocess);
	if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
		destroyOtherWritable(subprocessStdin, error$1);
		await waitForSubprocess(subprocess, error$1);
	}
};
const destroyOtherWritable = (stream$2, error$1) => {
	destroyOtherStream(stream$2, stream$2.writable, error$1);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/convert/duplex.js
const createDuplex = ({ subprocess, concurrentStreams, encoding }, { from, to, binary: binaryOption = true, preserveNewlines = true } = {}) => {
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
	const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
	const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
	const { read, onStdoutDataDone } = getReadableMethods({
		subprocessStdout,
		subprocess,
		binary,
		encoding,
		preserveNewlines
	});
	const duplex$1 = new Duplex({
		read,
		...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
		destroy: callbackify(onDuplexDestroy.bind(void 0, {
			subprocessStdout,
			subprocessStdin,
			subprocess,
			waitReadableDestroy,
			waitWritableFinal,
			waitWritableDestroy
		})),
		readableHighWaterMark,
		writableHighWaterMark: subprocessStdin.writableHighWaterMark,
		readableObjectMode,
		writableObjectMode: subprocessStdin.writableObjectMode,
		encoding: readableEncoding
	});
	onStdoutFinished({
		subprocessStdout,
		onStdoutDataDone,
		readable: duplex$1,
		subprocess,
		subprocessStdin
	});
	onStdinFinished(subprocessStdin, duplex$1, subprocessStdout);
	return duplex$1;
};
const onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error$1) => {
	await Promise.all([onReadableDestroy({
		subprocessStdout,
		subprocess,
		waitReadableDestroy
	}, error$1), onWritableDestroy({
		subprocessStdin,
		subprocess,
		waitWritableFinal,
		waitWritableDestroy
	}, error$1)]);
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/convert/iterable.js
const createIterable = (subprocess, encoding, { from, binary: binaryOption = false, preserveNewlines = false } = {}) => {
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const subprocessStdout = getFromStream(subprocess, from);
	const onStdoutData = iterateOnSubprocessStream({
		subprocessStdout,
		subprocess,
		binary,
		shouldEncode: true,
		encoding,
		preserveNewlines
	});
	return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};
const iterateOnStdoutData = async function* (onStdoutData, subprocessStdout, subprocess) {
	try {
		yield* onStdoutData;
	} finally {
		if (subprocessStdout.readable) subprocessStdout.destroy();
		await subprocess;
	}
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/convert/add.js
const addConvertedStreams = (subprocess, { encoding }) => {
	const concurrentStreams = initializeConcurrentStreams();
	subprocess.readable = createReadable.bind(void 0, {
		subprocess,
		concurrentStreams,
		encoding
	});
	subprocess.writable = createWritable.bind(void 0, {
		subprocess,
		concurrentStreams
	});
	subprocess.duplex = createDuplex.bind(void 0, {
		subprocess,
		concurrentStreams,
		encoding
	});
	subprocess.iterable = createIterable.bind(void 0, subprocess, encoding);
	subprocess[Symbol.asyncIterator] = createIterable.bind(void 0, subprocess, encoding, {});
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/promise.js
const mergePromise = (subprocess, promise) => {
	for (const [property, descriptor] of descriptors) {
		const value = descriptor.value.bind(promise);
		Reflect.defineProperty(subprocess, property, {
			...descriptor,
			value
		});
	}
};
const nativePromisePrototype = (async () => {})().constructor.prototype;
const descriptors = [
	"then",
	"catch",
	"finally"
].map((property) => [property, Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)]);

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/main-async.js
const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {
	const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
	const { subprocess, promise } = spawnSubprocessAsync({
		file,
		commandArguments,
		options,
		startTime,
		verboseInfo,
		command,
		escapedCommand,
		fileDescriptors
	});
	subprocess.pipe = pipeToSubprocess.bind(void 0, {
		source: subprocess,
		sourcePromise: promise,
		boundOptions: {},
		createNested
	});
	mergePromise(subprocess, promise);
	SUBPROCESS_OPTIONS.set(subprocess, {
		options,
		fileDescriptors
	});
	return subprocess;
};
const handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {
	const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
	const { file, commandArguments, options: normalizedOptions } = normalizeOptions(rawFile, rawArguments, rawOptions);
	const options = handleAsyncOptions(normalizedOptions);
	const fileDescriptors = handleStdioAsync(options, verboseInfo);
	return {
		file,
		commandArguments,
		command,
		escapedCommand,
		startTime,
		verboseInfo,
		options,
		fileDescriptors
	};
};
const handleAsyncOptions = ({ timeout, signal,...options }) => {
	if (signal !== void 0) throw new TypeError("The \"signal\" option has been renamed to \"cancelSignal\" instead.");
	return {
		...options,
		timeoutDuration: timeout
	};
};
const spawnSubprocessAsync = ({ file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors }) => {
	let subprocess;
	try {
		subprocess = spawn(file, commandArguments, options);
	} catch (error$1) {
		return handleEarlyError({
			error: error$1,
			command,
			escapedCommand,
			fileDescriptors,
			options,
			startTime,
			verboseInfo
		});
	}
	const controller = new AbortController();
	setMaxListeners(Number.POSITIVE_INFINITY, controller.signal);
	const originalStreams = [...subprocess.stdio];
	pipeOutputAsync(subprocess, fileDescriptors, controller);
	cleanupOnExit(subprocess, options, controller);
	const context$1 = {};
	const onInternalError = createDeferred();
	subprocess.kill = subprocessKill.bind(void 0, {
		kill: subprocess.kill.bind(subprocess),
		options,
		onInternalError,
		context: context$1,
		controller
	});
	subprocess.all = makeAllStream(subprocess, options);
	addConvertedStreams(subprocess, options);
	addIpcMethods(subprocess, options);
	const promise = handlePromise({
		subprocess,
		options,
		startTime,
		verboseInfo,
		fileDescriptors,
		originalStreams,
		command,
		escapedCommand,
		context: context$1,
		onInternalError,
		controller
	});
	return {
		subprocess,
		promise
	};
};
const handlePromise = async ({ subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context: context$1, onInternalError, controller }) => {
	const [errorInfo, [exitCode, signal], stdioResults, allResult, ipcOutput] = await waitForSubprocessResult({
		subprocess,
		options,
		context: context$1,
		verboseInfo,
		fileDescriptors,
		originalStreams,
		onInternalError,
		controller
	});
	controller.abort();
	onInternalError.resolve();
	const stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));
	const all = stripNewline(allResult, options, "all");
	const result = getAsyncResult({
		errorInfo,
		exitCode,
		signal,
		stdio,
		all,
		ipcOutput,
		context: context$1,
		options,
		command,
		escapedCommand,
		startTime
	});
	return handleResult(result, verboseInfo, options);
};
const getAsyncResult = ({ errorInfo, exitCode, signal, stdio, all, ipcOutput, context: context$1, options, command, escapedCommand, startTime }) => "error" in errorInfo ? makeError({
	error: errorInfo.error,
	command,
	escapedCommand,
	timedOut: context$1.terminationReason === "timeout",
	isCanceled: context$1.terminationReason === "cancel" || context$1.terminationReason === "gracefulCancel",
	isGracefullyCanceled: context$1.terminationReason === "gracefulCancel",
	isMaxBuffer: errorInfo.error instanceof MaxBufferError,
	isForcefullyTerminated: context$1.isForcefullyTerminated,
	exitCode,
	signal,
	stdio,
	all,
	ipcOutput,
	options,
	startTime,
	isSync: false
}) : makeSuccessResult({
	command,
	escapedCommand,
	stdio,
	all,
	ipcOutput,
	options,
	startTime
});

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/bind.js
const mergeOptions = (boundOptions, options) => {
	const newOptions = Object.fromEntries(Object.entries(options).map(([optionName, optionValue]) => [optionName, mergeOption(optionName, boundOptions[optionName], optionValue)]));
	return {
		...boundOptions,
		...newOptions
	};
};
const mergeOption = (optionName, boundOptionValue, optionValue) => {
	if (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) return {
		...boundOptionValue,
		...optionValue
	};
	return optionValue;
};
const DEEP_OPTIONS = new Set(["env", ...FD_SPECIFIC_OPTIONS]);

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/create.js
const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {
	const createNested = (mapArguments$1, boundOptions$1, setBoundExeca$1) => createExeca(mapArguments$1, boundOptions$1, deepOptions, setBoundExeca$1);
	const boundExeca = (...execaArguments) => callBoundExeca({
		mapArguments,
		deepOptions,
		boundOptions,
		setBoundExeca,
		createNested
	}, ...execaArguments);
	if (setBoundExeca !== void 0) setBoundExeca(boundExeca, createNested, boundOptions);
	return boundExeca;
};
const callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments) => {
	if (isPlainObject(firstArgument)) return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
	const { file, commandArguments, options, isSync } = parseArguments({
		mapArguments,
		firstArgument,
		nextArguments,
		deepOptions,
		boundOptions
	});
	return isSync ? execaCoreSync(file, commandArguments, options) : execaCoreAsync(file, commandArguments, options, createNested);
};
const parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions }) => {
	const callArguments = isTemplateString(firstArgument) ? parseTemplates(firstArgument, nextArguments) : [firstArgument, ...nextArguments];
	const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
	const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
	const { file = initialFile, commandArguments = initialArguments, options = mergedOptions, isSync = false } = mapArguments({
		file: initialFile,
		commandArguments: initialArguments,
		options: mergedOptions
	});
	return {
		file,
		commandArguments,
		options,
		isSync
	};
};

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/command.js
const mapCommandAsync = ({ file, commandArguments }) => parseCommand(file, commandArguments);
const mapCommandSync = ({ file, commandArguments }) => ({
	...parseCommand(file, commandArguments),
	isSync: true
});
const parseCommand = (command, unusedArguments) => {
	if (unusedArguments.length > 0) throw new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);
	const [file, ...commandArguments] = parseCommandString(command);
	return {
		file,
		commandArguments
	};
};
const parseCommandString = (command) => {
	if (typeof command !== "string") throw new TypeError(`The command must be a string: ${String(command)}.`);
	const trimmedCommand = command.trim();
	if (trimmedCommand === "") return [];
	const tokens = [];
	for (const token of trimmedCommand.split(SPACES_REGEXP)) {
		const previousToken = tokens.at(-1);
		if (previousToken && previousToken.endsWith("\\")) tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
		else tokens.push(token);
	}
	return tokens;
};
const SPACES_REGEXP = / +/g;

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/lib/methods/script.js
const setScriptSync = (boundExeca, createNested, boundOptions) => {
	boundExeca.sync = createNested(mapScriptSync, boundOptions);
	boundExeca.s = boundExeca.sync;
};
const mapScriptAsync = ({ options }) => getScriptOptions(options);
const mapScriptSync = ({ options }) => ({
	...getScriptOptions(options),
	isSync: true
});
const getScriptOptions = (options) => ({ options: {
	...getScriptStdinOption(options),
	...options
} });
const getScriptStdinOption = ({ input, inputFile, stdio }) => input === void 0 && inputFile === void 0 && stdio === void 0 ? { stdin: "inherit" } : {};
const deepScriptOptions = { preferLocal: true };

//#endregion
//#region node_modules/.pnpm/execa@9.3.1/node_modules/execa/index.js
const execa = createExeca(() => ({}));
const execaSync = createExeca(() => ({ isSync: true }));
const execaCommand = createExeca(mapCommandAsync);
const execaCommandSync = createExeca(mapCommandSync);
const execaNode = createExeca(mapNode);
const $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);
const { sendMessage, getOneMessage, getEachMessage, getCancelSignal } = getIpcExport();

//#endregion
//#region node_modules/.pnpm/cr-asst@0.14.0/node_modules/cr-asst/dist/shared/cr-asst.24X5B4jE.mjs
function genEnBuiltinPrompt(replacements$1) {
	const { $DIFFS } = replacements$1;
	return `Below I will provide some code changes. Please read these changes, understand its intent, and review it.

Your response should adhere to the following rules:

- Your response should follow the format of the response template.
- The response template provided below will be wrapped in a code block, but your response **should not** be wrapped in code block symbols (i.e., "\`\`\`markdown" and "\`\`\`"). To emphasize, **do not use code blocks to wrap your response**.
- In the response template, \`{{}}\` is the part you need to replace, for example, you should replace \`{{review comment}}\` with your actual review comment.
- In the response template, as an example, only one item item is listed in every sections. You should **list the appropriate number of items** based on the actual situation.
- The code changes provided below are represented in \`diff\` format. The file paths may be prefixed with \`a/\` or \`b/\`, but these two prefixes should not be considered as part of the file path.
- Review comments should point out potential improvements in the code, but there's no need to be overly nitpicky.
- Review comments should point out syntax issues in the code, such as incorrect syntax usage, unclosed brackets, etc.
- Review comments should point out logical issues in the code, such as infinite loops, incorrect conditions, wrong expressions, etc.
- Review comments should **especially point out** security issues in the code, which refer to vulnerabilities that could lead to attacks, such as SQL injection, XSS, CSRF, etc.
- In the section "Issues and Potential Improvements", **only** point out the issues and potential improvements in the code, and do not provide review comments for reasonable code.

This is the response template you need to follow:

\`\`\`markdown
# Overall Changes

1. {{overall change}}

# Overall Review Comments

1. {{overall review comment}}

# Issues and Potential Improvements

1. \`{{path of the file with issue or potential improvement}}\`

   1. {{issue or potential improvement}}
\`\`\`

This is the code changes you need to review:

\`\`\`diff
${$DIFFS}
\`\`\``;
}
function genZhCnBuiltinPrompt(replacements$1, options = {}) {
	const { $DIFFS } = replacements$1;
	const { nyan } = options;
	return `\u6211\u5C06\u7ED9\u51FA\u4E00\u4E9B\u4EE3\u7801\u6539\u52A8\uFF0C\u8BF7\u4F60\u9605\u8BFB\u8FD9\u4E9B\u6539\u52A8\uFF0C\u5E76\u7406\u89E3\u8FD9\u4E9B\u6539\u52A8\u7684\u610F\u56FE\uFF0C\u7136\u540E\u8BC4\u5BA1\u8FD9\u4E9B\u6539\u52A8\u3002

\u4F60\u7684\u56DE\u590D\u5E94\u8BE5\u9075\u5B88\u4EE5\u4E0B\u89C4\u5219\uFF1A

- \u4F60\u7684\u56DE\u590D\u5E94\u8BE5\u9075\u5B88\u56DE\u590D\u6A21\u677F\u7684\u683C\u5F0F\u3002
- \u4E0B\u9762\u7ED9\u51FA\u7684\u56DE\u590D\u6A21\u677F\u4F1A\u88AB\u5305\u88F9\u5728\u4EE3\u7801\u5757\u4E2D\uFF0C\u4F46\u662F\u4F60\u7684\u56DE\u590D**\u4E0D\u8981**\u7528\u4EE3\u7801\u5757\u7B26\u53F7\uFF08\u5373 "\`\`\`markdown" \u548C "\`\`\`"\uFF09\u6765\u5305\u88F9\u3002\u518D\u6B21\u5F3A\u8C03\uFF0C**\u4E0D\u8981\u7528\u4EE3\u7801\u5757\u6765\u5305\u88F9\u4F60\u7684\u56DE\u590D**\u3002
- \u5728\u56DE\u590D\u6A21\u677F\u4E2D\uFF0C\`{{}}\` \u662F\u4F60\u9700\u8981\u66FF\u6362\u7684\u90E8\u5206\uFF0C\u4F8B\u5982\u4F60\u9700\u8981\u5C06 \`{{\u8BC4\u5BA1\u610F\u89C1}}\` \u66FF\u6362\u4E3A\u4F60\u5B9E\u9645\u7684\u8BC4\u5BA1\u610F\u89C1\u3002
- \u5728\u56DE\u590D\u6A21\u677F\u4E2D\uFF0C\u4F5C\u4E3A\u793A\u4F8B\uFF0C\u6BCF\u4E2A\u7AE0\u8282\u4EC5\u5217\u51FA\u4E86\u4E00\u9879\u5185\u5BB9\u3002\u4F60\u7684\u56DE\u590D\u5E94\u8BE5\u6839\u636E\u5B9E\u9645\u60C5\u51B5\uFF0C\u5217\u51FA**\u5408\u9002\u7684\u9879\u76EE\u6570\u91CF**\u3002
- \u4E0B\u9762\u7ED9\u51FA\u7684\u4EE3\u7801\u6539\u52A8\u4EE5 \`diff\` \u683C\u5F0F\u8868\u793A\u3002\u5176\u4E2D\u7684\u6587\u4EF6\u8DEF\u5F84\u53EF\u80FD\u4EE5 \`a/\` \u6216 \`b/\` \u4F5C\u4E3A\u524D\u7F00\uFF0C\u4E0D\u8981\u5C06\u8FD9\u4E24\u4E2A\u524D\u7F00\u89C6\u4E3A\u6587\u4EF6\u8DEF\u5F84\u7684\u4E00\u90E8\u5206\u3002
- \u8BC4\u5BA1\u610F\u89C1\u5E94\u8BE5\u6307\u51FA\u4EE3\u7801\u7684\u6539\u8FDB\u70B9\uFF0C\u4F46\u4E0D\u5FC5\u8FC7\u4E8E\u5439\u6BDB\u6C42\u75B5\u3002
- \u8BC4\u5BA1\u610F\u89C1\u5E94\u8BE5\u6307\u51FA\u4EE3\u7801\u7684\u8BED\u6CD5\u95EE\u9898\uFF0C\u5982\u4F7F\u7528\u4E86\u8BED\u6CD5\u9519\u8BEF\u3001\u62EC\u53F7\u672A\u95ED\u5408\u7B49\u3002
- \u8BC4\u5BA1\u610F\u89C1\u5E94\u8BE5\u6307\u51FA\u4EE3\u7801\u7684\u903B\u8F91\u95EE\u9898\uFF0C\u5982\u65E0\u9650\u5FAA\u73AF\u3001\u6761\u4EF6\u9519\u8BEF\u3001\u8868\u8FBE\u5F0F\u9519\u8BEF\u7B49\u3002
- \u8BC4\u5BA1\u610F\u89C1\u5E94\u8BE5**\u7279\u522B\u6307\u51FA**\u4EE3\u7801\u7684\u5B89\u5168\u95EE\u9898\uFF0C\u5373\u53EF\u80FD\u5BFC\u81F4\u88AB\u653B\u51FB\u7684\u6F0F\u6D1E\uFF0C\u5982 SQL \u6CE8\u5165\u3001XSS\u3001CSRF \u7B49\u3002
- \u5728\u201C\u95EE\u9898\u548C\u6539\u8FDB\u70B9\u201D\u7AE0\u8282\u4E2D\uFF0C**\u53EA\u9700\u8981**\u6307\u51FA\u4EE3\u7801\u4E2D\u7684\u95EE\u9898\u6216\u6539\u8FDB\u70B9\uFF0C\u4E0D\u9700\u8981\u7ED9\u51FA\u5408\u7406\u4EE3\u7801\u7684\u8BC4\u5BA1\u610F\u89C1\u3002
${nyan ? "- 扮演一个猫娘，你的回复需要带上猫娘的语癖，例如使用“喵~”、emoji、颜表情等。你应该在句子中使用第一人称“猫猫”，包括在描述意图、改动点时，例如“猫猫觉得...”、“猫猫认为...”、“猫猫喜欢...”。" : ""}

\u4F60\u7684\u56DE\u590D\u6A21\u677F\u5982\u4E0B\uFF1A

\`\`\`markdown
# \u6574\u4F53\u6539\u52A8

1. {{\u6574\u4F53\u6539\u52A8\u70B9}}

# \u6574\u4F53\u8BC4\u5BA1

1. {{\u6574\u4F53\u8BC4\u5BA1\u610F\u89C1}}

# \u95EE\u9898\u548C\u6539\u8FDB\u70B9

1. \`{{\u6709\u95EE\u9898\u6216\u6539\u8FDB\u70B9\u7684\u6587\u4EF6\u8DEF\u5F84}}\`

   1. {{\u95EE\u9898\u6216\u6539\u8FDB\u70B9}}
\`\`\`

\u4EE5\u4E0B\u662F\u4F60\u9700\u8981\u8BC4\u5BA1\u7684\u4EE3\u7801\u6539\u52A8\uFF1A

\`\`\`diff
${$DIFFS}
\`\`\``;
}
function getBuiltinPrompt(name, replacements$1) {
	switch (name) {
		case "en": return genEnBuiltinPrompt(replacements$1);
		case "zh-cn": return genZhCnBuiltinPrompt(replacements$1);
		case "zh-cn-nyan": return genZhCnBuiltinPrompt(replacements$1, { nyan: true });
	}
}
async function getPrompt(fileOrBuiltinName, replacements$1) {
	const builtinPrompt = getBuiltinPrompt(fileOrBuiltinName, replacements$1);
	if (builtinPrompt) return builtinPrompt;
	let customPrompt = await readFile(fileOrBuiltinName, "utf8");
	for (const [key, value] of Object.entries(replacements$1)) customPrompt = customPrompt.replaceAll(key, value);
	return customPrompt;
}
function usageToString(usage) {
	return ["[USAGE]", [
		`promptTokens: ${usage?.promptTokens ? usage.promptTokens : "N/A"}`,
		`completionTokens: ${usage?.completionTokens ? usage.completionTokens : "N/A"}`,
		`totalTokens: ${usage?.totalTokens ? usage.totalTokens : "N/A"}`
	].join(", ")].join(" ");
}
function statsToString(stats) {
	return ["[STATS]", [
		`timeToFirstToken: ${(stats.timeToFirstToken / 1e3).toFixed(2)}s`,
		`timeToFinish: ${(stats.timeToFinish / 1e3).toFixed(2)}s`,
		`tokensPerSecond: ${stats.tokensPerSecond ? `${stats.tokensPerSecond.toFixed(2)} tokens/s` : "N/A"}`
	].join(", ")].join(" ");
}
async function createCompletion(options) {
	const { client, model, messages, tools, onDeltaReasoningContent, onDeltaContent } = options;
	const stream$2 = await client.chat.completions.create({
		stream: true,
		model,
		messages,
		tools
	});
	const completion = await readCompletionStream({
		stream: stream$2,
		onDeltaReasoningContent,
		onDeltaContent
	});
	return completion;
}
async function readCompletionStream(options) {
	const { stream: stream$2, onDeltaReasoningContent, onDeltaContent } = options;
	let reasoningContent;
	let reasoningContentCounter = 0;
	let content;
	let contentCounter = 0;
	let toolCalls;
	let finishReason = null;
	let usage;
	const stats = {
		startedAt: Date.now(),
		firstTokenReceivedAt: 0,
		finishedAt: 0,
		timeToFirstToken: 0,
		timeToFinish: 0
	};
	for await (const chunk of stream$2) {
		if (chunk.usage) usage = {
			promptTokens: chunk.usage.prompt_tokens,
			completionTokens: chunk.usage.completion_tokens,
			totalTokens: chunk.usage.total_tokens
		};
		if (stats.firstTokenReceivedAt === 0) stats.firstTokenReceivedAt = Date.now();
		const choice = chunk.choices[0];
		if (!choice) continue;
		if (choice.finish_reason) finishReason = choice.finish_reason;
		const delta = choice.delta;
		if (!delta) continue;
		if (typeof delta.reasoning_content === "string") {
			reasoningContent = (reasoningContent || "") + delta.reasoning_content;
			onDeltaReasoningContent?.(delta.reasoning_content, reasoningContentCounter);
			reasoningContentCounter++;
		}
		if (typeof delta.content === "string") {
			content = (content || "") + delta.content;
			onDeltaContent?.(delta.content, contentCounter);
			contentCounter++;
		}
		if (delta.tool_calls) {
			toolCalls = toolCalls || [];
			for (const toolCallChunk of delta.tool_calls) {
				toolCalls[toolCallChunk.index] = toolCalls[toolCallChunk.index] || {
					index: toolCallChunk.index,
					id: "",
					type: "",
					function: {
						name: "",
						arguments: ""
					}
				};
				const toolCall = toolCalls[toolCallChunk.index];
				if (toolCallChunk.id) toolCall.id = toolCallChunk.id;
				if (toolCallChunk.type) toolCall.type = toolCallChunk.type;
				if (toolCallChunk.function?.name) toolCall.function.name = toolCallChunk.function.name;
				if (toolCallChunk.function?.arguments) toolCall.function.arguments += toolCallChunk.function.arguments;
			}
		}
	}
	stats.finishedAt = Date.now();
	stats.timeToFirstToken = stats.firstTokenReceivedAt - stats.startedAt;
	stats.timeToFinish = stats.finishedAt - stats.startedAt;
	if (usage) stats.tokensPerSecond = usage.completionTokens / (stats.timeToFinish / 1e3);
	return {
		reasoningContent,
		content,
		toolCalls,
		finishReason,
		usage,
		stats
	};
}
async function codeReview(options) {
	const { model, apiKey, baseUrl: baseUrl$1, diffsCmd = "git log --no-prefix -p -n 1 -- . :!package-lock.json :!pnpm-lock.yaml :!yarn.lock", outputFile, promptFile = "en", print = false, printReasoning = false, printDebug = false } = options;
	const client = new openai_default({
		baseURL: baseUrl$1,
		apiKey
	});
	const diffs = options.diffs ? options.diffs : await (async () => {
		const cmdArr = diffsCmd.split(" ").filter((v) => !!v);
		const { stdout: stdout2 } = await execa(cmdArr[0], cmdArr.slice(1));
		return stdout2;
	})();
	const prompt = await getPrompt(promptFile, { $DIFFS: diffs });
	const completion = await createCompletion({
		client,
		model,
		messages: [{
			role: "user",
			content: prompt
		}],
		onDeltaReasoningContent: (delta, counter) => {
			if (print && printReasoning) {
				if (counter === 0) stdout.write("> (Reasoning)\n> \n> ");
				stdout.write(delta.replaceAll("\n", "\n> "));
			}
		},
		onDeltaContent: async (delta, counter) => {
			if (counter === 0 && outputFile) await writeFile(outputFile, "");
			if (print) stdout.write(delta);
			if (outputFile) await appendFile(outputFile, delta);
		}
	});
	if (print) console.log();
	if (printDebug) {
		console.log();
		console.log(usageToString(completion.usage));
		console.log(statsToString(completion.stats));
	}
	return {
		reasoningContent: completion.reasoningContent,
		content: completion.content || "",
		debug: {
			diffs,
			stats: completion.stats,
			usage: completion.usage
		}
	};
}

//#endregion
//#region src/run.ts
var import_core = __toESM(require_core(), 1);
var import_github = __toESM(require_github(), 1);
const reviewCommentIdentifier = "<!-- Commented by mys1024/cr-asst-action. -->";
async function _run() {
	if (!import_github.context.payload.pull_request) {
		import_core.setFailed("This action only works for pull request events.");
		return;
	}
	const issueNumber = import_github.context.payload.pull_request.number;
	const baseRef = import_github.context.payload.pull_request.base.ref;
	const headRef = import_github.context.payload.pull_request.head.ref;
	if (typeof baseRef !== "string") {
		import_core.setFailed("Failed to get \"baseRef\" of the pull request.");
		return;
	}
	if (typeof headRef !== "string") {
		import_core.setFailed("Failed to get \"headRef\" of the pull request.");
		return;
	}
	const githubToken = import_core.getInput("github-token");
	const model = import_core.getInput("model");
	const apiKey = import_core.getInput("api-key");
	const baseUrl$1 = import_core.getInput("base-url") ? import_core.getInput("base-url") : void 0;
	const promptFile = import_core.getInput("prompt-file") || "en";
	const excludeFiles = import_core.getInput("exclude-files") ? import_core.getInput("exclude-files").split(",") : [
		"pnpm-lock.yaml",
		"package-lock.json",
		"yarn.lock"
	];
	const diffsCmd = import_core.getInput("diffs-cmd") || `git diff --no-prefix remotes/origin/${baseRef}...remotes/origin/${headRef} -- ${excludeFiles.length > 0 ? `. ${excludeFiles.map((file) => `:!${file}`).join(" ")}` : "."}`;
	import_core.info("baseRef: " + baseRef);
	import_core.info("headRef: " + headRef);
	import_core.info("diffsCmd: " + diffsCmd);
	import_core.info("\nCode review started...\n");
	const { content: reviewComment } = await codeReview({
		model,
		apiKey,
		baseUrl: baseUrl$1,
		promptFile,
		diffsCmd,
		print: true,
		printReasoning: true,
		printDebug: true
	});
	import_core.info("\nCode review finished.\n");
	const octokit = (0, import_github.getOctokit)(githubToken);
	const { data: comments } = await octokit.rest.issues.listComments({
		owner: import_github.context.repo.owner,
		repo: import_github.context.repo.repo,
		issue_number: issueNumber
	});
	const existingComment = comments.find((comment) => comment.body?.startsWith(reviewCommentIdentifier));
	if (!existingComment) {
		const { data: comment } = await octokit.rest.issues.createComment({
			owner: import_github.context.repo.owner,
			repo: import_github.context.repo.repo,
			issue_number: issueNumber,
			body: `${reviewCommentIdentifier}\n\n${reviewComment}`
		});
		import_core.info(`Review comment added: ${comment.html_url}`);
	} else {
		import_core.info(`Existing review comment found, comment id: ${existingComment.id}.`);
		const { data: comment } = await octokit.rest.issues.updateComment({
			owner: import_github.context.repo.owner,
			repo: import_github.context.repo.repo,
			comment_id: existingComment.id,
			body: `${reviewCommentIdentifier}\n\n${reviewComment}`
		});
		import_core.info(`Review comment updated: ${comment.html_url}`);
	}
}
async function run() {
	try {
		await _run();
	} catch (error$1) {
		import_core.setFailed(error$1 instanceof Error ? error$1 : String(error$1));
	}
}

//#endregion
//#region src/index.ts
run();

//#endregion